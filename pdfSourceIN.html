<!DOCTYPE html><html><head><meta charset="UTF-8"><script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-java.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-kotlin.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-markup.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-nginx.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-none.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-scss.min.js"></script><style>
        .article {
            position: relative;
            padding-bottom: 24px;
        }
        

        .bordered-element {
            border: 1px solid #c4c4c4;
            overflow: hidden;
        }
        

        .bordered-element-rounded {
            border: 1px solid #c4c4c4;
            border-radius: 7px;
            overflow: hidden;
        }
        

        .center {
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        

        .center-text {
            text-align: center;
        }
        

        .code-block {
            overflow: hidden;
            position: relative;
            padding: 0;
            border-radius: 8px;
            font-variant-ligatures: none;
            background-color: rgba(25, 25, 28, .05);
            word-break: break-all;
        }
        

        .container {
            max-width: 100%;
            overflow: hidden;
            page-break-inside: avoid;
            display: block;
        }
        

        .control {
            color: #19191c;
            font-size: 16px;
            font-weight: 670;
        }
        

        .detached {
            margin-block-start: 0;
            margin-block-end: 0;
            margin-bottom: 8px;
        }
        

        .emphasis {
            color: inherit;
            font-weight: inherit;
            font-style: italic;
        }
        

        .flex {
            display: flex;
        }
        

        .header-row {
            background: #e6e6e6;
        }
        

        .image {
            max-width: 100%;
            max-height: 90vh;
            height: auto;
        }
        

        .image-container {
            max-width: 100vw;
        }
        

        .image-size {
            height: auto;
        }
        

        .inline-code {
            border-radius: 4px;
            display: inline;
            padding: 2px 1px;
            font-family: JetBrains Sans,monospace;
            background: #e6e6e6;
        }
        

        .list {
            list-style-type: disc;
            padding-left: 0;
            margin-left: 15px;
        }
        

        .list-decimal {
            list-style-type: decimal;
        }
        

        .list-item {
            margin-top: 6px;
            margin-bottom: 6px;
            margin-left: 4px;
        }
        

        .main-title {
            padding-bottom: 24px;
            margin-top: 0;
            font-size: 40px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        

        .mermaid {
            page-break-inside: avoid;
        }
        
        /* Light theme */
/** Common */
#mermaid .label, #mermaid {font-family:"trebuchet ms",arial,sans-serif; font-size:16px;fill:#333;}#mermaid .error-icon{fill:#552222;}#mermaid .error-text{fill:#552222;stroke:#552222;}#mermaid .edge-thickness-normal{stroke-width:2px;}#mermaid .edge-thickness-thick{stroke-width:3.5px;}#mermaid .edge-pattern-solid{stroke-dasharray:0;}#mermaid .edge-pattern-dashed{stroke-dasharray:3;}#mermaid .edge-pattern-dotted{stroke-dasharray:2;}#mermaid .marker{fill:#333333;stroke:#333333;}#mermaid .marker.cross{stroke:#333333;} #mermaid {max-width: 100%;}
/** Flowchart */
#mermaid .cluster-label text{fill:#333;}#mermaid .cluster-label span{color:#333;}#mermaid .label text,#mermaid span{fill:#333;color:#333;}#mermaid .node rect,#mermaid .node circle,#mermaid .node ellipse,#mermaid .node polygon,#mermaid .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid .node .label{text-align:center;}#mermaid .node.clickable{cursor:pointer;}#mermaid .arrowheadPath{fill:#333333;}#mermaid .edgePath .path{stroke:#333333;stroke-width:2.0px;}#mermaid .flowchart-link{stroke:#333333;fill:none;}#mermaid .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid .edgeLabel rect{opacity:0.5;background-color:#e8e8e8;fill:#e8e8e8;}#mermaid .cluster rect{fill:#ffffde;stroke:#aaaa33;stroke-width:1px;}#mermaid .cluster text{fill:#333;}#mermaid .cluster span{color:#333;}#mermaid div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}
/** Sequence diagram */
#mermaid .actor{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid text.actor>tspan{fill:black;stroke:none;}#mermaid .actor-line{stroke:grey;}#mermaid .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:#333;}#mermaid .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:#333;}#mermaid #arrowhead path{fill:#333;stroke:#333;}#mermaid .sequenceNumber{fill:white;}#mermaid #sequencenumber{fill:#333;}#mermaid #crosshead path{fill:#333;stroke:#333;}#mermaid .messageText{fill:#333;stroke:none;}#mermaid .labelBox{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid .labelText,#mermaid .labelText>tspan{fill:black;stroke:none;}#mermaid .loopText,#mermaid .loopText>tspan{fill:black;stroke:none;}#mermaid .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);}#mermaid .note{stroke:#aaaa33;fill:#fff5ad;}#mermaid .noteText,#mermaid .noteText>tspan{fill:black;stroke:none;}#mermaid .activation0{fill:#f4f4f4;stroke:#666;}#mermaid .activation1{fill:#f4f4f4;stroke:#666;}#mermaid .activation2{fill:#f4f4f4;stroke:#666;}#mermaid .actorPopupMenu{position:absolute;}#mermaid .actorPopupMenuPanel{position:absolute;fill:#ECECFF;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);filter:drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));}#mermaid .actor-man line{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;}#mermaid .actor-man circle,#mermaid line{stroke:hsl(259.6261682243, 59.7765363128%, 87.9019607843%);fill:#ECECFF;stroke-width:2px;}
/** Gantt */
#mermaid .exclude-range{fill:#eeeeee;}#mermaid .section{stroke:none;opacity:0.2;}#mermaid .section0{fill:rgba(102, 102, 255, 0.49);}#mermaid .section2{fill:#fff400;}#mermaid .section1,#mermaid .section3{fill:white;opacity:0.2;}#mermaid .sectionTitle0{fill:#333;}#mermaid .sectionTitle1{fill:#333;}#mermaid .sectionTitle2{fill:#333;}#mermaid .sectionTitle3{fill:#333;}#mermaid .sectionTitle{text-anchor:start;}#mermaid .grid .tick{stroke:lightgrey;opacity:0.8;shape-rendering:crispEdges;}#mermaid .grid .tick text{fill:#333;}#mermaid .grid path{stroke-width:0;}#mermaid .today{fill:none;stroke:red;stroke-width:2px;}#mermaid .task{stroke-width:2;}#mermaid .taskText{text-anchor:middle;}#mermaid .taskTextOutsideRight{fill:black;text-anchor:start;}#mermaid .taskTextOutsideLeft{fill:black;text-anchor:end;}#mermaid .task.clickable{cursor:pointer;}#mermaid .taskText.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}#mermaid .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}#mermaid .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}#mermaid .taskText0,#mermaid .taskText1,#mermaid .taskText2,#mermaid .taskText3{fill:white;}#mermaid .task0,#mermaid .task1,#mermaid .task2,#mermaid .task3{fill:#8a90dd;stroke:#534fbc;}#mermaid .taskTextOutside0,#mermaid .taskTextOutside2{fill:black;}#mermaid .taskTextOutside1,#mermaid .taskTextOutside3{fill:black;}#mermaid .active0,#mermaid .active1,#mermaid .active2,#mermaid .active3{fill:#bfc7ff;stroke:#534fbc;}#mermaid .activeText0,#mermaid .activeText1,#mermaid .activeText2,#mermaid .activeText3{fill:black!important;}#mermaid .done0,#mermaid .done1,#mermaid .done2,#mermaid .done3{stroke:grey;fill:lightgrey;stroke-width:2;}#mermaid .doneText0,#mermaid .doneText1,#mermaid .doneText2,#mermaid .doneText3{fill:black!important;}#mermaid .crit0,#mermaid .crit1,#mermaid .crit2,#mermaid .crit3{stroke:#ff8888;fill:red;stroke-width:2;}#mermaid .activeCrit0,#mermaid .activeCrit1,#mermaid .activeCrit2,#mermaid .activeCrit3{stroke:#ff8888;fill:#bfc7ff;stroke-width:2;}#mermaid .doneCrit0,#mermaid .doneCrit1,#mermaid .doneCrit2,#mermaid .doneCrit3{stroke:#ff8888;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges;}#mermaid .milestone{transform:rotate(45deg) scale(0.8,0.8);}#mermaid .milestoneText{font-style:italic;}#mermaid .doneCritText0,#mermaid .doneCritText1,#mermaid .doneCritText2,#mermaid .doneCritText3{fill:black!important;}#mermaid .activeCritText0,#mermaid .activeCritText1,#mermaid .activeCritText2,#mermaid .activeCritText3{fill:black!important;}#mermaid .titleText{text-anchor:middle;font-size:18px;fill:#333;}
/** Class diagram */
#mermaid g.classGroup text{fill:#9370DB;fill:#131300;stroke:none;font-size:10px;}#mermaid g.classGroup text .title{font-weight:bolder;}#mermaid .nodeLabel,#mermaid .edgeLabel{color:#131300;}#mermaid .edgeLabel .label rect{fill:#ECECFF;}#mermaid .label text{fill:#131300;}#mermaid .edgeLabel .label span{background:#ECECFF;}#mermaid .classTitle{font-weight:bolder;}#mermaid .node rect,#mermaid .node circle,#mermaid .node ellipse,#mermaid .node polygon,#mermaid .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid .divider{stroke:#9370DB;stroke:1;}#mermaid g.clickable{cursor:pointer;}#mermaid g.classGroup rect{fill:#ECECFF;stroke:#9370DB;}#mermaid g.classGroup line{stroke:#9370DB;stroke-width:1;}#mermaid .classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mermaid .classLabel .label{fill:#9370DB;font-size:10px;}#mermaid .relation{stroke:#333333;stroke-width:1;fill:none;}#mermaid .dashed-line{stroke-dasharray:3;}#mermaid #compositionStart,#mermaid .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #compositionEnd,#mermaid .composition{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #dependencyStart,#mermaid .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #dependencyStart,#mermaid .dependency{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #extensionStart,#mermaid .extension{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #extensionEnd,#mermaid .extension{fill:#333333!important;stroke:#333333!important;stroke-width:1;}#mermaid #aggregationStart,#mermaid .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mermaid #aggregationEnd,#mermaid .aggregation{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mermaid #lollipopStart,#mermaid .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mermaid #lollipopEnd,#mermaid .lollipop{fill:#ECECFF!important;stroke:#333333!important;stroke-width:1;}#mermaid .edgeTerminals{font-size:11px;}
/** Git graph */
#mermaid .commit-id,#mermaid .commit-msg{fill:lightgrey;}#mermaid .commit0{stroke:hsl(240, 100%, 46.2745098039%);fill:hsl(240, 100%, 46.2745098039%);}#mermaid .commit-highlight0{stroke:hsl(60, 100%, 3.7254901961%);fill:hsl(60, 100%, 3.7254901961%);}#mermaid .label0{fill:hsl(240, 100%, 46.2745098039%);}#mermaid .arrow0{stroke:hsl(240, 100%, 46.2745098039%);}#mermaid .branch-label1{fill:black;}#mermaid .commit1{stroke:hsl(60, 100%, 43.5294117647%);fill:hsl(60, 100%, 43.5294117647%);}#mermaid .commit-highlight1{stroke:rgb(0, 0, 160.5);fill:rgb(0, 0, 160.5);}#mermaid .label1{fill:hsl(60, 100%, 43.5294117647%);}#mermaid .arrow1{stroke:hsl(60, 100%, 43.5294117647%);}#mermaid .branch-label2{fill:black;}#mermaid .commit2{stroke:hsl(80, 100%, 46.2745098039%);fill:hsl(80, 100%, 46.2745098039%);}#mermaid .commit-highlight2{stroke:rgb(48.8333333334, 0, 146.5000000001);fill:rgb(48.8333333334, 0, 146.5000000001);}#mermaid .label2{fill:hsl(80, 100%, 46.2745098039%);}#mermaid .arrow2{stroke:hsl(80, 100%, 46.2745098039%);}#mermaid .branch-label3{fill:#ffffff;}#mermaid .commit3{stroke:hsl(210, 100%, 46.2745098039%);fill:hsl(210, 100%, 46.2745098039%);}#mermaid .commit-highlight3{stroke:rgb(146.5000000001, 73.2500000001, 0);fill:rgb(146.5000000001, 73.2500000001, 0);}#mermaid .label3{fill:hsl(210, 100%, 46.2745098039%);}#mermaid .arrow3{stroke:hsl(210, 100%, 46.2745098039%);}#mermaid .branch-label4{fill:black;}#mermaid .commit4{stroke:hsl(180, 100%, 46.2745098039%);fill:hsl(180, 100%, 46.2745098039%);}#mermaid .commit-highlight4{stroke:rgb(146.5000000001, 0, 0);fill:rgb(146.5000000001, 0, 0);}#mermaid .label4{fill:hsl(180, 100%, 46.2745098039%);}#mermaid .arrow4{stroke:hsl(180, 100%, 46.2745098039%);}#mermaid .branch-label5{fill:black;}#mermaid .commit5{stroke:hsl(150, 100%, 46.2745098039%);fill:hsl(150, 100%, 46.2745098039%);}#mermaid .commit-highlight5{stroke:rgb(146.5000000001, 0, 73.2500000001);fill:rgb(146.5000000001, 0, 73.2500000001);}#mermaid .label5{fill:hsl(150, 100%, 46.2745098039%);}#mermaid .arrow5{stroke:hsl(150, 100%, 46.2745098039%);}#mermaid .branch-label6{fill:black;}#mermaid .commit6{stroke:hsl(300, 100%, 46.2745098039%);fill:hsl(300, 100%, 46.2745098039%);}#mermaid .commit-highlight6{stroke:rgb(0, 146.5000000001, 0);fill:rgb(0, 146.5000000001, 0);}#mermaid .label6{fill:hsl(300, 100%, 46.2745098039%);}#mermaid .arrow6{stroke:hsl(300, 100%, 46.2745098039%);}#mermaid .branch-label7{fill:black;}#mermaid .commit7{stroke:hsl(0, 100%, 46.2745098039%);fill:hsl(0, 100%, 46.2745098039%);}#mermaid .commit-highlight7{stroke:rgb(0, 146.5000000001, 146.5000000001);fill:rgb(0, 146.5000000001, 146.5000000001);}#mermaid .label7{fill:hsl(0, 100%, 46.2745098039%);}#mermaid .arrow7{stroke:hsl(0, 100%, 46.2745098039%);}#mermaid .branch{stroke-width:1;stroke:#333333;stroke-dasharray:2;}#mermaid .commit-label{font-size:10px;fill:#000021;}#mermaid .commit-label-bkg{font-size:10px;fill:#ffffde;opacity:0.5;}#mermaid .tag-label{font-size:10px;fill:#131300;}#mermaid .tag-label-bkg{fill:#ECECFF;stroke:hsl(240, 60%, 86.2745098039%);}#mermaid .tag-hole{fill:#333;}#mermaid .commit-merge{stroke:#ECECFF;fill:#ECECFF;}#mermaid .commit-reverse{stroke:#ECECFF;fill:#ECECFF;stroke-width:3;}#mermaid .commit-highlight-inner{stroke:#ECECFF;fill:#ECECFF;}#mermaid .arrow{stroke-width:8;stroke-linecap:round;fill:none;}
#mermaid .branchLabel .label {font-size:16px;} #mermaid g.label.branch-label0 text, #mermaid g.label.branch-label3 text { fill: #eee; }
/** Entity relationship */
#mermaid .entityBox{fill:#ECECFF;stroke:#9370DB;}#mermaid .attributeBoxOdd{fill:#ffffff;stroke:#9370DB;}#mermaid .attributeBoxEven{fill:#f2f2f2;stroke:#9370DB;}#mermaid .relationshipLabelBox{fill:hsl(80, 100%, 96.2745098039%);opacity:0.7;background-color:hsl(80, 100%, 96.2745098039%);}#mermaid .relationshipLabelBox rect{opacity:0.5;}#mermaid .relationshipLine{stroke:#333333;}
/** Journey */
#mermaid .label{color:#333;}#mermaid .mouth{stroke:#666;}#mermaid line{stroke:#333;}#mermaid .legend{fill:#333;}#mermaid .label text{fill:#333;}#mermaid .label{color:#333;}#mermaid .face{fill:#FFF8DC;stroke:#999;}#mermaid .node rect,#mermaid .node circle,#mermaid .node ellipse,#mermaid .node polygon,#mermaid .node path{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid .node .label{text-align:center;}#mermaid .node.clickable{cursor:pointer;}#mermaid .arrowheadPath{fill:#333333;}#mermaid .edgePath .path{stroke:#333333;stroke-width:1.5px;}#mermaid .flowchart-link{stroke:#333333;fill:none;}#mermaid .edgeLabel{background-color:#e8e8e8;text-align:center;}#mermaid .edgeLabel rect{opacity:0.5;}#mermaid .cluster text{fill:#333;}#mermaid div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-size:12px;background:hsl(80, 100%, 96.2745098039%);border:1px solid #aaaa33;border-radius:2px;pointer-events:none;z-index:100;}#mermaid .task-type-0,#mermaid .section-type-0{fill:#ECECFF;}#mermaid .task-type-1,#mermaid .section-type-1{fill:#ffffde;}#mermaid .task-type-2,#mermaid .section-type-2{fill:hsl(304, 100%, 96.2745098039%);}#mermaid .task-type-3,#mermaid .section-type-3{fill:hsl(124, 100%, 93.5294117647%);}#mermaid .task-type-4,#mermaid .section-type-4{fill:hsl(176, 100%, 96.2745098039%);}#mermaid .task-type-5,#mermaid .section-type-5{fill:hsl(-4, 100%, 93.5294117647%);}#mermaid .task-type-6,#mermaid .section-type-6{fill:hsl(8, 100%, 96.2745098039%);}#mermaid .task-type-7,#mermaid .section-type-7{fill:hsl(188, 100%, 93.5294117647%);}
/** State diagram */
#mermaid defs #statediagram-barbEnd{fill:#333333;stroke:#333333;}#mermaid g.stateGroup text{fill:#9370DB;stroke:none;font-size:10px;}#mermaid g.stateGroup text{fill:#333;stroke:none;font-size:10px;}#mermaid g.stateGroup .state-title{font-weight:bolder;fill:#131300;}#mermaid g.stateGroup rect{fill:#ECECFF;stroke:#9370DB;}#mermaid g.stateGroup line{stroke:#333333;stroke-width:1;}#mermaid .transition{stroke:#333333;stroke-width:1;fill:none;}#mermaid .stateGroup .composit{fill:white;border-bottom:1px;}#mermaid .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px;}#mermaid .state-note{stroke:#aaaa33;fill:#fff5ad;}#mermaid .state-note text{fill:black;stroke:none;font-size:10px;}#mermaid .stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5;}#mermaid .edgeLabel .label rect{fill:#ECECFF;opacity:0.5;}#mermaid .edgeLabel .label text{fill:#333;}#mermaid .label div .edgeLabel{color:#333;}#mermaid .stateLabel text{fill:#131300;font-size:10px;font-weight:bold;}#mermaid .node circle.state-start{fill:#333333;stroke:#333333;}#mermaid .node .fork-join{fill:#333333;stroke:#333333;}#mermaid .node circle.state-end{fill:#9370DB;stroke:white;stroke-width:1.5;}#mermaid .end-state-inner{fill:white;stroke-width:1.5;}#mermaid .node rect{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid .node polygon{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid #statediagram-barbEnd{fill:#333333;}#mermaid .statediagram-cluster rect{fill:#ECECFF;stroke:#9370DB;stroke-width:1px;}#mermaid .cluster-label,#mermaid .nodeLabel{color:#131300;}#mermaid .statediagram-cluster rect.outer{rx:5px;ry:5px;}#mermaid .statediagram-state .divider{stroke:#9370DB;}#mermaid .statediagram-state .title-state{rx:5px;ry:5px;}#mermaid .statediagram-cluster.statediagram-cluster .inner{fill:white;}#mermaid .statediagram-cluster.statediagram-cluster-alt .inner{fill:#f0f0f0;}#mermaid .statediagram-cluster .inner{rx:0;ry:0;}#mermaid .statediagram-state rect.basic{rx:5px;ry:5px;}#mermaid .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#f0f0f0;}#mermaid .note-edge{stroke-dasharray:5;}#mermaid .statediagram-note rect{fill:#fff5ad;stroke:#aaaa33;stroke-width:1px;rx:0;ry:0;}#mermaid .statediagram-note rect{fill:#fff5ad;stroke:#aaaa33;stroke-width:1px;rx:0;ry:0;}#mermaid .statediagram-note text{fill:black;}#mermaid .statediagram-note .nodeLabel{color:black;}#mermaid .statediagram .edgeLabel{color:red;}#mermaid #dependencyStart,#mermaid #dependencyEnd{fill:#333333;stroke:#333333;stroke-width:1;}
/** Pie chart */
#mermaid .pieCircle{stroke:#222;stroke-width:1px;}#mermaid .pieTitleText{text-anchor:middle;font-size:25px;fill:black;}#mermaid .slice{fill:#333;font-size:17px;}#mermaid .legend text{fill:black;font-size:17px;}
/** Requirements */
#mermaid marker{fill:#333333;stroke:#333333;}#mermaid marker.cross{stroke:#333333;}#mermaid svg{font-size:16px;}#mermaid .reqBox{fill:#ECECFF;fill-opacity:100%;stroke:hsl(240, 60%, 86.2745098039%);stroke-width:hsl(240, 60%, 86.2745098039%);}#mermaid .reqTitle,#mermaid .reqLabel{fill:#131300;}#mermaid .reqLabelBox{fill:#e8e8e8;fill-opacity:100%;}#mermaid .req-title-line{stroke:hsl(240, 60%, 86.2745098039%);stroke-width:hsl(240, 60%, 86.2745098039%);}#mermaid .relationshipLine{stroke:#333333;stroke-width:1;}#mermaid .relationshipLabel{fill:black;}
/** C4 system */
#mermaid .person{stroke:calculated;fill:calculated;}
/** Mind map */
#mermaid .section-root.mindmap-node { fill: hsl(240, 100%, 50%); } #mermaid .section-root.mindmap-node text { fill: white; }
#mermaid .mindmap-edges .edge-depth-0 { stroke-width: 14; }
#mermaid .mindmap-edges .edge-depth-1 { stroke-width: 11; }
#mermaid .mindmap-edges .edge-depth-2 { stroke-width: 8; }
#mermaid .mindmap-edges .edge-depth-3 { stroke-width: 5; }
#mermaid .mindmap-edges .edge-depth-4 { stroke-width: 3; }
#mermaid .mindmap-edges .edge-depth-5 { stroke-width: 2; }
#mermaid .mindmap-edges .edge-depth-6 { stroke-width: 1; }
#mermaid .mindmap-edges .section-edge-0,  #mermaid .mindmap-node.section-0  path { fill: hsl(60, 100%, 70%); stroke: hsl(60, 100%, 70%); } #mermaid .mindmap-node.section-0  text { fill: black; }
#mermaid .mindmap-edges .section-edge-1,  #mermaid .mindmap-node.section-1  path { fill: hsl(170, 90%, 70%); stroke: hsl(170, 90%, 70%); } #mermaid .mindmap-node.section-1  text { fill: black; }
#mermaid .mindmap-edges .section-edge-2,  #mermaid .mindmap-node.section-2  path { fill: hsl(280, 90%, 70%); stroke: hsl(280, 90%, 70%); } #mermaid .mindmap-node.section-2  text { fill: white; }
#mermaid .mindmap-edges .section-edge-3,  #mermaid .mindmap-node.section-3  path { fill: hsl(30, 90%, 70%);  stroke: hsl(30, 90%, 70%);  } #mermaid .mindmap-node.section-3  text { fill: black; }
#mermaid .mindmap-edges .section-edge-4,  #mermaid .mindmap-node.section-4  path { fill: hsl(140, 90%, 70%); stroke: hsl(140, 90%, 70%); } #mermaid .mindmap-node.section-4  text { fill: black; }
#mermaid .mindmap-edges .section-edge-5,  #mermaid .mindmap-node.section-5  path { fill: hsl(250, 90%, 70%); stroke: hsl(250, 90%, 70%); } #mermaid .mindmap-node.section-5  text { fill: white; }
#mermaid .mindmap-edges .section-edge-6,  #mermaid .mindmap-node.section-6  path { fill: hsl(0, 90%, 70%);   stroke: hsl(0, 90%, 70%);   } #mermaid .mindmap-node.section-6  text { fill: black; }
#mermaid .mindmap-edges .section-edge-7,  #mermaid .mindmap-node.section-7  path { fill: hsl(110, 90%, 70%); stroke: hsl(110, 90%, 70%); } #mermaid .mindmap-node.section-7  text { fill: black; }
#mermaid .mindmap-edges .section-edge-8,  #mermaid .mindmap-node.section-8  path { fill: hsl(220, 90%, 70%); stroke: hsl(220, 90%, 70%); } #mermaid .mindmap-node.section-8  text { fill: white; }
#mermaid .mindmap-edges .section-edge-9,  #mermaid .mindmap-node.section-9  path { fill: hsl(330, 90%, 70%); stroke: hsl(330, 90%, 70%); } #mermaid .mindmap-node.section-9  text { fill: black; }
#mermaid .mindmap-edges .section-edge-10, #mermaid .mindmap-node.section-10 path { fill: hsl(80, 90%, 70%);  stroke: hsl(80, 90%, 70%);  } #mermaid .mindmap-node.section-10 text { fill: black; }
#mermaid .mindmap-edges .section-edge-11, #mermaid .mindmap-node.section-11 path { fill: hsl(190, 90%, 70%); stroke: hsl(190, 90%, 70%); } #mermaid .mindmap-node.section-11 text { fill: black; }
#mermaid .mindmap-edges .section-edge-12, #mermaid .mindmap-node.section-12 path { fill: hsl(300, 90%, 70%); stroke: hsl(300, 90%, 70%); } #mermaid .mindmap-node.section-12 text { fill: black; }
/** Timeline */
#mermaid .timeline text tspan { fill: #222; } #mermaid .timeline-node path { fill: #ccc; }

/* Dark theme */
/** Common */
html.theme-dark #mermaid {fill:#ccc;}html.theme-dark #mermaid .error-icon{fill:#a44141;}html.theme-dark #mermaid .error-text{fill:#ddd;stroke:#ddd;}html.theme-dark #mermaid .edge-pattern-solid{stroke-dasharray:0;}html.theme-dark #mermaid .edge-pattern-dashed{stroke-dasharray:3;}html.theme-dark #mermaid .edge-pattern-dotted{stroke-dasharray:2;}html.theme-dark #mermaid .marker{fill:lightgrey;stroke:lightgrey;}html.theme-dark #mermaid .marker.cross{stroke:lightgrey;}
/** Flowchart */
html.theme-dark #mermaid .label{color:#ccc;}html.theme-dark #mermaid .cluster-label text{fill:#F9FFFE;}html.theme-dark #mermaid .cluster-label span{color:#F9FFFE;}html.theme-dark #mermaid .label text,html.theme-dark #mermaid span{fill:#ccc;color:#ccc;}html.theme-dark #mermaid .node rect,html.theme-dark #mermaid .node circle,html.theme-dark #mermaid .node ellipse,html.theme-dark #mermaid .node polygon,html.theme-dark #mermaid .node path{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid .node .label{text-align:center;}html.theme-dark #mermaid .node.clickable{cursor:pointer;}html.theme-dark #mermaid .arrowheadPath{fill:lightgrey;}html.theme-dark #mermaid .edgePath .path{stroke:lightgrey;stroke-width:2.0px;}html.theme-dark #mermaid .flowchart-link{stroke:lightgrey;fill:none;}html.theme-dark #mermaid .edgeLabel{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}html.theme-dark #mermaid .edgeLabel rect{opacity:0.5;background-color:hsl(0, 0%, 34.4117647059%);fill:hsl(0, 0%, 34.4117647059%);}html.theme-dark #mermaid .cluster rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:rgba(255, 255, 255, 0.25);stroke-width:1px;}html.theme-dark #mermaid .cluster text{fill:#F9FFFE;}html.theme-dark #mermaid .cluster span{color:#F9FFFE;}html.theme-dark #mermaid div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;background:hsl(20, 1.5873015873%, 12.3529411765%);border:1px solid rgba(255, 255, 255, 0.25);border-radius:2px;pointer-events:none;z-index:100;}html.theme-dark #mermaid :root{--mermaid-}
/** Sequence diagram */
html.theme-dark #mermaid .actor{stroke:#81B1DB;fill:#1f2020;}html.theme-dark #mermaid text.actor>tspan{fill:lightgrey;stroke:none;}html.theme-dark #mermaid .actor-line{stroke:lightgrey;}html.theme-dark #mermaid .messageLine0{stroke-width:1.5;stroke-dasharray:none;stroke:lightgrey;}html.theme-dark #mermaid .messageLine1{stroke-width:1.5;stroke-dasharray:2,2;stroke:lightgrey;}html.theme-dark #mermaid #arrowhead path{fill:lightgrey;stroke:lightgrey;}html.theme-dark #mermaid .sequenceNumber{fill:black;}html.theme-dark #mermaid #sequencenumber{fill:lightgrey;}html.theme-dark #mermaid #crosshead path{fill:lightgrey;stroke:lightgrey;}html.theme-dark #mermaid .messageText{fill:lightgrey;stroke:none;}html.theme-dark #mermaid .labelBox{stroke:#81B1DB;fill:#1f2020;}html.theme-dark #mermaid .labelText,html.theme-dark #mermaid .labelText>tspan{fill:lightgrey;stroke:none;}html.theme-dark #mermaid .loopText,html.theme-dark #mermaid .loopText>tspan{fill:lightgrey;stroke:none;}html.theme-dark #mermaid .loopLine{stroke-width:2px;stroke-dasharray:2,2;stroke:#81B1DB;fill:#81B1DB;}html.theme-dark #mermaid .note{stroke:hsl(180, 0%, 18.3529411765%);fill:hsl(180, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid .noteText,html.theme-dark #mermaid .noteText>tspan{fill:rgb(183.8476190475, 181.5523809523, 181.5523809523);stroke:none;}html.theme-dark #mermaid .activation0{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:#81B1DB;}html.theme-dark #mermaid .activation1{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:#81B1DB;}html.theme-dark #mermaid .activation2{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:#81B1DB;}html.theme-dark #mermaid .actorPopupMenu{position:absolute;}html.theme-dark #mermaid .actorPopupMenuPanel{position:absolute;fill:#1f2020;box-shadow:0px 8px 16px 0px rgba(0,0,0,0.2);filter:drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));}html.theme-dark #mermaid .actor-man line{stroke:#81B1DB;fill:#1f2020;}html.theme-dark #mermaid .actor-man circle,html.theme-dark #mermaid line{stroke:#81B1DB;fill:#1f2020;stroke-width:2px;}html.theme-dark #mermaid :root{--mermaid-}
/** Gantt */
html.theme-dark #mermaid .exclude-range{fill:#444;}html.theme-dark #mermaid .section{stroke:none;opacity:0.2;}html.theme-dark #mermaid .section0{fill:hsl(52.9411764706, 28.813559322%, 58.431372549%);}html.theme-dark #mermaid .section2{fill:#EAE8D9;}html.theme-dark #mermaid .section1,html.theme-dark #mermaid .section3{fill:#333;opacity:0.2;}html.theme-dark #mermaid .sectionTitle0{fill:#F9FFFE;}html.theme-dark #mermaid .sectionTitle1{fill:#F9FFFE;}html.theme-dark #mermaid .sectionTitle2{fill:#F9FFFE;}html.theme-dark #mermaid .sectionTitle3{fill:#F9FFFE;}html.theme-dark #mermaid .sectionTitle{text-anchor:start;}html.theme-dark #mermaid .grid .tick{stroke:lightgrey;opacity:0.8;shape-rendering:crispEdges;}html.theme-dark #mermaid .grid .tick text{fill:#ccc;}html.theme-dark #mermaid .grid path{stroke-width:0;}html.theme-dark #mermaid .today{fill:none;stroke:#DB5757;stroke-width:2px;}html.theme-dark #mermaid .task{stroke-width:2;}html.theme-dark #mermaid .taskText{text-anchor:middle;}html.theme-dark #mermaid .taskTextOutsideRight{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%);text-anchor:start;}html.theme-dark #mermaid .taskTextOutsideLeft{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%);text-anchor:end;}html.theme-dark #mermaid .task.clickable{cursor:pointer;}html.theme-dark #mermaid .taskText.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}html.theme-dark #mermaid .taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}html.theme-dark #mermaid .taskTextOutsideRight.clickable{cursor:pointer;fill:#003163!important;font-weight:bold;}html.theme-dark #mermaid .taskText0,html.theme-dark #mermaid .taskText1,html.theme-dark #mermaid .taskText2,html.theme-dark #mermaid .taskText3{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%);}html.theme-dark #mermaid .task0,html.theme-dark #mermaid .task1,html.theme-dark #mermaid .task2,html.theme-dark #mermaid .task3{fill:hsl(180, 1.5873015873%, 35.3529411765%);stroke:#ffffff;}html.theme-dark #mermaid .taskTextOutside0,html.theme-dark #mermaid .taskTextOutside2{fill:lightgrey;}html.theme-dark #mermaid .taskTextOutside1,html.theme-dark #mermaid .taskTextOutside3{fill:lightgrey;}html.theme-dark #mermaid .active0,html.theme-dark #mermaid .active1,html.theme-dark #mermaid .active2,html.theme-dark #mermaid .active3{fill:#81B1DB;stroke:#ffffff;}html.theme-dark #mermaid .activeText0,html.theme-dark #mermaid .activeText1,html.theme-dark #mermaid .activeText2,html.theme-dark #mermaid .activeText3{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%)!important;}html.theme-dark #mermaid .done0,html.theme-dark #mermaid .done1,html.theme-dark #mermaid .done2,html.theme-dark #mermaid .done3{stroke:grey;fill:lightgrey;stroke-width:2;}html.theme-dark #mermaid .doneText0,html.theme-dark #mermaid .doneText1,html.theme-dark #mermaid .doneText2,html.theme-dark #mermaid .doneText3{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%)!important;}html.theme-dark #mermaid .crit0,html.theme-dark #mermaid .crit1,html.theme-dark #mermaid .crit2,html.theme-dark #mermaid .crit3{stroke:#E83737;fill:#E83737;stroke-width:2;}html.theme-dark #mermaid .activeCrit0,html.theme-dark #mermaid .activeCrit1,html.theme-dark #mermaid .activeCrit2,html.theme-dark #mermaid .activeCrit3{stroke:#E83737;fill:#81B1DB;stroke-width:2;}html.theme-dark #mermaid .doneCrit0,html.theme-dark #mermaid .doneCrit1,html.theme-dark #mermaid .doneCrit2,html.theme-dark #mermaid .doneCrit3{stroke:#E83737;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges;}html.theme-dark #mermaid .milestone{transform:rotate(45deg) scale(0.8,0.8);}html.theme-dark #mermaid .milestoneText{font-style:italic;}html.theme-dark #mermaid .doneCritText0,html.theme-dark #mermaid .doneCritText1,html.theme-dark #mermaid .doneCritText2,html.theme-dark #mermaid .doneCritText3{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%)!important;}html.theme-dark #mermaid .activeCritText0,html.theme-dark #mermaid .activeCritText1,html.theme-dark #mermaid .activeCritText2,html.theme-dark #mermaid .activeCritText3{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%)!important;}html.theme-dark #mermaid .titleText{text-anchor:middle;fill:#ccc;}html.theme-dark #mermaid :root{--mermaid-}
/** Class diagram */
html.theme-dark #mermaid g.classGroup text{fill:#e0dfdf;stroke:none;}html.theme-dark #mermaid g.classGroup text .title{font-weight:bolder;}html.theme-dark #mermaid .nodeLabel,html.theme-dark #mermaid .edgeLabel{color:#e0dfdf;}html.theme-dark #mermaid .edgeLabel .label rect{fill:#1f2020;}html.theme-dark #mermaid .label text{fill:#e0dfdf;}html.theme-dark #mermaid .edgeLabel .label span{background:#1f2020;}html.theme-dark #mermaid .classTitle{font-weight:bolder;}html.theme-dark #mermaid .node rect,html.theme-dark #mermaid .node circle,html.theme-dark #mermaid .node ellipse,html.theme-dark #mermaid .node polygon,html.theme-dark #mermaid .node path{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid .divider{stroke:#81B1DB;stroke:1;}html.theme-dark #mermaid g.clickable{cursor:pointer;}html.theme-dark #mermaid g.classGroup rect{fill:#1f2020;stroke:#81B1DB;}html.theme-dark #mermaid g.classGroup line{stroke:#81B1DB;stroke-width:1;}html.theme-dark #mermaid .classLabel .box{stroke:none;stroke-width:0;fill:#1f2020;opacity:0.5;}html.theme-dark #mermaid .classLabel .label{fill:#81B1DB;}html.theme-dark #mermaid .relation{stroke:lightgrey;stroke-width:1;fill:none;}html.theme-dark #mermaid .dashed-line{stroke-dasharray:3;}html.theme-dark #mermaid #compositionStart,html.theme-dark #mermaid .composition{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #compositionEnd,html.theme-dark #mermaid .composition{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #dependencyStart,html.theme-dark #mermaid .dependency{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #dependencyStart,html.theme-dark #mermaid .dependency{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #extensionStart,html.theme-dark #mermaid .extension{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #extensionEnd,html.theme-dark #mermaid .extension{fill:lightgrey!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #aggregationStart,html.theme-dark #mermaid .aggregation{fill:#1f2020!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #aggregationEnd,html.theme-dark #mermaid .aggregation{fill:#1f2020!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #lollipopStart,html.theme-dark #mermaid .lollipop{fill:#1f2020!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid #lollipopEnd,html.theme-dark #mermaid .lollipop{fill:#1f2020!important;stroke:lightgrey!important;stroke-width:1;}html.theme-dark #mermaid .edgeTerminals{}html.theme-dark #mermaid :root{--mermaid-}
/** Git graph */
html.theme-dark #mermaid .commit-id,html.theme-dark #mermaid .commit-msg,html.theme-dark #mermaid .branch-label{fill:lightgrey;color:lightgrey;}html.theme-dark #mermaid .branch-label0{fill:undefined;}html.theme-dark #mermaid .commit0{stroke:hsl(180, 1.5873015873%, 48.3529411765%);fill:hsl(180, 1.5873015873%, 48.3529411765%);}html.theme-dark #mermaid .commit-highlight0{stroke:rgb(133.6571428571, 129.7428571428, 129.7428571428);fill:rgb(133.6571428571, 129.7428571428, 129.7428571428);}html.theme-dark #mermaid .label0{fill:hsl(180, 1.5873015873%, 48.3529411765%);}html.theme-dark #mermaid .arrow0{stroke:hsl(180, 1.5873015873%, 48.3529411765%);}html.theme-dark #mermaid .branch-label1{fill:undefined;}html.theme-dark #mermaid .commit1{stroke:hsl(321.6393442623, 65.5913978495%, 38.2352941176%);fill:hsl(321.6393442623, 65.5913978495%, 38.2352941176%);}html.theme-dark #mermaid .commit-highlight1{stroke:rgb(93.5483870969, 221.4516129033, 139.677419355);fill:rgb(93.5483870969, 221.4516129033, 139.677419355);}html.theme-dark #mermaid .label1{fill:hsl(321.6393442623, 65.5913978495%, 38.2352941176%);}html.theme-dark #mermaid .arrow1{stroke:hsl(321.6393442623, 65.5913978495%, 38.2352941176%);}html.theme-dark #mermaid .branch-label2{fill:undefined;}html.theme-dark #mermaid .commit2{stroke:hsl(194.4, 16.5562913907%, 49.6078431373%);fill:hsl(194.4, 16.5562913907%, 49.6078431373%);}html.theme-dark #mermaid .commit-highlight2{stroke:rgb(149.4437086091, 117.6092715231, 107.5562913906);fill:rgb(149.4437086091, 117.6092715231, 107.5562913906);}html.theme-dark #mermaid .label2{fill:hsl(194.4, 16.5562913907%, 49.6078431373%);}html.theme-dark #mermaid .arrow2{stroke:hsl(194.4, 16.5562913907%, 49.6078431373%);}html.theme-dark #mermaid .branch-label3{fill:undefined;}html.theme-dark #mermaid .commit3{stroke:hsl(23.0769230769, 49.0566037736%, 40.7843137255%);fill:hsl(23.0769230769, 49.0566037736%, 40.7843137255%);}html.theme-dark #mermaid .commit-highlight3{stroke:rgb(99.9811320754, 162.7735849057, 202.0188679245);fill:rgb(99.9811320754, 162.7735849057, 202.0188679245);}html.theme-dark #mermaid .label3{fill:hsl(23.0769230769, 49.0566037736%, 40.7843137255%);}html.theme-dark #mermaid .arrow3{stroke:hsl(23.0769230769, 49.0566037736%, 40.7843137255%);}html.theme-dark #mermaid .branch-label4{fill:undefined;}html.theme-dark #mermaid .commit4{stroke:hsl(0, 83.3333333333%, 43.5294117647%);fill:hsl(0, 83.3333333333%, 43.5294117647%);}html.theme-dark #mermaid .commit-highlight4{stroke:rgb(51.5000000001, 236.5, 236.5);fill:rgb(51.5000000001, 236.5, 236.5);}html.theme-dark #mermaid .label4{fill:hsl(0, 83.3333333333%, 43.5294117647%);}html.theme-dark #mermaid .arrow4{stroke:hsl(0, 83.3333333333%, 43.5294117647%);}html.theme-dark #mermaid .branch-label5{fill:undefined;}html.theme-dark #mermaid .commit5{stroke:hsl(289.1666666667, 100%, 24.1176470588%);fill:hsl(289.1666666667, 100%, 24.1176470588%);}html.theme-dark #mermaid .commit-highlight5{stroke:rgb(154.2083333334, 255, 132.0000000001);fill:rgb(154.2083333334, 255, 132.0000000001);}html.theme-dark #mermaid .label5{fill:hsl(289.1666666667, 100%, 24.1176470588%);}html.theme-dark #mermaid .arrow5{stroke:hsl(289.1666666667, 100%, 24.1176470588%);}html.theme-dark #mermaid .branch-label6{fill:undefined;}html.theme-dark #mermaid .commit6{stroke:hsl(35.1315789474, 98.7012987013%, 40.1960784314%);fill:hsl(35.1315789474, 98.7012987013%, 40.1960784314%);}html.theme-dark #mermaid .commit-highlight6{stroke:rgb(51.331168831, 135.1948051946, 253.6688311688);fill:rgb(51.331168831, 135.1948051946, 253.6688311688);}html.theme-dark #mermaid .label6{fill:hsl(35.1315789474, 98.7012987013%, 40.1960784314%);}html.theme-dark #mermaid .arrow6{stroke:hsl(35.1315789474, 98.7012987013%, 40.1960784314%);}html.theme-dark #mermaid .branch-label7{fill:undefined;}html.theme-dark #mermaid .commit7{stroke:hsl(106.1538461538, 84.4155844156%, 35.0980392157%);fill:hsl(106.1538461538, 84.4155844156%, 35.0980392157%);}html.theme-dark #mermaid .commit-highlight7{stroke:rgb(206.1818181817, 89.948051948, 241.051948052);fill:rgb(206.1818181817, 89.948051948, 241.051948052);}html.theme-dark #mermaid .label7{fill:hsl(106.1538461538, 84.4155844156%, 35.0980392157%);}html.theme-dark #mermaid .arrow7{stroke:hsl(106.1538461538, 84.4155844156%, 35.0980392157%);}html.theme-dark #mermaid .branch{stroke-width:1;stroke:lightgrey;stroke-dasharray:2;}html.theme-dark #mermaid .commit-label{fill:rgb(183.8476190475, 181.5523809523, 181.5523809523);}html.theme-dark #mermaid .commit-label-bkg{fill:hsl(180, 1.5873015873%, 28.3529411765%);opacity:0.5;}html.theme-dark #mermaid .tag-label{fill:#e0dfdf;}html.theme-dark #mermaid .tag-label-bkg{fill:#1f2020;stroke:#cccccc;}html.theme-dark #mermaid .tag-hole{fill:#ccc;}html.theme-dark #mermaid .commit-merge{stroke:#1f2020;fill:#1f2020;}html.theme-dark #mermaid .commit-reverse{stroke:#1f2020;fill:#1f2020;stroke-width:3;}html.theme-dark #mermaid .commit-highlight-inner{stroke:#1f2020;fill:#1f2020;}html.theme-dark #mermaid .arrow{stroke-width:8;stroke-linecap:round;fill:none;}:root{--mermaid-}
/** Entity relationship */
html.theme-dark #mermaid .entityBox{fill:#1f2020;stroke:#81B1DB;}html.theme-dark #mermaid .attributeBoxOdd{fill:hsl(0, 0%, 32%);stroke:#81B1DB;}html.theme-dark #mermaid .attributeBoxEven{fill:hsl(0, 0%, 22%);stroke:#81B1DB;}html.theme-dark #mermaid .relationshipLabelBox{fill:hsl(20, 1.5873015873%, 12.3529411765%);opacity:0.7;background-color:hsl(20, 1.5873015873%, 12.3529411765%);}html.theme-dark #mermaid .relationshipLabelBox rect{opacity:0.5;}html.theme-dark #mermaid .relationshipLine{stroke:lightgrey;}html.theme-dark #mermaid :root{--mermaid-}
/** Journey */
html.theme-dark #mermaid .label{color:#ccc;}html.theme-dark #mermaid .mouth{stroke:#666;}html.theme-dark #mermaid line{stroke:#ccc;}html.theme-dark #mermaid .legend{fill:#ccc;}html.theme-dark #mermaid .label text{fill:#333;}html.theme-dark #mermaid .label{color:#ccc;}html.theme-dark #mermaid .face{fill:#FFF8DC;stroke:#999;}html.theme-dark #mermaid .node rect,html.theme-dark #mermaid .node circle,html.theme-dark #mermaid .node ellipse,html.theme-dark #mermaid .node polygon,html.theme-dark #mermaid .node path{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid .node .label{text-align:center;}html.theme-dark #mermaid .node.clickable{cursor:pointer;}html.theme-dark #mermaid .arrowheadPath{fill:lightgrey;}html.theme-dark #mermaid .edgePath .path{stroke:lightgrey;stroke-width:1.5px;}html.theme-dark #mermaid .flowchart-link{stroke:lightgrey;fill:none;}html.theme-dark #mermaid .edgeLabel{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}html.theme-dark #mermaid .edgeLabel rect{opacity:0.5;}html.theme-dark #mermaid .cluster text{fill:#F9FFFE;}html.theme-dark #mermaid div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;background:hsl(20, 1.5873015873%, 12.3529411765%);border:1px solid rgba(255, 255, 255, 0.25);border-radius:2px;pointer-events:none;z-index:100;}html.theme-dark #mermaid .task-type-0,html.theme-dark #mermaid .section-type-0{fill:#1f2020;}html.theme-dark #mermaid .task-type-1,html.theme-dark #mermaid .section-type-1{fill:hsl(180, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid .task-type-2,html.theme-dark #mermaid .section-type-2{fill:hsl(244, 1.5873015873%, 12.3529411765%);}html.theme-dark #mermaid .task-type-3,html.theme-dark #mermaid .section-type-3{fill:hsl(244, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid .task-type-4,html.theme-dark #mermaid .section-type-4{fill:hsl(116, 1.5873015873%, 12.3529411765%);}html.theme-dark #mermaid .task-type-5,html.theme-dark #mermaid .section-type-5{fill:hsl(116, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid .task-type-6,html.theme-dark #mermaid .section-type-6{fill:hsl(308, 1.5873015873%, 12.3529411765%);}html.theme-dark #mermaid .task-type-7,html.theme-dark #mermaid .section-type-7{fill:hsl(308, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid :root{--mermaid-}
/** State diagram */
html.theme-dark #mermaid defs #statediagram-barbEnd{fill:lightgrey;stroke:lightgrey;}html.theme-dark #mermaid g.stateGroup text{fill:#81B1DB;stroke:none;}html.theme-dark #mermaid g.stateGroup text{fill:#ccc;stroke:none;}html.theme-dark #mermaid g.stateGroup .state-title{font-weight:bolder;fill:#e0dfdf;}html.theme-dark #mermaid g.stateGroup rect{fill:#1f2020;stroke:#81B1DB;}html.theme-dark #mermaid g.stateGroup line{stroke:lightgrey;stroke-width:1;}html.theme-dark #mermaid .transition{stroke:lightgrey;stroke-width:1;fill:none;}html.theme-dark #mermaid .stateGroup .composit{fill:#333;border-bottom:1px;}html.theme-dark #mermaid .stateGroup .alt-composit{fill:#e0e0e0;border-bottom:1px;}html.theme-dark #mermaid .state-note{stroke:hsl(180, 0%, 18.3529411765%);fill:hsl(180, 1.5873015873%, 28.3529411765%);}html.theme-dark #mermaid .state-note text{fill:rgb(183.8476190475, 181.5523809523, 181.5523809523);stroke:none;}html.theme-dark #mermaid .stateLabel .box{stroke:none;stroke-width:0;fill:#1f2020;opacity:0.5;}html.theme-dark #mermaid .edgeLabel .label rect{fill:#1f2020;opacity:0.5;}html.theme-dark #mermaid .edgeLabel .label text{fill:#ccc;}html.theme-dark #mermaid .label div .edgeLabel{color:#ccc;}html.theme-dark #mermaid .stateLabel text{fill:#e0dfdf;font-weight:bold;}html.theme-dark #mermaid .node circle.state-start{fill:#f4f4f4;stroke:#f4f4f4;}html.theme-dark #mermaid .node .fork-join{fill:#f4f4f4;stroke:#f4f4f4;}html.theme-dark #mermaid .node circle.state-end{fill:#cccccc;stroke:#333;stroke-width:1.5;}html.theme-dark #mermaid .end-state-inner{fill:#333;stroke-width:1.5;}html.theme-dark #mermaid .node rect{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid .node polygon{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid #statediagram-barbEnd{fill:lightgrey;}html.theme-dark #mermaid .statediagram-cluster rect{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}html.theme-dark #mermaid .cluster-label,html.theme-dark #mermaid .nodeLabel{color:#e0dfdf;}html.theme-dark #mermaid .statediagram-cluster rect.outer{rx:5px;ry:5px;}html.theme-dark #mermaid .statediagram-state .divider{stroke:#81B1DB;}html.theme-dark #mermaid .statediagram-state .title-state{rx:5px;ry:5px;}html.theme-dark #mermaid .statediagram-cluster.statediagram-cluster .inner{fill:#333;}html.theme-dark #mermaid .statediagram-cluster.statediagram-cluster-alt .inner{fill:#555;}html.theme-dark #mermaid .statediagram-cluster .inner{rx:0;ry:0;}html.theme-dark #mermaid .statediagram-state rect.basic{rx:5px;ry:5px;}html.theme-dark #mermaid .statediagram-state rect.divider{stroke-dasharray:10,10;fill:#555;}html.theme-dark #mermaid .note-edge{stroke-dasharray:5;}html.theme-dark #mermaid .statediagram-note rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:hsl(180, 0%, 18.3529411765%);stroke-width:1px;rx:0;ry:0;}html.theme-dark #mermaid .statediagram-note rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:hsl(180, 0%, 18.3529411765%);stroke-width:1px;rx:0;ry:0;}html.theme-dark #mermaid .statediagram-note text{fill:rgb(183.8476190475, 181.5523809523, 181.5523809523);}html.theme-dark #mermaid .statediagram-note .nodeLabel{color:rgb(183.8476190475, 181.5523809523, 181.5523809523);}html.theme-dark #mermaid .statediagram .edgeLabel{color:red;}html.theme-dark #mermaid #dependencyStart,html.theme-dark #mermaid #dependencyEnd{fill:lightgrey;stroke:lightgrey;stroke-width:1;}html.theme-dark #mermaid :root{--mermaid-}
/** Pie chart */
html.theme-dark #mermaid .pieCircle{filter: brightness(0.7);} html.theme-dark #mermaid[aria-roledescription=pie] .legend rect { filter: brightness(0.7); } html.theme-dark #mermaid .pieTitleText{text-anchor:middle;fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%);}html.theme-dark #mermaid .slice{fill:#222;}html.theme-dark #mermaid .legend text{fill:hsl(28.5714285714, 17.3553719008%, 86.2745098039%);}html.theme-dark #mermaid :root{--mermaid-}
/** Requirements */
html.theme-dark #mermaid marker{fill:lightgrey;stroke:lightgrey;}html.theme-dark #mermaid marker.cross{stroke:lightgrey;}html.theme-dark #mermaid svg{}html.theme-dark #mermaid .reqBox{fill:#1f2020;fill-opacity:100%;stroke:#cccccc;stroke-width:#cccccc;}html.theme-dark #mermaid .reqTitle,html.theme-dark #mermaid .reqLabel{fill:#e0dfdf;}html.theme-dark #mermaid .reqLabelBox{fill:hsl(180, 1.5873015873%, 28.3529411765%);fill-opacity:100%;}html.theme-dark #mermaid .req-title-line{stroke:#cccccc;stroke-width:#cccccc;}html.theme-dark #mermaid .relationshipLine{stroke:lightgrey;stroke-width:1;}html.theme-dark #mermaid .relationshipLabel{fill:lightgrey;}html.theme-dark #mermaid :root{--mermaid-}
/** C4 system */
html.theme-dark #mermaid .person{stroke:calculated;fill:calculated;} html.theme-dark #mermaid[aria-roledescription=c4] rect {stroke: #ddd;} html.theme-dark #mermaid[aria-roledescription=c4] text {fill:#eee;}
/** Mind map */
html.theme-dark #mermaid .section-root.mindmap-node { fill: #ccc; } html.theme-dark #mermaid .section-root.mindmap-node text { fill: black; }
html.theme-dark #mermaid .mindmap-edges path, html.theme-dark #mermaid .mindmap-node { filter: hue-rotate(180deg) invert(0.9); }
/** Timeline */
html.theme-dark #mermaid .timeline text tspan { fill: #eee; } html.theme-dark #mermaid .timeline-node path { fill: #222; }

        

        .note {
            background: rgba(77, 187, 95, .2);
        }
        

        .prism {
            page-break-inside: avoid;
        }
        
        /* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript+abap+abnf+actionscript+ada+agda+al+antlr4+apacheconf+apex+apl+applescript+aql+arduino+arff+armasm+arturo+asciidoc+aspnet+asm6502+asmatmel+autohotkey+autoit+avisynth+avro-idl+awk+bash+basic+batch+bbcode+bbj+bicep+birb+bison+bnf+bqn+brainfuck+brightscript+bro+bsl+c+csharp+cpp+cfscript+chaiscript+cil+cilkc+cilkcpp+clojure+cmake+cobol+coffeescript+concurnas+csp+cooklang+coq+crystal+css-extras+csv+cue+cypher+d+dart+dataweave+dax+dhall+diff+django+dns-zone-file+docker+dot+ebnf+editorconfig+eiffel+ejs+elixir+elm+etlua+erb+erlang+excel-formula+fsharp+factor+false+firestore-security-rules+flow+fortran+ftl+gml+gap+gcode+gdscript+gedcom+gettext+gherkin+git+glsl+gn+linker-script+go+go-module+gradle+graphql+groovy+haml+handlebars+haskell+haxe+hcl+hlsl+hoon+http+hpkp+hsts+ichigojam+icon+icu-message-format+idris+ignore+inform7+ini+io+j+java+javadoc+javadoclike+javastacktrace+jexl+jolie+jq+jsdoc+js-extras+json+json5+jsonp+jsstacktrace+js-templates+julia+keepalived+keyman+kotlin+kumir+kusto+latex+latte+less+lilypond+liquid+lisp+livescript+llvm+log+lolcode+lua+magma+makefile+markdown+markup-templating+mata+matlab+maxscript+mel+mermaid+metafont+mizar+mongodb+monkey+moonscript+n1ql+n4js+nand2tetris-hdl+naniscript+nasm+neon+nevod+nginx+nim+nix+nsis+objectivec+ocaml+odin+opencl+openqasm+oz+parigp+parser+pascal+pascaligo+psl+pcaxis+peoplecode+perl+php+phpdoc+php-extras+plant-uml+plsql+powerquery+powershell+processing+prolog+promql+properties+protobuf+pug+puppet+pure+purebasic+purescript+python+qsharp+q+qml+qore+r+racket+cshtml+jsx+tsx+reason+regex+rego+renpy+rescript+rest+rip+roboconf+robotframework+ruby+rust+sas+sass+scss+scala+scheme+shell-session+smali+smalltalk+smarty+sml+solidity+solution-file+soy+sparql+splunk-spl+sqf+sql+squirrel+stan+stata+iecst+stylus+supercollider+swift+systemd+t4-templating+t4-cs+t4-vb+tap+tcl+tt2+textile+toml+tremor+turtle+twig+typescript+typoscript+unrealscript+uorazor+uri+v+vala+vbnet+velocity+verilog+vhdl+vim+visual-basic+warpscript+wasm+web-idl+wgsl+wiki+wolfram+wren+xeora+xml-doc+xojo+xquery+yaml+yang+zig&plugins=highlight-keywords */
code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre-wrap;word-spacing:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:16px;margin:0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}

        

        .procedure-steps {
            box-sizing: border-box;
            padding: 8px 8px 2px 8px;
        }
        
        .procedure-steps ol {
            margin-block-end: 0;
            margin-block-start: 0;
        }
        

        .prompt {
            flex-direction: row;
            letter-spacing: .0015em;
            font-size: 16px;
            font-weight: 400;
            line-height: 24px;
            margin-left: 0;
            margin-right: 0;
        }
        

        .prompt-content {
            padding: 15px;
            overflow: hidden;
            flex: 1 1 auto;
        }
        

        .prompt-content-p p {
            margin-block-start: 0;
            margin-block-end: 0;
        }
        

        .prompt-icon {
            flex: 0 0 auto;
            margin-left: 15px;
            margin-top: 15px;
            fill: currentcolor;
            width: 24px;
            height: 24px;
        }
        

        .prompt-title {
            font-size: 17px;
            font-weight: 600;
            line-height: 24px;
            margin-bottom: 5px;
            color: inherit;
        }
        

        :root {
            width: 95%;
            max-width: 95vw;
            padding: 0 0 0 30px;
        }
        
        body {
            font-family: JetBrains Sans,serif;
        }
        
        a {
            overflow-wrap: anywhere;
            width: 100vw;
        }
        
        
        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Light.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Light.woff) format("woff");
            font-weight: 300;
            font-style: normal;
        }

        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Regular.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-Regular.woff) format("woff");
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: JetBrains Sans;
            src: url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-SemiBold.woff2) format("woff2"), url(https://resources.jetbrains.com/storage/jetbrains-sans/JetBrainsSans-SemiBold.woff) format("woff");
            font-weight: 600;
            font-style: normal;
        }
        
        
        code {
            display: inline;
            word-break: break-word;
            font-size: 15px;
            line-height: inherit;
            font-variant-ligatures: none;
            font-family: JetBrains Sans,monospace;
            white-space: pre-line;
            overflow-wrap: break-word;
        }
        
        figcaption {
            margin-top: 5px;
        }
        
        h2 {
            padding-top: 16px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        h3 {
            padding-top: 8px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        h4 {
            padding-top: 4px;
            padding-bottom: 8px;
            margin-block-start: 0;
            margin-block-end: 0;
        }
        
        p {
            padding: 0;
            border: 0;
            line-height: 25px;
            margin-block-start: 0;
            margin-block-end: 0;
            padding-bottom: 8px;
        }
        
        div {
            display: block;
        }
        
        table {
            border-collapse: collapse;
            width: 100%;
            page-break-inside: avoid;
        }
        
        th, td {
            border: 1px solid #c4c4c4;
            padding: 10px;
            text-align: left;
            word-break: break-all;
        }
        
        .no-bold {
            font-weight: normal; 
        }
        
        .entry {
            display: grid;
            grid-template-columns: auto max-content;
            grid-template-areas: "chapter page";
            align-items: end;
            gap: 0 .25rem;
            line-height: 25px;
        }
        
        .toc-link-container{
            grid-area: chapter;
            position: relative;
            overflow: hidden;
        }
        
        .toc-link{
            text-decoration: none;
            color: black;
        }
        
        .toc-link-container::after {
            position: absolute;
            padding-left: .25ch;
            content: " . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
            ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
            ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
            text-align: right;
        }
        
        .page {
            grid-area: page;
            width: 30px;
            text-align: right;
        }
        

        .table-wrapper {
            overflow: hidden;
            box-sizing: border-box;
            font: inherit;
        }
        

        .tip {
            background-color: rgba(25, 25, 28, .05);
        }
        

        .topic {
            page-break-before: always;
        }
        </style><title>pdfSourceIN</title></head><body><div><section class="topic"><div><article class="article"><h1 class="main-title">Table of Contents</h1><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1619448550">suleimanovs.github.io</a></div><div class="page">2</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#472117165">ViewModel под капотом: как она выживает при пересоздании Activity</a></div><div class="page">3</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-989866833">ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов</a></div><div class="page">28</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-566818116">ViewModel под капотом: как работает в Compose и View</a></div><div class="page">63</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#-1282102256">SavedStateHandle и Bundle под капотом: как Android сохраняет состояние</a></div><div class="page">93</div></div><div class="entry"><div class="toc-link-container"><a class="toc-link" href="#1175324909">Decompose и Essenty: под капотом сохранения состояния без ViewModel</a></div><div class="page">176</div></div></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1619448550">suleimanovs.github.io</h1><p id="-1619448550#z659qde_3">Репозиторий для публикации личного сайта-архива.</p><p id="-1619448550#z659qde_4">Здесь хранятся технические заметки, черновики и наблюдения о внутреннем устройстве Android, архитектуре, системных механизмах и смежных темах.  Материалы обычно на <span class="control" id="-1619448550#z659qde_9">русском языке</span> и носят исследовательский, архивный характер.</p><section class="detached"><h2 id="-1619448550#z659qde_5" data-toc="z659qde_5#start-page.md-z659qde_5">Разделы</h2><ul class="list" id="-1619448550#z659qde_10" start="1"><li class="list-item" id="-1619448550#z659qde_11"><p id="-1619448550#z659qde_14">Технические заметки и примеры</p></li><li class="list-item" id="-1619448550#z659qde_12"><p id="-1619448550#z659qde_15">Разбор подкапотных механизмов Android и архитектурных компонентов</p></li><li class="list-item" id="-1619448550#z659qde_13"><p id="-1619448550#z659qde_16">Личные инженерные наблюдения и выводы</p></li></ul></section><section class="detached"><h2 id="-1619448550#z659qde_6" data-toc="z659qde_6#start-page.md-z659qde_6">О проекте</h2><p id="-1619448550#z659qde_17">Это не полноценный блог и не коммерческий сайт.  Репозиторий служит как архив и рабочий черновик для фиксации мыслей и промежуточных версий текстов.  Контент постепенно дополняется по мере появления новых заметок.</p></section><section class="detached"><h2 id="-1619448550#z659qde_7" data-toc="z659qde_7#start-page.md-z659qde_7">Ссылки</h2><ul class="list" id="-1619448550#z659qde_20" start="1"><li class="list-item" id="-1619448550#z659qde_21"><p id="-1619448550#z659qde_23">Блог suleimanov.com (<a href="https://www.suleimanov.com">https://www.suleimanov.com</a>)</p></li><li class="list-item" id="-1619448550#z659qde_22"><p id="-1619448550#z659qde_25">osman.suleimanovs@gmail.com</p></li></ul></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="472117165">ViewModel под капотом: как она выживает при пересоздании Activity</h1><section class="detached"><h2 id="472117165#-5ukyyn_3" data-toc="-5ukyyn_3#view-model-under-the-hood-store.md--5ukyyn_3">Введение</h2><p id="472117165#-5ukyyn_8">В статье не рассматривается работа с ViewModel, предполагается, что эта тема уже знакома. Основное внимание уделяется тому, как ViewModel переживает изменение конфигурации. Но для начала &mdash; небольшое введение в ViewModel.</p><p id="472117165#-5ukyyn_9"><span class="control" id="472117165#-5ukyyn_14">ViewModel</span> - компонент архитектурного паттерна MVVM, который был предоставлен Google как примитив позволяющий пережить изменение конфигураций. Изменение конфигураций в свою очередь - это состояние, заставляющая activity/fragment пересоздаваться, это именно то состояние которое может пережить ViewModel. Популярные конфигурации которые приводят к пересозданию Activity:</p><ol class="list list-decimal" id="472117165#-5ukyyn_10" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_15"><p id="472117165#-5ukyyn_19">Изменение ориентаций экрана(screenOrientation): portrait/landscape</p></li><li class="list-item" id="472117165#-5ukyyn_16"><p id="472117165#-5ukyyn_20">Изменение направления экрана(layoutDirection): rtl/ltr</p></li><li class="list-item" id="472117165#-5ukyyn_17"><p id="472117165#-5ukyyn_21">Изменение языка приложения(locale)</p></li><li class="list-item" id="472117165#-5ukyyn_18"><p id="472117165#-5ukyyn_22">Изменение размера шрифтов/соотношение экрана</p></li></ol><p id="472117165#-5ukyyn_11">Есть конечно способ сообщать системе о том что пересоздавать Activity при изменении конфигураций не нужно. Флаг <span class="inline-code" id="472117165#-5ukyyn_23">android:configChanges</span> используется в <span class="inline-code" id="472117165#-5ukyyn_24">AndroidManifest.xml</span> в теге <span class="inline-code" id="472117165#-5ukyyn_25">&lt;activity/&gt;</span>, чтобы указать, какие изменения конфигурации система не должна пересоздавать Activity, а передавать управление методу <span class="inline-code" id="472117165#-5ukyyn_26">Activity.onConfigurationChanged()</span>.</p><div class="detached code-block" id="472117165#-5ukyyn_12"><pre><code class="language-markup">&lt;activity
        android:name=&quot;MainActivity&quot;
        android:configChanges=&quot;layoutDirection|touchscreen|density|orientation|keyboard|locale|keyboardHidden|navigation|screenLayout|mcc|mnc|fontScale|uiMode|screenSize|smallestScreenSize&quot;
/&gt;</code></pre></div><p id="472117165#-5ukyyn_13">Однако сейчас речь не об этом. Наша цель &mdash; разобраться, каким образом <span class="inline-code" id="472117165#-5ukyyn_27">ViewModel</span> умудряется переживать все изменения конфигурации и сохранять своё состояние.</p></section><section class="detached"><h2 id="472117165#viewmodel" data-toc="viewmodel#view-model-under-the-hood-store.md-viewmodel">Объявление ViewModel</h2><p id="472117165#-5ukyyn_28">С появлением делегатов в Kotlin разработчики получили возможность значительно упростить создание и использование компонентов. Теперь объявление <span class="inline-code" id="472117165#-5ukyyn_35">ViewModel</span> с использованием делегатов выглядит следующим образом:</p><div class="detached code-block" id="472117165#-5ukyyn_29"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    private val viewModel by viewModel&lt;MyViewModel&gt;()
}</code></pre></div><p id="472117165#-5ukyyn_30">Без делегатов создание объекта ViewModel, используя явный вызов ViewModelProvider выглядит следующий образом:</p><div class="detached code-block" id="472117165#-5ukyyn_31"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // В старых версиях ViewModelProvider был частью lifecycle-viewmodel
        viewModel = ViewModelProvider(this).get(MyViewModel::class.java)

        // После адаптации ViewModel под KMP и переноса ViewModelProvider в lifecycle-viewmodel-android 
        // можно и рекомендуется через перегруженный фабричный метод create:
        viewModel = ViewModelProvider.create(owner = this).get(MyViewModel::class)

        // Альтернативный способ создания ViewModel (эквивалентен предыдущему)
        viewModel = ViewModelProvider.create(store = this.viewModelStore).get(MyViewModel::class)
    }
}</code></pre></div><p id="472117165#-5ukyyn_32">Метод <span class="inline-code" id="472117165#-5ukyyn_36">ViewModelProvider.create</span> имеет параметры со значениями по умолчанию, поэтому на уровне байткода компилятор создаст несколько перегруженных версий метода (overloads). Это позволяет вызывать его с разным количеством аргументов: только с <span class="inline-code" id="472117165#-5ukyyn_37">store</span>, с <span class="inline-code" id="472117165#-5ukyyn_38">store</span> и <span class="inline-code" id="472117165#-5ukyyn_39">factory</span>, либо со всеми параметрами, включая <span class="inline-code" id="472117165#-5ukyyn_40">extras</span>.</p><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="472117165#-5ukyyn_41"><span class="control" id="472117165#-5ukyyn_44">Jetpack ViewModel</span> теперь поддерживает <span class="control" id="472117165#-5ukyyn_45">Kotlin Multiplatform (KMP)</span>, что позволяет использовать его не только на Android, но и на iOS, Desktop и Web. Это стало возможным благодаря разделению на два модуля:</p><p id="472117165#-5ukyyn_42"><span class="control" id="472117165#-5ukyyn_46">lifecycle-viewmodel(expected):</span> KMP-модуль без привязки к Android. <span class="control" id="472117165#-5ukyyn_47">lifecycle-viewmodel-android(actual):</span> модуль для работы с ViewModelStoreOwner и ViewModelProvider на Android.</p><p id="472117165#-5ukyyn_43">Начиная с версии <span class="control" id="472117165#-5ukyyn_48">2.8.0-alpha03</span>, артефакты <span class="control" id="472117165#-5ukyyn_49">lifecycle-</span>* теперь официально поддерживают Kotlin Multiplatform! Это означает, что классы, такие как ViewModel, ViewModelStore, ViewModelStoreOwner и ViewModelProvider, теперь можно использовать в общем коде.</p></div>
</blockquote>
<blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Далее в статье мы рассмотрим именно версию viewmodel:2.8.0+, если в версий на которой вы находитесь сейчас немного отличаются исходники, то не переживайте, c добавлением поддержки kmp немного поменяли внутренюю структуру , но реализация и внутренняя логика такая же что и до поддержки kmp</p></div>
</blockquote>
</section><section class="detached"><h2 id="472117165#viewmodelstoreowner" data-toc="viewmodelstoreowner#view-model-under-the-hood-store.md-viewmodelstoreowner">ViewModelStoreOwner ?</h2><p id="472117165#-5ukyyn_50">Как мы видим выше, мы вручную не создаём объект ViewModel, а только передаём тип его класса в ViewModelProvider, который самостоятельно занимается созданием экземпляра.</p><p id="472117165#-5ukyyn_51">Обратите внимание, что мы также передаём в метод <span class="inline-code" id="472117165#-5ukyyn_56">ViewModelProvider.create</span> параметр <span class="inline-code" id="472117165#-5ukyyn_57">owner = this</span>. Если заглянуть в исходники метода <span class="control" id="472117165#-5ukyyn_58">create</span>, можно заметить, что требуется тип owner: ViewModelStoreOwner:</p><div class="detached code-block" id="472117165#-5ukyyn_52"><pre><code class="language-kotlin">public actual companion object {

    @JvmStatic
    @Suppress(&quot;MissingJvmstatic&quot;)
    public actual fun create(
        owner: ViewModelStoreOwner, // &lt;- нас интересует этот тип
        factory: Factory,
        extras: CreationExtras,
    ): ViewModelProvider = ViewModelProvider(owner.viewModelStore, factory, extras)
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Если интересно, почему метод `create()` можно вызывать без передачи значений для параметров `factory` и `extras` (хоть они и обязательны): </p><div class="detached code-block" id="472117165#-5ukyyn_59"><pre><code class="language-kotlin">ViewModelProvider.create(owner = this)</code></pre></div><p id="472117165#-5ukyyn_60">Это связано с тем, что код использует KMP (Kotlin Multiplatform). В expect-объявлении для create() уже заданы значения по умолчанию для factory и extras, поэтому передавать их явно необязательно.</p><div class="detached code-block" id="472117165#-5ukyyn_61"><pre><code class="language-kotlin">public expect class ViewModelProvider {
    ....
    public companion object {
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider

    }
    ....
}</code></pre></div><p id="472117165#-5ukyyn_62">Подробнее можно посмотреть в исходниках: ViewModelProvider.kt (<a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt">https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt</a>)</p></div>
</blockquote>
<section class="detached"><h3 id="472117165#viewmodelstore-owner" data-toc="viewmodelstore-owner#view-model-under-the-hood-store.md-viewmodelstore-owner">Углубляемся в ViewModelStore / Owner</h3><p id="472117165#-5ukyyn_64">Получается что при вызове метода <span class="inline-code" id="472117165#-5ukyyn_70">ViewModelProvider.create()</span> для параметра <span class="inline-code" id="472117165#-5ukyyn_71">owner</span> мы передаем <span class="inline-code" id="472117165#-5ukyyn_72">this</span> (само активити), и как можно догадаться, это означает, что activity реализует(наследуется) от интерфейса <span class="inline-code" id="472117165#-5ukyyn_73">ViewModelStoreOwner</span>. Давайте взглянем на исходники этого интерфейса: ViewModelStoreOwner (<a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelStoreOwner.kt">https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelStoreOwner.kt</a>):</p><div class="detached code-block" id="472117165#-5ukyyn_65"><pre><code class="language-kotlin">public interface [[[ViewModelStoreOwner |https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt]]] {

/**
 * The owned [ViewModelStore]
 */
public val viewModelStore: ViewModelStore
}</code></pre></div><p id="472117165#-5ukyyn_66"><span class="inline-code" id="472117165#-5ukyyn_75">ViewModelStoreOwner</span> &mdash; это интерфейс с единственным полем, которое представляет собой <span class="inline-code" id="472117165#-5ukyyn_76">ViewModelStore</span> (хранитель view models). От <span class="inline-code" id="472117165#-5ukyyn_77">ViewModelStoreOwner</span> наследуются такие компоненты как: <span class="control" id="472117165#-5ukyyn_78">ComponentActivity</span>, <span class="control" id="472117165#-5ukyyn_79">Fragment</span>, * <span class="emphasis" id="472117165#-5ukyyn_80">NavBackStackEntry</span>*.</p><p id="472117165#-5ukyyn_67">Официальная документация гласит:</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="472117165#-5ukyyn_81">A scope that owns ViewModelStore. A responsibility of an implementation of this interface is to retain owned ViewModelStore during the configuration changes and call ViewModelStore. clear, when this scope is going to be destroyed.</p></div>
</blockquote>
</section><section class="detached"><h3 id="472117165#123" data-toc="123#view-model-under-the-hood-store.md-123">Обязанности ViewModelStoreOwner:</h3><ol class="list list-decimal" id="472117165#-5ukyyn_82" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_118"><p id="472117165#-5ukyyn_120"><span class="control" id="472117165#-5ukyyn_121">Хранение ViewModelStore во время изменения конфигураций.</span></p></li><li class="list-item" id="472117165#-5ukyyn_119"><p id="472117165#-5ukyyn_122"><span class="control" id="472117165#-5ukyyn_123">Очистка ViewModelStore при уничтожении ComponentActivity/Fragment</span> &mdash; в состоянии <span class="inline-code" id="472117165#-5ukyyn_124">onDestroy()</span>. Удаляются все ViewModel-и которые ViewModelStore хранить в себе.</p></li></ol><p id="472117165#-5ukyyn_83">Мы определили, что ViewModelStoreOwner &mdash; это всего лишь интерфейс, не содержащий собственной логики. Его реализуют такие компоненты, как:</p><ul class="list" id="472117165#-5ukyyn_84" start="1"><li class="list-item" id="472117165#-5ukyyn_125"><p id="472117165#-5ukyyn_128"><span class="control" id="472117165#-5ukyyn_129"><span class="inline-code" id="472117165#-5ukyyn_131">ComponentActivity</span></span> (<span class="emphasis" id="472117165#-5ukyyn_130">и его наследники: <span class="inline-code" id="472117165#-5ukyyn_132">FragmentActivity, AppCompatActivity</span></span>)</p></li><li class="list-item" id="472117165#-5ukyyn_126"><p id="472117165#-5ukyyn_133"><span class="control" id="472117165#-5ukyyn_134"><span class="inline-code" id="472117165#-5ukyyn_136">Fragment</span></span> (<span class="emphasis" id="472117165#-5ukyyn_135">и его производные: <span class="inline-code" id="472117165#-5ukyyn_137">DialogFragment</span>, <span class="inline-code" id="472117165#-5ukyyn_138">BottomSheetDialogFragment</span>, <span class="inline-code" id="472117165#-5ukyyn_139">AppCompatDialogFragment</span></span>).</p></li><li class="list-item" id="472117165#-5ukyyn_127"><p id="472117165#-5ukyyn_140"><span class="control" id="472117165#-5ukyyn_141"><span class="inline-code" id="472117165#-5ukyyn_142">NavBackStackEntry</span></span> - Класс из библиотеки Jetpack Navigation (он же androidx navigation)</p></li></ul><p id="472117165#-5ukyyn_86">Далее нас уже интересует сам ViewModelStore:</p><p id="472117165#-5ukyyn_87">ViewModelStore &mdash; это класс, который внутри себя делегирует управление коллекцией Map (LinkedHashMap) для хранения ViewModel по ключу:</p><div class="detached code-block" id="472117165#-5ukyyn_88"><pre><code class="language-kotlin">private val map = mutableMapOf&lt;String, ViewModel&gt;()</code></pre></div><p id="472117165#-5ukyyn_89">По умолчанию в качестве ключа используется полное имя класса (включая его пакет). Этот ключ генерируется следующим образом в исходниках утилитного класса ViewModelProviders (не путать с ViewModelProvider):</p><div class="detached code-block" id="472117165#-5ukyyn_90"><pre><code class="language-kotlin">private const val VIEW_MODEL_PROVIDER_DEFAULT_KEY: String = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;

internal fun &lt;T : ViewModel&gt; getDefaultKey(modelClass: KClass&lt;T&gt;): String {
    return &quot;$VIEW_MODEL_PROVIDER_DEFAULT_KEY:$modelClass.canonicalName&quot;
}</code></pre></div><p id="472117165#-5ukyyn_91">Таким образом, для MyViewModel ключ будет выглядеть так: <span class="emphasis" id="472117165#-5ukyyn_143"><span class="inline-code" id="472117165#-5ukyyn_144">androidx.lifecycle.ViewModelProvider.DefaultKey:com.example.MyViewModel</span></span>.</p><p id="472117165#-5ukyyn_92">Поскольку ViewModelStore основан на <span class="inline-code" id="472117165#-5ukyyn_145">Map</span>, он делегирует все основные операции, такие как <span class="inline-code" id="472117165#-5ukyyn_146">put, get, keys и clear</span>, внутреннему Map (<span class="emphasis" id="472117165#-5ukyyn_147">LinkedHashMap</span>).</p><p id="472117165#-5ukyyn_93">Соответственно, так как внутренняя реализация <span class="inline-code" id="472117165#-5ukyyn_148">ViewModelStore</span> полагается на Map, он также делегирует свои методы <span class="inline-code" id="472117165#-5ukyyn_149">put</span>, <span class="inline-code" id="472117165#-5ukyyn_150">get</span>, <span class="inline-code" id="472117165#-5ukyyn_151">key</span>, <span class="inline-code" id="472117165#-5ukyyn_152">clear</span> внутреннему <span class="inline-code" id="472117165#-5ukyyn_153">Map</span> (<span class="emphasis" id="472117165#-5ukyyn_154">LinkedHashMap</span>). Особого внимания заслуживает метод <span class="inline-code" id="472117165#-5ukyyn_155">clear()</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_94"><pre><code class="language-kotlin">public open class ViewModelStore {

    private val map = mutableMapOf&lt;String, ViewModel&gt;()
    ...
    /**
     * Clears internal storage and notifies `ViewModel`s that they are no longer used.
     */
    public fun clear() {
        for (vm in map.values) {
            vm.clear()
        }
        map.clear()
    }
}</code></pre></div><p id="472117165#-5ukyyn_95">Давайте разберёмся, что здесь происходит. Когда наш <span class="inline-code" id="472117165#-5ukyyn_156">ViewModelStoreOwner</span> (в лице <span class="inline-code" id="472117165#-5ukyyn_157">ComponentActivity</span> или <span class="inline-code" id="472117165#-5ukyyn_158">Fragment</span>) окончательно умирает (смерть не связана с пересозданием из-за изменения конфигураций), он вызывает метод <span class="inline-code" id="472117165#-5ukyyn_159">clear()</span> у <span class="inline-code" id="472117165#-5ukyyn_160">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_96">В методе <span class="inline-code" id="472117165#-5ukyyn_161">clear()</span> цикл <span class="inline-code" id="472117165#-5ukyyn_162">for</span> проходит по всем значениям (<span class="inline-code" id="472117165#-5ukyyn_163">view models</span>), которые хранятся внутри внутреннего <span class="inline-code" id="472117165#-5ukyyn_164">HashMap</span>, и вызывает у каждой <span class="inline-code" id="472117165#-5ukyyn_165">ViewModel</span> внутренний метод <span class="inline-code" id="472117165#-5ukyyn_166">clear()</span>. Этот метод, в свою очередь, инициирует вызов метода <span class="inline-code" id="472117165#-5ukyyn_167">onCleared()</span> у нашей <span class="inline-code" id="472117165#-5ukyyn_168">ViewModel</span>.</p><p id="472117165#-5ukyyn_97"><span class="inline-code" id="472117165#-5ukyyn_169">onCleared()</span> &mdash; это метод, который мы можем переопределить в своей <span class="inline-code" id="472117165#-5ukyyn_170">ViewModel</span>, и он вызывается только в момент окончательного уничтожения <span class="inline-code" id="472117165#-5ukyyn_171">ViewModel</span>, когда активити или фрагмент также окончательно завершают свою работу.</p><div class="detached code-block" id="472117165#-5ukyyn_98"><pre><code class="language-kotlin">public actual abstract class ViewModel {
    ...
    protected actual open fun onCleared() {} // &lt;- метод onCleared, который можно переопределить

    @MainThread
    internal actual fun clear() {
        impl?.clear()
        onCleared() // &lt;- вызов метода onCleared
    }
}</code></pre></div><p id="472117165#-5ukyyn_99">Таким образом, метод <span class="inline-code" id="472117165#-5ukyyn_172">clear()</span> гарантирует, что все ресурсы и фоновые задачи, связанные с <span class="inline-code" id="472117165#-5ukyyn_173">ViewModel</span>, будут корректно освобождены перед уничтожением. Соответственно, сам метод <span class="inline-code" id="472117165#-5ukyyn_174">viewModelStore.clear()</span> вызывается <span class="inline-code" id="472117165#-5ukyyn_175">ViewModelStoreOwner</span> (в лице <span class="inline-code" id="472117165#-5ukyyn_176">ComponentActivity</span> или <span class="inline-code" id="472117165#-5ukyyn_177">Fragment</span>).  Давайте в качестве примера выберем <span class="inline-code" id="472117165#-5ukyyn_179">ComponentActivity</span>, чтобы понять, как работает очистка.</p><p id="472117165#-5ukyyn_100">Ниже приведён фрагмент кода из <span class="inline-code" id="472117165#-5ukyyn_180">ComponentActivity</span>, который отслеживает её уничтожение и вызывает <span class="inline-code" id="472117165#-5ukyyn_181">viewModelStore.clear()</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_101"><pre><code class="language-kotlin">@Suppress(&quot;LeakingThis&quot;)
lifecycle.addObserver(
    LifecycleEventObserver { _, event -&gt;
        if (event == Lifecycle.Event.ON_DESTROY) { // &lt;- состояние ON_DESTROY является триггером
            // Clear out the available context
            contextAwareHelper.clearAvailableContext()
            // And clear the ViewModelStore 
            if (!isChangingConfigurations) { // &lt;- проверка на то можно ли очищать ViewModelStore
                viewModelStore.clear()      // &lt;- очистка ViewModelStore
            }
            reportFullyDrawnExecutor.activityDestroyed()
        }
    }
)</code></pre></div><p id="472117165#-5ukyyn_102">В данном коде происходит добавление наблюдателя на жизненный цикл активности с использованием <span class="inline-code" id="472117165#-5ukyyn_182">LifecycleEventObserver</span>. Когда активность достигает состояния <span class="inline-code" id="472117165#-5ukyyn_183">ON_DESTROY</span>, запускается проверка, не происходит ли изменение конфигурации (<span class="inline-code" id="472117165#-5ukyyn_184">isChangingConfigurations</span>). Если активность действительно умирает окончательно (и не пересоздаётся), вызывается метод <span class="inline-code" id="472117165#-5ukyyn_185">viewModelStore.clear()</span>, который очищает все связанные с активностью <span class="inline-code" id="472117165#-5ukyyn_186">ViewModel</span>.</p><p id="472117165#-5ukyyn_103">Мы видим, что проверка состояния <span class="inline-code" id="472117165#-5ukyyn_187">ON_DESTROY</span> в сочетании с условием if (!isChangingConfigurations) позволяет убедиться в том, что причиной уничтожения не является изменение конфигурации. Только в этом случае очищается ViewModelStore и удаляются все экземпляры ViewModel, связанные с данной активностью.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="472117165#-5ukyyn_188">В этой статье мы подробно разбираем внутренние методы класса <span class="inline-code" id="472117165#-5ukyyn_190">ComponentActivity</span>, начиная с версии **androidx.activity:activity:1.9.0-alpha01 ** (<a href="https://developer.android.com/jetpack/androidx/releases/activity#1.9.0-alpha01">https://developer.android.com/jetpack/androidx/releases/activity#1.9.0-alpha01</a>), когда он был переписан на Kotlin.</p><p id="472117165#-5ukyyn_189">Если у вас установлена более старая версия библиотеки, и вы видите реализацию на Java &mdash; не переживайте. Логика и основные методы остались прежними, поэтому все представленные концепции и объяснения будут актуальны.</p></div>
</blockquote>
<section class="procedure-steps bordered-element detached"><h3 id="472117165#example-procedure">Процесс очистки ViewModel при уничтожении активности:</h3><ol class="list list"><li class="list-item" id="472117165#-5ukyyn_193"><p>Уничтожение Activity (не связано с изменением конфигураций) <span class="inline-code" id="472117165#-5ukyyn_194">ComponentActivity.onDestroy()</span> <span class="control" id="472117165#-5ukyyn_195">-&gt;</span> Очистка ViewModelStore <span class="inline-code" id="472117165#-5ukyyn_196">getViewModelStore().clear()</span> <span class="control" id="472117165#-5ukyyn_197">-&gt;</span> Оповещение ViewModel <span class="inline-code" id="472117165#-5ukyyn_198">MyViewModel.onCleared()</span></p></li></ol></section><p id="472117165#-5ukyyn_106">Теперь мы разобрались с процессом очистки и уничтожения <span class="inline-code" id="472117165#-5ukyyn_199">ViewModel</span>.  Перейдём к следующему этапу &mdash; рассмотрим подробнее, как происходит создание объекта <span class="inline-code" id="472117165#-5ukyyn_201">ViewModel</span>, когда мы передаём её в <span class="inline-code" id="472117165#-5ukyyn_202">ViewModelProvider</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_107"><pre><code class="language-kotlin">ViewModelProvider.create(owner = this).get(MyViewModel::class)</code></pre></div><p id="472117165#-5ukyyn_108">Да, можно уточнить, что <span class="inline-code" id="472117165#-5ukyyn_203">ViewModelProvider.create</span> &mdash; это функция с значениями по умолчанию. Например:</p><div class="detached code-block" id="472117165#-5ukyyn_109"><pre><code class="language-kotlin">ViewModelProvider.create(owner = this).get(MyViewModel::class)</code></pre></div><p id="472117165#-5ukyyn_110">Ранее мы разобрали один из перегруженных методов <span class="inline-code" id="472117165#-5ukyyn_204">ViewModelProvider.create</span> (функция с аргументами по умолчанию). Это фабричный метод, который принимает минимум <span class="inline-code" id="472117165#-5ukyyn_205">ViewModelStore</span> или <span class="inline-code" id="472117165#-5ukyyn_206">ViewModelStoreOwner</span>, создаёт объект<span class="inline-code" id="472117165#-5ukyyn_207">ViewModelProvider</span> и на этом завершает свою работу.</p><p id="472117165#-5ukyyn_111">Теперь нас интересует следующий ключевой метод &mdash; <span class="inline-code" id="472117165#-5ukyyn_208">get</span>, который принимает класс <span class="inline-code" id="472117165#-5ukyyn_209">ViewModel</span> в качестве параметра. <span class="inline-code" id="472117165#-5ukyyn_210">ViewModelProvider</span> делегирует свою работу классу <span class="inline-code" id="472117165#-5ukyyn_211">ViewModelProviderImpl</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_112"><pre><code class="language-kotlin">public actual open class ViewModelProvider private constructor(
    private val impl: ViewModelProviderImpl,
) {
    ...
    @MainThread
    public actual operator fun &lt;T : ViewModel&gt; get(modelClass: KClass&lt;T&gt;): T =
        impl.getViewModel(modelClass) // &lt;- вызов метода getViewModel, принадлежащий ViewModelProviderImpl
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Разработчики Google вынесли общую логику создания ViewModel в отдельный объект ViewModelProviderImpl. Это позволило избежать дублирования кода на разных платформах в KMP. Причина в том, что expect-классы в Kotlin Multiplatform не могут содержать реализации методов по умолчанию. Если бы они могли, реализация находилась бы прямо внутри expect-версии ViewModelProvider, без необходимости выносить её в отдельный объект. Однако, из-за этого ограничения, была создана ViewModelProviderImpl, которая содержит общую логику создания ViewModel для всех платформ. </p><p id="472117165#-5ukyyn_212"><span class="control" id="472117165#-5ukyyn_214">Оригинальный комментарий:</span></p><p id="472117165#-5ukyyn_213"><span class="emphasis" id="472117165#-5ukyyn_215">Kotlin Multiplatform does not support expect class with default implementation yet, so we extracted the common logic used by all platforms to this internal class.</span></p></div>
</blockquote>
<p id="472117165#-5ukyyn_114">Исходники метода <span class="inline-code" id="472117165#-5ukyyn_216">getViewModel()</span> в <span class="inline-code" id="472117165#-5ukyyn_217">ViewModelProviderImpl.kt</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_115"><pre><code class="language-kotlin">internal fun &lt;T : ViewModel&gt; getViewModel(
    modelClass: KClass&lt;T&gt;,
    key: String = ViewModelProviders.getDefaultKey(modelClass),
): T {
    val viewModel = store[key] // 1. Достается viewmodel из ViewModelStore, если он существует
    if (modelClass.isInstance(viewModel)) {
        if (factory is ViewModelProvider.OnRequeryFactory) {
            factory.onRequery(viewModel!!)
        }
        return viewModel as T
    }

    val extras = MutableCreationExtras(extras)
    extras[ViewModelProviders.ViewModelKey] = key
    // 2. Создается viewmodel и кладется в ViewModelStore
    return createViewModel(factory, modelClass, extras).also { vm -&gt; store.put(key, vm) }
}</code></pre></div><p id="472117165#-5ukyyn_116">При вызове <span class="inline-code" id="472117165#-5ukyyn_218">ViewModelProvider.create()</span> под капотом вызывается метод <span class="inline-code" id="472117165#-5ukyyn_219">getViewModel()</span>, который выполняет следующие шаги:</p><ol class="list list-decimal" id="472117165#-5ukyyn_117" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_220"><p id="472117165#-5ukyyn_222">Проверяет наличие объекта <span class="inline-code" id="472117165#-5ukyyn_223">ViewModel</span> в <span class="inline-code" id="472117165#-5ukyyn_224">ViewModelStore</span> по заданному ключу. Если объект уже существует, он возвращается.</p></li><li class="list-item" id="472117165#-5ukyyn_221"><p id="472117165#-5ukyyn_225">Если объект не найден, создаётся новый экземпляр <span class="inline-code" id="472117165#-5ukyyn_226">ViewModel</span>, который затем кладётся в <span class="inline-code" id="472117165#-5ukyyn_227">ViewModelStore</span> для последующего использования.</p></li></ol></section></section><section class="detached"><h2 id="472117165#321" data-toc="321#view-model-under-the-hood-store.md-321">Где ViewModelStore сохраняется?</h2><p id="472117165#-5ukyyn_228">Теперь, когда мы знаем полный процесс создания <span class="inline-code" id="472117165#-5ukyyn_271">ViewModel</span> и её размещения в <span class="inline-code" id="472117165#-5ukyyn_272">ViewModelStore</span>, возникает логичный вопрос: если все <span class="inline-code" id="472117165#-5ukyyn_273">ViewModel</span>-и хранятся внутри <span class="inline-code" id="472117165#-5ukyyn_274">ViewModelStore</span>, а сам <span class="inline-code" id="472117165#-5ukyyn_275">ViewModelStore</span> находится в <span class="inline-code" id="472117165#-5ukyyn_276">ComponentActivity</span> или <span class="inline-code" id="472117165#-5ukyyn_277">Fragment</span>, которые реализуют интерфейс <span class="inline-code" id="472117165#-5ukyyn_278">ViewModelStoreOwner</span>, то где и как хранится сам объект <span class="inline-code" id="472117165#-5ukyyn_279">ViewModelStore</span>?</p><p id="472117165#-5ukyyn_229">Для того чтобы найти ответ на вопрос о хранении <span class="inline-code" id="472117165#-5ukyyn_280">ViewModelStore</span>, давайте посмотрим, как <span class="inline-code" id="472117165#-5ukyyn_281">ComponentActivity</span> реализует интерфейс <span class="inline-code" id="472117165#-5ukyyn_282">ViewModelStoreOwner</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_230"><pre><code class="language-kotlin">override val viewModelStore: ViewModelStore
get() {
    checkNotNull(application) {
        (&quot;Your activity is not yet attached to the &quot; +
                &quot;Application instance. You can't request ViewModel before onCreate call.&quot;)
    }
    ensureViewModelStore()
    return _viewModelStore!!
}</code></pre></div><p id="472117165#-5ukyyn_231">Мы видим, что вызывается метод <span class="inline-code" id="472117165#-5ukyyn_283">ensureViewModelStore</span>, а затем возвращается поле <span class="inline-code" id="472117165#-5ukyyn_284">_viewModelStore</span>.</p><div class="detached code-block" id="472117165#-5ukyyn_232"><pre><code class="language-kotlin">// Lazily recreated from NonConfigurationInstances by val viewModelStore
private var _viewModelStore: ViewModelStore? = null</code></pre></div><p id="472117165#-5ukyyn_233">Поле <span class="inline-code" id="472117165#-5ukyyn_285">_viewModelStore</span> не имеет значения по умолчанию, поэтому перед возвратом оно инициализируется внутри метода <span class="inline-code" id="472117165#-5ukyyn_286">ensureViewModelStore</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_234"><pre><code class="language-kotlin">private fun ensureViewModelStore() {
    if (_viewModelStore == null) {
        // Извлекается ComponentActivity#NonConfigurationInstances из метода Activity#getLastNonConfigurationInstance()
        val nc = lastNonConfigurationInstance as NonConfigurationInstances?
        if (nc != null) {
            // Восстанавливается ViewModelStore из NonConfigurationInstances
            _viewModelStore = nc.viewModelStore
        }
        if (_viewModelStore == null) {
            // Создается ViewModelStore если нет сохраненного внутри объекта NonConfigurationInstances
            _viewModelStore = ViewModelStore()
        }
    }
}</code></pre></div><p id="472117165#-5ukyyn_235">Тут-то и начинается самое интересное. Если поле <span class="inline-code" id="472117165#-5ukyyn_287">_viewModelStore</span> равно <span class="inline-code" id="472117165#-5ukyyn_288">null</span>, сначала выполняется попытка получить его из метода <span class="inline-code" id="472117165#-5ukyyn_289">getLastNonConfigurationInstance()</span>, который возвращает объект класса <span class="inline-code" id="472117165#-5ukyyn_290">NonConfigurationInstances</span>.</p><p id="472117165#-5ukyyn_236">Если <span class="inline-code" id="472117165#-5ukyyn_291">ViewModelStore</span> отсутствует и там, это может означать одно из двух:</p><ol class="list list-decimal" id="472117165#-5ukyyn_237" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_292"><p id="472117165#-5ukyyn_294">Активность создаётся впервые и у неё ещё нет сохранённого <span class="inline-code" id="472117165#-5ukyyn_295">ViewModelStore</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_293"><p id="472117165#-5ukyyn_296">Система уничтожила процесс приложения (например, из-за нехватки памяти), а затем пользователь снова запустил приложение, из-за чего <span class="inline-code" id="472117165#-5ukyyn_297">ViewModelStore</span> не сохранился.</p></li></ol><p id="472117165#-5ukyyn_238">В любом из этих случаев создаётся новый экземпляр <span class="inline-code" id="472117165#-5ukyyn_298">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_239">Самая неочевидная часть &mdash; это вызов метода <span class="inline-code" id="472117165#-5ukyyn_299">getLastNonConfigurationInstance()</span>. Этот метод принадлежит классу<span class="inline-code" id="472117165#-5ukyyn_300">Activity</span>, а класс <span class="inline-code" id="472117165#-5ukyyn_301">NonConfigurationInstances</span>, у которого даже само название выглядит интригующе, объявлен в<span class="inline-code" id="472117165#-5ukyyn_302">ComponentActivity</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_240"><pre><code class="language-kotlin">internal class NonConfigurationInstances {
    var custom: Any? = null
    var viewModelStore: ViewModelStore? = null
}</code></pre></div><p id="472117165#-5ukyyn_241">Таким образом, объект <span class="inline-code" id="472117165#-5ukyyn_303">NonConfigurationInstances</span> используется для хранения <span class="inline-code" id="472117165#-5ukyyn_304">ViewModelStore</span> при изменении конфигурации активности. Это позволяет сохранить состояние <span class="inline-code" id="472117165#-5ukyyn_305">ViewModel</span> и восстановить его после пересоздания активности.</p><p id="472117165#-5ukyyn_242">Переменная <span class="inline-code" id="472117165#-5ukyyn_306">custom</span> по умолчанию имеет значение <span class="inline-code" id="472117165#-5ukyyn_307">null</span> и фактически не используется, поскольку <span class="inline-code" id="472117165#-5ukyyn_308">ViewModelStore</span> более гибко выполняет всю работу по сохранению состояний для переживания изменений конфигураций. Тем не менее, переменную <span class="inline-code" id="472117165#-5ukyyn_309">custom</span> можно задействовать, переопределив такие функции, как <span class="inline-code" id="472117165#-5ukyyn_310">onRetainCustomNonConfigurationInstance</span> и <span class="inline-code" id="472117165#-5ukyyn_311">getLastCustomNonConfigurationInstance</span>. До появления <span class="inline-code" id="472117165#-5ukyyn_312">ViewModel</span> многие разработчики активно использовали(в 2012) именно её для сохранения данных при пересоздании активности когда менялась конфигурация.</p><p id="472117165#-5ukyyn_243">Переменная <span class="inline-code" id="472117165#-5ukyyn_313">viewModelStore</span> имеет тип <span class="inline-code" id="472117165#-5ukyyn_314">ViewModelStore</span> и хранит ссылку на наш объект <span class="inline-code" id="472117165#-5ukyyn_315">ViewModelStore</span>. Значение в эту переменную <span class="inline-code" id="472117165#-5ukyyn_316">NonConfigurationInstances#viewModelStore</span> присваивается при вызове метода<span class="inline-code" id="472117165#-5ukyyn_317">onRetainNonConfigurationInstance</span>, а извлекается при вызове <span class="inline-code" id="472117165#-5ukyyn_318">getLastNonConfigurationInstance</span> (с этим методом мы уже столкнулись выше в методе <span class="inline-code" id="472117165#-5ukyyn_319">ensureViewModelStore</span>).</p><p id="472117165#-5ukyyn_245">Разобравшись с классом <span class="inline-code" id="472117165#-5ukyyn_320">NonConfigurationInstances</span>, давайте выясним, где создаётся объект этого класса и каким образом в поле <span class="inline-code" id="472117165#-5ukyyn_321">viewModelStore</span> присваивается значение.  Для этого обратимся к методам <span class="inline-code" id="472117165#-5ukyyn_323">onRetainNonConfigurationInstance</span> и <span class="inline-code" id="472117165#-5ukyyn_324">getLastNonConfigurationInstance</span>, которые присутствуют в <span class="inline-code" id="472117165#-5ukyyn_325">Activity</span> и <span class="inline-code" id="472117165#-5ukyyn_326">ComponentActivity</span>.  Исходники метода в <span class="inline-code" id="472117165#-5ukyyn_328">ComponentActivity</span> выглядят следующим образом:</p><div class="detached code-block" id="472117165#-5ukyyn_246"><pre><code class="language-kotlin">@Suppress(&quot;deprecation&quot;)
final override fun onRetainNonConfigurationInstance(): Any? {
    // Maintain backward compatibility.
    val custom = onRetainCustomNonConfigurationInstance()
    var viewModelStore = _viewModelStore
    if (viewModelStore == null) {
        // No one called getViewModelStore(), so see if there was an existing
        // ViewModelStore from our last NonConfigurationInstance
        val nc = lastNonConfigurationInstance as NonConfigurationInstances?
        if (nc != null) {
            viewModelStore = nc.viewModelStore
        }
    }
    if (viewModelStore == null &amp;&amp; custom == null) {
        return null
    }
    val nci = NonConfigurationInstances()
    nci.custom = custom
    nci.viewModelStore = viewModelStore
    return nci
}</code></pre></div><p id="472117165#-5ukyyn_247">Метод <span class="inline-code" id="472117165#-5ukyyn_329">onRetainNonConfigurationInstance()</span> возвращает объект <span class="inline-code" id="472117165#-5ukyyn_330">NonConfigurationInstances</span>, содержащий ссылку на ранее созданный <span class="inline-code" id="472117165#-5ukyyn_331">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_248">Таким образом, при уничтожении активности (например, при повороте экрана) вызывается этот метод, и <span class="inline-code" id="472117165#-5ukyyn_332">ViewModelStore</span> сохраняется в экземпляре <span class="inline-code" id="472117165#-5ukyyn_333">NonConfigurationInstances</span>.  Когда активность пересоздаётся, объект <span class="inline-code" id="472117165#-5ukyyn_335">NonConfigurationInstances</span> восстанавливается через вызов метода <span class="inline-code" id="472117165#-5ukyyn_336">getLastNonConfigurationInstance()</span>, и из него извлекается сохранённый <span class="inline-code" id="472117165#-5ukyyn_337">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_249">В методе <span class="inline-code" id="472117165#-5ukyyn_338">onRetainNonConfigurationInstance</span> реализована логика получения уже существующего <span class="inline-code" id="472117165#-5ukyyn_339">ViewModelStore</span> и объекта <span class="inline-code" id="472117165#-5ukyyn_340">Custom</span> (если он есть). После получения этих объектов они кладутся в экземпляр класса <span class="inline-code" id="472117165#-5ukyyn_341">NonConfigurationInstances</span>, который затем возвращается из метода.</p><p id="472117165#-5ukyyn_250">Метод <span class="inline-code" id="472117165#-5ukyyn_342">onRetainNonConfigurationInstance</span> создаёт объект класса <span class="inline-code" id="472117165#-5ukyyn_343">NonConfigurationInstances</span>, помещает внутрь <span class="inline-code" id="472117165#-5ukyyn_344">viewModelStore</span> и кастомный объект, а затем возвращает его. Возникает вопрос: кто именно вызывает этот метод?</p><p id="472117165#-5ukyyn_252">Вызывающий метод внутри самого класса Activity(самый базовый Activity от которого наследуются все остальные):</p><div class="detached code-block" id="472117165#-5ukyyn_253"><pre><code class="language-java">NonConfigurationInstances retainNonConfigurationInstances() {
    Object activity = onRetainNonConfigurationInstance(); // &lt;- вызов onRetainNonConfigurationInstance()

    //...code

    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity; // &lt;- присвоение извлеченного объекта из onRetainNonConfigurationInstance()
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = loaders;
    if (mVoiceInteractor != null) {
        mVoiceInteractor.retainInstance();
        nci.voiceInteractor = mVoiceInteractor;
    }
    return nci;
}</code></pre></div><p id="472117165#-5ukyyn_254">Как видно, сам класс <span class="inline-code" id="472117165#-5ukyyn_345">Activity</span> вызывает метод <span class="inline-code" id="472117165#-5ukyyn_346">onRetainNonConfigurationInstance</span> с которым мы ранее познакомились и сохраняет результат в поле<span class="inline-code" id="472117165#-5ukyyn_347">activity</span> класса <span class="inline-code" id="472117165#-5ukyyn_348">NonConfigurationInstances</span>. При этом мы снова сталкиваемся с классом <span class="inline-code" id="472117165#-5ukyyn_349">NonConfigurationInstances</span>, но на этот раз он объявлен в самой <span class="inline-code" id="472117165#-5ukyyn_350">Activity</span> и имеет дополнительные поля:</p><div class="detached code-block" id="472117165#-5ukyyn_255"><pre><code class="language-java">static final class NonConfigurationInstances {
    Object activity; // &lt;- Здесь и будет храниться ComponentActivity.NonConfigurationInstances
    HashMap&lt;String, Object&gt; children;
    FragmentManagerNonConfig fragments;
    ArrayMap&lt;String, LoaderManager&gt; loaders;
    VoiceInteractor voiceInteractor;
}</code></pre></div><p id="472117165#-5ukyyn_257">Чтобы устранить путаницу:</p><ul class="list" id="472117165#-5ukyyn_258" start="1"><li class="list-item" id="472117165#-5ukyyn_351"><p id="472117165#-5ukyyn_354">Объект <span class="inline-code" id="472117165#-5ukyyn_355">ViewModelStore</span> хранится внутри <span class="inline-code" id="472117165#-5ukyyn_356">ComponentActivity#NonConfigurationInstances</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_352"><p id="472117165#-5ukyyn_357">Сам объект <span class="inline-code" id="472117165#-5ukyyn_358">ComponentActivity#NonConfigurationInstances</span> хранится в <span class="inline-code" id="472117165#-5ukyyn_359">Activity#NonConfigurationInstance</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_353"><p id="472117165#-5ukyyn_360">Это достигается через метод <span class="inline-code" id="472117165#-5ukyyn_361">retainNonConfigurationInstances()</span> класса <span class="inline-code" id="472117165#-5ukyyn_362">Activity</span>.</p></li></ul><p id="472117165#-5ukyyn_259">Но кто же вызывает метод <span class="inline-code" id="472117165#-5ukyyn_363">retainNonConfigurationInstances</span> () и где хранится конечный объект <span class="inline-code" id="472117165#-5ukyyn_364">Activity#NonConfigurationInstance</span>, который содержит <span class="inline-code" id="472117165#-5ukyyn_365">ViewModelStore</span>?</p><p id="472117165#-5ukyyn_260">Ответ на этот вопрос кроется в классе <span class="inline-code" id="472117165#-5ukyyn_366">ActivityThread</span>, который отвечает за управление жизненным циклом активностей и их взаимодействие с системой. Именно этот класс обрабатывает создание, уничтожение и повторное создание активности, а также отвечает за сохранение и восстановление данных при изменениях конфигурации.</p><p id="472117165#-5ukyyn_261">Метод из <span class="inline-code" id="472117165#-5ukyyn_367">ActivityThread</span>, который непосредственно вызывает <span class="inline-code" id="472117165#-5ukyyn_368">Activity.retainNonConfigurationInstances()</span>, называется <span class="inline-code" id="472117165#-5ukyyn_369">ActivityThread.performDestroyActivity()</span>.</p><p id="472117165#-5ukyyn_262">Рассмотрим его исходники в классе <span class="inline-code" id="472117165#-5ukyyn_370">ActivityThread</span>, далее исходники:</p><div class="detached code-block" id="472117165#-5ukyyn_263"><pre><code class="language-java">void performDestroyActivity(ActivityClientRecord r, boolean finishing,
                            boolean getNonConfigInstance, String reason) {
    //...
    if (getNonConfigInstance) {
        try {
            // Вызов Activity.retainNonConfigurationInstances() 
            // и сохранение в r.lastNonConfigurationInstances
            r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();
        } catch (Exception e) {
            if (!mInstrumentation.onException(r.activity, e)) {
                throw new RuntimeException(&quot;Unable to retain activity &quot;
                        + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e);
            }
        }
    }
    //...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Чтобы найти исходники `ActivityThread`, достаточно в Android Studio воспользоваться поиском по имени класса: `ActivityThread`. Или зайти в исходники Android по одной из ссылок: </p><ul class="list" id="472117165#-5ukyyn_371" start="1"><li class="list-item" id="472117165#-5ukyyn_372"><p id="472117165#-5ukyyn_374">Android Source (cs.android.com) (<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityThread.java">https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityThread.java</a>)</p></li><li class="list-item" id="472117165#-5ukyyn_373"><p id="472117165#-5ukyyn_376">Android Google Source (googlesource.com) (<a href="https://android.googlesource.com/platform/frameworks/base/+/0e40462e11d27eb859b829b112cecb8c6f0d7afb/core/java/android/app/ActivityThread.java">https://android.googlesource.com/platform/frameworks/base/+/0e40462e11d27eb859b829b112cecb8c6f0d7afb/core/java/android/app/ActivityThread.java</a>)</p></li></ul></div>
</blockquote>
<p id="472117165#-5ukyyn_265">После вызова метода <span class="inline-code" id="472117165#-5ukyyn_378">retainNonConfigurationInstances()</span> результат сохраняется в поле <span class="inline-code" id="472117165#-5ukyyn_379">lastNonConfigurationInstances</span> объекта <span class="inline-code" id="472117165#-5ukyyn_380">ActivityClientRecord</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_266"><pre><code class="language-kotlin">r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();</code></pre></div><p id="472117165#-5ukyyn_267">Класс <span class="inline-code" id="472117165#-5ukyyn_381">ActivityClientRecord</span> представляет собой запись активности и используется для хранения всей информации, связанной с реальным экземпляром активности.  Это своего рода структура данных для ведения учета активности в процессе выполнения приложения.</p><section class="detached"><h3 id="472117165#activityclientrecord" data-toc="activityclientrecord#view-model-under-the-hood-store.md-activityclientrecord">Основные поля класса ActivityClientRecord:</h3><ul class="list" id="472117165#-5ukyyn_384" start="1"><li class="list-item" id="472117165#-5ukyyn_404"><p id="472117165#-5ukyyn_412"><span class="inline-code" id="472117165#-5ukyyn_413">lastNonConfigurationInstances</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_414">Activity#NonConfigurationInstance</span>, в котором хранится <span class="inline-code" id="472117165#-5ukyyn_415">ComponentActivity#NonConfigurationInstances</span> в котором хранится<span class="inline-code" id="472117165#-5ukyyn_416">ViewModelStore</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_405"><p id="472117165#-5ukyyn_417"><span class="inline-code" id="472117165#-5ukyyn_418">state</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_419">Bundle</span>, содержащий сохраненное состояние активности. Да, да, это тот самый Bundle который мы получаем в методе <span class="inline-code" id="472117165#-5ukyyn_420">onCreate</span>, <span class="inline-code" id="472117165#-5ukyyn_421">onRestoreInstanceState</span> и <span class="inline-code" id="472117165#-5ukyyn_422">onSaveInstanceState</span></p></li><li class="list-item" id="472117165#-5ukyyn_406"><p id="472117165#-5ukyyn_423"><span class="inline-code" id="472117165#-5ukyyn_424">intent</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_425">Intent</span>, представляющий намерение запуска активности.</p></li><li class="list-item" id="472117165#-5ukyyn_407"><p id="472117165#-5ukyyn_426"><span class="inline-code" id="472117165#-5ukyyn_427">window</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_428">Window</span>, связанный с активностью.</p></li><li class="list-item" id="472117165#-5ukyyn_408"><p id="472117165#-5ukyyn_429"><span class="inline-code" id="472117165#-5ukyyn_430">activity</span> &mdash; сам объект <span class="inline-code" id="472117165#-5ukyyn_431">Activity</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_409"><p id="472117165#-5ukyyn_432"><span class="inline-code" id="472117165#-5ukyyn_433">parent</span> &mdash; родительская активность (если есть).</p></li><li class="list-item" id="472117165#-5ukyyn_410"><p id="472117165#-5ukyyn_434"><span class="inline-code" id="472117165#-5ukyyn_435">createdConfig</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_436">Configuration</span>, содержащий настройки, примененные при создании активности.</p></li><li class="list-item" id="472117165#-5ukyyn_411"><p id="472117165#-5ukyyn_437"><span class="inline-code" id="472117165#-5ukyyn_438">overrideConfig</span> &mdash; объект <span class="inline-code" id="472117165#-5ukyyn_439">Configuration</span>, содержащий текущие настройки активности.</p></li></ul><p id="472117165#-5ukyyn_385">В рамках данной статьи нас интересует только поле <span class="inline-code" id="472117165#-5ukyyn_440">lastNonConfigurationInstances</span>, так как именно оно связано с хранением и восстановлением <span class="inline-code" id="472117165#-5ukyyn_441">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_387">Теперь давайте разберемся, как вызывается метод <span class="inline-code" id="472117165#-5ukyyn_442">performDestroyActivity()</span> в рамках системного вызова.</p><p id="472117165#-5ukyyn_388">Последовательность вызовов:</p><ol class="list list-decimal" id="472117165#-5ukyyn_389" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_443"><p id="472117165#-5ukyyn_449"><span class="inline-code" id="472117165#-5ukyyn_450">ActivityTransactionItem.execute()</span></p></li><li class="list-item" id="472117165#-5ukyyn_444"><p id="472117165#-5ukyyn_451"><span class="inline-code" id="472117165#-5ukyyn_452">ActivityRelaunchItem.execute()</span></p></li><li class="list-item" id="472117165#-5ukyyn_445"><p id="472117165#-5ukyyn_453"><span class="inline-code" id="472117165#-5ukyyn_454">ActivityThread.handleRelaunchActivity()</span></p></li><li class="list-item" id="472117165#-5ukyyn_446"><p id="472117165#-5ukyyn_455"><span class="inline-code" id="472117165#-5ukyyn_456">ActivityThread.handleRelaunchActivityInner()</span></p></li><li class="list-item" id="472117165#-5ukyyn_447"><p id="472117165#-5ukyyn_457"><span class="inline-code" id="472117165#-5ukyyn_458">ActivityThread.handleDestroyActivity()</span></p></li><li class="list-item" id="472117165#-5ukyyn_448"><p id="472117165#-5ukyyn_459"><span class="inline-code" id="472117165#-5ukyyn_460">ActivityThread.performDestroyActivity()</span></p></li></ol><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Важно понимать, что на более высоком уровне в этой цепочке стоят такие классы, как ClientTransactionItem, ClientTransaction и ClientLifecycleManager, а еще выше &mdash; сама система, которая управляет взаимодействием устройства с сенсорами и другими компонентами. Однако, углубляться дальше в эту цепочку мы не будем, так как всего через пару слоев окажемся на уровне межпроцессного взаимодействия (IPC) и работы системы с процессами.</p></div>
</blockquote>
<p id="472117165#-5ukyyn_391">На вершине вызовов находится метод <span class="inline-code" id="472117165#-5ukyyn_461">ActivityTransactionItem.execute()</span>, который запускает цепочку: сначала вызывает <span class="inline-code" id="472117165#-5ukyyn_462">getActivityClientRecord()</span>, а затем тот вызывает <span class="inline-code" id="472117165#-5ukyyn_463">ClientTransactionHandler.getActivityClient()</span>.</p><div class="detached code-block" id="472117165#-5ukyyn_392"><pre><code class="language-java">public abstract class ActivityTransactionItem extends ClientTransactionItem {
    @Override
    public final void execute(ClientTransactionHandler client, IBinder token,
                              PendingTransactionActions pendingActions) {
        final ActivityClientRecord r = getActivityClientRecord(client, token); // &lt;- Вызов getActivityClientRecord

        execute(client, r, pendingActions);
    }

    @NonNull
    ActivityClientRecord getActivityClientRecord(
            @NonNull ClientTransactionHandler client, IBinder token) {
        final ActivityClientRecord r = client.getActivityClient(token); // &lt;- получение клиент от ClientTransactionHandler(ActivityThread)
        ...
        return r;
    }
}</code></pre></div><p id="472117165#-5ukyyn_393"><span class="inline-code" id="472117165#-5ukyyn_464">ClientTransactionHandler</span> &mdash; это абстрактный класс, и одна из его реализаций &mdash; класс <span class="inline-code" id="472117165#-5ukyyn_465">ActivityThread</span>, с которым мы уже успели познакомиться.</p><div class="detached code-block" id="472117165#-5ukyyn_394"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler
        implements ActivityThreadInternal {
   ...

    @Override
    public ActivityClientRecord getActivityClient(IBinder token) {
        return mActivities.get(token); // &lt;- Возвращает из Map ActivityClientRecord по ключу
    }
   ...
}</code></pre></div><p id="472117165#-5ukyyn_395">От ActivityTransactionItem - наследуется класс ActivityRelaunchItem, который и запускает у ActivityThread метод <span class="inline-code" id="472117165#-5ukyyn_466">handleRelaunchActivity</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_396"><pre><code class="language-java">public class ActivityRelaunchItem extends ActivityTransactionItem {

    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
        ...
    }
}</code></pre></div><p id="472117165#-5ukyyn_397">Все запущенные активности внутри нашего приложения хранятся в коллекций Map в объекте класса <span class="inline-code" id="472117165#-5ukyyn_467">ActivityThread</span>:</p><div class="detached code-block" id="472117165#-5ukyyn_398"><pre><code class="language-java">/**
 * Maps from activity token to local record of running activities in this process.
 * ....
 */
@UnsupportedAppUsage
final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();</code></pre></div><p id="472117165#-5ukyyn_399">Таким образом, мы наконец выяснили, что наша <span class="inline-code" id="472117165#-5ukyyn_468">ViewModel</span> фактически хранится в объекте <span class="inline-code" id="472117165#-5ukyyn_469">ActivityThread</span>, который является синглтоном. Благодаря этому <span class="inline-code" id="472117165#-5ukyyn_470">ViewModel</span> не уничтожается при изменении конфигурации.</p><p id="472117165#-5ukyyn_401"><span class="control" id="472117165#-5ukyyn_471">Важно:</span> Экземпляр <span class="inline-code" id="472117165#-5ukyyn_472">ActivityThread</span> является синглтоном и существует на протяжении всего жизненного цикла процесса приложения. В методе <span class="inline-code" id="472117165#-5ukyyn_473">handleBindApplication()</span> внутри <span class="inline-code" id="472117165#-5ukyyn_474">ActivityThread</span> создается объект <span class="inline-code" id="472117165#-5ukyyn_475">Application</span>, который также живет до завершения процесса. Это означает, что <span class="inline-code" id="472117165#-5ukyyn_476">ActivityThread</span> и <span class="inline-code" id="472117165#-5ukyyn_477">Application</span> связаны общим жизненным циклом, за исключением того, что <span class="inline-code" id="472117165#-5ukyyn_478">ActivityThread</span> появляется раньше &mdash; еще до создания <span class="inline-code" id="472117165#-5ukyyn_479">Application</span> &mdash; и управляет его инициализацией.</p></section><section class="detached"><h3 id="472117165#viewmodelstore" data-toc="viewmodelstore#view-model-under-the-hood-store.md-viewmodelstore">Восстановление ViewModelStore</h3><p id="472117165#-5ukyyn_481">Исходя из того, что мы обнаружили ранее, цепочка хранения <span class="inline-code" id="472117165#-5ukyyn_488">ViewModel</span> выглядит следующим образом:</p><ol class="list list-decimal" id="472117165#-5ukyyn_482" type="1" start="1"><li class="list-item" id="472117165#-5ukyyn_489"><p id="472117165#-5ukyyn_494"><span class="inline-code" id="472117165#-5ukyyn_495">ViewModel</span> хранится внутри <span class="inline-code" id="472117165#-5ukyyn_496">ViewModelStore</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_490"><p id="472117165#-5ukyyn_497"><span class="inline-code" id="472117165#-5ukyyn_498">ViewModelStore</span> хранится в <span class="inline-code" id="472117165#-5ukyyn_499">ComponentActivity#NonConfigurationInstances</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_491"><p id="472117165#-5ukyyn_500"><span class="inline-code" id="472117165#-5ukyyn_501">ComponentActivity#NonConfigurationInstances</span> хранится в <span class="inline-code" id="472117165#-5ukyyn_502">Activity#NonConfigurationInstance</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_492"><p id="472117165#-5ukyyn_503"><span class="inline-code" id="472117165#-5ukyyn_504">Activity#NonConfigurationInstance</span> хранится в <span class="inline-code" id="472117165#-5ukyyn_505">ActivityClientRecord</span>.</p></li><li class="list-item" id="472117165#-5ukyyn_493"><p id="472117165#-5ukyyn_506"><span class="inline-code" id="472117165#-5ukyyn_507">ActivityClientRecord</span> хранится в <span class="inline-code" id="472117165#-5ukyyn_508">ActivityThread</span>.</p></li></ol><p id="472117165#-5ukyyn_483">При повторном создании <span class="inline-code" id="472117165#-5ukyyn_509">Activity</span> вызывается его метод <span class="inline-code" id="472117165#-5ukyyn_510">attach()</span>, одним из параметров которого является <span class="inline-code" id="472117165#-5ukyyn_511">Activity#NonConfigurationInstances</span>. Этот объект извлекается из связанного с <span class="inline-code" id="472117165#-5ukyyn_512">Activity</span> объекта <span class="inline-code" id="472117165#-5ukyyn_513">ActivityClientRecord</span>.</p><p id="472117165#-5ukyyn_484">Когда у <span class="inline-code" id="472117165#-5ukyyn_514">Activity</span> меняется конфигурация, система сразу же перезапускает её, чтобы применить новые параметры. В этот момент <span class="inline-code" id="472117165#-5ukyyn_515">ActivityThread.java</span> мгновенно извлекает <span class="inline-code" id="472117165#-5ukyyn_516">ViewModelStore</span>, который хранится в <span class="inline-code" id="472117165#-5ukyyn_517">ComponentActivity#NonConfigurationInstances</span>. Этот объект, в свою очередь, находится внутри <span class="inline-code" id="472117165#-5ukyyn_518">Activity#NonConfigurationInstances</span>.</p><p id="472117165#-5ukyyn_485">Далее <span class="inline-code" id="472117165#-5ukyyn_519">Activity#NonConfigurationInstances</span> сохраняется в <span class="inline-code" id="472117165#-5ukyyn_520">ActivityClientRecord</span>, связанном с пересоздаваемой <span class="inline-code" id="472117165#-5ukyyn_521">Activity</span>. Внутри <span class="inline-code" id="472117165#-5ukyyn_522">ActivityClientRecord</span> есть специальное поле <span class="inline-code" id="472117165#-5ukyyn_523">lastNonConfigurationInstances</span>, куда и помещается этот объект. Сам <span class="inline-code" id="472117165#-5ukyyn_524">ActivityClientRecord</span> хранится в Map-коллекции внутри <span class="inline-code" id="472117165#-5ukyyn_525">ActivityThread.java</span>, который является синглтоном в рамках процесса приложения и способен переживать изменения конфигурации.</p><p id="472117165#-5ukyyn_486">После этого ActivityThread пересоздаёт Activity, применяя новые параметры конфигурации. При создании он передаёт в неё все сохранённые данные, включая <span class="inline-code" id="472117165#-5ukyyn_526">NonConfigurationInstances</span>, который, в конечном итоге, содержит <span class="inline-code" id="472117165#-5ukyyn_527">ViewModelStore</span>. А ViewModelStore, в свою очередь, хранит нашу ViewModel</p></section><section class="detached"><h3 id="472117165#viewmodelstore_1" data-toc="viewmodelstore_1#view-model-under-the-hood-store.md-viewmodelstore_1">Диаграмма вызовов при сохранении и восстановлении ViewModelStore</h3><p id="472117165#-5ukyyn_528">Диаграмма ниже иллюстрирует цепочку вызовов. Ради упрощения некоторые детали опущены, а избыточные абстракции убраны:</p><div class="detached mermaid" id="472117165#-5ukyyn_529"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 2329.0234375 2428"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="2329.0234375" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="152" width="330" y="2164" x="1234.4609375" style=""></rect><g transform="translate(1332.0234375, 2164)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="Activity.java" class="cluster"><rect height="533" width="1526.609375" y="1249" x="8" style=""></rect><g transform="translate(726.4765625, 1249)" class="cluster-label"><foreignObject height="24" width="89.65625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Activity.java</p></span></div></foreignObject></g></g><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="282" width="1527.9765625" y="1832" x="140.640625" style=""></rect><g transform="translate(827.01953125, 1832)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityClientRecord" class="cluster"><rect height="104" width="603.859375" y="1475" x="1717.1640625" style=""></rect><g transform="translate(1945.5546875, 1475)" class="cluster-label"><foreignObject height="24" width="147.078125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityClientRecord</p></span></div></foreignObject></g></g><g data-look="classic" id="s1" class="cluster"><rect height="513" width="628.0625" y="840" x="1554.609375" style=""></rect><g transform="translate(1797.6171875, 840)" class="cluster-label"><foreignObject height="24" width="142.046875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityThread.java</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.java" class="cluster"><rect height="128" width="1347.12890625" y="1629" x="167.48046875" style=""></rect><g transform="translate(727.068359375, 1629)" class="cluster-label"><foreignObject height="24" width="227.953125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.java</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="1399.453125" y="1961" x="165.0078125" style=""></rect><g transform="translate(758.828125, 1961)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_scheduleTransactionItemNow_scheduleTransaction_0" d="M2009.094,62L2009.094,66.167C2009.094,70.333,2009.094,78.667,2009.094,84.917C2009.094,91.167,2009.094,95.333,2009.094,98.833C2009.094,102.333,2009.094,105.167,2009.094,106.583L2009.094,108"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_scheduleTransaction_ClientTransaction_1" d="M2009.094,166L2009.094,170.167C2009.094,174.333,2009.094,182.667,2009.094,188.917C2009.094,195.167,2009.094,199.333,2009.094,202.833C2009.094,206.333,2009.094,209.167,2009.094,210.583L2009.094,212"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ClientTransaction_IApplicationThread.scheduleTransaction_2" d="M2009.094,270L2009.094,274.167C2009.094,278.333,2009.094,286.667,2009.094,292.917C2009.094,299.167,2009.094,303.333,2009.094,306.833C2009.094,310.333,2009.094,313.167,2009.094,314.583L2009.094,316"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IApplicationThread.scheduleTransaction_IApplicationThread.scheduleRelaunchActivity_3" d="M2009.094,374L2009.094,378.167C2009.094,382.333,2009.094,390.667,2009.094,396.917C2009.094,403.167,2009.094,407.333,2009.094,410.833C2009.094,414.333,2009.094,417.167,2009.094,418.583L2009.094,420"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IApplicationThread.scheduleRelaunchActivity_A_4" d="M2009.094,478L2009.094,482.167C2009.094,486.333,2009.094,494.667,2009.094,500.917C2009.094,507.167,2009.094,511.333,2009.094,514.833C2009.094,518.333,2009.094,521.167,2009.094,522.583L2009.094,524"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_5" d="M2009.094,582L2009.094,586.167C2009.094,590.333,2009.094,598.667,2009.094,604.917C2009.094,611.167,2009.094,615.333,2009.094,618.833C2009.094,622.333,2009.094,625.167,2009.094,626.583L2009.094,628"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_ClientTransactionHandler_6" d="M2009.094,686L2009.094,690.167C2009.094,694.333,2009.094,702.667,2009.094,708.917C2009.094,715.167,2009.094,719.333,2009.094,722.833C2009.094,726.333,2009.094,729.167,2009.094,730.583L2009.094,732"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ClientTransactionHandler_C_7" d="M2009.094,790L2009.094,794.167C2009.094,798.333,2009.094,806.667,2009.094,815C2009.094,823.333,2009.094,831.667,2009.094,837.917C2009.094,844.167,2009.094,848.333,2009.094,851.833C2009.094,855.333,2009.094,858.167,2009.094,859.583L2009.094,861"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_X4_8" d="M1901.487,1328L1884.881,1332.167C1868.275,1336.333,1835.063,1344.667,1690.993,1359C1546.922,1373.333,1291.992,1393.667,1164.527,1414C1037.063,1434.333,1037.063,1454.667,1037.063,1466.917C1037.063,1479.167,1037.063,1483.333,1037.063,1486.833C1037.063,1490.333,1037.063,1493.167,1037.063,1494.583L1037.063,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_9" d="M2009.094,919L2009.094,923.167C2009.094,927.333,2009.094,935.667,2009.094,941.917C2009.094,948.167,2009.094,952.333,2009.094,955.833C2009.094,959.333,2009.094,962.167,2009.094,963.583L2009.094,965"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_10" d="M2009.094,1023L2009.094,1027.167C2009.094,1031.333,2009.094,1039.667,2009.094,1045.917C2009.094,1052.167,2009.094,1056.333,2009.094,1059.833C2009.094,1063.333,2009.094,1066.167,2009.094,1067.583L2009.094,1069"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_11" d="M2009.094,1127L2009.094,1137.167C2009.094,1147.333,2009.094,1167.667,2009.094,1188C2009.094,1208.333,2009.094,1228.667,2009.094,1240.917C2009.094,1253.167,2009.094,1257.333,2009.094,1260.833C2009.094,1264.333,2009.094,1267.167,2009.094,1268.583L2009.094,1270"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_PerformLaunch_LAUNCHER_12" d="M1707.469,1023L1707.469,1027.167C1707.469,1031.333,1707.469,1039.667,1707.469,1045.917C1707.469,1052.167,1707.469,1056.333,1707.469,1059.833C1707.469,1063.333,1707.469,1066.167,1707.469,1067.583L1707.469,1069"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_H_13" d="M2014.286,1328L2015.087,1332.167C2015.889,1336.333,2017.491,1344.667,2018.292,1359C2019.094,1373.333,2019.094,1393.667,2019.094,1414C2019.094,1434.333,2019.094,1454.667,2019.094,1466.917C2019.094,1479.167,2019.094,1483.333,2019.094,1486.833C2019.094,1490.333,2019.094,1493.167,2019.094,1494.583L2019.094,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_LAUNCHER_X3_16" d="M1707.469,1127L1707.469,1137.167C1707.469,1147.333,1707.469,1167.667,1707.469,1188C1707.469,1208.333,1707.469,1228.667,1603.226,1242.654C1498.983,1256.642,1290.497,1264.283,1082.678,1271.9C874.858,1279.518,667.705,1287.11,564.129,1290.907L460.552,1294.703"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X3_X2_17" d="M288.758,1328L288.758,1332.167C288.758,1336.333,288.758,1344.667,288.758,1359C288.758,1373.333,288.758,1393.667,288.758,1414C288.758,1434.333,288.758,1454.667,288.758,1466.917C288.758,1479.167,288.758,1483.333,288.758,1486.833C288.758,1490.333,288.758,1493.167,288.758,1494.583L288.758,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_MAP_MyViewModel_22" d="M1399.461,2291L1399.461,2295.167C1399.461,2299.333,1399.461,2307.667,1399.461,2316C1399.461,2324.333,1399.461,2332.667,1399.461,2338.917C1399.461,2345.167,1399.461,2349.333,1399.461,2352.833C1399.461,2356.333,1399.461,2359.167,1399.461,2360.583L1399.461,2362"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_NonConfigurationInstances.java_14" d="M2019.094,1554L2019.094,1558.167C2019.094,1562.333,2019.094,1570.667,1832.025,1579C1644.957,1587.333,1270.82,1595.667,1083.752,1601.917C896.684,1608.167,896.684,1612.333,896.684,1615.833C896.684,1619.333,896.684,1622.167,896.684,1623.583L896.684,1625"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X2_NonConfigurationInstances.java_15" d="M288.758,1554L288.758,1558.167C288.758,1562.333,288.758,1570.667,288.758,1579C288.758,1587.333,288.758,1595.667,288.758,1601.917C288.758,1608.167,288.758,1612.333,288.758,1615.833C288.758,1619.333,288.758,1622.167,288.758,1623.583L288.758,1625"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigurationInstances.kt_18" d="M680.813,1911L680.813,1915.167C680.813,1919.333,680.813,1927.667,680.813,1933.917C680.813,1940.167,680.813,1944.333,680.813,1947.833C680.813,1951.333,680.813,1954.167,680.813,1955.583L680.813,1957"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_NonConfigurationInstances.kt_19" d="M320.643,1720L325.641,1726.167C330.639,1732.333,340.636,1744.667,345.634,1755C350.633,1765.333,350.633,1773.667,350.633,1782C350.633,1790.333,350.633,1798.667,350.633,1807C350.633,1815.333,350.633,1823.667,350.633,1836.5C350.633,1849.333,350.633,1866.667,350.633,1884C350.633,1901.333,350.633,1918.667,350.633,1929.417C350.633,1940.167,350.633,1944.333,350.633,1947.833C350.633,1951.333,350.633,1954.167,350.633,1955.583L350.633,1957"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_R_ViewModelStore.kt_20" d="M1399.461,2064L1399.461,2068.167C1399.461,2072.333,1399.461,2080.667,1399.461,2089C1399.461,2097.333,1399.461,2105.667,1399.461,2114C1399.461,2122.333,1399.461,2130.667,1399.461,2136.917C1399.461,2143.167,1399.461,2147.333,1399.461,2150.833C1399.461,2154.333,1399.461,2157.167,1399.461,2158.583L1399.461,2160"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-thick edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ComponentActivity.kt_Activity.java_21" d="M246.883,1832L246.883,1827.833C246.883,1823.667,246.883,1815.333,246.883,1809.083C246.883,1802.833,246.883,1798.667,246.883,1795.167C246.883,1791.667,246.883,1788.833,246.883,1787.417L246.883,1786"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(1037.0625, 1414)" class="edgeLabel"><g transform="translate(-100, -36)" class="label"><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>До уничтожения получает Activity . NonConfigurationInstances</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(2019.09375, 1414)" class="edgeLabel"><g transform="translate(-78.734375, -12)" class="label"><foreignObject height="24" width="157.46875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Сохраняет состояние</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 1188)" class="edgeLabel"><g transform="translate(-108.7421875, -36)" class="label"><foreignObject height="72" width="217.484375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Передает ActivityClientRecord . lastNonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1414)" class="edgeLabel"><g transform="translate(-47.265625, -12)" class="label"><foreignObject height="24" width="94.53125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Присваивает</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(350.63281, 1835.18606)" class="edgeLabel"><g transform="translate(-36.65625, -12)" class="label"><foreignObject height="24" width="73.3125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Содержит</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(246.8828125, 1807)" class="edgeLabel"><g transform="translate(-47.09375, -12)" class="label"><foreignObject height="24" width="94.1875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Наследуется</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(2009.09375, 996)" id="flowchart-D-413" class="node default"><rect height="54" width="277.15625" y="-27" x="-138.578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-108.578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="217.15625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleRelaunchActivityInner()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 892)" id="flowchart-C-414" class="node default"><rect height="54" width="240.140625" y="-27" x="-120.0703125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-90.0703125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="180.140625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 1100)" id="flowchart-E-415" class="node default"><rect height="54" width="229.515625" y="-27" x="-114.7578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-84.7578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="169.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleDestroyActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 1301)" id="flowchart-F-416" class="node default"><rect height="54" width="239.140625" y="-27" x="-119.5703125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-89.5703125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="179.140625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>performDestroyActivity()</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 1100)" id="flowchart-LAUNCHER-417" class="node default"><rect height="54" width="235.71875" y="-27" x="-117.859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-87.859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="175.71875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>performLaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 996)" id="flowchart-PerformLaunch-418" class="node default"><rect height="54" width="226.09375" y="-27" x="-113.046875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-83.046875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="166.09375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleLaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2019.09375, 1527)" id="flowchart-H-419" class="node default"><rect height="54" width="533.859375" y="-27" x="-266.9296875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-236.9296875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="473.859375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>lastNonConfigurationInstances:Activity.NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1527)" id="flowchart-X2-420" class="node default"><rect height="54" width="491.515625" y="-27" x="-245.7578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-215.7578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="431.515625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mLastNonConfigurationInstances:NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1301)" id="flowchart-X3-422" class="node default"><rect height="54" width="335.59375" y="-27" x="-167.796875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-137.796875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="275.59375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>attach(lastNonConfigurationInstances)</p></span></div></foreignObject></g></g><g transform="translate(1037.0625, 1527)" id="flowchart-X4-423" class="node default"><rect height="54" width="503.71875" y="-27" x="-251.859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-221.859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="443.71875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>retainNonConfigurationInstances():NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(680.8125, 1884)" id="flowchart-RetainMethod-424" class="node default"><rect height="54" width="517.046875" y="-27" x="-258.5234375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-228.5234375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="457.046875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance():NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(350.6328125, 2025)" id="flowchart-Q-426" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2025)" id="flowchart-R-427" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g><g transform="translate(298.7578125, 1693)" id="flowchart-J-428" class="node default"><rect height="54" width="167.609375" y="-27" x="-83.8046875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-53.8046875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="107.609375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Object activity</p></span></div></foreignObject></g></g><g transform="translate(525.828125, 1693)" id="flowchart-K-429" class="node default"><rect height="54" width="186.53125" y="-27" x="-93.265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-63.265625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="126.53125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashMap children</p></span></div></foreignObject></g></g><g transform="translate(802.296875, 1693)" id="flowchart-L-430" class="node default"><rect height="78" width="266.40625" y="-39" x="-133.203125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-103.203125, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="206.40625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerNonConfig fragments</p></span></div></foreignObject></g></g><g transform="translate(1077.5546875, 1693)" id="flowchart-M-431" class="node default"><rect height="54" width="184.109375" y="-27" x="-92.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-62.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="124.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ArrayMap loaders</p></span></div></foreignObject></g></g><g transform="translate(1349.609375, 1693)" id="flowchart-N-432" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>VoiceInteractor voiceInteractor</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2240)" id="flowchart-MAP-433" class="node default"><rect height="102" width="260" y="-51" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -36)" style="" class="label"><rect></rect><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf&lt;String, ViewModel&gt;()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 35)" id="flowchart-scheduleTransactionItemNow-434" class="node default"><rect height="54" width="452.171875" y="-27" x="-226.0859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-196.0859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="392.171875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientLifecycleManager.scheduleTransactionItemNow()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 139)" id="flowchart-scheduleTransaction-435" class="node default"><rect height="54" width="388.5" y="-27" x="-194.25" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-164.25, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="328.5"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientLifecycleManager.scheduleTransaction()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 243)" id="flowchart-ClientTransaction-437" class="node default"><rect height="54" width="265.875" y="-27" x="-132.9375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-102.9375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="205.875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientTransaction.schedule()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 347)" id="flowchart-IApplicationThread.scheduleTransaction-439" class="node default"><rect height="54" width="359.359375" y="-27" x="-179.6796875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-149.6796875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="299.359375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>IApplicationThread.scheduleTransaction()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 451)" id="flowchart-IApplicationThread.scheduleRelaunchActivity-441" class="node default"><rect height="54" width="397.109375" y="-27" x="-198.5546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-168.5546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="337.109375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>IApplicationThread.scheduleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 555)" id="flowchart-A-443" class="node default"><rect height="54" width="305.265625" y="-27" x="-152.6328125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-122.6328125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="245.265625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityTransactionItem.execute()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 763)" id="flowchart-ClientTransactionHandler-444" class="node default"><rect height="54" width="425.28125" y="-27" x="-212.640625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-182.640625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="365.28125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientTransactionHandler.handleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 659)" id="flowchart-B-446" class="node default"><rect height="54" width="287.921875" y="-27" x="-143.9609375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-113.9609375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="227.921875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityRelaunchItem.execute()</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2393)" id="flowchart-MyViewModel-480" class="node default"><rect height="54" width="156.109375" y="-27" x="-78.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-48.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MyViewModel</p></span></div></foreignObject></g></g></g></g></g></svg></div></section></section><section class="detached"><h2 id="472117165#-5ukyyn_7" data-toc="-5ukyyn_7#view-model-under-the-hood-store.md--5ukyyn_7">Итоги</h2><p id="472117165#-5ukyyn_530">В этой статье мы не касались работы ViewModel как таковой &mdash; фокус был исключительно на том, <span class="control" id="472117165#-5ukyyn_536">почему она не умирает при пересоздании Activity</span>, и за счёт чего это вообще возможно.</p><p id="472117165#-5ukyyn_531">Мы проследили всю цепочку: <span class="inline-code" id="472117165#-5ukyyn_537">ViewModel</span> &rarr; <span class="inline-code" id="472117165#-5ukyyn_538">ViewModelStore</span> &rarr; <span class="inline-code" id="472117165#-5ukyyn_539">ComponentActivity#NonConfigurationInstances</span> &rarr; <span class="inline-code" id="472117165#-5ukyyn_540">Activity#NonConfigurationInstances</span> &rarr; <span class="inline-code" id="472117165#-5ukyyn_541">ActivityClientRecord</span> &rarr; <span class="inline-code" id="472117165#-5ukyyn_542">ActivityThread</span>. Именно в этой глубокой вложенности и заключается ответ: <span class="control" id="472117165#-5ukyyn_543">ViewModel выживает, потому что сохраняется не в Activity напрямую, а в объекте, который система сама передаёт новой Activity при конфигурационных изменениях.</span></p><p id="472117165#-5ukyyn_532">Сам <span class="inline-code" id="472117165#-5ukyyn_544">ViewModelStore</span> создаётся либо с нуля, либо восстанавливается через <span class="inline-code" id="472117165#-5ukyyn_545">getLastNonConfigurationInstance()</span>. Он очищается только в <span class="inline-code" id="472117165#-5ukyyn_546">onDestroy()</span>, если <span class="inline-code" id="472117165#-5ukyyn_547">isChangingConfigurations == false</span>, &mdash; то есть если Activity действительно умирает, а не пересоздаётся.</p><p id="472117165#-5ukyyn_533">Под капотом всё это обеспечивается <span class="inline-code" id="472117165#-5ukyyn_548">ActivityThread</span>, который сохраняет <span class="inline-code" id="472117165#-5ukyyn_549">NonConfigurationInstances</span> в <span class="inline-code" id="472117165#-5ukyyn_550">ActivityClientRecord</span>, а потом передаёт в метод <span class="inline-code" id="472117165#-5ukyyn_551">attach()</span> при создании новой Activity. <span class="inline-code" id="472117165#-5ukyyn_552">ActivityThread</span> &mdash; синглтон, живущий столько же, сколько и процесс, и именно он является опорной точкой, через которую проходит вся цепочка восстановления.</p><p id="472117165#-5ukyyn_534"><span class="control" id="472117165#-5ukyyn_553">ViewModel выживает не потому, что её кто-то &ldquo;сохраняет&rdquo; &mdash; а потому, что никто её не убивает.</span> Пока жив <span class="inline-code" id="472117165#-5ukyyn_554">ActivityThread</span>, жив и <span class="inline-code" id="472117165#-5ukyyn_555">ViewModelStore</span>.</p><p id="472117165#-5ukyyn_535">Позже мы снова вернемся к <span class="inline-code" id="472117165#-5ukyyn_556">ActivityThread</span> и <span class="inline-code" id="472117165#-5ukyyn_557">ActivityClientRecord</span>, это будет в рамках следующих статьей.</p></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-989866833">ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов</h1><p id="-989866833#z1dyhj3_3">В предыдущей статье мы рассмотрели ViewModelStore (<a href="#472117165">ViewModel под капотом: как она выживает при пересоздании Activity</a>) и изучили полный путь от создания <span class="inline-code" id="-989866833#z1dyhj3_10">ViewModel</span> до его хранения в <span class="inline-code" id="-989866833#z1dyhj3_11">ViewModelStore</span>. Мы выяснили, где хранится сам <span class="inline-code" id="-989866833#z1dyhj3_12">ViewModelStore</span>, но рассматривали это в контексте <span class="inline-code" id="-989866833#z1dyhj3_13">ComponentActivity</span> и его родителя <span class="inline-code" id="-989866833#z1dyhj3_14">Activity</span>.</p><p id="-989866833#z1dyhj3_4">А как обстоят дела у <span class="inline-code" id="-989866833#z1dyhj3_15">Fragment</span>-ов? В этой статье мы ответим на вопрос:</p><p id="-989866833#z1dyhj3_5"><span class="control" id="-989866833#z1dyhj3_16">Где хранятся <span class="inline-code" id="-989866833#z1dyhj3_17">ViewModelStore</span> для <span class="inline-code" id="-989866833#z1dyhj3_18">Fragment</span>-ов и как <span class="inline-code" id="-989866833#z1dyhj3_19">Retain</span>-фрагменты переживают изменение конфигурации?</span></p><section class="detached"><h2 id="-989866833#z1dyhj3_6" data-toc="z1dyhj3_6#fragment-viewmodelstore-and-retain-fragment.md-z1dyhj3_6">Вводная</h2><p id="-989866833#z1dyhj3_20"><span class="control" id="-989866833#z1dyhj3_25">ViewModelStore</span> &mdash; это класс, который содержит внутри себя коллекцию <span class="inline-code" id="-989866833#z1dyhj3_26">Map&lt;String, ViewModel&gt;</span>.  ViewModel-и хранятся в этой коллекции по ключу, а <span class="inline-code" id="-989866833#z1dyhj3_28">ViewModelStoreOwner</span> - в лице <span class="inline-code" id="-989866833#z1dyhj3_29">Fragment</span>, <span class="inline-code" id="-989866833#z1dyhj3_30">ComponentActivity</span> и <span class="inline-code" id="-989866833#z1dyhj3_31">NavBackStackEntry</span> может очистить их при необходимости.</p><p id="-989866833#z1dyhj3_21"><span class="control" id="-989866833#z1dyhj3_32">Fragment(Фрагменты)</span> &mdash; это части UI, которые могут жить внутри активности или в другом фрагменте, обеспечивая гибкость и переиспользуемость интерфейса. Фрагменты управляются активностью и её жизненным циклом, а навигация часто строится на базе фрагментов с использованием подхода <span class="inline-code" id="-989866833#z1dyhj3_33">SingleActivity</span>. Прямые наследники &mdash; <span class="inline-code" id="-989866833#z1dyhj3_34">DialogFragment</span>, <span class="inline-code" id="-989866833#z1dyhj3_35">BottomSheetDialogFragment</span> и <span class="inline-code" id="-989866833#z1dyhj3_36">AppCompatDialogFragment</span> &mdash; используются для отображения диалогов и нижних листов.</p><p id="-989866833#z1dyhj3_22"><span class="control" id="-989866833#z1dyhj3_37">Retain Fragment</span><span class="emphasis" id="-989866833#z1dyhj3_38">(<span id="-989866833#z1dyhj3_42"><span style="text-decoration:line-through">@Deprecated</span></span>)</span> &mdash; это фрагмент, который сохраняется при изменении конфигурации активности,  вместо того чтобы пересоздаваться. Это достигается вызовом метода <span class="inline-code" id="-989866833#z1dyhj3_40">setRetainInstance(true)</span> у Fragment, который указывает системе <span class="control" id="-989866833#z1dyhj3_41">не уничтожать фрагмент</span> при пересоздании активности.</p><p id="-989866833#z1dyhj3_23">Раньше механизм Retain Fragment использовался для хранения данных и фоновых операций, так как если жив фрагмент, то живы все его данные. Но сейчас он считается устаревшим и не рекомендуется к использованию. В современных приложениях его заменяет <span class="inline-code" id="-989866833#z1dyhj3_43">ViewModel</span>.</p></section><section class="detached"><h2 id="-989866833#viewmodelstore-fragment" data-toc="viewmodelstore-fragment#fragment-viewmodelstore-and-retain-fragment.md-viewmodelstore-fragment">Как сохраняется ViewModelStore у Fragment?</h2><p id="-989866833#z1dyhj3_44">В этой статье я рассчитываю, что вы уже ознакомились со статьей ViewModelStore (<a href="#472117165">ViewModel под капотом: как она выживает при пересоздании Activity</a>).</p><p id="-989866833#z1dyhj3_45">В предыдущей статье мы <span class="control" id="-989866833#z1dyhj3_134">детально</span> рассмотрели процесс сохранения <span class="inline-code" id="-989866833#z1dyhj3_135">ViewModelStore</span> для <span class="inline-code" id="-989866833#z1dyhj3_136">Activity</span>.  Цепочка вызовов содержала все шаги до конечной точки <span class="inline-code" id="-989866833#z1dyhj3_138">ActivityThread</span> и даже выше.</p><p id="-989866833#z1dyhj3_46">Однако в случае <span class="inline-code" id="-989866833#z1dyhj3_139">Fragment</span>-ов цепочка вызовов к счастью <span class="control" id="-989866833#z1dyhj3_140">короче</span> и проще.  Поэтому мы рассмотрим сохранение <span class="inline-code" id="-989866833#z1dyhj3_142">ViewModelStore</span> для <span class="inline-code" id="-989866833#z1dyhj3_143">Fragment</span> и <span class="inline-code" id="-989866833#z1dyhj3_144">Retain Fragment</span> отталкиваясь от следующей диаграммы и дополним ее для Fragment-ов:</p><div class="detached mermaid" id="-989866833#z1dyhj3_47"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 671.6171875 549"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="671.6171875" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="306" width="655.6171875" y="8" x="8" style=""></rect><g transform="translate(258.19921875, 8)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="560.78125" y="161" x="82.8359375" style=""></rect><g transform="translate(257.3203125, 161)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigurationInstances.kt_0" d="M208.227,111L208.227,115.167C208.227,119.333,208.227,127.667,208.227,133.917C208.227,140.167,208.227,144.333,208.227,147.833C208.227,151.333,208.227,154.167,208.227,155.583L208.227,157"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_R_ViewModelStore.kt_1" d="M478.617,264L478.617,268.167C478.617,272.333,478.617,280.667,478.617,289C478.617,297.333,478.617,305.667,478.617,314C478.617,322.333,478.617,330.667,478.617,336.917C478.617,343.167,478.617,347.333,478.617,350.833C478.617,354.333,478.617,357.167,478.617,358.583L478.617,360"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(305.6171875, 356)" class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="177" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 96.5)" id="flowchart-MAP-408" class="node default"><rect height="102" width="260" y="-51" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -36)" style="" class="label"><rect></rect><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf&lt;String, ViewModel&gt;()</p></span></div></foreignObject></g></g></g></g><g transform="translate(208.2265625, 72)" id="flowchart-RetainMethod-404" class="node default"><rect height="78" width="330.453125" y="-39" x="-165.2265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-135.2265625, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="270.453125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance(): NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(208.2265625, 225)" id="flowchart-Q-406" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(478.6171875, 225)" id="flowchart-R-407" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g></g></g></g></svg></div><p id="-989866833#z1dyhj3_48">Начнём работу с фрагментами. В этой статье мы не будем углубляться в работу <span class="inline-code" id="-989866833#z1dyhj3_145">FragmentManager</span> и транзакциями &mdash; вместо этого сосредоточимся на том, <span class="control" id="-989866833#z1dyhj3_146">где и как хранятся <span class="inline-code" id="-989866833#z1dyhj3_147">ViewModel</span> и <span class="inline-code" id="-989866833#z1dyhj3_148">ViewModelStore</span></span> в случае с фрагментами.</p><p id="-989866833#z1dyhj3_49">Как мы знаем, фрагменты не существуют сами по себе &mdash; они запускаются внутри <span class="control" id="-989866833#z1dyhj3_149">активити</span> или даже <span class="control" id="-989866833#z1dyhj3_150">внутри других фрагментов</span>.</p><p id="-989866833#z1dyhj3_50">Рассмотрим простой пример <span class="inline-code" id="-989866833#z1dyhj3_151">Activity</span>, которая добавляет фрагмент в контейнер(FrameLayout):</p><div class="detached code-block" id="-989866833#z1dyhj3_51"><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        supportFragmentManager
            .beginTransaction()
            .add(R.id.frameLayoutContainer, FirstFragment())
            .commit()
    }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_152"><span class="control" id="-989866833#z1dyhj3_153">Важно:</span> Код в статье предназначен исключительно для демонстрации и <span class="control" id="-989866833#z1dyhj3_154">не претендует на best practices</span>. Примеры упрощены для лучшего понимания.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_53">Теперь имея Activity и транзакцию создадим сам фрагмент и инициализируем в нём <span class="inline-code" id="-989866833#z1dyhj3_155">ViewModel</span> стандартным способ:</p><div class="detached code-block" id="-989866833#z1dyhj3_54"><pre><code class="language-kotlin">class FirstFragment : Fragment() {

    private lateinit var viewModel: MyViewModel
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewModel = ViewModelProvider.create(owner = this).get(MyViewModel::class)
    }
}</code></pre></div><p id="-989866833#z1dyhj3_55">Здесь, как и в предыдущих примерах (в прошлой статье), используется <span class="inline-code" id="-989866833#z1dyhj3_156">ViewModelProvider.create</span>, который требует в качестве параметра <span class="control" id="-989866833#z1dyhj3_157"><span class="inline-code" id="-989866833#z1dyhj3_164">owner</span></span>. Это означает, что класс <span class="inline-code" id="-989866833#z1dyhj3_158">Fragment</span> должен реализовывать некий интерфейс, позволяющий ему выступать в роли владельца <span class="inline-code" id="-989866833#z1dyhj3_159">ViewModel</span>. Таким интерфейсом является <span class="inline-code" id="-989866833#z1dyhj3_160">ViewModelStoreOwner</span>, который реализуют такие классы, как <span class="inline-code" id="-989866833#z1dyhj3_161">Fragment</span>, <span class="inline-code" id="-989866833#z1dyhj3_162">ComponentActivity</span> и <span class="inline-code" id="-989866833#z1dyhj3_163">NavBackStackEntry</span>.</p><p id="-989866833#z1dyhj3_56">В исходном коде метода <span class="inline-code" id="-989866833#z1dyhj3_165">create</span> у <span class="inline-code" id="-989866833#z1dyhj3_166">ViewModelProvider</span> явно требуется именно этот интерфейс. Поскольку <span class="inline-code" id="-989866833#z1dyhj3_167">ViewModelProvider</span> был переписан для KMP, его <span class="inline-code" id="-989866833#z1dyhj3_168">expect</span>-объявление находится в <span class="inline-code" id="-989866833#z1dyhj3_169">commonMain</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_57"><pre><code class="language-kotlin">public expect class ViewModelProvider {
    ....
    public companion object {
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider
    }
}</code></pre></div><p id="-989866833#z1dyhj3_58">Раз мы это выяснили, давайте сразу посмотрим, как <span class="control" id="-989866833#z1dyhj3_170"><span class="inline-code" id="-989866833#z1dyhj3_177">Fragment</span></span> реализует интерфейс <span class="inline-code" id="-989866833#z1dyhj3_171">ViewModelStoreOwner</span>.  Это важно, потому что такие классы, как <span class="inline-code" id="-989866833#z1dyhj3_173">DialogFragment</span>, <span class="inline-code" id="-989866833#z1dyhj3_174">BottomSheetDialogFragment</span>, <span class="inline-code" id="-989866833#z1dyhj3_175">AppCompatDialogFragment</span> &mdash; наследуются от <span class="inline-code" id="-989866833#z1dyhj3_176">Fragment</span>, и среди них только он реализует этот интерфейс:</p><div class="detached code-block" id="-989866833#z1dyhj3_59"><pre><code class="language-java">@NonNull
@Override
public ViewModelStore getViewModelStore() {
    if (mFragmentManager == null) {
        throw new IllegalStateException(&quot;Can't access ViewModels from detached fragment&quot;);
    }
    if (getMinimumMaxLifecycleState() == Lifecycle.State.INITIALIZED.ordinal()) {
        throw new IllegalStateException(&quot;Calling getViewModelStore() before a Fragment &quot;
                + &quot;reaches onCreate() when using setMaxLifecycle(INITIALIZED) is not &quot;
                + &quot;supported&quot;);
    }
    return mFragmentManager.getViewModelStore(this);
}</code></pre></div><p id="-989866833#z1dyhj3_60">Как видим, фрагмент для получения своего <span class="inline-code" id="-989866833#z1dyhj3_178">ViewModelStore</span> обращается к <span class="inline-code" id="-989866833#z1dyhj3_179">FragmentManager</span> и запрашивает у него нужный ViewModelStore, передавая <span class="control" id="-989866833#z1dyhj3_180">самого себя</span> в качестве ключа:</p><div class="detached code-block" id="-989866833#z1dyhj3_61"><pre><code class="language-java">...
        return mFragmentManager.getViewModelStore(this);
...</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_181"><span class="control" id="-989866833#z1dyhj3_183">Напоминание:</span></p><p id="-989866833#z1dyhj3_182"><span class="inline-code" id="-989866833#z1dyhj3_184">FragmentManager</span> &mdash; это основной компонент, управляющий фрагментами. Он управляет их стеком и позволяет добавлять фрагменты в back stack.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_63">Далее нас интересует метод <span class="inline-code" id="-989866833#z1dyhj3_185">getViewModelStore</span>, который есть у класса <span class="inline-code" id="-989866833#z1dyhj3_186">FragmentManager.java</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_64"><pre><code class="language-java">@NonNull
ViewModelStore getViewModelStore(@NonNull Fragment f) {
    return mNonConfig.getViewModelStore(f);
}</code></pre></div><p id="-989866833#z1dyhj3_65">Оказывается, тут есть ещё один вложенный вызов: у объекта <span class="inline-code" id="-989866833#z1dyhj3_187">mNonConfig</span> вызывается метод <span class="inline-code" id="-989866833#z1dyhj3_188">getViewModelStore</span>, куда передаётся фрагмент в качестве ключа. Давайте посмотрим, что это за объект <span class="inline-code" id="-989866833#z1dyhj3_189">mNonConfig</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_66"><pre><code class="language-java">private FragmentManagerViewModel mNonConfig;</code></pre></div><p id="-989866833#z1dyhj3_67">Вот это интересно: <span class="inline-code" id="-989866833#z1dyhj3_190">FragmentManager</span> использует свою <span class="control" id="-989866833#z1dyhj3_191">ViewModel</span>, чтобы хранить информацию о <span class="inline-code" id="-989866833#z1dyhj3_192">ViewModelStore</span> фрагментов которые он запускал.  И это логично &mdash; ведь ему нужно как-то сохранять состояние фрагментов и их ViewModel-и при изменениях конфигурации.</p><p id="-989866833#z1dyhj3_68">Итак, мы выяснили следующий стек вызовов (по порядку):</p><ol class="list list-decimal" id="-989866833#z1dyhj3_69" type="1" start="1"><li class="list-item" id="-989866833#z1dyhj3_194"><p id="-989866833#z1dyhj3_198"><span class="inline-code" id="-989866833#z1dyhj3_199">ViewModelProvider.create(owner = this).get(MyViewModel::class)</span></p></li><li class="list-item" id="-989866833#z1dyhj3_195"><p id="-989866833#z1dyhj3_200"><span class="inline-code" id="-989866833#z1dyhj3_201">Fragment.getViewModelStore()</span></p></li><li class="list-item" id="-989866833#z1dyhj3_196"><p id="-989866833#z1dyhj3_202"><span class="inline-code" id="-989866833#z1dyhj3_203">FragmentManager.getViewModelStore(fragment)</span></p></li><li class="list-item" id="-989866833#z1dyhj3_197"><p id="-989866833#z1dyhj3_204"><span class="inline-code" id="-989866833#z1dyhj3_205">FragmentManagerViewModel.getViewModelStore(fragment)</span></p></li></ol><p id="-989866833#z1dyhj3_70"><span class="control" id="-989866833#z1dyhj3_206">Поэтому дальше нас будет интересовать класс <span class="inline-code" id="-989866833#z1dyhj3_208">FragmentManagerViewModel</span>.</span> Свой путь начнем с его вызова метода <span class="inline-code" id="-989866833#z1dyhj3_207">FragmentManagerViewModel.getViewModelStore(fragment)</span>:</p><p id="-989866833#z1dyhj3_71"><span class="control" id="-989866833#z1dyhj3_209">FragmentManagerViewModel.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_72"><pre><code class="language-java">final class FragmentManagerViewModel extends ViewModel {
    ...

    @NonNull
    ViewModelStore getViewModelStore(@NonNull Fragment f) {
        ViewModelStore viewModelStore = mViewModelStores.get(f.mWho);
        if (viewModelStore == null) {
            viewModelStore = new ViewModelStore();
            mViewModelStores.put(f.mWho, viewModelStore);
        }
        return viewModelStore;
    }
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_73">Как это работает?  Внутри <span class="inline-code" id="-989866833#z1dyhj3_211">FragmentManagerViewModel</span> есть коллекция <span class="inline-code" id="-989866833#z1dyhj3_212">HashMap&lt;String, ViewModelStore&gt;()</span>, которая хранит <span class="inline-code" id="-989866833#z1dyhj3_213">ViewModelStore</span> для каждого фрагмента, принадлежащего <span class="inline-code" id="-989866833#z1dyhj3_214">FragmentManager</span>'у.  То есть все фрагменты, которые были добавлены с помощью <span class="inline-code" id="-989866833#z1dyhj3_216">FragmentManager</span>'а &mdash; при попытке получить <span class="inline-code" id="-989866833#z1dyhj3_217">ViewModelStore</span>, сначала ищут его по ключу (<span class="inline-code" id="-989866833#z1dyhj3_218">f.mWho</span>).</p><p id="-989866833#z1dyhj3_74">Если <span class="inline-code" id="-989866833#z1dyhj3_219">ViewModelStore</span> не найден &mdash; это означает, что фрагмент впервые внутри себя создает <span class="inline-code" id="-989866833#z1dyhj3_220">ViewModel</span>, и, соответственно, впервые ему требуется <span class="inline-code" id="-989866833#z1dyhj3_221">ViewModelStore</span>.  В этом случае <span class="inline-code" id="-989866833#z1dyhj3_223">ViewModelStore</span> создается и помещается в HashMap <span class="inline-code" id="-989866833#z1dyhj3_224">mViewModelStores</span>.</p><div class="detached code-block" id="-989866833#z1dyhj3_75"><pre><code class="language-java">final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_225"><span class="control" id="-989866833#z1dyhj3_226"><span class="inline-code" id="-989866833#z1dyhj3_234">mViewModelStores</span></span> &mdash; это <span class="inline-code" id="-989866833#z1dyhj3_227">HashMap</span>, в которой хранятся <span class="inline-code" id="-989866833#z1dyhj3_228">ViewModelStore</span> всех фрагментов, находящихся * <span class="emphasis" id="-989866833#z1dyhj3_229">внутри <span class="inline-code" id="-989866833#z1dyhj3_235">Activity</span> или вложенных в родительский фрагмент</span>*.  Каждый <span class="inline-code" id="-989866833#z1dyhj3_231">ViewModelStore</span> связан с конкретным фрагментом по его уникальному ключу (<span class="inline-code" id="-989866833#z1dyhj3_232">fragment.mWho</span>) и используется для хранения <span class="inline-code" id="-989866833#z1dyhj3_233">ViewModel</span>, привязанных к жизненному циклу соответствующего фрагмента.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_77">Что нам известно в данный момент?  Когда мы создаем <span class="inline-code" id="-989866833#z1dyhj3_237">ViewModel</span> внутри нашего <span class="inline-code" id="-989866833#z1dyhj3_238">Fragment</span>'а, то его <span class="inline-code" id="-989866833#z1dyhj3_239">ViewModelStore</span> хранится внутри <span class="inline-code" id="-989866833#z1dyhj3_240">FragmentManager</span>, точнее &mdash; внутри его <span class="inline-code" id="-989866833#z1dyhj3_241">ViewModel</span>'ки (<span class="inline-code" id="-989866833#z1dyhj3_242">FragmentManagerViewModel</span>).</p><p id="-989866833#z1dyhj3_78">Вроде бы всё ясно: наша <span class="inline-code" id="-989866833#z1dyhj3_243">ViewModel</span> хранится внутри <span class="inline-code" id="-989866833#z1dyhj3_244">ViewModelStore</span>, который сам хранится внутри <span class="inline-code" id="-989866833#z1dyhj3_245">FragmentManagerViewModel</span> (который тоже является <span class="inline-code" id="-989866833#z1dyhj3_246">ViewModel</span>).  И тут возникает логичный вопрос &mdash; <span class="control" id="-989866833#z1dyhj3_248">а где хранится сам <span class="inline-code" id="-989866833#z1dyhj3_252">FragmentManagerViewModel</span>?</span> Он ведь тоже <span class="inline-code" id="-989866833#z1dyhj3_250">ViewModel</span>, а значит должен храниться внутри какого-то <span class="inline-code" id="-989866833#z1dyhj3_251">ViewModelStore</span>.</p><p id="-989866833#z1dyhj3_79">Краткий ответ: он хранится внутри <span class="inline-code" id="-989866833#z1dyhj3_253">ViewModelStore</span>, который принадлежит самой <span class="inline-code" id="-989866833#z1dyhj3_254">Activity</span>.</p><p id="-989866833#z1dyhj3_80"><span class="control" id="-989866833#z1dyhj3_255">Хочешь убедиться? Тогда читай дальше.</span></p><p id="-989866833#z1dyhj3_81">Чтобы ответить на наш вопрос, начнём с основ &mdash; с того, как работают фрагменты и откуда берётся <span class="inline-code" id="-989866833#z1dyhj3_256">FragmentManager</span>. Но перед этим давайте взглянем на иерархию всех существующих видов Activity, чтобы понять, с какой цепочки мы начнём работу:</p><p id="-989866833#z1dyhj3_82"><span class="control" id="-989866833#z1dyhj3_257">Иерархия Activity</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_83"><pre><code class="language-none">Activity
└── ComponentActivity
    └── FragmentActivity
        └── AppCompatActivity</code></pre></div><div class="table-wrapper detached"><table id="-989866833#z1dyhj3_84"><tr class="header-row" id="-989866833#z1dyhj3_258"><th id="-989866833#z1dyhj3_263"><p>Класс</p></th><th id="-989866833#z1dyhj3_264"><p>Назначение</p></th></tr><tr class="" id="-989866833#z1dyhj3_259"><td id="-989866833#z1dyhj3_265"><p><span class="inline-code" id="-989866833#z1dyhj3_267">Activity</span></p></td><td id="-989866833#z1dyhj3_266"><p>Базовый низкоуровневый класс экрана в Android SDK. Напрямую использовать не рекомендуется.</p></td></tr><tr class="" id="-989866833#z1dyhj3_260"><td id="-989866833#z1dyhj3_268"><p><span class="inline-code" id="-989866833#z1dyhj3_270">ComponentActivity</span></p></td><td id="-989866833#z1dyhj3_269"><p>Современная основа для Jetpack компонентов: <span class="inline-code" id="-989866833#z1dyhj3_271">ViewModel</span>, <span class="inline-code" id="-989866833#z1dyhj3_272">SavedState</span>, <span class="inline-code" id="-989866833#z1dyhj3_273">ActivityResult API</span>, <span class="inline-code" id="-989866833#z1dyhj3_274">OnBackPressedDispatcher</span></p></td></tr><tr class="" id="-989866833#z1dyhj3_261"><td id="-989866833#z1dyhj3_275"><p><span class="inline-code" id="-989866833#z1dyhj3_277">FragmentActivity</span></p></td><td id="-989866833#z1dyhj3_276"><p>Добавляет поддержку фрагментов (через AndroidX). Фрагменты из <span class="inline-code" id="-989866833#z1dyhj3_278">android.app.Fragment</span> больше не поддерживаются.</p></td></tr><tr class="" id="-989866833#z1dyhj3_262"><td id="-989866833#z1dyhj3_279"><p><span class="inline-code" id="-989866833#z1dyhj3_281">AppCompatActivity</span></p></td><td id="-989866833#z1dyhj3_280"><p>Поддержка старых версий Android c <span class="inline-code" id="-989866833#z1dyhj3_282">Deprecated Api</span>, <span class="inline-code" id="-989866833#z1dyhj3_283">AppCompatDelegate</span> <span class="inline-code" id="-989866833#z1dyhj3_284">ActionBar</span>, тем <span class="inline-code" id="-989866833#z1dyhj3_285">AppCompat</span>, <span class="inline-code" id="-989866833#z1dyhj3_286">Material UI</span>, .</p></td></tr></table></div><p id="-989866833#z1dyhj3_85">Как вы наверняка догадались, нас будет интересовать именно <span class="inline-code" id="-989866833#z1dyhj3_287">FragmentActivity</span>. <span class="inline-code" id="-989866833#z1dyhj3_288">FragmentActivity</span> &mdash; это базовый класс, предоставляющий интеграцию с системой фрагментов. Именно он отвечает за создание и управление <span class="inline-code" id="-989866833#z1dyhj3_289">FragmentManager</span>. На его основе построен и более часто используемый <span class="inline-code" id="-989866833#z1dyhj3_290">AppCompatActivity</span>, который расширяет функциональность за счёт поддержки компонентов из библиотеки поддержки (AppCompat).</p><p id="-989866833#z1dyhj3_86">Именно <span class="inline-code" id="-989866833#z1dyhj3_291">FragmentActivity</span> (или его наследник <span class="inline-code" id="-989866833#z1dyhj3_292">AppCompatActivity</span>) позволяет полноценно работать с фрагментами и <span class="inline-code" id="-989866833#z1dyhj3_293">FragmentManager</span>. Остальные способы взаимодействия с фрагментами считаются устаревшими.</p><p id="-989866833#z1dyhj3_87">Рассмотрим исходный код <span class="inline-code" id="-989866833#z1dyhj3_294">FragmentActivity</span>:</p><p id="-989866833#z1dyhj3_88"><span class="control" id="-989866833#z1dyhj3_295">FragmentActivity.java</span></p><div class="detached code-block" id="-989866833#z1dyhj3_89"><pre><code class="language-java">public class FragmentActivity extends ComponentActivity {
    ...
    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());

    class HostCallbacks extends FragmentHostCallback&lt;FragmentActivity&gt; implements ViewModelStoreOwner {
        ...

        public ViewModelStore getViewModelStore() {
            return FragmentActivity.this.getViewModelStore();
        }
        ...
    }
    ...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_296"><span class="inline-code" id="-989866833#z1dyhj3_297">HostCallbacks</span> реализует множество интерфейсов помимо <span class="inline-code" id="-989866833#z1dyhj3_298">ViewModelStoreOwner</span>, но в статье они опущены, чтобы не отвлекать от сути.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_91">Мы видим переменную <span class="inline-code" id="-989866833#z1dyhj3_299">mFragments</span>, которая имеет тип <span class="inline-code" id="-989866833#z1dyhj3_300">FragmentController</span>.  Этой переменной присваивается результат вызова статического метода <span class="inline-code" id="-989866833#z1dyhj3_302">createController</span>, куда передаётся новый экземпляр <span class="inline-code" id="-989866833#z1dyhj3_303">HostCallbacks()</span>.</p><p id="-989866833#z1dyhj3_92"><span class="inline-code" id="-989866833#z1dyhj3_304">HostCallbacks</span> &mdash; это класс, реализующий интерфейс <span class="inline-code" id="-989866833#z1dyhj3_305">ViewModelStoreOwner</span>. В своём методе <span class="inline-code" id="-989866833#z1dyhj3_306">getViewModelStore()</span> он возвращает <span class="inline-code" id="-989866833#z1dyhj3_307">ViewModelStore</span>, принадлежащий самому <span class="inline-code" id="-989866833#z1dyhj3_308">FragmentActivity</span>.</p><p id="-989866833#z1dyhj3_93">Кроме того, <span class="inline-code" id="-989866833#z1dyhj3_309">HostCallbacks</span> наследуется от класса <span class="inline-code" id="-989866833#z1dyhj3_310">FragmentHostCallback</span>, который выглядит следующим образом:</p><div class="detached code-block" id="-989866833#z1dyhj3_94"><pre><code class="language-kotlin">@Suppress(&quot;deprecation&quot;)
abstract class FragmentHostCallback&lt;H&gt; internal constructor(
    ...
) : FragmentContainer() {

    @get:RestrictTo(RestrictTo.Scope.LIBRARY)
    val fragmentManager: FragmentManager = FragmentManagerImpl()
    ...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>`FragmentHostCallback` был переписан с Java на Kotlin, начиная с версии `androidx.fragment:fragment:*:1.7.0-beta01`.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_96">Внутри <span class="inline-code" id="-989866833#z1dyhj3_311">FragmentHostCallback</span> создаётся объект <span class="inline-code" id="-989866833#z1dyhj3_312">FragmentManager</span>. Зная это, возвращаемся к исходникам <span class="inline-code" id="-989866833#z1dyhj3_313">FragmentActivity</span>,  где есть поле <span class="inline-code" id="-989866833#z1dyhj3_315">mFragments</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_97"><pre><code class="language-java">final FragmentController mFragments = FragmentController.createController(new HostCallbacks());</code></pre></div><p id="-989866833#z1dyhj3_98">Здесь создаётся объект <span class="inline-code" id="-989866833#z1dyhj3_316">HostCallbacks</span>, который наследуется от <span class="inline-code" id="-989866833#z1dyhj3_317">FragmentHostCallback</span> и реализует интерфейс<span class="inline-code" id="-989866833#z1dyhj3_319">ViewModelStoreOwner</span>, в конечном итоге возвращая <span class="inline-code" id="-989866833#z1dyhj3_320">ViewModelStore</span>, принадлежащий самой активности.</p><p id="-989866833#z1dyhj3_99">Посмотрим на исходники статического метода <span class="inline-code" id="-989866833#z1dyhj3_321">FragmentController.createController()</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_100"><pre><code class="language-java">public class FragmentController {

    private final FragmentHostCallback&lt;?&gt; mHost;

    /**
     * Returns a {@link FragmentController}.
     */
    @NonNull
    public static FragmentController createController(@NonNull FragmentHostCallback&lt;?&gt; callbacks) {
        return new FragmentController(checkNotNull(callbacks, &quot;callbacks == null&quot;));
    }

    private FragmentController(FragmentHostCallback&lt;?&gt; callbacks) {
        mHost = callbacks;
    }

}</code></pre></div><p id="-989866833#z1dyhj3_101">Мы видим, что внутри <span class="inline-code" id="-989866833#z1dyhj3_322">FragmentActivity</span> создаётся <span class="inline-code" id="-989866833#z1dyhj3_323">FragmentController</span> посредством вызова метода <span class="inline-code" id="-989866833#z1dyhj3_324">createController()</span>.  Метод принимает объект <span class="inline-code" id="-989866833#z1dyhj3_326">FragmentHostCallback</span> &mdash; в нашем случае это подкласс <span class="inline-code" id="-989866833#z1dyhj3_327">HostCallbacks</span>, который реализует <span class="inline-code" id="-989866833#z1dyhj3_328">ViewModelStoreOwner</span> и предоставляет <span class="inline-code" id="-989866833#z1dyhj3_329">ViewModelStore</span> самой активности.</p><p id="-989866833#z1dyhj3_102">Чтобы лучше понять цепочку создания и передачи зависимостей, посмотрим на схему:</p><div class="detached code-block" id="-989866833#z1dyhj3_103"><pre><code class="language-none">FragmentActivity
    └── Has a → FragmentController (mFragments)
           └── Created with → HostCallbacks
                   ├── Implements → ViewModelStoreOwner (delegates to FragmentActivity)
                   └── Extends → FragmentHostCallback
                            └── Has a → FragmentManagerImpl (as fragmentManager)</code></pre></div><p id="-989866833#z1dyhj3_104">Эта структура позволяет <span class="inline-code" id="-989866833#z1dyhj3_330">FragmentActivity</span> делегировать управление фрагментами специальному помощнику &mdash; <span class="inline-code" id="-989866833#z1dyhj3_331">FragmentController</span>.  Таким образом, <span class="inline-code" id="-989866833#z1dyhj3_333">FragmentActivity</span> не занимается напрямую логикой работы с фрагментами, но при этом сохраняет доступ к ключевым компонентам: <span class="inline-code" id="-989866833#z1dyhj3_334">FragmentManager</span> и <span class="inline-code" id="-989866833#z1dyhj3_335">ViewModelStore</span>, благодаря вспомогательному классу <span class="inline-code" id="-989866833#z1dyhj3_336">HostCallbacks</span>.</p><p id="-989866833#z1dyhj3_105">Теперь давайте подробнее рассмотрим, как создаётся и инициализируется <span class="inline-code" id="-989866833#z1dyhj3_337">FragmentController</span>. Обратим внимание на следующую строку:</p><div class="detached code-block" id="-989866833#z1dyhj3_106"><pre><code class="language-java">final FragmentController mFragments = FragmentController.createController(new HostCallbacks());</code></pre></div><p id="-989866833#z1dyhj3_107">Здесь создаётся экземпляр <span class="inline-code" id="-989866833#z1dyhj3_338">FragmentController</span>, которому в качестве параметра передаётся объект <span class="inline-code" id="-989866833#z1dyhj3_339">HostCallbacks</span>. Именно этот объект предоставляет необходимые зависимости, такие как <span class="inline-code" id="-989866833#z1dyhj3_340">FragmentManager</span>.</p><p id="-989866833#z1dyhj3_108">Далее обратимся к конструктору <span class="inline-code" id="-989866833#z1dyhj3_341">FragmentActivity</span>. В нём вызывается метод <span class="inline-code" id="-989866833#z1dyhj3_342">init</span>, внутри которого регистрируется слушатель <span class="inline-code" id="-989866833#z1dyhj3_343">OnContextAvailableListener</span>. Этот слушатель срабатывает, когда контекст становится доступен, и в этот момент вызывается метод <span class="inline-code" id="-989866833#z1dyhj3_344">attachHost</span> у <span class="inline-code" id="-989866833#z1dyhj3_345">FragmentController</span>:</p><p id="-989866833#z1dyhj3_109"><span class="control" id="-989866833#z1dyhj3_346">FragmentActivity.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_110"><pre><code class="language-java">public class FragmentActivity extends ComponentActivity {
    ...
    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());

    public FragmentActivity() {
        super();
        init();
    }

    private void init() {
        ...
        addOnContextAvailableListener(context -&gt; mFragments.attachHost(null /*parent*/));
    }
}</code></pre></div><p id="-989866833#z1dyhj3_111">Теперь заглянем внутрь самого метода <span class="inline-code" id="-989866833#z1dyhj3_347">attachHost</span>, который реализован в классе <span class="inline-code" id="-989866833#z1dyhj3_348">FragmentController</span>.</p><p id="-989866833#z1dyhj3_112"><span class="control" id="-989866833#z1dyhj3_349">FragmentController.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_113"><pre><code class="language-java">/**
 * Attaches the host to the FragmentManager for this controller. The host must be
 * attached before the FragmentManager can be used to manage Fragments.
 */
public void attachHost(@Nullable Fragment parent) {
    mHost.getFragmentManager().attachController(
            mHost, mHost /*container*/, parent);
}</code></pre></div><p id="-989866833#z1dyhj3_114">Внутри этого метода вызывается <span class="inline-code" id="-989866833#z1dyhj3_350">getFragmentManager()</span> у переменной <span class="inline-code" id="-989866833#z1dyhj3_351">mHost</span>. Эта переменная представляет собой объект типа <span class="inline-code" id="-989866833#z1dyhj3_352">FragmentHostCallback&lt;?&gt;</span>, а если точнее, то передается именно его наследник - объект <span class="inline-code" id="-989866833#z1dyhj3_353">HostCallbacks</span>. Получив <span class="inline-code" id="-989866833#z1dyhj3_354">FragmentManager</span>, у него вызывается метод <span class="inline-code" id="-989866833#z1dyhj3_355">attachController</span>, которому передаются: сам <span class="inline-code" id="-989866833#z1dyhj3_356">HostCallbacks</span> как хост, он же как контейнер, и опционально &mdash; родительский фрагмент (в данном случае <span class="inline-code" id="-989866833#z1dyhj3_357">null</span>).</p><p id="-989866833#z1dyhj3_115">Сама переменная <span class="inline-code" id="-989866833#z1dyhj3_358">mHost</span>, используемая внутри <span class="inline-code" id="-989866833#z1dyhj3_359">FragmentController</span>, выглядит следующим образом:</p><p id="-989866833#z1dyhj3_116"><span class="control" id="-989866833#z1dyhj3_360">FragmentController.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_117"><pre><code class="language-java">private final FragmentHostCallback&lt;?&gt; mHost;</code></pre></div><p id="-989866833#z1dyhj3_118">На этапе инициализации <span class="inline-code" id="-989866833#z1dyhj3_361">FragmentActivity</span> создаётся экземпляр <span class="inline-code" id="-989866833#z1dyhj3_362">FragmentController</span>, которому делегируется управление фрагментами. Этот контроллер получает в конструктор объект <span class="inline-code" id="-989866833#z1dyhj3_363">HostCallbacks</span>, обеспечивая тем самым связку между <span class="inline-code" id="-989866833#z1dyhj3_364">FragmentManager</span> и жизненным циклом активити.</p><p id="-989866833#z1dyhj3_119">Мы уже вскользь рассмотрели, как инициализируется эта переменная, но давай коротко повторим:</p><p id="-989866833#z1dyhj3_120">Класс <span class="inline-code" id="-989866833#z1dyhj3_365">HostCallbacks</span> &mdash; это внутренний класс <span class="inline-code" id="-989866833#z1dyhj3_366">FragmentActivity</span>, который наследуется от <span class="inline-code" id="-989866833#z1dyhj3_367">FragmentHostCallback</span> и одновременно реализует интерфейс <span class="inline-code" id="-989866833#z1dyhj3_368">ViewModelStoreOwner</span>. Когда создаётся объект <span class="inline-code" id="-989866833#z1dyhj3_369">FragmentController</span>, он получает в качестве параметра экземпляр <span class="inline-code" id="-989866833#z1dyhj3_370">HostCallbacks</span>. Этот объект сохраняется во внутреннем поле <span class="inline-code" id="-989866833#z1dyhj3_371">mHost</span> типа <span class="inline-code" id="-989866833#z1dyhj3_372">FragmentHostCallback&lt;?&gt;</span>.</p><p id="-989866833#z1dyhj3_121">Поскольку <span class="inline-code" id="-989866833#z1dyhj3_373">HostCallbacks</span> является потомком <span class="inline-code" id="-989866833#z1dyhj3_374">FragmentHostCallback</span>, ему также доступны методы родителя &mdash; в частности, <span class="inline-code" id="-989866833#z1dyhj3_375">getFragmentManager()</span> (точнее, поле <span class="inline-code" id="-989866833#z1dyhj3_376">fragmentManager</span>, полученное через геттер). В Java оно вызывается как <span class="inline-code" id="-989866833#z1dyhj3_377">getFragmentManager()</span>, хотя в Kotlin это просто свойство. Далее мы уже можем передавать <span class="inline-code" id="-989866833#z1dyhj3_378">mHost</span> в методы <span class="inline-code" id="-989866833#z1dyhj3_379">FragmentManager</span>.</p><p id="-989866833#z1dyhj3_122">Теперь давай посмотрим, как именно <span class="inline-code" id="-989866833#z1dyhj3_380">FragmentManager</span> получает доступ к <span class="inline-code" id="-989866833#z1dyhj3_381">FragmentManagerViewModel</span>. Это происходит в методе <span class="inline-code" id="-989866833#z1dyhj3_382">attachController</span>, который вызывается внутри <span class="inline-code" id="-989866833#z1dyhj3_383">FragmentManager</span>:</p><p id="-989866833#z1dyhj3_123"><span class="control" id="-989866833#z1dyhj3_384">FragmentManager.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_124"><pre><code class="language-java">void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container, @Nullable final Fragment parent) {
    ...
    // Get the FragmentManagerViewModel
    if (parent != null) {
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        mNonConfig = new FragmentManagerViewModel(false);
    }
    ...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_385"><span class="control" id="-989866833#z1dyhj3_387">Цепочка инициализации:</span><span class="control" id="-989866833#z1dyhj3_389"><span class="inline-code" id="-989866833#z1dyhj3_390">FragmentActivity</span> &rarr; <span class="inline-code" id="-989866833#z1dyhj3_391">HostCallbacks</span> &rarr; <span class="inline-code" id="-989866833#z1dyhj3_392">FragmentManager</span> &rarr; <span class="inline-code" id="-989866833#z1dyhj3_393">FragmentManagerViewModel</span></span></p><p id="-989866833#z1dyhj3_386">Эта последовательность отражает, как создаются и связываются между собой ключевые компоненты фреймворка фрагментов.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_126">Теперь разберём, что именно происходит внутри метода <span class="inline-code" id="-989866833#z1dyhj3_394">attachController</span>:</p><section class="detached"><h3 id="-989866833#1-parent-null" data-toc="1-parent-null#fragment-viewmodelstore-and-retain-fragment.md-1-parent-null">1. Если parent != null</h3><p id="-989866833#z1dyhj3_396">Это означает, что мы имеем дело с <span class="control" id="-989866833#z1dyhj3_401">вложенными фрагментами</span>, которые управляются через <span class="inline-code" id="-989866833#z1dyhj3_402">childFragmentManager</span>.  В таком случае <span class="inline-code" id="-989866833#z1dyhj3_404">FragmentManager</span> обращается к своему полю <span class="inline-code" id="-989866833#z1dyhj3_405">mChildNonConfigs</span>, где хранятся <span class="inline-code" id="-989866833#z1dyhj3_406">FragmentManagerViewModel</span>-ки для вложенных фрагментов.  Если нужной <span class="inline-code" id="-989866833#z1dyhj3_408">FragmentManagerViewModel</span> ещё нет, она будет создана и сохранена в <span class="inline-code" id="-989866833#z1dyhj3_409">HashMap</span>, используя идентификатор родительского фрагмента в качестве ключа.</p><div class="detached code-block" id="-989866833#z1dyhj3_397"><pre><code class="language-java">private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();</code></pre></div></section><section class="detached"><h3 id="-989866833#2-parent-null-host-instanceof-viewmodelstoreowner" data-toc="2-parent-null-host-instanceof-viewmodelstoreowner#fragment-viewmodelstore-and-retain-fragment.md-2-parent-null-host-instanceof-viewmodelstoreowner">2. Если parent == null, и host instanceof ViewModelStoreOwner</h3><p id="-989866833#z1dyhj3_411">Это основной путь при работе с <span class="inline-code" id="-989866833#z1dyhj3_417">FragmentActivity</span> и <span class="inline-code" id="-989866833#z1dyhj3_418">AppCompatActivity</span>, потому что <span class="inline-code" id="-989866833#z1dyhj3_419">HostCallbacks</span> реализует <span class="inline-code" id="-989866833#z1dyhj3_420">ViewModelStoreOwner</span>.  В этом случае <span class="inline-code" id="-989866833#z1dyhj3_422">FragmentManager</span> получает <span class="inline-code" id="-989866833#z1dyhj3_423">ViewModelStore</span>, привязанный к <span class="inline-code" id="-989866833#z1dyhj3_424">FragmentActivity</span>, и передаёт его в <span class="inline-code" id="-989866833#z1dyhj3_425">FragmentManagerViewModel.getInstance()</span>.</p><p id="-989866833#z1dyhj3_412">Таким образом, <span class="inline-code" id="-989866833#z1dyhj3_426">FragmentManagerViewModel</span> сохраняется в **том же <span class="inline-code" id="-989866833#z1dyhj3_427">ViewModelStore</span>, что и остальные ViewModel-ки Activity **, и будет жить столько же, сколько и сама <span class="inline-code" id="-989866833#z1dyhj3_428">Activity</span>.</p></section><section class="detached"><h3 id="-989866833#3-host-viewmodelstoreowner" data-toc="3-host-viewmodelstoreowner#fragment-viewmodelstore-and-retain-fragment.md-3-host-viewmodelstoreowner">3. Если host не реализует ViewModelStoreOwner</h3><p id="-989866833#z1dyhj3_430">Это <span class="control" id="-989866833#z1dyhj3_458">устаревший сценарий</span>, когда <span class="inline-code" id="-989866833#z1dyhj3_459">Activity</span> напрямую наследуется от <span class="inline-code" id="-989866833#z1dyhj3_460">Activity</span> или <span class="inline-code" id="-989866833#z1dyhj3_461">ComponentActivity</span>, минуя <span class="inline-code" id="-989866833#z1dyhj3_462">FragmentActivity</span>/<span class="inline-code" id="-989866833#z1dyhj3_463">AppCompatActivity</span>.</p><p id="-989866833#z1dyhj3_431">В этом случае <span class="inline-code" id="-989866833#z1dyhj3_464">FragmentManager</span> создаёт <span class="inline-code" id="-989866833#z1dyhj3_465">FragmentManagerViewModel</span> без использования <span class="inline-code" id="-989866833#z1dyhj3_466">ViewModelStore</span>. Такая ViewModel сохраняется через механизм <span class="inline-code" id="-989866833#z1dyhj3_467">NonConfigurationInstances</span>, который Android применял до появления архитектурных компонентов.</p><p id="-989866833#z1dyhj3_432">Этот подход уже <span class="control" id="-989866833#z1dyhj3_468">не рекомендуется</span>, и с современными <span class="inline-code" id="-989866833#z1dyhj3_469">androidx.fragment.app.Fragment</span> он <span class="control" id="-989866833#z1dyhj3_470">не работает</span>. Он применим только для старых <span class="inline-code" id="-989866833#z1dyhj3_471">android.app.Fragment</span> и только при активном флаге <span class="inline-code" id="-989866833#z1dyhj3_472">setRetainInstance(true)</span>. Когда мы добавляем фрагмент в активити через <span class="inline-code" id="-989866833#z1dyhj3_473">supportFragmentManager</span>, мы всегда попадаем под <span class="control" id="-989866833#z1dyhj3_474">второе условие</span>, описанное выше: <span class="inline-code" id="-989866833#z1dyhj3_476">host instanceof ViewModelStoreOwner</span>. В этой ситуации <span class="inline-code" id="-989866833#z1dyhj3_477">FragmentManager</span> получает <span class="inline-code" id="-989866833#z1dyhj3_478">ViewModelStore</span> у <span class="inline-code" id="-989866833#z1dyhj3_479">host</span> (то есть <span class="inline-code" id="-989866833#z1dyhj3_480">FragmentActivity</span>) и передаёт его в метод <span class="inline-code" id="-989866833#z1dyhj3_481">FragmentManagerViewModel.getInstance()</span>.</p><p id="-989866833#z1dyhj3_433">Внутри этого метода создаётся <span class="inline-code" id="-989866833#z1dyhj3_482">FragmentManagerViewModel</span>, который сохраняется в <span class="inline-code" id="-989866833#z1dyhj3_483">ViewModelStore</span>. Как мы уже говорили ранее, этот <span class="inline-code" id="-989866833#z1dyhj3_484">ViewModelStore</span> принадлежит <span class="inline-code" id="-989866833#z1dyhj3_485">FragmentActivity</span> (или её наследнику <span class="inline-code" id="-989866833#z1dyhj3_486">AppCompatActivity</span>).</p><p id="-989866833#z1dyhj3_434"><span class="control" id="-989866833#z1dyhj3_487">FragmentManagerViewModel.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_435"><pre><code class="language-java">@NonNull
static FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) {
    ViewModelProvider viewModelProvider = new ViewModelProvider(viewModelStore, FACTORY);
    return viewModelProvider.get(FragmentManagerViewModel.class);
}</code></pre></div><p id="-989866833#z1dyhj3_437">Теперь соберём <span class="control" id="-989866833#z1dyhj3_488">всю цепочку шагов</span>, которая выполняется при создании <span class="inline-code" id="-989866833#z1dyhj3_489">ViewModel</span> внутри фрагмента:</p><div class="detached code-block" id="-989866833#z1dyhj3_438"><pre><code class="language-kotlin">viewmodel = ViewModelProvider(owner = this).get(MyViewModel::class)</code></pre></div><ol class="list list-decimal" id="-989866833#z1dyhj3_439" type="1" start="1"><li class="list-item" id="-989866833#z1dyhj3_490"><p id="-989866833#z1dyhj3_496"><span class="inline-code" id="-989866833#z1dyhj3_497">ViewModelProvider</span> запрашивает у <span class="inline-code" id="-989866833#z1dyhj3_498">ViewModelStoreOwner</span> его <span class="inline-code" id="-989866833#z1dyhj3_499">ViewModelStore</span>.  В данном случае <span class="inline-code" id="-989866833#z1dyhj3_501">owner = this</span>, и это фрагмент.</p></li><li class="list-item" id="-989866833#z1dyhj3_491"><p id="-989866833#z1dyhj3_502">У фрагмента вызывается <span class="inline-code" id="-989866833#z1dyhj3_503">getViewModelStore()</span>, поскольку он реализует интерфейс <span class="inline-code" id="-989866833#z1dyhj3_504">ViewModelStoreOwner</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_492"><p id="-989866833#z1dyhj3_505">Внутри <span class="inline-code" id="-989866833#z1dyhj3_506">Fragment.getViewModelStore()</span> происходит обращение к <span class="inline-code" id="-989866833#z1dyhj3_507">FragmentManager</span>, в котором зарегистрирован этот фрагмент.  Вызов: <span class="inline-code" id="-989866833#z1dyhj3_509">FragmentManager.getViewModelStore(fragment)</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_493"><p id="-989866833#z1dyhj3_510"><span class="inline-code" id="-989866833#z1dyhj3_511">FragmentManager</span> делегирует дальше и обращается к своей ViewModel-ке &mdash; <span class="inline-code" id="-989866833#z1dyhj3_512">FragmentManagerViewModel</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_494"><p id="-989866833#z1dyhj3_513">Внутри <span class="inline-code" id="-989866833#z1dyhj3_514">FragmentManagerViewModel.getViewModelStore(fragment)</span> происходит поиск <span class="inline-code" id="-989866833#z1dyhj3_515">ViewModelStore</span> по <span class="inline-code" id="-989866833#z1dyhj3_516">fragment.mWho</span> в <span class="inline-code" id="-989866833#z1dyhj3_517">HashMap&lt;String, ViewModelStore&gt;</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_495"><p id="-989866833#z1dyhj3_518">Если <span class="inline-code" id="-989866833#z1dyhj3_519">ViewModelStore</span> уже есть, он возвращается. Если нет &mdash; создаётся новый, сохраняется в мапу и возвращается.</p></li></ol><div class="detached code-block" id="-989866833#z1dyhj3_440"><pre><code class="language-scss">FragmentActivity
     │
     ▼
HostCallbacks (наследуетcя от FragmentHostCallback &amp; ViewModelStoreOwner)
     │
     ▼
FragmentController
     │
     ▼
FragmentManager.attachController(...)
     │
     ├─ Если есть parent:Fragment → используем его childFragmentManager
     │
     └─ Если host is ViewModelStoreOwner → берём ViewModelStore из host (Activity)
               │
               ▼
      FragmentManagerViewModel (ViewModel, хранится в Activity's ViewModelStore)
               │
               ▼
    ┌─────────────────────────────────────────────┐
    │ HashMap&lt;String, ViewModelStore&gt;             │
    │ └─ ключ: fragment.mWho                      │
    │ └─ значение: ViewModelStore конкретного Fragment-а │
    └─────────────────────────────────────────────┘
               │
               ▼
     ViewModelProvider(fragment).get(MyViewModel::class)</code></pre></div><p id="-989866833#z1dyhj3_442">В упрощённом виде, схема ниже иллюстрирует, как устроено взаимодействие между <span class="inline-code" id="-989866833#z1dyhj3_520">Activity</span>, <span class="inline-code" id="-989866833#z1dyhj3_521">FragmentManager</span> и <span class="inline-code" id="-989866833#z1dyhj3_522">ViewModelStore</span>. Заметьте что это диаграмма продолжение диаграммы которая была в начале статьи</p><p id="-989866833#z1dyhj3_443">У нас есть <span class="inline-code" id="-989866833#z1dyhj3_523">Activity</span>, которая наследуется от <span class="inline-code" id="-989866833#z1dyhj3_524">FragmentActivity</span> (а чаще &mdash; от его расширенного потомка <span class="inline-code" id="-989866833#z1dyhj3_525">AppCompatActivity</span>). При создании <span class="inline-code" id="-989866833#z1dyhj3_526">Activity</span> инициализируется <span class="inline-code" id="-989866833#z1dyhj3_527">FragmentController</span>, которому передаётся <span class="inline-code" id="-989866833#z1dyhj3_528">FragmentHostCallback</span> &mdash; точнее, его наследник <span class="inline-code" id="-989866833#z1dyhj3_529">HostCallbacks</span>.</p><p id="-989866833#z1dyhj3_444"><span class="inline-code" id="-989866833#z1dyhj3_530">HostCallbacks</span> реализует интерфейс <span class="inline-code" id="-989866833#z1dyhj3_531">ViewModelStoreOwner</span>, но при этом <span class="control" id="-989866833#z1dyhj3_532">не создаёт</span> новый <span class="inline-code" id="-989866833#z1dyhj3_533">ViewModelStore</span>, а возвращает уже существующий &mdash; тот, что принадлежит <span class="inline-code" id="-989866833#z1dyhj3_534">Activity</span>.</p><p id="-989866833#z1dyhj3_445">Далее <span class="inline-code" id="-989866833#z1dyhj3_535">FragmentController</span> прикрепляет <span class="inline-code" id="-989866833#z1dyhj3_536">FragmentManager</span> к своему хосту (<span class="inline-code" id="-989866833#z1dyhj3_537">Activity</span> или <span class="inline-code" id="-989866833#z1dyhj3_538">ParentFragment</span>). <span class="inline-code" id="-989866833#z1dyhj3_539">FragmentManager</span> создаёт <span class="inline-code" id="-989866833#z1dyhj3_540">FragmentManagerViewModel</span> и сохраняет его во <span class="inline-code" id="-989866833#z1dyhj3_541">ViewModelStore</span>, предоставленном <span class="inline-code" id="-989866833#z1dyhj3_542">HostCallbacks</span>, то есть &mdash; в <span class="inline-code" id="-989866833#z1dyhj3_543">ViewModelStore</span>, принадлежащем <span class="inline-code" id="-989866833#z1dyhj3_544">Activity</span>.</p><p id="-989866833#z1dyhj3_446">Теперь, когда внутри <span class="inline-code" id="-989866833#z1dyhj3_545">Activity</span> мы добавляем фрагмент через <span class="inline-code" id="-989866833#z1dyhj3_546">supportFragmentManager</span>, инициализация <span class="inline-code" id="-989866833#z1dyhj3_547">MyViewModel</span> во фрагменте приводит к тому, что <span class="inline-code" id="-989866833#z1dyhj3_548">ViewModelProvider</span> запрашивает у фрагмента его <span class="inline-code" id="-989866833#z1dyhj3_549">ViewModelStore</span>.</p><p id="-989866833#z1dyhj3_447">Фрагмент, в свою очередь, обращается к своему <span class="inline-code" id="-989866833#z1dyhj3_550">FragmentManager</span> &mdash; <span class="emphasis" id="-989866833#z1dyhj3_551">&quot;дай мой <span class="inline-code" id="-989866833#z1dyhj3_557">ViewModelStore</span> &quot;</span>. <span class="inline-code" id="-989866833#z1dyhj3_552">FragmentManager</span>, имея прямую ссылку на <span class="inline-code" id="-989866833#z1dyhj3_553">FragmentManagerViewModel</span>, запрашивает у него <span class="inline-code" id="-989866833#z1dyhj3_554">ViewModelStore</span> по ключу (обычно это <span class="inline-code" id="-989866833#z1dyhj3_555">fragment.mWho</span>) &mdash; и возвращает <span class="inline-code" id="-989866833#z1dyhj3_556">ViewModelStore</span>, связанный с этим фрагментом.</p><p id="-989866833#z1dyhj3_448">Именно туда, в этот <span class="inline-code" id="-989866833#z1dyhj3_558">ViewModelStore</span>, и будет помещён <span class="inline-code" id="-989866833#z1dyhj3_559">MyViewModel</span>.</p><div class="detached mermaid" id="-989866833#z1dyhj3_450"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 1658.98046875 981"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="1658.98046875" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="Fragment.kt" class="cluster"><rect height="356" width="399.890625" y="617" x="607.97265625" style=""></rect><g transform="translate(763.56640625, 617)" class="cluster-label"><foreignObject height="24" width="88.703125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Fragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="FragmentActivity.java" class="cluster"><rect height="381" width="749.890625" y="8" x="373" style=""></rect><g transform="translate(668.9453125, 8)" class="cluster-label"><foreignObject height="24" width="158"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentActivity.java</p></span></div></foreignObject></g></g><g data-look="classic" id="FragmentManagerViewModel" class="cluster"><rect height="128" width="632.8359375" y="439" x="705.41796875" style=""></rect><g transform="translate(919.2265625, 439)" class="cluster-label"><foreignObject height="24" width="205.21875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="585.50390625" y="617" x="1027.86328125" style=""></rect><g transform="translate(1214.708984375, 617)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="381" width="400.453125" y="8" x="1250.52734375" style=""></rect><g transform="translate(1373.14453125, 8)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="HostCallbacks.java" class="cluster"><rect height="128" width="709.890625" y="236" x="393" style=""></rect><g transform="translate(679.9921875, 236)" class="cluster-label"><foreignObject height="24" width="135.90625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HostCallbacks.java</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigRef_0" d="M1457.522,148.5L1459.329,158.917C1461.137,169.333,1464.752,190.167,1466.56,204.75C1468.367,219.333,1468.367,227.667,1468.367,233.917C1468.367,240.167,1468.367,244.333,1468.367,247.833C1468.367,251.333,1468.367,254.167,1468.367,255.583L1468.367,257"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_NonConfigRef_VMStoreField_1" d="M1468.367,339L1468.367,343.167C1468.367,347.333,1468.367,355.667,1468.367,364C1468.367,372.333,1468.367,380.667,1468.367,389C1468.367,397.333,1468.367,405.667,1468.367,414C1468.367,422.333,1468.367,430.667,1468.367,445.5C1468.367,460.333,1468.367,481.667,1468.367,503C1468.367,524.333,1468.367,545.667,1468.367,560.5C1468.367,575.333,1468.367,583.667,1468.367,592C1468.367,600.333,1468.367,608.667,1467.716,614.917C1467.065,621.167,1465.763,625.333,1464.66,628.864C1463.557,632.394,1462.652,635.288,1462.2,636.735L1461.748,638.182"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FMStoreMap_fgetViewModelStore_6" d="M858.689,542L850.227,546.167C841.765,550.333,824.841,558.667,816.38,567C807.918,575.333,807.918,583.667,807.918,592C807.918,600.333,807.918,608.667,807.918,615.917C807.918,623.167,807.918,629.333,807.918,634.833C807.918,640.333,807.918,645.167,807.918,647.583L807.918,650"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_fgetViewModelStore_MyViewModel_7" d="M807.918,708L807.918,714.167C807.918,720.333,807.918,732.667,807.918,743C807.918,753.333,807.918,761.667,807.918,772.042C807.918,782.417,807.918,794.833,807.918,806.583C807.918,818.333,807.918,829.417,807.918,834.958L807.918,840.5"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_VMStoreField_ViewModelStore.kt_2" d="M1448.367,720L1448.367,724.167C1448.367,728.333,1448.367,736.667,1448.367,745C1448.367,753.333,1448.367,761.667,1448.367,767.917C1448.367,774.167,1448.367,778.333,1448.367,781.833C1448.367,785.333,1448.367,788.167,1448.367,789.583L1448.367,791"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentController_HostCallbacks.java_3" d="M592.945,148.5L592.945,158.917C592.945,169.333,592.945,190.167,592.945,202.667C592.945,215.167,592.945,219.333,592.945,222.833C592.945,226.333,592.945,229.167,592.945,230.583L592.945,232"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_overidenFragmentManager_FragmentManagerViewModel_4" d="M937.891,339L937.891,343.167C937.891,347.333,937.891,355.667,937.891,364C937.891,372.333,937.891,380.667,937.891,389C937.891,397.333,937.891,405.667,937.891,411.917C937.891,418.167,937.891,422.333,937.891,425.833C937.891,429.333,937.891,432.167,937.891,433.583L937.891,435"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentHostCallback.kt_HostCallbacks.java_5" d="M338,160.254L365.495,168.712C392.991,177.169,447.982,194.085,475.477,204.626C502.973,215.167,502.973,219.333,502.973,222.833C502.973,226.333,502.973,229.167,502.973,230.583L502.973,232"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ComponentActivity.kt_FragmentActivity.java_8" d="M1250.527,252.336L1239.891,253.51C1229.255,254.685,1207.982,257.033,1187.372,259.309C1166.761,261.585,1146.814,263.787,1136.84,264.888L1126.866,265.99"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentManagerViewModel_VMStoreField_9" d="M1245.754,567L1245.754,571.167C1245.754,575.333,1245.754,583.667,1245.754,592C1245.754,600.333,1245.754,608.667,1252.349,614.917C1258.945,621.167,1272.136,625.333,1284.691,629.299C1297.246,633.265,1309.166,637.03,1315.126,638.913L1321.085,640.795"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(0, 25)" class="root"><g class="clusters"><g data-look="classic" id="FragmentHostCallback.kt" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(82.203125, 8)" class="cluster-label"><foreignObject height="24" width="181.59375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentHostCallback.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-fragmentManager-502" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManager fragmentManager</p></span></div></foreignObject></g></g></g></g><g transform="translate(1275.3671875, 787)" class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-MAP-485" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(1450.75390625, 109.5)" id="flowchart-RetainMethod-481" class="node default"><rect height="78" width="330.453125" y="-39" x="-165.2265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-135.2265625, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="270.453125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance(): NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(1468.3671875, 300)" id="flowchart-NonConfigRef-482" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>val lastNonConfigInstance: NonConfigurationInstances?</p></span></div></foreignObject></g></g><g transform="translate(1153.25390625, 681)" id="flowchart-Custom-483" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(1448.3671875, 681)" id="flowchart-VMStoreField-484" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g><g transform="translate(937.890625, 503)" id="flowchart-FMStoreMap-492" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashMap&lt;String, ViewModelStore&gt;</p></span></div></foreignObject></g></g><g transform="translate(592.9453125, 109.5)" id="flowchart-FragmentController-493" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentController mFragments</p></span></div></foreignObject></g></g><g transform="translate(592.9453125, 300)" id="flowchart-getViewModelStore-496" class="node default"><rect height="54" width="329.890625" y="-27" x="-164.9453125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-134.9453125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="269.890625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>getViewModelStore():ViewModelStore</p></span></div></foreignObject></g></g><g transform="translate(937.890625, 300)" id="flowchart-overidenFragmentManager-497" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManager fragmentManager</p></span></div></foreignObject></g></g><g transform="translate(807.91796875, 681)" id="flowchart-fgetViewModelStore-503" class="node default"><rect height="54" width="329.890625" y="-27" x="-164.9453125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-134.9453125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="269.890625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>getViewModelStore():ViewModelStore</p></span></div></foreignObject></g></g><g transform="translate(807.91796875, 871.5)" id="flowchart-MyViewModel-507" class="node default"><rect height="54" width="156.109375" y="-27" x="-78.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-48.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MyViewModel</p></span></div></foreignObject></g></g></g></g></g></svg></div><p id="-989866833#z1dyhj3_451">Наконец, давайте убедимся, что <span class="inline-code" id="-989866833#z1dyhj3_560">FragmentManagerViewModel</span>, привязанный к <span class="inline-code" id="-989866833#z1dyhj3_561">FragmentManager</span> активити, действительно хранится внутри <span class="inline-code" id="-989866833#z1dyhj3_562">ViewModelStore</span>, который принадлежит самой активити. Для этого в методе <span class="inline-code" id="-989866833#z1dyhj3_563">onCreate()</span> можно залогировать все ключи, содержащиеся в <span class="inline-code" id="-989866833#z1dyhj3_564">viewModelStore</span> активити:</p><div class="detached code-block" id="-989866833#z1dyhj3_452"><pre><code class="language-kotlin">override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    supportFragmentManager
        .beginTransaction()
        .add(R.id.frameLayoutContainer, FirstFragment())
        .commit()

    Log.d(&quot;MainActivity&quot;, &quot;onCreate: ${viewModelStore.keys()}&quot;)
    // Output: onCreate: [androidx.lifecycle.ViewModelProvider.DefaultKey:androidx.fragment.app.FragmentManagerViewModel]
}</code></pre></div><p id="-989866833#z1dyhj3_453"><span class="emphasis" id="-989866833#z1dyhj3_565">Скриншот: ключ FragmentManagerViewModel, зарегистрированный в ViewModelStore активити</span><div class="container"><figure class="image-container"><img class="center image image-size" id="-989866833#z1dyhj3_567" alt="Screenshot" title="Screenshot" src="/Users/osman/jetbrains/WritersideProjects/insider/Writerside/images/studio1.png" width="2442" height="597"><figcaption class="center-text">Screenshot</figcaption></figure></div></p><p id="-989866833#z1dyhj3_454">На этом этапе мы полностью проследили весь флоу в случае, когда у нас есть <span class="inline-code" id="-989866833#z1dyhj3_568">Activity</span>, поверх которой запускается <span class="inline-code" id="-989866833#z1dyhj3_569">Fragment</span>, и внутри этого фрагмента инициализируется <span class="inline-code" id="-989866833#z1dyhj3_570">ViewModel</span>. Мы дошли до конечной точки &mdash; увидели, где именно хранятся <span class="inline-code" id="-989866833#z1dyhj3_571">ViewModel</span>-ы.</p></section><section class="detached"><h3 id="-989866833#childfragmentmanager" data-toc="childfragmentmanager#fragment-viewmodelstore-and-retain-fragment.md-childfragmentmanager">Вложенные фрагменты и childFragmentManager</h3><p id="-989866833#z1dyhj3_573">Остался один важный кейс &mdash; <span class="control" id="-989866833#z1dyhj3_580">вложенные фрагменты</span>. То есть ситуация, когда мы запускаем один <span class="inline-code" id="-989866833#z1dyhj3_581">Fragment</span> внутри другого с помощью <span class="inline-code" id="-989866833#z1dyhj3_582">childFragmentManager</span>. До сих пор мы рассматривали только добавление фрагмента через <span class="inline-code" id="-989866833#z1dyhj3_583">FragmentManager</span> активити (<span class="inline-code" id="-989866833#z1dyhj3_584">supportFragmentManager</span>).</p><p id="-989866833#z1dyhj3_574">Напомню, мы уже сталкивались с этим кейсом при разборе метода <span class="inline-code" id="-989866833#z1dyhj3_585">attachController()</span>, в котором реализуется логика выбора источника <span class="inline-code" id="-989866833#z1dyhj3_586">FragmentManagerViewModel</span>.</p><p id="-989866833#z1dyhj3_575"><span class="control" id="-989866833#z1dyhj3_587">FragmentManager.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_576"><pre><code class="language-java">void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container,
                      @Nullable final Fragment parent) {
    ...
    // Получение FragmentManagerViewModel
    if (parent != null) {
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        mNonConfig = new FragmentManagerViewModel(false);
    }
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_577">В случае, когда мы добавляем фрагмент поверх другого фрагмента через <span class="inline-code" id="-989866833#z1dyhj3_588">childFragmentManager</span>, создавая вложенность, срабатывает первое условие, а именно &mdash; проверка <span class="inline-code" id="-989866833#z1dyhj3_589">parent != null</span>. Ранее мы уже выяснили, в каких случаях это условие выполняется, но для понимания продублируем ещё раз:</p><section class="detached"><h4 id="-989866833#parent-null" data-toc="parent-null#fragment-viewmodelstore-and-retain-fragment.md-parent-null">Если parent != null</h4><p id="-989866833#z1dyhj3_591">Это означает, что мы имеем дело с <span class="control" id="-989866833#z1dyhj3_602">вложенными фрагментами</span>, которые управляются через <span class="inline-code" id="-989866833#z1dyhj3_603">childFragmentManager</span>.  В таком случае <span class="inline-code" id="-989866833#z1dyhj3_605">FragmentManager</span> обращается к своему полю <span class="inline-code" id="-989866833#z1dyhj3_606">mChildNonConfigs</span>, где хранятся <span class="inline-code" id="-989866833#z1dyhj3_607">FragmentManagerViewModel</span> для вложенных фрагментов.  Если нужной <span class="inline-code" id="-989866833#z1dyhj3_609">FragmentManagerViewModel</span> ещё нет, она создаётся и сохраняется в <span class="inline-code" id="-989866833#z1dyhj3_610">HashMap</span>, используя <span class="inline-code" id="-989866833#z1dyhj3_611">fragment.mWho</span> родительского фрагмента в качестве ключа.</p><p id="-989866833#z1dyhj3_592">При таком кейсе <span class="inline-code" id="-989866833#z1dyhj3_612">FragmentManager</span> обращается к <span class="inline-code" id="-989866833#z1dyhj3_613">parent</span>, вызывает у него метод <span class="inline-code" id="-989866833#z1dyhj3_614">getChildNonConfig</span>, и попадает в следующий код: <span class="control" id="-989866833#z1dyhj3_615">FragmentManager.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_593"><pre><code class="language-java">@NonNull
private FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
    return mNonConfig.getChildNonConfig(f);
}</code></pre></div><p id="-989866833#z1dyhj3_594">Здесь <span class="inline-code" id="-989866833#z1dyhj3_616">mNonConfig</span> &mdash; это <span class="inline-code" id="-989866833#z1dyhj3_617">FragmentManagerViewModel</span>, привязанный к родительскому <span class="inline-code" id="-989866833#z1dyhj3_618">FragmentManager</span>. У него вызывается <span class="inline-code" id="-989866833#z1dyhj3_619">getChildNonConfig(f)</span>, и происходит следующее в <span class="control" id="-989866833#z1dyhj3_620">FragmentManagerViewModel.java</span></p><div class="detached code-block" id="-989866833#z1dyhj3_595"><pre><code class="language-java">final class FragmentManagerViewModel extends ViewModel {

    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();

    @NonNull
    FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
        FragmentManagerViewModel childNonConfig = mChildNonConfigs.get(f.mWho);
        if (childNonConfig == null) {
            childNonConfig = new FragmentManagerViewModel(mStateAutomaticallySaved);
            mChildNonConfigs.put(f.mWho, childNonConfig);
        }
        return childNonConfig;
    }
}</code></pre></div><p id="-989866833#z1dyhj3_596">В этом методе мы пытаемся получить <span class="inline-code" id="-989866833#z1dyhj3_621">FragmentManagerViewModel</span> для <span class="inline-code" id="-989866833#z1dyhj3_622">childFragmentManager</span> родительского фрагмента, чтобы у <span class="inline-code" id="-989866833#z1dyhj3_623">childFragmentManager</span> была собственная <span class="inline-code" id="-989866833#z1dyhj3_624">FragmentManagerViewModel</span>, в которой можно будет хранить <span class="inline-code" id="-989866833#z1dyhj3_625">ViewModelStore</span> всех фрагментов, которые будут запущены внутри <span class="inline-code" id="-989866833#z1dyhj3_626">childFragmentManager</span>.</p><p id="-989866833#z1dyhj3_597">Если такого <span class="inline-code" id="-989866833#z1dyhj3_627">FragmentManagerViewModel</span> ещё не существует, он создаётся, кладётся в <span class="inline-code" id="-989866833#z1dyhj3_628">mChildNonConfigs</span>, и затем возвращается обратно в метод <span class="inline-code" id="-989866833#z1dyhj3_629">attachController</span>, где продолжает использоваться для инициализации <span class="inline-code" id="-989866833#z1dyhj3_630">childFragmentManager</span>.</p><p id="-989866833#z1dyhj3_598">Отличный запрос. Вот как можно лаконично и понятно сформулировать это как завершение или рефлексивный блок &mdash; с пояснением про дерево <span class="inline-code" id="-989866833#z1dyhj3_631">FragmentManagerViewModel</span> и как оно строится:</p></section></section><section class="detached"><h3 id="-989866833#fragmentmanagerviewmodel" data-toc="fragmentmanagerviewmodel#fragment-viewmodelstore-and-retain-fragment.md-fragmentmanagerviewmodel">Как формируется дерево FragmentManagerViewModel</h3><p id="-989866833#z1dyhj3_633">Чтобы понять полную картину, важно представить, как строится иерархия <span class="inline-code" id="-989866833#z1dyhj3_660">FragmentManagerViewModel</span> в реальном приложении:</p><ul class="list" id="-989866833#z1dyhj3_634" start="1"><li class="list-item" id="-989866833#z1dyhj3_661"><p id="-989866833#z1dyhj3_663">В начале у нас есть <span class="inline-code" id="-989866833#z1dyhj3_664">Activity</span>, у которой есть <span class="inline-code" id="-989866833#z1dyhj3_665">FragmentManager</span> (чаще всего это <span class="inline-code" id="-989866833#z1dyhj3_666">supportFragmentManager</span>).</p></li><li class="list-item" id="-989866833#z1dyhj3_662"><p id="-989866833#z1dyhj3_667">У этого <span class="inline-code" id="-989866833#z1dyhj3_668">FragmentManager</span> создаётся собственный <span class="inline-code" id="-989866833#z1dyhj3_669">FragmentManagerViewModel</span>. Он сохраняется внутри <span class="inline-code" id="-989866833#z1dyhj3_670">ViewModelStore</span>, который принадлежит самой <span class="inline-code" id="-989866833#z1dyhj3_671">Activity</span>.</p></li></ul><p id="-989866833#z1dyhj3_635">Теперь, если мы добавляем фрагменты через <span class="inline-code" id="-989866833#z1dyhj3_672">FragmentManager</span> который принадлежит <span class="inline-code" id="-989866833#z1dyhj3_673">Activity</span> (<span class="inline-code" id="-989866833#z1dyhj3_674">supportFragmentManager</span>), то для каждого такого фрагмента будет создан свой <span class="inline-code" id="-989866833#z1dyhj3_675">ViewModelStore</span>. Эти <span class="inline-code" id="-989866833#z1dyhj3_676">ViewModelStore</span> будут храниться <span class="control" id="-989866833#z1dyhj3_677">внутри</span> <span class="inline-code" id="-989866833#z1dyhj3_678">FragmentManagerViewModel</span>, связанного с <span class="inline-code" id="-989866833#z1dyhj3_679">FragmentManager</span> самой <span class="inline-code" id="-989866833#z1dyhj3_680">Activity</span>, в поле <span class="inline-code" id="-989866833#z1dyhj3_681">FragmentManagerViewModel#mViewModelStores</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_636"><pre><code class="language-java">final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_637">Каждый такой фрагмент, в свою очередь, тоже имеет собственный <span class="inline-code" id="-989866833#z1dyhj3_682">FragmentManager</span> &mdash; это <span class="inline-code" id="-989866833#z1dyhj3_683">childFragmentManager</span>. Он используется, если мы хотим внутри фрагмента запускать другие фрагменты (вложенность, локальный стек навигации).</p><ul class="list" id="-989866833#z1dyhj3_638" start="1"><li class="list-item" id="-989866833#z1dyhj3_684"><p id="-989866833#z1dyhj3_686">У <span class="inline-code" id="-989866833#z1dyhj3_687">childFragmentManager</span> тоже должен быть свой <span class="inline-code" id="-989866833#z1dyhj3_688">FragmentManagerViewModel</span> (как у всех <span class="inline-code" id="-989866833#z1dyhj3_689">FragmentManager</span>-ов), чтобы он мог хранить <span class="inline-code" id="-989866833#z1dyhj3_690">ViewModelStore</span> для фрагментов, запущенных внутри родительского фрагмента, то есть внутри него.</p></li><li class="list-item" id="-989866833#z1dyhj3_685"><p id="-989866833#z1dyhj3_691">Эти <span class="inline-code" id="-989866833#z1dyhj3_692">FragmentManagerViewModel</span> хранятся в <span class="inline-code" id="-989866833#z1dyhj3_693">mChildNonConfigs</span> &mdash; это <span class="inline-code" id="-989866833#z1dyhj3_694">Map&lt;String, FragmentManagerViewModel&gt;</span> внутри <span class="inline-code" id="-989866833#z1dyhj3_695">FragmentManagerViewModel</span> родителя.</p></li></ul><p id="-989866833#z1dyhj3_639">Таким образом, формируется дерево:</p><ul class="list" id="-989866833#z1dyhj3_640" start="1"><li class="list-item" id="-989866833#z1dyhj3_696"><p id="-989866833#z1dyhj3_699">Корень &mdash; это <span class="inline-code" id="-989866833#z1dyhj3_700">FragmentManagerViewModel</span>, привязанный к <span class="inline-code" id="-989866833#z1dyhj3_701">FragmentManager</span> самой <span class="inline-code" id="-989866833#z1dyhj3_702">Activity</span> и хранящийся в её <span class="inline-code" id="-989866833#z1dyhj3_703">ViewModelStore</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_697"><p id="-989866833#z1dyhj3_704">Далее &mdash; <span class="inline-code" id="-989866833#z1dyhj3_705">FragmentManagerViewModel</span> для каждого вложенного <span class="inline-code" id="-989866833#z1dyhj3_706">childFragmentManager</span>, сохранённые внутри <span class="inline-code" id="-989866833#z1dyhj3_707">mChildNonConfigs</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_698"><p id="-989866833#z1dyhj3_708">Это дерево может быть сколь угодно глубоким, повторяя структуру вложенности фрагментов в приложении. Каждый узел в этом дереве это <span class="inline-code" id="-989866833#z1dyhj3_709">FragmentManagerViewModel</span></p></li></ul><p id="-989866833#z1dyhj3_641">Именно такая структура позволяет корректно управлять <span class="inline-code" id="-989866833#z1dyhj3_710">ViewModel</span>, сохраняя их сквозь конфигурационные изменения и обеспечивая жизненный цикл, привязанный к конкретному фрагменту.</p><div class="detached mermaid" id="-989866833#z1dyhj3_642"><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 2751 1231"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="2751" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="SubChildFragment.kt" class="cluster"><rect height="203" width="1400" y="1020" x="613" style=""></rect><g transform="translate(1237.6171875, 1020)" class="cluster-label"><foreignObject height="24" width="150.765625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>SubChildFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="SecondChildFragment.kt" class="cluster"><rect height="253" width="1750" y="717" x="628" style=""></rect><g transform="translate(1414.96875, 717)" class="cluster-label"><foreignObject height="24" width="176.0625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>SecondChildFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ParentFragment.kt" class="cluster"><rect height="253" width="2425" y="414" x="318" style=""></rect><g transform="translate(1462.765625, 414)" class="cluster-label"><foreignObject height="24" width="135.46875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ParentFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="MainActivity.kt" class="cluster"><rect height="356" width="2720" y="8" x="8" style=""></rect><g transform="translate(1314.6640625, 8)" class="cluster-label"><foreignObject height="24" width="106.671875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MainActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="SecondChildFragmentFragmentManagerViewModel" class="cluster"><rect height="203" width="1330" y="742" x="648" style=""></rect><g transform="translate(1179.7109375, 742)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ParentFragmentFragmentManagerViewModel" class="cluster"><rect height="203" width="2005" y="439" x="338" style=""></rect><g transform="translate(1207.2109375, 439)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityFragmentManagerViewModel" class="cluster"><rect height="128" width="2680" y="211" x="28" style=""></rect><g transform="translate(1234.7109375, 211)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри supportFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityViewModelStore" class="cluster"><rect height="128" width="330" y="33" x="28" style=""></rect><g transform="translate(125.5625, 33)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_MAP_ActivityFragmentManagerViewModel_0" d="M193,136L193,140.167C193,144.333,193,152.667,193,161C193,169.333,193,177.667,193,183.917C193,190.167,193,194.333,193,197.833C193,201.333,193,204.167,193,205.583L193,207"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ViewModelStores1_ParentFragmentViewModelStore_1" d="M2543,314L2543,318.167C2543,322.333,2543,330.667,2543,339C2543,347.333,2543,355.667,2543,364C2543,372.333,2543,380.667,2543,389C2543,397.333,2543,405.667,2543,414C2543,422.333,2543,430.667,2543,436.917C2543,443.167,2543,447.333,2543,450.833C2543,454.333,2543,457.167,2543,458.583L2543,460"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ChildNonConfigs1_ParentFragmentFragmentManagerViewModel_2" d="M503,314L503,318.167C503,322.333,503,330.667,503,339C503,347.333,503,355.667,503,364C503,372.333,503,380.667,503,389C503,397.333,503,405.667,503,411.917C503,418.167,503,422.333,503,425.833C503,429.333,503,432.167,503,433.583L503,435"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ParentChildNonConfigs_SecondChildFragmentFragmentManagerViewModel_3" d="M813,579.5L813,589.917C813,600.333,813,621.167,813,635.75C813,650.333,813,658.667,813,667C813,675.333,813,683.667,813,692C813,700.333,813,708.667,813,714.917C813,721.167,813,725.333,813,728.833C813,732.333,813,735.167,813,736.583L813,738"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ParentViewModelStores_SecondChildFragmentViewModelStore_4" d="M2178,579.5L2178,589.917C2178,600.333,2178,621.167,2178,635.75C2178,650.333,2178,658.667,2178,667C2178,675.333,2178,683.667,2178,692C2178,700.333,2178,708.667,2178,717C2178,725.333,2178,733.667,2178,739.917C2178,746.167,2178,750.333,2178,753.833C2178,757.333,2178,760.167,2178,761.583L2178,763"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_SecondChildNonConfigs_SubChildFragmentFragmentManagerViewModel_5" d="M1123,882.5L1123,892.917C1123,903.333,1123,924.167,1123,938.75C1123,953.333,1123,961.667,1123,970C1123,978.333,1123,986.667,1123,995C1123,1003.333,1123,1011.667,1123,1017.917C1123,1024.167,1123,1028.333,1123,1031.833C1123,1035.333,1123,1038.167,1123,1039.583L1123,1041"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_SecondChildViewModelStores_SubChildFragmentViewModelStore_6" d="M1813,882.5L1813,892.917C1813,903.333,1813,924.167,1813,938.75C1813,953.333,1813,961.667,1813,970C1813,978.333,1813,986.667,1813,995C1813,1003.333,1813,1011.667,1813,1017.917C1813,1024.167,1813,1028.333,1813,1031.833C1813,1035.333,1813,1038.167,1813,1039.583L1813,1041"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(640, 1037)" class="root"><g class="clusters"><g data-look="classic" id="SubChildFragmentFragmentManagerViewModel" class="cluster"><rect height="153" width="950" y="8" x="8" style=""></rect><g transform="translate(349.7109375, 8)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SubChildRetained-535" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(483, 84.5)" id="flowchart-SubChildNonConfigs-536" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(793, 84.5)" id="flowchart-SubChildViewModelStores-537" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g></g></g><g transform="translate(1640, 1037)" class="root"><g class="clusters"><g data-look="classic" id="SubChildFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SubChildMAP-534" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(2005, 759)" class="root"><g class="clusters"><g data-look="classic" id="SecondChildFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SecondChildMAP-526" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(2370, 456)" class="root"><g class="clusters"><g data-look="classic" id="ParentFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-ParentMAP-518" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(193, 97)" id="flowchart-MAP-512" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g><g transform="translate(193, 275)" id="flowchart-Retained1-513" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(503, 275)" id="flowchart-ChildNonConfigs1-514" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(2543, 275)" id="flowchart-ViewModelStores1-515" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g><g transform="translate(503, 540.5)" id="flowchart-ParentRetained-519" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(813, 540.5)" id="flowchart-ParentChildNonConfigs-520" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(2178, 540.5)" id="flowchart-ParentViewModelStores-521" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g><g transform="translate(813, 843.5)" id="flowchart-SecondChildRetained-527" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(1123, 843.5)" id="flowchart-SecondChildNonConfigs-528" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(1813, 843.5)" id="flowchart-SecondChildViewModelStores-529" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g></g></g></g></svg></div><p id="-989866833#z1dyhj3_643">Думаю, теперь весь флоу хранения <span class="inline-code" id="-989866833#z1dyhj3_711">ViewModelStore</span> должен быть полностью понятен.</p><p id="-989866833#z1dyhj3_644">Если у нас есть <span class="inline-code" id="-989866833#z1dyhj3_712">FragmentActivity</span> или <span class="inline-code" id="-989866833#z1dyhj3_713">AppCompatActivity</span>, то у неё есть свой собственный <span class="inline-code" id="-989866833#z1dyhj3_714">ViewModelStore</span>. Когда мы добавляем фрагмент через её <span class="inline-code" id="-989866833#z1dyhj3_715">FragmentManager</span>, для этого фрагмента создаётся отдельный <span class="inline-code" id="-989866833#z1dyhj3_716">ViewModelStore</span>. Этот <span class="inline-code" id="-989866833#z1dyhj3_717">ViewModelStore</span> будет храниться внутри <span class="inline-code" id="-989866833#z1dyhj3_718">FragmentManagerViewModel</span>, который, в свою очередь, лежит внутри <span class="inline-code" id="-989866833#z1dyhj3_719">ViewModelStore</span>, принадлежащего активности.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_720"><span class="inline-code" id="-989866833#z1dyhj3_721">FragmentManagerViewModel</span> создаётся автоматически при инициализации <span class="inline-code" id="-989866833#z1dyhj3_722">FragmentManager</span> и регистрируется как обычный <span class="inline-code" id="-989866833#z1dyhj3_723">ViewModel</span> в <span class="inline-code" id="-989866833#z1dyhj3_724">ViewModelStoreOwner</span> (например, в активности). Он предназначен именно для хранения <span class="inline-code" id="-989866833#z1dyhj3_725">ViewModelStore</span>-ов всех дочерних фрагментов.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_646">Если мы добавим ещё один фрагмент на тот же уровень &mdash; всё повторится: новый <span class="inline-code" id="-989866833#z1dyhj3_726">ViewModelStore</span> &rarr; в <span class="inline-code" id="-989866833#z1dyhj3_727">FragmentManagerViewModel</span> &rarr; в <span class="inline-code" id="-989866833#z1dyhj3_728">ViewModelStore</span> активности.</p><p id="-989866833#z1dyhj3_647">Но фишка в том, что каждый фрагмент имеет свой <span class="inline-code" id="-989866833#z1dyhj3_729">childFragmentManager</span>, то есть может быть контейнером для других фрагментов. И <span class="inline-code" id="-989866833#z1dyhj3_730">childFragmentManager</span>, как и любой <span class="inline-code" id="-989866833#z1dyhj3_731">FragmentManager</span>, имеет свой <span class="inline-code" id="-989866833#z1dyhj3_732">FragmentManagerViewModel</span>.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_733">При каждом вызове <span class="inline-code" id="-989866833#z1dyhj3_734">getChildFragmentManager()</span> фреймворк создаёт или использует уже существующий <span class="inline-code" id="-989866833#z1dyhj3_735">FragmentManagerViewModel</span>. Это гарантирует, что даже при пересоздании фрагмента <span class="inline-code" id="-989866833#z1dyhj3_736">ViewModelStore</span> вложенных фрагментов не теряется.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_649">Это значит: при добавлении вложенных фрагментов, <span class="inline-code" id="-989866833#z1dyhj3_737">ViewModelStore</span> каждого из них будет храниться во внутренней <span class="inline-code" id="-989866833#z1dyhj3_738">FragmentManagerViewModel</span>, принадлежащей <span class="inline-code" id="-989866833#z1dyhj3_739">childFragmentManager</span> родительского фрагмента.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_740">Внутри <span class="inline-code" id="-989866833#z1dyhj3_741">FragmentManagerViewModel</span> используются ключи <span class="inline-code" id="-989866833#z1dyhj3_742">Fragment.mWho</span>, чтобы сохранить и потом правильно восстановить соответствие между <span class="inline-code" id="-989866833#z1dyhj3_743">Fragment</span> и его <span class="inline-code" id="-989866833#z1dyhj3_744">ViewModelStore</span>.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_651">Чем глубже вложенность, тем больше разрастается дерево.</p><p id="-989866833#z1dyhj3_652">Например:</p><div class="detached code-block" id="-989866833#z1dyhj3_653"><pre><code class="language-none">Activity
└── ParentFragment1
    └── ParentFragment2
        ├── ChildFragment1
        └── ChildFragment2</code></pre></div><p id="-989866833#z1dyhj3_654">В таком дереве:</p><ul class="list" id="-989866833#z1dyhj3_655" start="1"><li class="list-item" id="-989866833#z1dyhj3_745"><p id="-989866833#z1dyhj3_749"><span class="inline-code" id="-989866833#z1dyhj3_750">ChildFragment1</span> и <span class="inline-code" id="-989866833#z1dyhj3_751">ChildFragment2</span> &mdash; их <span class="inline-code" id="-989866833#z1dyhj3_752">ViewModelStore</span> хранятся в <span class="inline-code" id="-989866833#z1dyhj3_753">FragmentManagerViewModel</span>, принадлежащем <span class="inline-code" id="-989866833#z1dyhj3_754">childFragmentManager</span> <span class="inline-code" id="-989866833#z1dyhj3_755">ParentFragment2</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_746"><p id="-989866833#z1dyhj3_756"><span class="inline-code" id="-989866833#z1dyhj3_757">ParentFragment2</span> &mdash; его <span class="inline-code" id="-989866833#z1dyhj3_758">ViewModelStore</span> хранится в <span class="inline-code" id="-989866833#z1dyhj3_759">FragmentManagerViewModel</span>, принадлежащем <span class="inline-code" id="-989866833#z1dyhj3_760">childFragmentManager</span> <span class="inline-code" id="-989866833#z1dyhj3_761">ParentFragment1</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_747"><p id="-989866833#z1dyhj3_762"><span class="inline-code" id="-989866833#z1dyhj3_763">ParentFragment1</span> &mdash; его <span class="inline-code" id="-989866833#z1dyhj3_764">ViewModelStore</span> лежит в <span class="inline-code" id="-989866833#z1dyhj3_765">FragmentManagerViewModel</span> от <span class="inline-code" id="-989866833#z1dyhj3_766">supportFragmentManager</span> активности.</p></li><li class="list-item" id="-989866833#z1dyhj3_748"><p id="-989866833#z1dyhj3_767">А сама <span class="inline-code" id="-989866833#z1dyhj3_768">FragmentManagerViewModel</span> из <span class="inline-code" id="-989866833#z1dyhj3_769">supportFragmentManager</span> &mdash; хранится в <span class="inline-code" id="-989866833#z1dyhj3_770">ViewModelStore</span> самой активности.</p></li></ul><p id="-989866833#z1dyhj3_656">Такой флоу помогает сохранить <span class="inline-code" id="-989866833#z1dyhj3_771">ViewModel</span> даже при сложной навигации и вложенности фрагментов.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_772">Зачем вся эта сложность? Такой флоу помогает сохранить ViewModel даже при сложной навигации и глубокой вложенности фрагментов. Такая структура сохраняет иерархию ViewModelStore, обеспечивая корректное восстановление ViewModel даже при пересоздании компонентов.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_658">Итак, мы рассмотрели весь флоу хранения <span class="inline-code" id="-989866833#z1dyhj3_773">ViewModelStore</span> для фрагментов. Пора двигаться дальше, ведь тема Retain-фрагментов осталась нераскрытой &mdash; поэтому переходим к следующей части статьи.</p></section></section><section class="detached"><h2 id="-989866833#retain" data-toc="retain#fragment-viewmodelstore-and-retain-fragment.md-retain">Как Retain-фрагменты переживают изменение конфигурации?</h2><p id="-989866833#z1dyhj3_774">Напоминаю ещё раз: Retain-фрагменты устарели довольно давно, и на практике их использование не рекомендуется. О них хорошо помнят разработчики, которые ещё писали на Java &mdash; Retain-фрагменты существовали задолго до появления <span class="inline-code" id="-989866833#z1dyhj3_824">ViewModel</span>. Когда <span class="inline-code" id="-989866833#z1dyhj3_825">ViewModel</span> стала стандартом, Retain-фрагменты официально объявили устаревшими.  Но знать о них всё же полезно. Итак, начнём.</p><p id="-989866833#z1dyhj3_775">В начале статьи уже было дано определение Retain-фрагментам. А при разборе &laquo;внутренностей&raquo; FragmentManagerViewModel внимательные глаза могли заметить нечто, связанное с Retain-фрагментами &mdash; а именно, вот этот блок кода, который появлялся в статье уже не раз:</p><div class="detached code-block" id="-989866833#z1dyhj3_776"><pre><code class="language-java">final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_777">Здесь есть три поля. Два из них мы уже подробно разобрали:</p><ul class="list" id="-989866833#z1dyhj3_778" start="1"><li class="list-item" id="-989866833#z1dyhj3_827"><p id="-989866833#z1dyhj3_829"><span class="inline-code" id="-989866833#z1dyhj3_830">mViewModelStores</span> &mdash; для хранения <span class="inline-code" id="-989866833#z1dyhj3_831">ViewModelStore</span> на одном уровне в дереве,</p></li><li class="list-item" id="-989866833#z1dyhj3_828"><p id="-989866833#z1dyhj3_832"><span class="inline-code" id="-989866833#z1dyhj3_833">mChildNonConfigs</span> &mdash; для хранения вложенных <span class="inline-code" id="-989866833#z1dyhj3_834">FragmentManagerViewModel</span>, соответствующих дочерним фрагментам / <span class="inline-code" id="-989866833#z1dyhj3_835">FragmentManager</span>.</p></li></ul><p id="-989866833#z1dyhj3_779">Но вот поле, которому мы до сих пор не уделяли внимания &mdash; это самое верхнее: <span class="inline-code" id="-989866833#z1dyhj3_836">mRetainedFragments</span>. Это коллекция, которая хранит фрагменты по ключу.  Стоп&hellip; что? Фрагменты <span class="control" id="-989866833#z1dyhj3_838">внутри</span> <span class="inline-code" id="-989866833#z1dyhj3_839">ViewModel</span>?! Именно так.</p><p id="-989866833#z1dyhj3_780">Все фрагменты, у которых установлен флаг <span class="inline-code" id="-989866833#z1dyhj3_840">setRetainInstance(true)</span>, попадают именно туда.  Заинтриговал? Тогда давай разбираться глубже.</p><p id="-989866833#z1dyhj3_781">Как создать Retain Fragment?  Retain-фрагменты &mdash; это не какой-то отдельный класс, наследник <span class="inline-code" id="-989866833#z1dyhj3_843">Fragment</span>. Это всё тот же старый добрый <span class="inline-code" id="-989866833#z1dyhj3_844">Fragment</span>, но с активированным флагом <span class="inline-code" id="-989866833#z1dyhj3_845">setRetainInstance</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_782"><pre><code class="language-kotlin">class MyFragment : Fragment() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setRetainInstance(true)
    }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-989866833#z1dyhj3_846">Так как Retain-фрагменты устарели, метод <span class="inline-code" id="-989866833#z1dyhj3_847">setRetainInstance</span> также помечен аннотацией <span class="inline-code" id="-989866833#z1dyhj3_848">@Deprecated</span>.</p></div>
</blockquote>
<p id="-989866833#z1dyhj3_784">С этого момента наш фрагмент становится <span class="emphasis" id="-989866833#z1dyhj3_849">Retain</span>, и он сможет пережить изменение конфигурации &mdash; по той же схеме, по которой выживают <span class="inline-code" id="-989866833#z1dyhj3_850">ViewModel</span>.  Как именно? Мы уже немного знаем, но всё же давай проследим путь целиком &mdash; от вызова <span class="inline-code" id="-989866833#z1dyhj3_852">setRetainInstance()</span> до хранения внутри <span class="inline-code" id="-989866833#z1dyhj3_853">FragmentManagerViewModel#mRetainedFragments</span>.</p><p id="-989866833#z1dyhj3_785">Для этого заглянем в исходники метода <span class="inline-code" id="-989866833#z1dyhj3_854">setRetainInstance</span>: <span class="control" id="-989866833#z1dyhj3_855">Fragment.java:</span></p><div class="detached code-block" id="-989866833#z1dyhj3_786"><pre><code class="language-java">@Deprecated
public void setRetainInstance(boolean retain) {
    ...
    if (retain) {
        mFragmentManager.addRetainedFragment(this);
    } else {
        mFragmentManager.removeRetainedFragment(this);
    }
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_787">Логика простая: если флаг <span class="inline-code" id="-989866833#z1dyhj3_856">retain</span> установлен в <span class="inline-code" id="-989866833#z1dyhj3_857">true</span>, фрагмент передаётся в <span class="inline-code" id="-989866833#z1dyhj3_858">FragmentManager</span> как <span class="emphasis" id="-989866833#z1dyhj3_859">Retain</span> &mdash; через метод <span class="inline-code" id="-989866833#z1dyhj3_860">addRetainedFragment</span>.  Если <span class="inline-code" id="-989866833#z1dyhj3_862">false</span> &mdash; наоборот, удаляется из списка Retain-фрагментов через <span class="inline-code" id="-989866833#z1dyhj3_863">removeRetainedFragment</span>.</p><p id="-989866833#z1dyhj3_788">Давайте продолжим и заглянем в сам <span class="inline-code" id="-989866833#z1dyhj3_864">FragmentManager</span> и рассмотрим метод его <span class="inline-code" id="-989866833#z1dyhj3_865">addRetainedFragment</span>:</p><p id="-989866833#z1dyhj3_789"><span class="control" id="-989866833#z1dyhj3_866">FragmentManager.java</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_790"><pre><code class="language-java">void addRetainedFragment(@NonNull Fragment f) {
    mNonConfig.addRetainedFragment(f);
}</code></pre></div><p id="-989866833#z1dyhj3_791">Как по старинке, метод передает управление на <span class="inline-code" id="-989866833#z1dyhj3_867">mNonConfig</span>, который, как мы уже знаем, является экземпляром <span class="inline-code" id="-989866833#z1dyhj3_868">FragmentManagerViewModel</span>.</p><p id="-989866833#z1dyhj3_792"><span class="control" id="-989866833#z1dyhj3_869">FragmentManager.java</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_793"><pre><code class="language-java">private FragmentManagerViewModel mNonConfig;</code></pre></div><p id="-989866833#z1dyhj3_794">Теперь давайте взглянем на метод <span class="inline-code" id="-989866833#z1dyhj3_870">addRetainedFragment</span> внутри <span class="inline-code" id="-989866833#z1dyhj3_871">FragmentManagerViewModel</span>:</p><p id="-989866833#z1dyhj3_795"><span class="control" id="-989866833#z1dyhj3_872">FragmentManagerViewModel.java</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_796"><pre><code class="language-java">void addRetainedFragment(@NonNull Fragment fragment) {
    ...
    if (mRetainedFragments.containsKey(fragment.mWho)) {
        return;
    }
    mRetainedFragments.put(fragment.mWho, fragment);
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_797">Вот и все: мы разобрались, как фрагмент становится <span class="emphasis" id="-989866833#z1dyhj3_873">Retain</span> и как его хранение работает в <span class="inline-code" id="-989866833#z1dyhj3_874">FragmentManagerViewModel</span>.</p><p id="-989866833#z1dyhj3_798">Теперь рассмотрим метод удаления фрагмента из Retain-списка, который работает по аналогичному принципу &mdash; через тот же flow: <span class="control" id="-989866833#z1dyhj3_875">Fragment -&gt; FragmentManager -&gt; FragmentManagerViewModel</span>:</p><p id="-989866833#z1dyhj3_799"><span class="control" id="-989866833#z1dyhj3_876">FragmentManagerViewModel.java</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_800"><pre><code class="language-java">void removeRetainedFragment(@NonNull Fragment fragment) {
    ...
    boolean removed = mRetainedFragments.remove(fragment.mWho) != null;
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_801">Осталось понять как же потом эти фрагменты восстанавливаются после изменения конфигураций, одного их хранения не достаточно ведь их нужно обратно вернуть после того как Activity пересоздается, все фрагменты пересоздаются, FragmentManager тоже, но Retain фрагменты не должны пересоздаваться, а должны браться из <span class="inline-code" id="-989866833#z1dyhj3_877">mRetainedFragments</span>, мы уже в начале статьи видели метод attachController у <span class="inline-code" id="-989866833#z1dyhj3_878">FragmentManager</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_802"><pre><code class="language-java">@SuppressLint(&quot;SyntheticAccessor&quot;)
void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container, @Nullable final Fragment parent) {

    ...

    if (savedInstanceState != null) {
        restoreSaveStateInternal(savedInstanceState);
    }
    ...
}</code></pre></div><p id="-989866833#z1dyhj3_803">Видим что идет обращение к методу restoreSaveStateInternal:</p><div class="detached code-block" id="-989866833#z1dyhj3_804"><pre><code class="language-java">void restoreSaveStateInternal(@Nullable Parcelable state) {
    ...
    Bundle bundle = (Bundle) state;
    ...
    FragmentManagerState fms = bundle.getParcelable(FRAGMENT_MANAGER_STATE_KEY);
    ...

    for (String who : fms.mActive) {
        ...
        Fragment retainedFragment = mNonConfig.findRetainedFragmentByWho(fs.mWho);
        ...
        mFragmentStore.makeActive(fragmentStateManager);
        ...
    }
}</code></pre></div><p id="-989866833#z1dyhj3_805">Нас интересует это строка, очередное обращение к <span class="inline-code" id="-989866833#z1dyhj3_879">mNonConfig</span>:</p><div class="detached code-block" id="-989866833#z1dyhj3_806"><pre><code class="language-java">Fragment retainedFragment = mNonConfig.findRetainedFragmentByWho(fs.mWho);</code></pre></div><p id="-989866833#z1dyhj3_807">Вот и сам метод findRetainedFragmentByWho внутри FragmentManagerViewModel:</p><div class="detached code-block" id="-989866833#z1dyhj3_808"><pre><code class="language-java">@Nullable
Fragment findRetainedFragmentByWho(String who) {
    return mRetainedFragments.get(who);
}</code></pre></div><p id="-989866833#z1dyhj3_809">Таким образом, при восстановлении <span class="inline-code" id="-989866833#z1dyhj3_880">FragmentManager</span> и пересоздании <span class="inline-code" id="-989866833#z1dyhj3_881">Activity</span>, <span class="control" id="-989866833#z1dyhj3_882">Retain-фрагменты</span> переживают это пересоздание: они открепляются, а после восстановления <span class="inline-code" id="-989866833#z1dyhj3_883">FragmentManager</span> и <span class="inline-code" id="-989866833#z1dyhj3_884">Activity</span> &mdash; снова подключаются.</p><p id="-989866833#z1dyhj3_810">Ранее я упоминал, что <span class="control" id="-989866833#z1dyhj3_885">Retain-фрагменты</span> существовали до появления <span class="inline-code" id="-989866833#z1dyhj3_886">ViewModel</span>. Но в текущей реализации мы видим, что они переживают пересоздание <span class="inline-code" id="-989866833#z1dyhj3_887">Activity</span> благодаря хранению в <span class="inline-code" id="-989866833#z1dyhj3_888">FragmentManagerViewModel</span>, и именно там они поддерживаются. Но как они работали до появления <span class="inline-code" id="-989866833#z1dyhj3_889">ViewModel</span> в Android?</p><p id="-989866833#z1dyhj3_811">Кратко напомню: это было во времена <span class="inline-code" id="-989866833#z1dyhj3_890">android.app.Fragment</span>. Сейчас они устарели и заменены на <span class="inline-code" id="-989866833#z1dyhj3_891">androidx.fragment.app.Fragment</span>. В старой реализации механизм напоминал работу с <span class="inline-code" id="-989866833#z1dyhj3_892">NonConfigurationInstances</span>. Если кратко, то для <span class="control" id="-989866833#z1dyhj3_893">Retain-фрагментов</span> в <span class="inline-code" id="-989866833#z1dyhj3_894">android.app.Fragment</span> использовался следующий механизм &mdash; они хранились здесь:</p><div class="detached code-block" id="-989866833#z1dyhj3_812"><pre><code class="language-kotlin">@Deprecated
public class FragmentManagerNonConfig {
    private final List&lt;Fragment&gt; mFragments;
    private final List&lt;FragmentManagerNonConfig&gt; mChildNonConfigs;

    FragmentManagerNonConfig(List&lt;Fragment&gt; fragments,
    List&lt;FragmentManagerNonConfig&gt; childNonConfigs)
    {
        mFragments = fragments;
        mChildNonConfigs = childNonConfigs;
    }

    /**
     * @return the retained instance fragments returned by a FragmentManager
     */
    List&lt;Fragment&gt; getFragments()
    {
        return mFragments;
    }

    /**
     * @return the FragmentManagerNonConfigs from any applicable fragment's child FragmentManager
     */
    List&lt;FragmentManagerNonConfig&gt; getChildNonConfigs()
    {
        return mChildNonConfigs;
    }
}</code></pre></div><p id="-989866833#z1dyhj3_813">Далее объект <span class="inline-code" id="-989866833#z1dyhj3_895">FragmentManagerNonConfig</span> хранился внутри <span class="inline-code" id="-989866833#z1dyhj3_896">NonConfigurationInstances</span> в поле <span class="inline-code" id="-989866833#z1dyhj3_897">fragments</span> и переживал изменения конфигураций ровно по той же схеме, которую мы уже рассмотрели в первой статье:</p><div class="detached code-block" id="-989866833#z1dyhj3_814"><pre><code class="language-java">public class Activity extends ContextThemeWrapper ...{

static final class NonConfigurationInstances {
    Object activity;
    HashMap&lt;String, Object&gt; children;
    FragmentManagerNonConfig fragments;
    ArrayMap&lt;String, LoaderManager&gt; loaders;
    VoiceInteractor voiceInteractor;
}
}</code></pre></div><p id="-989866833#z1dyhj3_815">Мы кратко рассмотрели этот механизм, потому что он представляет собой тройное устаревание:</p><ul class="list" id="-989866833#z1dyhj3_816" start="1"><li class="list-item" id="-989866833#z1dyhj3_898"><p id="-989866833#z1dyhj3_901">сами <span class="inline-code" id="-989866833#z1dyhj3_902">android.app.Fragment</span> устарели и были заменены на <span class="inline-code" id="-989866833#z1dyhj3_903">androidx.fragment.app.Fragment</span>;</p></li><li class="list-item" id="-989866833#z1dyhj3_899"><p id="-989866833#z1dyhj3_904">концепция <span class="control" id="-989866833#z1dyhj3_905">Retain-фрагментов</span>, которая позволяла фрагментам переживать пересоздание <span class="inline-code" id="-989866833#z1dyhj3_906">Activity</span>, устарела, и теперь вместо неё рекомендуется использовать <span class="inline-code" id="-989866833#z1dyhj3_907">ViewModel</span>;</p></li><li class="list-item" id="-989866833#z1dyhj3_900"><p id="-989866833#z1dyhj3_908">способ хранения этих фрагментов через <span class="inline-code" id="-989866833#z1dyhj3_909">FragmentManagerNonConfig</span> также устарел &mdash; его заменил более современный механизм с использованием <span class="inline-code" id="-989866833#z1dyhj3_910">FragmentManagerViewModel</span>, несмотря на то, что концепция <span class="control" id="-989866833#z1dyhj3_911">Retain-фрагментов</span> уже не считается актуальной.</p></li></ul><p id="-989866833#z1dyhj3_817">Таким образом, это не просто устаревшая реализация, а целая цепочка из трёх устаревших технологий, которые были полностью переработаны в современных версиях Android.</p><p id="-989866833#z1dyhj3_818">На этом, пожалуй, всё. В этой статье мы рассмотрели некоторые смежные моменты и пересечения, подведём итоги.</p><section class="detached"><h3 id="-989866833#viewmodel-fragment" data-toc="viewmodel-fragment#fragment-viewmodelstore-and-retain-fragment.md-viewmodel-fragment">ViewModel в Fragment</h3><div class="detached code-block" id="-989866833#z1dyhj3_913"><pre><code class="language-none">MyViewModel -&gt; ViewModelStore -&gt; FragmentManagerViewModel -&gt; ViewModelStore(Activity's) -&gt; 
ComponentActivity.NonConfigurationInstances -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord</code></pre></div><p id="-989866833#z1dyhj3_914">Современный способ хранения состояний в <span class="inline-code" id="-989866833#z1dyhj3_917">Fragment</span> основан на использовании <span class="inline-code" id="-989866833#z1dyhj3_918">ViewModel</span>, которая помещается в <span class="inline-code" id="-989866833#z1dyhj3_919">ViewModelStore</span>. Управление этим хранилищем осуществляется через <span class="inline-code" id="-989866833#z1dyhj3_920">FragmentManagerViewModel</span>. В свою очередь, <span class="inline-code" id="-989866833#z1dyhj3_921">FragmentManagerViewModel</span> привязан к <span class="inline-code" id="-989866833#z1dyhj3_922">ViewModelStore</span> активности, которая сохраняет его в <span class="inline-code" id="-989866833#z1dyhj3_923">NonConfigurationInstances</span>. Эта цепочка позволяет сохранять состояние фрагмента даже при изменении конфигурации, избегая пересоздания объектов, которые критичны для долгосрочного хранения данных.</p></section><section class="detached"><h3 id="-989866833#retainfragment-androidx-fragment-app-fragment" data-toc="retainfragment-androidx-fragment-app-fragment#fragment-viewmodelstore-and-retain-fragment.md-retainfragment-androidx-fragment-app-fragment">RetainFragment в androidx.fragment.app.Fragment</h3><div class="detached code-block" id="-989866833#z1dyhj3_925"><pre><code class="language-none">MyRetainFragment -&gt; FragmentManagerViewModel -&gt; ViewModelStore(Activity's) -&gt; 
ComponentActivity.NonConfigurationInstances -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord</code></pre></div><p id="-989866833#z1dyhj3_926">Термин <span class="control" id="-989866833#z1dyhj3_930">RetainFragment</span> в <span class="inline-code" id="-989866833#z1dyhj3_931">androidx.fragment.app.Fragment</span> &mdash; это скорее пережиток старых версий API. В современных реализациях <span class="inline-code" id="-989866833#z1dyhj3_932">androidx</span>, фрагменты с сохранением состояния через <span class="inline-code" id="-989866833#z1dyhj3_933">setRetainInstance(true)</span> фактически больше не рекомендуется использовать. Вместо этого управление состоянием переместилось в <span class="inline-code" id="-989866833#z1dyhj3_934">ViewModel</span>, которая синхронизируется с жизненным циклом фрагмента через <span class="inline-code" id="-989866833#z1dyhj3_935">FragmentManagerViewModel</span>. Сохранение происходит в <span class="inline-code" id="-989866833#z1dyhj3_936">ViewModelStore</span> активности, которая, как и в первом случае, попадает в <span class="inline-code" id="-989866833#z1dyhj3_937">NonConfigurationInstances</span> при пересоздании <span class="inline-code" id="-989866833#z1dyhj3_938">Activity</span>. Таким образом, <span class="control" id="-989866833#z1dyhj3_939">RetainFragment</span> в классическом понимании уже не используется, его роль полностью взяла на себя связка <span class="inline-code" id="-989866833#z1dyhj3_940">Fragment</span> + <span class="inline-code" id="-989866833#z1dyhj3_941">ViewModel</span>.</p></section><section class="detached"><h3 id="-989866833#retainfragment-android-app-fragment" data-toc="retainfragment-android-app-fragment#fragment-viewmodelstore-and-retain-fragment.md-retainfragment-android-app-fragment">RetainFragment в android.app.Fragment (устаревший механизм)</h3><div class="detached code-block" id="-989866833#z1dyhj3_943"><pre><code class="language-none">MyRetainFragment -&gt; FragmentManagerNonConfig -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord</code></pre></div><p id="-989866833#z1dyhj3_944">В старой реализации Android, когда использовались <span class="inline-code" id="-989866833#z1dyhj3_948">android.app.Fragment</span>, механизм пересоздания фрагментов реализовывался через <span class="inline-code" id="-989866833#z1dyhj3_949">FragmentManagerNonConfig</span>. Объекты <span class="inline-code" id="-989866833#z1dyhj3_950">RetainFragment</span> помещались в специальный контейнер, который сохранялся в <span class="inline-code" id="-989866833#z1dyhj3_951">NonConfigurationInstances</span>. При пересоздании активности, эта структура восстанавливалась из <span class="inline-code" id="-989866833#z1dyhj3_952">ActivityClientRecord</span> в <span class="inline-code" id="-989866833#z1dyhj3_953">ActivityThread</span>. Этот механизм сейчас полностью устарел и был заменён на использование <span class="inline-code" id="-989866833#z1dyhj3_954">ViewModel</span>, так как это более надёжный и гибкий способ сохранить данные на время изменения конфигурации.</p></section><section class="detached"><h3 id="-989866833#z1dyhj3_823" data-toc="z1dyhj3_823#fragment-viewmodelstore-and-retain-fragment.md-z1dyhj3_823">Итоги</h3><p id="-989866833#z1dyhj3_956">Эволюция механизмов хранения состояний в <span class="inline-code" id="-989866833#z1dyhj3_961">Fragment</span> прошла несколько стадий:</p><ol class="list list-decimal" id="-989866833#z1dyhj3_957" type="1" start="1"><li class="list-item" id="-989866833#z1dyhj3_962"><p id="-989866833#z1dyhj3_965"><span class="control" id="-989866833#z1dyhj3_966">android.app.Fragment</span> с <span class="inline-code" id="-989866833#z1dyhj3_967">FragmentManagerNonConfig</span> &rarr; полностью устарел, более не поддерживается.</p></li><li class="list-item" id="-989866833#z1dyhj3_963"><p id="-989866833#z1dyhj3_968"><span class="control" id="-989866833#z1dyhj3_969">RetainFragment</span> в <span class="inline-code" id="-989866833#z1dyhj3_970">androidx.fragment.app.Fragment</span> &rarr; больше не рекомендуется, его заменяет связка с <span class="inline-code" id="-989866833#z1dyhj3_971">ViewModel</span>.</p></li><li class="list-item" id="-989866833#z1dyhj3_964"><p id="-989866833#z1dyhj3_972"><span class="control" id="-989866833#z1dyhj3_973">Современный подход</span> &mdash; <span class="inline-code" id="-989866833#z1dyhj3_974">ViewModelStore</span> внутри <span class="inline-code" id="-989866833#z1dyhj3_975">FragmentManagerViewModel</span>, который напрямую привязан к жизненному циклу фрагмента и сохраняется в <span class="inline-code" id="-989866833#z1dyhj3_976">Activity</span>.</p></li></ol><p id="-989866833#z1dyhj3_958">Теперь вместо устаревших концепций рекомендуется использовать обычные фрагменты в паре с <span class="inline-code" id="-989866833#z1dyhj3_977">ViewModel</span>, что делает код более предсказуемым и легко поддерживаемым.</p></section></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-566818116">ViewModel под капотом: как работает в Compose и View</h1><p id="-566818116#i6omz6_3">Это продолжение двух предыдущих статей. Если в первой мы разобрали, где в конечном итоге хранится <span class="inline-code" id="-566818116#i6omz6_10">ViewModelStore</span> в случае с <span class="inline-code" id="-566818116#i6omz6_11">Activity</span>, а во второй &mdash; как это устроено во <span class="inline-code" id="-566818116#i6omz6_12">Fragment</span>, то сегодня разберёмся, где хранятся <span class="inline-code" id="-566818116#i6omz6_13">ViewModel</span>-и, когда мы используем <span class="control" id="-566818116#i6omz6_14">Compose</span> (или даже просто <span class="inline-code" id="-566818116#i6omz6_15">View</span>).  Особенно когда мы объявляем <span class="inline-code" id="-566818116#i6omz6_17">ViewModel</span> прямо внутри <span class="inline-code" id="-566818116#i6omz6_18">Composable</span> функций. Но, как всегда, начнём с базиса.</p><p id="-566818116#i6omz6_4">Есть такой подход &mdash; <span class="control" id="-566818116#i6omz6_19">View-based ViewModel scoping</span>. Что он значит?  Мы все знаем стандартную практику, когда у каждого фрагмента или активити есть своя <span class="inline-code" id="-566818116#i6omz6_21">ViewModel</span>.  Но также существует и менее популярная история &mdash; когда у каждой <span class="inline-code" id="-566818116#i6omz6_23">View</span> может быть своя собственная <span class="inline-code" id="-566818116#i6omz6_24">ViewModel</span>.  Насколько это полезно &mdash; решать вам. Вы спросите: а при чём тут Compose?  А я отвечу: дело в том, что Compose работает <span class="control" id="-566818116#i6omz6_27">примерно по той же схеме</span>. Давайте начнём с простого примера:</p><section class="detached"><h2 id="-566818116#view-based-viewmodel-scoping" data-toc="view-based-viewmodel-scoping#view-model-under-the-hood-сompose.md-view-based-viewmodel-scoping">View-based ViewModel scoping &mdash; первый взгляд</h2><p id="-566818116#i6omz6_28">Создадим кастомную <span class="inline-code" id="-566818116#i6omz6_69">View</span>. Пусть это будет <span class="inline-code" id="-566818116#i6omz6_70">TranslatableTextView</span>.  Для нашего примера не так важно, <span class="control" id="-566818116#i6omz6_72">что именно делает</span> эта вьюха &mdash; главное, что мы хотим рассмотреть подход View-based ViewModel scoping. Вот как это может выглядеть:</p><div class="detached code-block" id="-566818116#i6omz6_29"><pre><code class="language-kotlin">class TranslatableTextView(context: Context) : AppCompatTextView(context) {

    private val viewModel: TranslatableTextViewViewModel by lazy {
        val owner = findViewTreeViewModelStoreOwner() ?: error(&quot;ViewModelStoreOwner not found for TranslatableTextView&quot;)
        ViewModelProvider.create(owner = owner).get(TranslatableTextViewViewModel::class.java)
    }

    fun translateTo(locale: Locale) {
        text = viewModel.getTranslatedText(text.toString(), locale)
    }
}</code></pre></div><p id="-566818116#i6omz6_30">Представим, что <span class="inline-code" id="-566818116#i6omz6_73">TranslatableTextView</span> умеет переводить текст, как, например, в Telegram.  Если бы мы использовали обычную <span class="inline-code" id="-566818116#i6omz6_75">ViewModel</span>, пришлось бы дублировать логику на всех экранах, где используется эта <span class="inline-code" id="-566818116#i6omz6_76">View</span>. Но благодаря подходу <span class="control" id="-566818116#i6omz6_77">View-based ViewModel scoping</span>, у <span class="inline-code" id="-566818116#i6omz6_78">TranslatableTextView</span> есть <span class="control" id="-566818116#i6omz6_79">своя собственная</span> <span class="inline-code" id="-566818116#i6omz6_80">ViewModel</span>.</p><p id="-566818116#i6omz6_31">Что мы здесь видим?  &ndash; Инициализацию <span class="inline-code" id="-566818116#i6omz6_82">viewModel</span> напрямую через ViewModelProvider без делегатов, с передачей ViewModelStoreOwner.  &ndash; Простой метод <span class="inline-code" id="-566818116#i6omz6_84">translateTo</span>, который принимает <span class="inline-code" id="-566818116#i6omz6_85">Locale</span> и обновляет текст вьюхи (<span class="inline-code" id="-566818116#i6omz6_86">AppCompatTextView</span>) на переведённый.</p><p id="-566818116#i6omz6_32">Давайте взглянем и на саму <span class="inline-code" id="-566818116#i6omz6_87">ViewModel</span>, чтобы пример был полноценным и наглядным:</p><div class="detached code-block" id="-566818116#i6omz6_33"><pre><code class="language-kotlin">class TranslatableTextViewViewModel : ViewModel() {
    fun getTranslatedText(currentText: String, locale: Locale): String {
        // Здесь может быть настоящая локализация
        return &quot;Translated('$currentText') to ${locale.displayLanguage}&quot;
    }
}</code></pre></div><p id="-566818116#i6omz6_34">Теперь снова вернёмся к <span class="inline-code" id="-566818116#i6omz6_88">TranslatableTextView</span>, чтобы детальнее рассмотреть инициализацию <span class="inline-code" id="-566818116#i6omz6_89">ViewModel</span>. Она выглядит немного необычно:</p><div class="detached code-block" id="-566818116#i6omz6_35"><pre><code class="language-kotlin">class TranslatableTextView(context: Context) : AppCompatTextView(context) {

    private val viewModel: TranslatableTextViewViewModel by lazy {
        val owner = findViewTreeViewModelStoreOwner() ?: error(&quot;ViewModelStoreOwner not found for TranslatableTextView&quot;)
        ViewModelProvider.create(owner = owner).get(TranslatableTextViewViewModel::class.java)
    }
    ...
}</code></pre></div><p id="-566818116#i6omz6_36">Первое, что бросается в глаза &mdash; это вызов метода <span class="inline-code" id="-566818116#i6omz6_90">findViewTreeViewModelStoreOwner()</span>.  Он возвращает нам <span class="inline-code" id="-566818116#i6omz6_92">ViewModelStoreOwner</span>, а как мы помним, им могут быть только <span class="inline-code" id="-566818116#i6omz6_93">ComponentActivity</span>, <span class="inline-code" id="-566818116#i6omz6_94">Fragment</span> или <span class="inline-code" id="-566818116#i6omz6_95">NavBackStackEntry</span>.</p><p id="-566818116#i6omz6_37">Затем этот <span class="inline-code" id="-566818116#i6omz6_96">owner</span> мы передаём в <span class="inline-code" id="-566818116#i6omz6_97">ViewModelProvider</span>, чтобы тот создал (или вернул) нужную <span class="inline-code" id="-566818116#i6omz6_98">ViewModel</span> и поместил её в <span class="inline-code" id="-566818116#i6omz6_99">ViewModelStore</span>.  Напомню: <span class="inline-code" id="-566818116#i6omz6_101">ViewModelStore</span> &mdash; это то место, где живёт и хранится наша <span class="inline-code" id="-566818116#i6omz6_102">ViewModel</span>, и доступен он у каждого <span class="inline-code" id="-566818116#i6omz6_103">ViewModelStoreOwner</span>.</p><p id="-566818116#i6omz6_38">Давайте заглянем, как устроен сам метод <span class="inline-code" id="-566818116#i6omz6_104">findViewTreeViewModelStoreOwner()</span> и каким образом он умеет доставать <span class="inline-code" id="-566818116#i6omz6_105">ViewModelStoreOwner</span>:</p><p id="-566818116#i6omz6_39"><span class="control" id="-566818116#i6omz6_106">ViewTreeViewModelStoreOwner.android.kt</span>:</p><div class="detached code-block" id="-566818116#i6omz6_40"><pre><code class="language-kotlin">/**
 * Retrieve the [ViewModelStoreOwner] associated with the given [View]. This may be used to retain
 * state associated with this view across configuration changes.
 *
 * @return The [ViewModelStoreOwner] associated with this view and/or some subset of its ancestors
 */
@JvmName(&quot;get&quot;)
public fun View.findViewTreeViewModelStoreOwner(): ViewModelStoreOwner? {
    var currentView: View? = this
    while (currentView != null) {
        val storeOwner =
            currentView.getTag(R.id.view_tree_view_model_store_owner) as? ViewModelStoreOwner
        if (storeOwner != null) {
            return storeOwner
        }
        currentView = currentView.getParentOrViewTreeDisjointParent() as? View
    }
    return null
}</code></pre></div><p id="-566818116#i6omz6_41">Если коротко, то в этом методе происходит следующее: у текущей <span class="inline-code" id="-566818116#i6omz6_107">View</span>, на которой вызвали <span class="inline-code" id="-566818116#i6omz6_108">findViewTreeViewModelStoreOwner</span>,  мы ищем тег с id <span class="inline-code" id="-566818116#i6omz6_110">R.id.view_tree_view_model_store_owner</span>. Полученное значение приводим к <span class="inline-code" id="-566818116#i6omz6_111">ViewModelStoreOwner</span>,  и если он не <span class="inline-code" id="-566818116#i6omz6_113">null</span> &mdash; возвращаем его. А если <span class="inline-code" id="-566818116#i6omz6_114">null</span>, то начинаем подниматься вверх по иерархии <span class="inline-code" id="-566818116#i6omz6_115">View</span>.  Эту работу выполняет метод <span class="inline-code" id="-566818116#i6omz6_117">getParentOrViewTreeDisjointParent</span>. В исходники его лезть не будем &mdash; он просто возвращает родителя текущей <span class="inline-code" id="-566818116#i6omz6_118">View</span> (прямого родителя или не прямого родителя).  Поскольку это происходит внутри цикла, мы поднимаемся по иерархии, пока не найдём одного из родителей, имеющий тег <span class="inline-code" id="-566818116#i6omz6_120">R.id.view_tree_view_model_store_owner</span> и в котором уже есть <span class="inline-code" id="-566818116#i6omz6_121">ViewModelStoreOwner</span>.</p><p id="-566818116#i6omz6_42">На этом, в стиле Кристофера Нолана, временно забываем про этот метод &mdash; и посмотрим, как мы будем использовать <span class="inline-code" id="-566818116#i6omz6_122">TranslatableTextView</span>:</p><div class="detached code-block" id="-566818116#i6omz6_43"><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    private val frameRootLayout by lazy { findViewById&lt;FrameLayout&gt;(R.id.frameRootLayout) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Привязываем ViewModelStoreOwner к дереву ViewView(frameRootLayout)
        frameRootLayout.setViewTreeViewModelStoreOwner(this)

        val translatableView = TranslatableTextView(this)
        translatableView.text = &quot;Hello, world!&quot;
        frameRootLayout.addView(translatableView)

        // Пример использования перевода
        translatableView.translateTo(Locale.ENGLISH)
    }
}</code></pre></div><p id="-566818116#i6omz6_44">Всё довольно просто, да?  У нас есть некий layout, у которого root &mdash; это <span class="inline-code" id="-566818116#i6omz6_124">FrameLayout</span> с id <span class="inline-code" id="-566818116#i6omz6_125">R.id.frameRootLayout</span>.  Мы находим этот <span class="inline-code" id="-566818116#i6omz6_127">FrameLayout</span> и добавляем в него наш кастомный <span class="inline-code" id="-566818116#i6omz6_128">View</span>: <span class="inline-code" id="-566818116#i6omz6_129">TranslatableTextView</span>. Здесь всё понятно.</p><p id="-566818116#i6omz6_45">Но самое интересное &mdash; это вот эта строка:</p><div class="detached code-block" id="-566818116#i6omz6_46"><pre><code class="language-kotlin">// Привязываем ViewModelStoreOwner к дереву View(frameRootLayout)
frameRootLayout.setViewTreeViewModelStoreOwner(this)</code></pre></div><p id="-566818116#i6omz6_48">Мы вызываем <span class="inline-code" id="-566818116#i6omz6_130">setViewTreeViewModelStoreOwner</span> и передаём в него <span class="inline-code" id="-566818116#i6omz6_131">this</span> &mdash; то есть саму <span class="inline-code" id="-566818116#i6omz6_132">Activity</span>.  Как мы знаем, <span class="inline-code" id="-566818116#i6omz6_134">Activity</span> реализует интерфейс <span class="inline-code" id="-566818116#i6omz6_135">ViewModelStoreOwner</span>,  поэтому мы спокойно можем передать её туда, где требуется <span class="inline-code" id="-566818116#i6omz6_137">ViewModelStoreOwner</span>.</p><p id="-566818116#i6omz6_49">Вот как выглядит цепочка наследования начиная с интерфейса ViewModelStoreOwner:</p><div class="detached code-block" id="-566818116#i6omz6_50"><pre><code class="language-none">[interface] ViewModelStoreOwner → ComponentActivity → FragmentActivity → AppCompatActivity</code></pre></div><p id="-566818116#i6omz6_51">То есть, когда мы передаём <span class="inline-code" id="-566818116#i6omz6_138">this</span> из <span class="inline-code" id="-566818116#i6omz6_139">Activity</span> в <span class="inline-code" id="-566818116#i6omz6_140">setViewTreeViewModelStoreOwner</span>, то передаём полностью валидный <span class="inline-code" id="-566818116#i6omz6_141">ViewModelStoreOwner</span>, и всё работает как надо.  Но как именно это связывание происходит внутри? За счёт чего потом <span class="inline-code" id="-566818116#i6omz6_143">findViewTreeViewModelStoreOwner()</span> находит этого владельца(<span class="inline-code" id="-566818116#i6omz6_144">ViewModelStoreOwner</span>)?</p><p id="-566818116#i6omz6_52">Чтобы в этом разобраться, давайте заглянем в исходники метода <span class="inline-code" id="-566818116#i6omz6_145">setViewTreeViewModelStoreOwner</span>, который мы ранее уже встретили. <span class="control" id="-566818116#i6omz6_146">ViewTreeViewModelStoreOwner.android.kt</span>:</p><div class="detached code-block" id="-566818116#i6omz6_53"><pre><code class="language-kotlin">/**
 * Set the [ViewModelStoreOwner] associated with the given [View]. Calls to [get] from this view or
 * descendants will return `viewModelStoreOwner`.
 *
 * This should only be called by constructs such as activities or fragments that manage a view tree
 * and retain state through a [ViewModelStoreOwner]. Callers should only set a [ViewModelStoreOwner]
 * that will be *stable.* The associated [ViewModelStore] should be cleared if the view tree is
 * removed and is not guaranteed to later become reattached to a window.
 *
 * @param viewModelStoreOwner ViewModelStoreOwner associated with the given view
 */
@JvmName(&quot;set&quot;)
public fun View.setViewTreeViewModelStoreOwner(viewModelStoreOwner: ViewModelStoreOwner?) {
    setTag(R.id.view_tree_view_model_store_owner, viewModelStoreOwner)
}</code></pre></div><p id="-566818116#i6omz6_54">Рядом также находится метод <span class="inline-code" id="-566818116#i6omz6_147">findViewTreeViewModelStoreOwner</span>, с которым мы уже знакомы.  Сейчас нас интересует <span class="inline-code" id="-566818116#i6omz6_149">setViewTreeViewModelStoreOwner</span>. Как видим, он просто кладёт <span class="inline-code" id="-566818116#i6omz6_150">viewModelStoreOwner</span> в виде тега в указанную <span class="inline-code" id="-566818116#i6omz6_152">View</span> по ключу <span class="inline-code" id="-566818116#i6omz6_153">R.id.view_tree_view_model_store_owner</span>:</p><div class="detached code-block" id="-566818116#i6omz6_55"><pre><code class="language-kotlin">setTag(R.id.view_tree_view_model_store_owner, viewModelStoreOwner)</code></pre></div><p id="-566818116#i6omz6_56">Все, кто работал с <span class="inline-code" id="-566818116#i6omz6_154">View</span>, знают метод <span class="inline-code" id="-566818116#i6omz6_155">setTag(Object?)</span>, но помимо этого есть и перегруженный метод:</p><div class="detached code-block" id="-566818116#i6omz6_57"><pre><code class="language-java">public void setTag(int key, final Object tag) {
    ...
}</code></pre></div><p id="-566818116#i6omz6_58">Этот метод позволяет хранить разные теги по ключам, используя под капотом <span class="inline-code" id="-566818116#i6omz6_156">SparseArray</span>. Это важный момент, потому что именно через этот механизм мы и будем передавать <span class="inline-code" id="-566818116#i6omz6_157">ViewModelStoreOwner</span>.</p><p id="-566818116#i6omz6_59">Теперь давайте разберёмся, что происходит на практике.</p><p id="-566818116#i6omz6_60">В методе <span class="inline-code" id="-566818116#i6omz6_158">onCreate</span> в <span class="inline-code" id="-566818116#i6omz6_159">Activity</span> мы вызываем метод <span class="inline-code" id="-566818116#i6omz6_160">setViewTreeViewModelStoreOwner</span> для рутовой<span class="inline-code" id="-566818116#i6omz6_161">View</span> (<span class="control" id="-566818116#i6omz6_162">R.id.frameRootLayout</span>), передавая в качестве параметра <span class="inline-code" id="-566818116#i6omz6_163">this</span>, то есть само <span class="inline-code" id="-566818116#i6omz6_164">Activity</span>. Это потому, что <span class="inline-code" id="-566818116#i6omz6_165">Activity</span>реализует интерфейс <span class="inline-code" id="-566818116#i6omz6_166">ViewModelStoreOwner</span>. Мы связываем эту активность с деревом представлений(View), чтобы иметь доступ к <span class="inline-code" id="-566818116#i6omz6_167">ViewModelStore</span> (так как Activity является ViewModelStoreOwner).</p><p id="-566818116#i6omz6_61">Далее мы добавляем нашу кастомную <span class="inline-code" id="-566818116#i6omz6_168">View</span> (он же TranslatableTextView) в этот <span class="inline-code" id="-566818116#i6omz6_169">frameRootLayout</span>. Пример:</p><div class="detached code-block" id="-566818116#i6omz6_62"><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    private val frameRootLayout by lazy { findViewById&lt;FrameLayout&gt;(R.id.frameRootLayout) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Привязываем ViewModelStoreOwner к дереву View
        frameRootLayout.setViewTreeViewModelStoreOwner(this)

        val translatableView = TranslatableTextView(this)
        translatableView.text = &quot;Hello, world!&quot;
        frameRootLayout.addView(translatableView)

        // Пример использования перевода
        translatableView.translateTo(Locale.ENGLISH)
    }
}</code></pre></div><p id="-566818116#i6omz6_63">Теперь, что происходит дальше?</p><p id="-566818116#i6omz6_64">Когда мы находимся в нашем кастомном <span class="inline-code" id="-566818116#i6omz6_170">View</span>, мы вызываем метод <span class="inline-code" id="-566818116#i6omz6_171">findViewTreeViewModelStoreOwner</span>. Этот метод начинает искать тег с ID <span class="inline-code" id="-566818116#i6omz6_172">R.id.view_tree_view_model_store_owner</span> в самой вьюшке. Если он не находит нужный тег, он поднимется по иерархии представлений, пока не найдёт родительский элемент, в котором этот тег присутствует:</p><div class="detached code-block" id="-566818116#i6omz6_65"><pre><code class="language-kotlin">class TranslatableTextView(context: Context) : AppCompatTextView(context) {

    private val viewModel: TranslatableTextViewViewModel by lazy {
        val owner = findViewTreeViewModelStoreOwner() ?: error(&quot;ViewTreeViewModelStoreOwner not found for TranslatableTextView&quot;)
        ViewModelProvider.create(owner = owner).get(TranslatableTextViewViewModel::class.java)
    }
    ...
}</code></pre></div><p id="-566818116#i6omz6_66">Итак, этот механизм позволяет найти нужный <span class="inline-code" id="-566818116#i6omz6_173">ViewModelStoreOwner</span> в дереве представлений, начиная с текущей вьюшки и двигаясь вверх по иерархии до родительского компонента, в котором хранятся <span class="inline-code" id="-566818116#i6omz6_174">ViewModelStore</span>.</p><p id="-566818116#i6omz6_67">В нашем случае <span class="inline-code" id="-566818116#i6omz6_175">findViewTreeViewModelStoreOwner</span> находит <span class="inline-code" id="-566818116#i6omz6_176">ViewModelStoreOwner</span> у родительского view: <span class="inline-code" id="-566818116#i6omz6_177">FrameLayout(R.id.frameRootLayout)</span>, и мы получаем <span class="inline-code" id="-566818116#i6omz6_178">ViewModelStoreOwner</span> и по умолчанию создаём <span class="inline-code" id="-566818116#i6omz6_179">ViewModel</span> вызовом <span class="inline-code" id="-566818116#i6omz6_180">ViewModelProvider</span>. В конечном итоге таким образом наша ViewModel, которую создали внутри TranslatableTextView, будет храниться в ViewModelStore, принадлежащей Activity.</p><p id="-566818116#i6omz6_68">Теперь вопрос, а почему мы это рассмотрели? И при чём тут Compose? Ответ в следующей главе статьи.</p></section><section class="detached"><h2 id="-566818116#compose-viewmodel" data-toc="compose-viewmodel#view-model-under-the-hood-сompose.md-compose-viewmodel">Где Compose хранит ViewModel-и?</h2><p id="-566818116#i6omz6_182">Давайте возьмём очень простую <span class="inline-code" id="-566818116#i6omz6_217">ViewModel</span> и очень простой composable screen. Начнём с <span class="inline-code" id="-566818116#i6omz6_218">ViewModel</span>:</p><div class="detached code-block" id="-566818116#i6omz6_183"><pre><code class="language-kotlin">class MyViewModel : ViewModel() {
    fun getName(): String = &quot;Compose&quot;
}</code></pre></div><p id="-566818116#i6omz6_184">Наша <span class="inline-code" id="-566818116#i6omz6_219">ViewModel</span> очень простая, и она нам нужна только в качестве примера, чтобы добраться до сути. Далее, наш Composable Screen:</p><div class="detached code-block" id="-566818116#i6omz6_185"><pre><code class="language-kotlin">@Composable
fun Greeting(modifier: Modifier = Modifier) {
    val viewModel = androidx.lifecycle.viewmodel.compose.viewModel&lt;MyViewModel&gt;()
    Text(
        text = &quot;Hello ${viewModel.getName()}&quot;,
        modifier = modifier
    )
}</code></pre></div><p id="-566818116#i6omz6_186">Теперь продолжим:</p><p id="-566818116#i6omz6_188"><span class="inline-code" id="-566818116#i6omz6_220">viewModel()</span> &mdash; это функция из библиотеки: <span class="control" id="-566818116#i6omz6_221">androidx.lifecycle:lifecycle-viewmodel-compose:2.8.7</span>. Я специально указал полный путь к функции в примере, чтобы вас не смущало, где она хранится и откуда взялась. С использованием Koin, например, мы могли бы использовать <span class="inline-code" id="-566818116#i6omz6_222">koinViewModel()</span> из библиотеки <span class="inline-code" id="-566818116#i6omz6_223">io.insert-koin:koin-androidx-compose</span>, или даже <span class="inline-code" id="-566818116#i6omz6_224">hiltViewModel()</span> из <span class="inline-code" id="-566818116#i6omz6_225">androidx.hilt:hilt-navigation-compose</span>.</p><p id="-566818116#i6omz6_189">Независимо от того, какой метод мы бы использовали для получения <span class="inline-code" id="-566818116#i6omz6_226">ViewModel</span> в Compose, все они работают под капотом одинаково, особенно в контексте получения <span class="inline-code" id="-566818116#i6omz6_227">ViewModelStore</span>, так как его из воздуха не взять. Поэтому давайте начнём изучение с <span class="inline-code" id="-566818116#i6omz6_228">androidx.lifecycle.viewmodel.compose.viewModel()</span>, потому что он был первым, а библиотеки вроде Hilt и Koin для создания <span class="inline-code" id="-566818116#i6omz6_229">ViewModel</span> в Compose используют похожий механизм.</p><p id="-566818116#i6omz6_190">Далее, исходники метода <span class="inline-code" id="-566818116#i6omz6_230">androidx.lifecycle.viewmodel.compose.viewModel</span> в файле:</p><p id="-566818116#i6omz6_191"><span class="control" id="-566818116#i6omz6_231"><span class="inline-code" id="-566818116#i6omz6_232">androidx.lifecycle.viewmodel.compose.ViewModel.kt:</span></span></p><div class="detached code-block" id="-566818116#i6omz6_192"><pre><code class="language-kotlin">@Suppress(&quot;MissingJvmstatic&quot;)
@Composable
public inline fun &lt;reified VM : ViewModel&gt; viewModel(
    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {
        &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;
    },
    ...
): VM = viewModel(VM::class, viewModelStoreOwner, key, factory, extras)</code></pre></div><p id="-566818116#i6omz6_193">Остальные входные параметры нас не интересуют в этой статье, кроме параметра <span class="control" id="-566818116#i6omz6_233"><span class="inline-code" id="-566818116#i6omz6_234">viewModelStoreOwner</span></span>:</p><div class="detached code-block" id="-566818116#i6omz6_194"><pre><code class="language-kotlin">viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {
    &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;
},</code></pre></div><p id="-566818116#i6omz6_195">Далее нас будет интересовать LocalViewModelStoreOwner.current - так как он нам предоставляет ViewModelStore, судя по всему. LocalViewModelStoreOwner.current из названия и синтаксиса сразу понятно, что это CompositionLocal:</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-566818116#i6omz6_235"><span class="inline-code" id="-566818116#i6omz6_236">CompositionLocal</span> &mdash; это механизм в <span class="inline-code" id="-566818116#i6omz6_237">Jetpack Compose</span>, позволяющий передавать значения по дереву UI без явной передачи через параметры, с доступом к ним через .current в любой точке композиции. Для использования необходимо предварительно предоставить значение через <span class="inline-code" id="-566818116#i6omz6_238">CompositionLocalProvider</span> или задать его по умолчанию при создании.</p></div>
</blockquote>
<p id="-566818116#i6omz6_197">Давайте глянем на исходники LocalViewModelStoreOwner:</p><div class="detached code-block" id="-566818116#i6omz6_198"><pre><code class="language-kotlin">/**
 * The CompositionLocal containing the current [ViewModelStoreOwner].
 */
public object LocalViewModelStoreOwner {
    private val LocalViewModelStoreOwner =
        compositionLocalOf&lt;ViewModelStoreOwner?&gt; { null }

    /**
     * Returns current composition local value for the owner or `null` if one has not
     * been provided nor is one available via [findViewTreeViewModelStoreOwner] on the
     * current [androidx.compose.ui.platform.LocalView].
     */
    public val current: ViewModelStoreOwner?
        @Composable
        get() = LocalViewModelStoreOwner.current ?: findViewTreeViewModelStoreOwner()

    /**
     * Associates a [LocalViewModelStoreOwner] key to a value in a call to
     * [CompositionLocalProvider].
     */
    public infix fun provides(viewModelStoreOwner: ViewModelStoreOwner):
            ProvidedValue&lt;ViewModelStoreOwner?&gt; {
        return LocalViewModelStoreOwner.provides(viewModelStoreOwner)
    }
}</code></pre></div><p id="-566818116#i6omz6_199">Видим, что <span class="inline-code" id="-566818116#i6omz6_239">LocalViewModelStoreOwner</span> &mdash; это просто обёртка над настоящим <span class="inline-code" id="-566818116#i6omz6_240">CompositionLocal</span>. Мы обращаемся именно к его полю current, чтобы прочесть текущее значение. Мы либо попытаемся достать значение из поля current у <span class="inline-code" id="-566818116#i6omz6_241">CompositionLocal</span> &mdash; это означает, что кто-то где-то должен был его <span class="inline-code" id="-566818116#i6omz6_242">provide</span>-ить. Если же там пусто, то в таком случае вызывается метод <span class="inline-code" id="-566818116#i6omz6_243">findViewTreeViewModelStoreOwner</span>. При обычном сценарии использования из коробки мы попадаем именно под второй кейс, когда вызывается метод <span class="inline-code" id="-566818116#i6omz6_244">findViewTreeViewModelStoreOwner</span>. Поэтому далее рассмотрим его исходники:</p><p id="-566818116#i6omz6_200"><span class="control" id="-566818116#i6omz6_245">LocalViewModelStoreOwner.android.kt</span></p><div class="detached code-block" id="-566818116#i6omz6_201"><pre><code class="language-kotlin">@Composable
internal actual fun findViewTreeViewModelStoreOwner(): ViewModelStoreOwner? =
    LocalView.current.findViewTreeViewModelStoreOwner()</code></pre></div><p id="-566818116#i6omz6_202">И мы видим, что у другого <span class="inline-code" id="-566818116#i6omz6_246">CompositionLocal</span> &mdash; <span class="inline-code" id="-566818116#i6omz6_247">LocalView</span> вызывается метод View.findViewTreeViewModelStoreOwner() &mdash; это тот самый метод, который мы уже смотрели в первой части статьи. LocalView.current возвращает нам текущий View. Текущий View? Разве мы не работаем сейчас в compose? Откуда взялся текущий View? Об этом чуть позже узнаем, что это за View и откуда он взялся. Сейчас просто знайте, что под капотом LocalView.current нам возвращает текущий View, у которого мы можем вызвать extension-функцию <span class="inline-code" id="-566818116#i6omz6_248">findViewTreeViewModelStoreOwner</span>, которую мы уже видели в первой части статьи, и положит ViewModel в ViewModelStore:</p><p id="-566818116#i6omz6_203"><span class="control" id="-566818116#i6omz6_249">ViewTreeLifecycleOwner.android.kt</span></p><div class="detached code-block" id="-566818116#i6omz6_204"><pre><code class="language-kotlin">/**
 * Retrieve the [ViewModelStoreOwner] associated with the given [View]. This may be used to retain
 * state associated with this view across configuration changes.
 *
 * @return The [ViewModelStoreOwner] associated with this view and/or some subset of its ancestors
 */
@JvmName(&quot;get&quot;)
public fun View.findViewTreeViewModelStoreOwner(): ViewModelStoreOwner? {
    var currentView: View? = this
    while (currentView != null) {
        val storeOwner =
            currentView.getTag(R.id.view_tree_view_model_store_owner) as? ViewModelStoreOwner
        if (storeOwner != null) {
            return storeOwner
        }
        currentView = currentView.getParentOrViewTreeDisjointParent() as? View
    }
    return null
}</code></pre></div><p id="-566818116#i6omz6_205">Пройдёмся ещё раз по флоу:</p><p id="-566818116#i6omz6_206">Когда мы внутри нашего Composable-функций вызываем любую из extension-функций по созданию viewmodel: то ли viewModel из библиотеки <span class="control" id="-566818116#i6omz6_250">androidx.lifecycle:lifecycle-viewmodel-composе</span>, или хоть даже <span class="inline-code" id="-566818116#i6omz6_251">koinViewModel()</span> из библиотеки <span class="inline-code" id="-566818116#i6omz6_252">io.insert-koin:koin-androidx-compose</span>, или даже <span class="inline-code" id="-566818116#i6omz6_253">hiltViewModel()</span> из <span class="inline-code" id="-566818116#i6omz6_254">androidx.hilt:hilt-navigation-compose</span>, то в конечном итоге мы обращаемся именно к CompositionLocal с названием <span class="inline-code" id="-566818116#i6omz6_255">LocalViewModelStoreOwner</span> к его полю current. А тот, в свою очередь, либо достаёт значение, которое внутри него хранится, либо обращается к Composable-методу <span class="inline-code" id="-566818116#i6omz6_256">findViewTreeViewModelStoreOwner</span>. А тот, в свою очередь, обращается к <span class="inline-code" id="-566818116#i6omz6_257">LocalView</span> &mdash; это ещё один <span class="inline-code" id="-566818116#i6omz6_258">CompositionLocal</span>, у которого есть текущее <span class="inline-code" id="-566818116#i6omz6_259">View</span>, и для него запускается extension-метод <span class="inline-code" id="-566818116#i6omz6_260">View.findViewTreeViewModelStoreOwner</span>, и происходит поиск по дереву <span class="inline-code" id="-566818116#i6omz6_261">View</span> в поисках <span class="inline-code" id="-566818116#i6omz6_262">ViewModelStoreOwner</span>. В итоге он его находит, но как? В голове возникают два вопроса:</p><ol class="list list-decimal" id="-566818116#i6omz6_207" type="1" start="1"><li class="list-item" id="-566818116#i6omz6_263"><p id="-566818116#i6omz6_265">При чём тут View-шки? Почему Compose обращается к LocalView, и LocalView откуда сам взялся?</p></li><li class="list-item" id="-566818116#i6omz6_264"><p id="-566818116#i6omz6_266">Из предыдущей главы в статье мы увидели, что прежде чем вызывать метод View.findViewTreeViewModelStoreOwner(), до него мы клали ViewModelStoreOwner во внутренний тег внутри FrameLayout, который являлся рутовым View в нашем макете, с помощью метода setViewTreeViewModelStoreOwner. Но в примере с Compose мы ничего никуда не клали &mdash; как всё это работает само по себе?</p></li></ol><p id="-566818116#i6omz6_208">Всё довольно просто, разработчики Google позаботились об этом за нас. Обычно в Composable есть два подхода:</p><ol class="list list-decimal" id="-566818116#i6omz6_209" type="1" start="1"><li class="list-item" id="-566818116#i6omz6_267"><p id="-566818116#i6omz6_269">Когда весь проект на Compose полностью, или как минимум в каждой активити UI-дерево начинается с <span class="inline-code" id="-566818116#i6omz6_271">setContent{}</span>, а не с <span class="inline-code" id="-566818116#i6omz6_272">setContentView</span>:</p><div class="detached code-block" id="-566818116#i6omz6_270"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            Greeting(modifier = Modifier.fillMaxWidth())
        }
    }
}</code></pre></div></li><li class="list-item" id="-566818116#i6omz6_268"><p id="-566818116#i6omz6_273">Гибридный UI, где часть на compose, а часть на View. Тогда прибегают к использованию ComposeView:</p></li></ol><div class="detached code-block" id="-566818116#i6omz6_210"><pre><code class="language-markup">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
              android:id=&quot;@+id/linearLayout&quot;
              android:layout_width=&quot;match_parent&quot;
              android:layout_height=&quot;match_parent&quot;
              android:orientation=&quot;vertical&quot;&gt;

    &lt;androidx.compose.ui.platform.ComposeView
            android:id=&quot;@+id/composeView&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;200dp&quot;/&gt;
&lt;/LinearLayout&gt;</code></pre></div><div class="detached code-block" id="-566818116#i6omz6_211"><pre><code class="language-kotlin">class MainActivity : ComponentActivity(R.layout.activity_main) {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val composeView = findViewById&lt;ComposeView&gt;(R.id.composeView)

        composeView.setContent { Greeting() }
    }
}</code></pre></div><p id="-566818116#i6omz6_212">В обоих случаях, если запустить в таком виде, как сейчас, всё заработает: наша <span class="inline-code" id="-566818116#i6omz6_274">ViewModel</span> внутри функции <span class="control" id="-566818116#i6omz6_275"><span class="inline-code" id="-566818116#i6omz6_277">Greeting</span></span> без проблем создастся и положится в <span class="inline-code" id="-566818116#i6omz6_276">ViewModelStore</span>, который принадлежит Activity. Почему так происходит?</p><p id="-566818116#i6omz6_213">В обоих случаях мы вызываем метод setContent{}, в первом кейсе это <span class="inline-code" id="-566818116#i6omz6_278">ComponentActivity.setContent{}</span>, а во втором <span class="inline-code" id="-566818116#i6omz6_279">ComposeView.setContent {}</span>, которые открывают Composable-область.</p><p id="-566818116#i6omz6_214">Рассмотрим сначала первый кейс, начнём с setContent для активити (ComponentActivity).</p><section class="detached"><h3 id="-566818116#componentactivity-setcontent" data-toc="componentactivity-setcontent#view-model-under-the-hood-сompose.md-componentactivity-setcontent">Использование ComponentActivity.setContent:</h3><div class="detached code-block" id="-566818116#i6omz6_280"><pre><code class="language-kotlin">public fun ComponentActivity.setContent(
    parent: CompositionContext? = null,
    content: @Composable () -&gt; Unit
) {
    val existingComposeView =
        window.decorView.findViewById&lt;ViewGroup&gt;(android.R.id.content).getChildAt(0) as? ComposeView

    if (existingComposeView != null)
        with(existingComposeView) {
            setParentCompositionContext(parent)
            setContent(content)
        }
    else
        ComposeView(this).apply {
            // Set content and parent **before** setContentView
            // to have ComposeView create the composition on attach
            setParentCompositionContext(parent)
            setContent(content)
            // Set the view tree owners before setting the content view so that the inflation
            // process and attach listeners will see them already present
            setOwners()
            setContentView(this, DefaultActivityContentLayoutParams)
        }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-566818116#i6omz6_285">Обратите внимание, что это функция расширения setContent является расширением для ComponentActivity и имеет дополнительную логику по инициализации Owner-ов и прочих компонентов. Внутри себя она использует ComposeView и его метод setContent.</p></div>
</blockquote>
<p id="-566818116#i6omz6_282">Что здесь происходит? У window есть DecorView, внутри этого DecorView лежит ещё один ViewGroup(FrameLayout). У этого ViewGroup извлекается ComposeView под индексом 0, если он есть. Если его нет, то создается новый и вызывается метод setContentView (который есть у всех активити и унаследован от самого Activity). Но то, что нам нужно, происходит до вызова метода setContentView &mdash; речь идёт о <span class="inline-code" id="-566818116#i6omz6_286">setOwners</span>. Давайте глянем на его исходники тоже:</p><div class="detached code-block" id="-566818116#i6omz6_283"><pre><code class="language-kotlin">private fun ComponentActivity.setOwners() {
    val decorView = window.decorView
    ...
    if (decorView.findViewTreeViewModelStoreOwner() == null) {
        decorView.setViewTreeViewModelStoreOwner(this)
    }
    ...
}</code></pre></div><p id="-566818116#i6omz6_284">И именно здесь ViewModelStoreOwner кладётся в DecorView посредством вызова метода setViewTreeViewModelStoreOwner, куда передается this &mdash; то есть само активити. DecorView является самым(почти) корневым View во всей иерархии View, выше его стоит только сам Window.</p></section></section><section class="detached"><h2 id="-566818116#viewmodelstoreowner-composeview-localview" data-toc="viewmodelstoreowner-composeview-localview#view-model-under-the-hood-сompose.md-viewmodelstoreowner-composeview-localview">Общая картина взаимодействия ViewModelStoreOwner, ComposeView и LocalView</h2><p id="-566818116#i6omz6_287">Теперь давайте обобщим весь процесс и сделаем итоги: когда мы используем ComponentActivity (или его наследников FragmentActivity и AppCompatActivity) в Compose и создаём ViewModel, используя делегаты compose/hilt/koin, то внутри идёт обращение к LocalViewModelStoreOwner. Тот отдаёт ViewModelStoreOwner, если он есть. Если нет, то обращается к Composable-методу <span class="inline-code" id="-566818116#i6omz6_323">findViewTreeViewModelStoreOwner</span>. Тот, в свою очередь, внутри себя обращается к composition local &mdash; LocalView.current, получает View и у этого View вызывает другой extension-метод View.findViewTreeViewModelStoreOwner. Этот метод рекурсивно, начиная с LocalView, ищет сохранённый ViewModelStoreOwner в тегах View и так добирается вверх по иерархии View, пока не найдёт. Если найдёт, то вернёт его; если не найдёт, то вернёт null, и выбросится ошибка: <span class="control" id="-566818116#i6omz6_324"><span class="emphasis" id="-566818116#i6omz6_325">No ViewModelStoreOwner was provided via LocalViewModelStoreOwner</span></span></p><p id="-566818116#i6omz6_288">Как мы видели выше, при вызове <span class="inline-code" id="-566818116#i6omz6_326">ComponentActivity.setContent{}</span> под капотом внутри вызывается метод <span class="inline-code" id="-566818116#i6omz6_327">ComponentActivity.setOwners()</span>, в котором помещается ViewModelStoreOwner в тег DecorView. Получается, что при вызове метода View.findViewTreeViewModelStoreOwner(), пробираясь по иерархии View, в конечном итоге найдётся ViewModelStoreOwner внутри самой верхней View (DecorView), но в Compose нет прямого доступа к DecorView, вместо этого идёт обращение к LocalView.current:</p><p id="-566818116#i6omz6_289"><span class="control" id="-566818116#i6omz6_328">LocalViewModelStoreOwner.android.kt</span></p><div class="detached code-block" id="-566818116#i6omz6_290"><pre><code class="language-kotlin">@Composable
internal actual fun findViewTreeViewModelStoreOwner(): ViewModelStoreOwner? =
    LocalView.current.findViewTreeViewModelStoreOwner()</code></pre></div><p id="-566818116#i6omz6_291">В этой цепочке мы не рассмотрели только один момент &mdash; откуда берётся <span class="inline-code" id="-566818116#i6omz6_329">LocalView</span>. Точнее, понятно, что это <span class="inline-code" id="-566818116#i6omz6_330">CompositionLocal</span>, но <span class="control" id="-566818116#i6omz6_331">откуда в нём ссылка на текущее <span class="inline-code" id="-566818116#i6omz6_333">View</span>?</span> или <span class="control" id="-566818116#i6omz6_332">кем является текущее <span class="inline-code" id="-566818116#i6omz6_334">View</span>?</span></p><p id="-566818116#i6omz6_292">Если кратко и абстрактно: <span class="inline-code" id="-566818116#i6omz6_335">ComposeView</span> внутри себя сам вызывает <span class="inline-code" id="-566818116#i6omz6_336">LocalView</span> и провайдит ему <span class="control" id="-566818116#i6omz6_337">самого себя</span>. Поэтому <span class="inline-code" id="-566818116#i6omz6_338">LocalView</span> по умолчанию ссылается на тот <span class="inline-code" id="-566818116#i6omz6_339">ComposeView</span>, в котором было запущено дерево Composable-функций. А дерево Compose в Android всегда начинается именно с ComposеView.</p><p id="-566818116#i6omz6_293">Ниже &mdash; полный путь до момента, где <span class="inline-code" id="-566818116#i6omz6_340">LocalView</span> получает значение. Без подробных комментариев, просто цепочка:</p><div class="detached code-block" id="-566818116#i6omz6_294"><pre><code class="language-kotlin">class ComposeView @JvmOverloads constructor(...) : AbstractComposeView(context, attrs, defStyleAttr)</code></pre></div><p id="-566818116#i6omz6_295"><span class="inline-code" id="-566818116#i6omz6_341">ComposeView</span> наследуется от <span class="inline-code" id="-566818116#i6omz6_342">AbstractComposeView</span>. Смотрим, что происходит внутри <span class="inline-code" id="-566818116#i6omz6_343">AbstractComposeView</span>:</p><div class="detached code-block" id="-566818116#i6omz6_296"><pre><code class="language-kotlin">abstract class AbstractComposeView(...) : ViewGroup(...) {
    private fun ensureCompositionCreated() {
        if (composition == null) {
            composition = setContent(resolveParentCompositionContext()) {
                Content()
            }
        }
    }
}</code></pre></div><p id="-566818116#i6omz6_297">В методе <span class="inline-code" id="-566818116#i6omz6_344">ensureCompositionCreated</span>, который вызывается, например, при <span class="inline-code" id="-566818116#i6omz6_345">onMeasure</span> или <span class="inline-code" id="-566818116#i6omz6_346">onAttachedToWindow</span>, или когда вызываем ComposeView.setContent, нас интересует вызов функции <span class="inline-code" id="-566818116#i6omz6_347">setContent</span>:</p><div class="detached code-block" id="-566818116#i6omz6_298"><pre><code class="language-kotlin">internal fun AbstractComposeView.setContent(...): Composition {
    val composeView = ... ?: AndroidComposeView(...).also {
        addView(it.view, DefaultLayoutParams)
    }
    return doSetContent(composeView, parent, content)
}</code></pre></div><p id="-566818116#i6omz6_299">Тут происходит следующее: создаётся объект класса <span class="inline-code" id="-566818116#i6omz6_348">AndroidComposeView</span>, этот же объект помещается внутрь <span class="inline-code" id="-566818116#i6omz6_349">ComposeView</span> вызовом <span class="inline-code" id="-566818116#i6omz6_350">addView</span>. Напоминаю, что <span class="inline-code" id="-566818116#i6omz6_351">AbstractComposeView</span> это абстрактный класс, и один из его наследников &mdash; это <span class="inline-code" id="-566818116#i6omz6_352">ComposeView</span>. Хоть здесь работа идёт на уровне абстракций, фактически когда вызывается <span class="inline-code" id="-566818116#i6omz6_353">addView</span>, то он вызывается для <span class="inline-code" id="-566818116#i6omz6_354">ComposeView</span>.</p><p id="-566818116#i6omz6_300">Если стало слишком много новых названий, которые вызывают путаницу, то вот краткое объяснение:</p><ul class="list" id="-566818116#i6omz6_301" start="1"><li class="list-item" id="-566818116#i6omz6_355"><p id="-566818116#i6omz6_358"><span class="inline-code" id="-566818116#i6omz6_359">AbstractComposeView</span> - абстрактный класс, который является ViewGroup и имеет уже много реализаций внутри</p></li><li class="list-item" id="-566818116#i6omz6_356"><p id="-566818116#i6omz6_360"><span class="inline-code" id="-566818116#i6omz6_361">ComposeView</span> - один из наследников <span class="inline-code" id="-566818116#i6omz6_362">AbstractComposeView</span>, который позволяет нам запускать Composable функции внутри себя. В Android всё упирается в работу с ним в конечном итоге, так как в Android нет способа запускать Composable напрямую на уровне Window. Между Window и нашими Composable экранами стоят куча View и ViewGroup, в том числе и сам <span class="inline-code" id="-566818116#i6omz6_363">ComposeView</span></p></li><li class="list-item" id="-566818116#i6omz6_357"><p id="-566818116#i6omz6_364"><span class="inline-code" id="-566818116#i6omz6_365">AndroidComposeView</span> - низкоуровневый класс, внутри которого в конечном итоге и рисуются наши Composable экраны</p></li></ul><p id="-566818116#i6omz6_302">Далее &mdash; <span class="inline-code" id="-566818116#i6omz6_366">doSetContent</span>:</p><div class="detached code-block" id="-566818116#i6omz6_303"><pre><code class="language-kotlin">private fun doSetContent(
    owner: AndroidComposeView,
    parent: CompositionContext,
    content: @Composable () -&gt; Unit
): Composition {
    ...
    val wrapped = owner.view.getTag(R.id.wrapped_composition_tag)
            as? WrappedComposition
        ?: WrappedComposition(owner, original).also {
            owner.view.setTag(R.id.wrapped_composition_tag, it)
        }
    wrapped.setContent(content)
}</code></pre></div><p id="-566818116#i6omz6_304">Переходим в <span class="inline-code" id="-566818116#i6omz6_367">WrappedComposition.setContent</span>:</p><div class="detached code-block" id="-566818116#i6omz6_305"><pre><code class="language-kotlin">private class WrappedComposition(
    val owner: AndroidComposeView,
    val original: Composition
) : Composition, LifecycleEventObserver, CompositionServices {
    override fun setContent(content: @Composable () -&gt; Unit) {
        ...
        ProvideAndroidCompositionLocals(owner, content)
        ...
    }
}</code></pre></div><p id="-566818116#i6omz6_306">И вот &mdash; ключевой момент:</p><div class="detached code-block" id="-566818116#i6omz6_307"><pre><code class="language-kotlin">@Composable
internal fun ProvideAndroidCompositionLocals(
    owner: AndroidComposeView,
    content: @Composable () -&gt; Unit
) {
    CompositionLocalProvider(
        ...
    LocalView provides owner.view,
    ...
    ) {
        content()
    }
}</code></pre></div><p id="-566818116#i6omz6_308">Здесь <span class="inline-code" id="-566818116#i6omz6_368">LocalView</span> получает значение <span class="inline-code" id="-566818116#i6omz6_369">owner.view</span>, где <span class="inline-code" id="-566818116#i6omz6_370">owner</span> &mdash; это <span class="inline-code" id="-566818116#i6omz6_371">AndroidComposeView</span>, созданный внутри <span class="inline-code" id="-566818116#i6omz6_372">ComposeView</span>.</p><p id="-566818116#i6omz6_310"><span class="control" id="-566818116#i6omz6_373">Вывод:</span> <span class="inline-code" id="-566818116#i6omz6_374">LocalView</span> получает ссылку на <span class="inline-code" id="-566818116#i6omz6_375">View</span>, внутри которого выполняется композиция, за счёт того, что <span class="inline-code" id="-566818116#i6omz6_376">ComposeView</span> сам инициализирует <span class="inline-code" id="-566818116#i6omz6_377">AndroidComposeView</span>, который далее передаётся в <span class="inline-code" id="-566818116#i6omz6_378">ProvideAndroidCompositionLocals</span>. <span class="inline-code" id="-566818116#i6omz6_379">AndroidComposeView</span> создаётся и хранится <span class="control" id="-566818116#i6omz6_380">внутри</span> <span class="inline-code" id="-566818116#i6omz6_381">ComposeView</span>, и <span class="inline-code" id="-566818116#i6omz6_382">LocalView</span> ссылается именно на этот <span class="inline-code" id="-566818116#i6omz6_383">AndroidComposeView</span>, а не на сам <span class="inline-code" id="-566818116#i6omz6_384">ComposeView</span>.</p><p id="-566818116#i6omz6_311"><span class="inline-code" id="-566818116#i6omz6_385">ComposeView</span> наследуется от <span class="inline-code" id="-566818116#i6omz6_386">AbstractComposeView</span>, который в свою очередь &mdash; <span class="inline-code" id="-566818116#i6omz6_387">ViewGroup</span>. То есть <span class="inline-code" id="-566818116#i6omz6_388">ComposeView</span> &mdash; это не сам <span class="inline-code" id="-566818116#i6omz6_389">AndroidComposeView</span>, а просто контейнер, который при вызове <span class="inline-code" id="-566818116#i6omz6_390">setContent</span> создаёт <span class="inline-code" id="-566818116#i6omz6_391">AndroidComposeView</span> и вставляет его внутрь.</p><p id="-566818116#i6omz6_312">Поэтому, когда в <span class="inline-code" id="-566818116#i6omz6_392">ProvideAndroidCompositionLocals</span> происходит вот это:</p><div class="detached code-block" id="-566818116#i6omz6_313"><pre><code class="language-kotlin">LocalView provides owner.view</code></pre></div><p id="-566818116#i6omz6_314"><span class="inline-code" id="-566818116#i6omz6_393">owner.view</span> &mdash; это <span class="inline-code" id="-566818116#i6omz6_394">AndroidComposeView</span>, а не <span class="inline-code" id="-566818116#i6omz6_395">ComposeView</span>.</p><p id="-566818116#i6omz6_315">Иерархия <span class="inline-code" id="-566818116#i6omz6_396">View</span>, если <span class="inline-code" id="-566818116#i6omz6_397">Activity</span> &mdash; это <span class="inline-code" id="-566818116#i6omz6_398">AppCompatActivity</span>, будет выглядеть так:</p><div class="detached code-block" id="-566818116#i6omz6_316"><pre><code class="language-none">ViewRootImpl
└── DecorView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)
    └── LinearLayout
        └── FrameLayout
            └── FitWindowsLinearLayout (action_bar_root)
                └── ContentFrameLayout (android:id/content)
                    └── ComposeView
                        └── AndroidComposeView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)</code></pre></div><p id="-566818116#i6omz6_317">А если это <span class="inline-code" id="-566818116#i6omz6_399">ComponentActivity</span> или <span class="inline-code" id="-566818116#i6omz6_400">FragmentActivity</span>, то чуть короче:</p><div class="detached code-block" id="-566818116#i6omz6_318"><pre><code class="language-none">ViewRootImpl
└── DecorView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)
    └── LinearLayout
        └── FrameLayout (android:id/content)
            └── ComposeView
                └── AndroidComposeView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)</code></pre></div><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p">
    <div class="prompt-title">Интересный факт</div>
<p id="-566818116#i6omz6_401"><span class="inline-code" id="-566818116#i6omz6_405">ViewRootImpl</span> &mdash; это корневой элемент всей иерархии <span class="inline-code" id="-566818116#i6omz6_406">View</span>. На практике каждый Android-разработчик хотя бы раз сталкивался с ошибкой:</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-566818116#i6omz6_407">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</p></div>
</blockquote>
<p id="-566818116#i6omz6_403">Эта ошибка возникает, если попытаться обратиться к <span class="inline-code" id="-566818116#i6omz6_408">View</span> из не-UI потока. А выбрасывает её как раз <span class="inline-code" id="-566818116#i6omz6_409">ViewRootImpl</span> внутри метода <span class="inline-code" id="-566818116#i6omz6_410">checkThread()</span>:</p><div class="detached code-block" id="-566818116#i6omz6_404"><pre><code class="language-java">public final class ViewRootImpl implements ViewParent, ... {

    void checkThread() {
        Thread current = Thread.currentThread();
        if (mThread != current) {
            throw new CalledFromWrongThreadException(
                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;
                + &quot; Expected: &quot; + mThread.getName()
                + &quot; Calling: &quot; + current.getName());
        }
    }
}</code></pre></div>  </div>
</blockquote>
<p id="-566818116#i6omz6_320">Ключевая мысль &mdash; <span class="inline-code" id="-566818116#i6omz6_411">LocalView</span> по умолчанию указывает на <span class="inline-code" id="-566818116#i6omz6_412">AndroidComposeView</span>, который создаётся внутри <span class="inline-code" id="-566818116#i6omz6_413">ComposeView</span> динамически. Сам <span class="inline-code" id="-566818116#i6omz6_414">ComposeView</span> &mdash; просто оболочка, которая знает, как всё связать и встроить дерево <span class="inline-code" id="-566818116#i6omz6_415">Composable</span> в нужное место иерархии.</p><p id="-566818116#i6omz6_321">Тут мы рассмотрели первый кейс, когда мы используем ComponentActicity.setContent{} с передачей нашей композиции и создания ViewModel. Второй флоу использования &mdash; это внутри иерархии View, например, если у нас все экраны на Fragment/View, и мы в каких-то местах используем Compose. Это возможно благодаря ComposeView. Рассмотрим такой кейс:</p><section class="detached"><h3 id="-566818116#omposeview-setcontent" data-toc="omposeview-setcontent#view-model-under-the-hood-сompose.md-omposeview-setcontent">Использование СomposeView.setContent:</h3><p id="-566818116#i6omz6_416">Вот пример кода из примеров выше:</p><div class="detached code-block" id="-566818116#i6omz6_417"><pre><code class="language-kotlin">class MainActivity : ComponentActivity(R.layout.activity_main) {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val composeView = findViewById&lt;ComposeView&gt;(R.id.composeView)

        composeView.setContent { Greeting() }
    }
}</code></pre></div><div class="detached code-block" id="-566818116#i6omz6_418"><pre><code class="language-kotlin">@Composable
fun Greeting(modifier: Modifier = Modifier) {
    val viewModel = androidx.lifecycle.viewmodel.compose.viewModel&lt;MyViewModel&gt;()
    Text(
        text = &quot;Hello ${viewModel.getName()}&quot;,
        modifier = modifier
    )
}</code></pre></div><p id="-566818116#i6omz6_419">Как работает setContent у ComposeView мы уже рассмотрели. Внутри себя ComposeView.setContent не кладёт ссылку на ViewModelStoreOwner и не имеет внутри себя вызов функции setViewTreeViewModelStoreOwner, он только помогает провайдить LocalView.</p><p id="-566818116#i6omz6_420">Но если запустить код в текущем виде, всё заработает как ожидалось. В чём дело? Ситуация аналогичная, как и ранее, когда уже за нас предусмотрели такую логику. Дело в следующем: при вызове метода setContentView(R.layout.activity_main) или даже при передаче ссылки на layout в конструктор: ComponentActivity(R.layout.activity_main) происходит следующая цепочка:</p><p id="-566818116#i6omz6_421">Если передаем Layout Id в конструктор:</p><div class="detached code-block" id="-566818116#i6omz6_422"><pre><code class="language-kotlin">open class ComponentActivity() ... {

    @ContentView
    constructor(@LayoutRes contentLayoutId: Int) : this() {
    this.contentLayoutId = contentLayoutId
}

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        if (contentLayoutId != 0) {
            setContentView(contentLayoutId)
        }
    }
}</code></pre></div><p id="-566818116#i6omz6_423">В методе <span class="inline-code" id="-566818116#i6omz6_445">onCreate</span> вызывается setContentView, если передали contentLayoutId в конструктор. Если же напрямую вызвали setContentView, то логика следующая:</p><p id="-566818116#i6omz6_424">Когда мы вызываем метод setContentView() и передаем нашу View или id макета, то под капотом происходит следующее (далее исходники метода setContentView):</p><div class="detached code-block" id="-566818116#i6omz6_425"><pre><code class="language-kotlin">open class ComponentActivity() ... {

    override fun setContentView(@LayoutRes layoutResID: Int) {
        initializeViewTreeOwners()
        reportFullyDrawnExecutor.viewCreated(window.decorView)
        super.setContentView(layoutResID)
    }
}</code></pre></div><p id="-566818116#i6omz6_426">Название метода initializeViewTreeOwners выглядит заманчивым, поэтому глянем в исходники:</p><div class="detached code-block" id="-566818116#i6omz6_427"><pre><code class="language-kotlin">@CallSuper
open class ComponentActivity() ... {

    open fun initializeViewTreeOwners() {
        ...
        window.decorView.setViewTreeViewModelStoreOwner(this)
        ...
    }
}</code></pre></div><p id="-566818116#i6omz6_428">И мы здесь видим, что у window вызывается метод <span class="inline-code" id="-566818116#i6omz6_446">getDecorView</span> (в Kotlin все геттеры из Java имеют синтаксис как у переменной), и дальше вызывается функция setViewTreeViewModelStoreOwner, который помещает this (ViewModelStoreOwner) в тег внутрь DecorView.</p><p id="-566818116#i6omz6_429">Сделаем итоги: когда мы начинаем свой UI с метода setContentView или передаем layout id в конструктор активити, то внутри самого ComponentActivity (он же родитель для FragmentActivity и AppCompatActivity) срабатывает логика, которая помещает себя (активити реализует интерфейс ViewModelStoreOwner) во внутренний тег DecorView (он же почти самый высокий по иерархии) посредством вызова метода setViewTreeViewModelStoreOwner. Далее, когда мы добавляем в иерархию View свой ComposeView, чтобы начать писать на Compose, то внутри ComposeView провайдится значение для LocalView.current. Затем при создании ViewModel внутри Compose идет обращение к LocalViewModelStoreOwner, а именно к его полю current. Там проверяется, есть ли значение, и если нет, вызывается метод <span class="inline-code" id="-566818116#i6omz6_447">findViewTreeViewModelStoreOwner</span> у LocalView, который ищет ViewModelStoreOwner, поднимаясь вверх по иерархии, пока не найдет. Таким образом, в конечном итоге находится ViewModelStoreOwner у DecorView. Вот так всё и работает. Далее диаграмма иерархии View:</p><div class="detached code-block" id="-566818116#i6omz6_430"><pre><code class="language-none">ViewRootImpl
└── DecorView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)
    └── LinearLayout
        └── FrameLayout (android:id/content)
            └── FrameLayout (app:id/frameRootLayout)
                └── ComposeView (app:id/composeView)
                    └── AndroidComposeView</code></pre></div><p id="-566818116#i6omz6_431">На этом статья почти закончена, осталось пролить свет на один момент. К этому моменту вся информация выше наводит на мысль: а почему мы в начале статьи вручную сами вызывали метод <span class="inline-code" id="-566818116#i6omz6_448">setViewTreeViewModelStoreOwner</span>, если всё это делается за нас?</p><p id="-566818116#i6omz6_432">(P.S. я возвращаюсь к примеру в начале статьи с View (TranslatableTextView))</p><p id="-566818116#i6omz6_433">Благодаря тому, что мы установили ViewModelStoreOwner для нашего корневого layout внутри нашего макета, тег внутри FrameLayout (frameRootLayout) имеет ссылку (weak) на ViewModelStoreOwner:</p><div class="detached code-block" id="-566818116#i6omz6_434"><pre><code class="language-kotlin">class MainActivity : AppCompatActivity() {

    private val frameRootLayout by lazy { findViewById&lt;FrameLayout&gt;(R.id.frameRootLayout) }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        ...
        // Привязываем ViewModelStoreOwner к дереву View
        frameRootLayout.setViewTreeViewModelStoreOwner(this)
        ...
    }
}</code></pre></div><p id="-566818116#i6omz6_435">И метод <span class="inline-code" id="-566818116#i6omz6_449">findViewTreeViewModelStoreOwner</span>, когда пробегается по иерархии View, сначала поищет в TranslatableTextView, а затем, если он не найдет, будет подниматься вверх по родителям. Родитель &mdash; это frameRootLayout (FrameLayout), там он и найдет ViewModelStoreOwner. Но что, если мы удалим установку <span class="inline-code" id="-566818116#i6omz6_450">frameRootLayout.setViewTreeViewModelStoreOwner(this)</span> и запустим код?</p><div class="detached code-block" id="-566818116#i6omz6_436"><pre><code class="language-kotlin">class TranslatableTextView(context: Context) : AppCompatTextView(context) {

    private val viewModel: TranslatableTextViewViewModel by lazy {
        val owner = findViewTreeViewModelStoreOwner() ?: error(&quot;ViewModelStoreOwner not found for TranslatableTextView&quot;)
        ViewModelProvider.create(owner = owner).get(TranslatableTextViewViewModel::class.java)
    }
    ...
}</code></pre></div><p id="-566818116#i6omz6_437">То всё так же будет работать. Почему? Дело в том, что, как мы уже ранее рассмотрели в иерархии, есть ещё один родитель &mdash; DecorView. Как это выглядит:</p><div class="detached code-block" id="-566818116#i6omz6_438"><pre><code class="language-none">ViewRootImpl
└── DecorView -&gt; имеет слабую ссылку на ViewModelStoreOwner (то есть активити)
    └── LinearLayout
        └── FrameLayout (android:id/content)
            └── FrameLayout (app:id/frameRootLayout)
                └── TranslatableTextView</code></pre></div><p id="-566818116#i6omz6_439">И когда мы вызываем метод AppCompatActivity.setContentView() и передаем нашу View или id макета, то под капотом происходит следующее (далее исходники метода setContentView):</p><div class="detached code-block" id="-566818116#i6omz6_440"><pre><code class="language-kotlin">open class ComponentActivity() ... {

    override fun setContentView(@LayoutRes layoutResID: Int) {
        initializeViewTreeOwners()
        ...
    }
}</code></pre></div><p id="-566818116#i6omz6_441">Название метода initializeViewTreeOwners выглядит заманчивым, поэтому глянем в исходники:</p><div class="detached code-block" id="-566818116#i6omz6_442"><pre><code class="language-kotlin">@CallSuper
open class ComponentActivity() ... {

    open fun initializeViewTreeOwners() {
        ...
        window.decorView.setViewTreeViewModelStoreOwner(this)
        ...
    }
}</code></pre></div><p id="-566818116#i6omz6_443">Итог такой: вызывайте <span class="inline-code" id="-566818116#i6omz6_451">setViewTreeViewModelStoreOwner</span> только если сами хотите указать, в какую <span class="inline-code" id="-566818116#i6omz6_452">View</span> вы хотите поместить определенный <span class="inline-code" id="-566818116#i6omz6_453">ViewModelStoreOwner</span>. В Compose вызывайте <span class="inline-code" id="-566818116#i6omz6_454">LocalViewModelStoreOwner provides yourViewModelStoreOwner</span> только если у вас появилась в этом необходимость, но на практике не встречал, чтобы кто-то занимался этим, так как решения из коробки от Google всё решают, и в ручной работе обычно нет необходимости &mdash; unless вы реально что-то очень кастомное мутите.</p></section></section><section class="detached"><h2 id="-566818116#viewmodel-compose-di-delegates" data-toc="viewmodel-compose-di-delegates#view-model-under-the-hood-сompose.md-viewmodel-compose-di-delegates">ViewModel Compose DI Delegates:</h2><p id="-566818116#i6omz6_456">Когда мы рассмотрели <span class="inline-code" id="-566818116#i6omz6_469">ViewModel</span> для <span class="inline-code" id="-566818116#i6omz6_470">Composable</span> функций, мы рассмотрели только <span class="inline-code" id="-566818116#i6omz6_471">composable</span> функцию <span class="inline-code" id="-566818116#i6omz6_472">viewModel()</span>&mdash; функцию из библиотеки: <span class="control" id="-566818116#i6omz6_474">androidx.lifecycle:lifecycle-viewmodel-compose:2.8.7</span> без DI. И инициализация была такая:</p><div class="detached code-block" id="-566818116#i6omz6_457"><pre><code class="language-kotlin">@Composable
fun Greeting(modifier: Modifier = Modifier) {
    // тут специально не импортировал функцию
    val viewModel = androidx.lifecycle.viewmodel.compose.viewModel&lt;MyViewModel&gt;()
}</code></pre></div><p id="-566818116#i6omz6_458">Ранее я говорил что:</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-566818116#i6omz6_475">Когда мы внутри нашего <span class="inline-code" id="-566818116#i6omz6_477">Composable</span>-функций вызываем любую из extension-функций по созданию <span class="inline-code" id="-566818116#i6omz6_478">viewModel</span>: то ли</p><ol class="list list-decimal" id="-566818116#i6omz6_476" type="1" start="1"><li class="list-item" id="-566818116#i6omz6_479"><p id="-566818116#i6omz6_482"><span class="inline-code" id="-566818116#i6omz6_483">viewModel</span> из библиотеки <span class="control" id="-566818116#i6omz6_484">androidx.lifecycle:lifecycle-viewmodel-composе</span>,</p></li><li class="list-item" id="-566818116#i6omz6_480"><p id="-566818116#i6omz6_485"><span class="inline-code" id="-566818116#i6omz6_486">koinViewModel()</span> из библиотеки <span class="inline-code" id="-566818116#i6omz6_487">io.insert-koin:koin-androidx-compose</span>,</p></li><li class="list-item" id="-566818116#i6omz6_481"><p id="-566818116#i6omz6_488"><span class="inline-code" id="-566818116#i6omz6_489">hiltViewModel()</span> из <span class="inline-code" id="-566818116#i6omz6_490">androidx.hilt:hilt-navigation-compose</span>,</p></li></ol></div>
</blockquote>
<p id="-566818116#i6omz6_460">То в конечном итоге мы обращаемся именно к <span class="inline-code" id="-566818116#i6omz6_491">CompositionLocal</span> с названием <span class="inline-code" id="-566818116#i6omz6_492">LocalViewModelStoreOwner</span> к его полю <span class="inline-code" id="-566818116#i6omz6_493">current</span>.  Поэтому реализация везде одна и та же независимо от библиотеки, весь флоу который мы рассмотрели независимо от делегата и библиотеки будет работать так же.</p><p id="-566818116#i6omz6_461">Давайте убедимся в этом, просто рассмотрим сигнатуру всех троих:</p><ol class="list list-decimal" id="-566818116#i6omz6_462" type="1" start="1"><li class="list-item" id="-566818116#i6omz6_495"><p id="-566818116#i6omz6_497">Первый мы уже видели, посмотрим еще раз: <span class="control" id="-566818116#i6omz6_499"><span class="inline-code" id="-566818116#i6omz6_500">androidx.lifecycle.viewmodel.compose.ViewModel.kt</span></span></p><div class="detached code-block" id="-566818116#i6omz6_498"><pre><code class="language-kotlin">@Suppress(&quot;MissingJvmstatic&quot;)
@Composable
public inline fun &lt;reified VM : ViewModel&gt; viewModel(
    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {
        &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;
    },
    ...
): VM = viewModel(VM::class, viewModelStoreOwner, key, factory, extras)</code></pre></div></li><li class="list-item" id="-566818116#i6omz6_496"><p id="-566818116#i6omz6_501">Koin: <span class="control" id="-566818116#i6omz6_502"><span class="inline-code" id="-566818116#i6omz6_503">org.koin.androidx.compose.ViewModel.kt:</span></span></p></li></ol><div class="detached code-block" id="-566818116#i6omz6_463"><pre><code class="language-kotlin">@OptIn(KoinInternalApi::class)
@Composable
inline fun &lt;reified T : ViewModel&gt; koinViewModel(
    qualifier: Qualifier? = null,
    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {
        &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;
    },
    ...
): T {
    return resolveViewModel(
        T::class, viewModelStoreOwner.viewModelStore, key, extras, qualifier, scope, parameters
    )
}</code></pre></div><p id="-566818116#i6omz6_464">3.Hilt: <span class="control" id="-566818116#i6omz6_504"><span class="inline-code" id="-566818116#i6omz6_505">androidx.hilt.navigation.compose.HiltViewModel.kt:</span></span></p><div class="detached code-block" id="-566818116#i6omz6_465"><pre><code class="language-kotlin">@Composable
inline fun &lt;reified VM : ViewModel&gt; hiltViewModel(
    viewModelStoreOwner: ViewModelStoreOwner = checkNotNull(LocalViewModelStoreOwner.current) {
        &quot;No ViewModelStoreOwner was provided via LocalViewModelStoreOwner&quot;
    },
    key: String? = null
): VM {
    val factory = createHiltViewModelFactory(viewModelStoreOwner)
    return viewModel(viewModelStoreOwner, key, factory = factory)
}</code></pre></div><p id="-566818116#i6omz6_466">Как можно заметить, все три делегата &mdash; <span class="inline-code" id="-566818116#i6omz6_506">viewModel()</span>, <span class="inline-code" id="-566818116#i6omz6_507">koinViewModel()</span> и <span class="inline-code" id="-566818116#i6omz6_508">hiltViewModel()</span> &mdash; используют один и тот же механизм получения <span class="inline-code" id="-566818116#i6omz6_509">ViewModelStoreOwner</span> через <span class="inline-code" id="-566818116#i6omz6_510">LocalViewModelStoreOwner.current</span>. Отличия лишь в синтаксисе и дополнительной логике, связанной с DI, но в основе всё сводится к одному &mdash; получению <span class="inline-code" id="-566818116#i6omz6_511">ViewModelStoreOwner</span> из дерева <span class="inline-code" id="-566818116#i6omz6_512">View</span>.</p><p id="-566818116#i6omz6_467">Причина проста: в Compose нет прямого доступа к <span class="inline-code" id="-566818116#i6omz6_513">ComponentActivity</span> и её производным (<span class="inline-code" id="-566818116#i6omz6_514">FragmentActivity</span>, <span class="inline-code" id="-566818116#i6omz6_515">AppCompatActivity</span>), как и к <span class="inline-code" id="-566818116#i6omz6_516">Fragment</span> или <span class="inline-code" id="-566818116#i6omz6_517">NavBackStackEntry</span>. Поэтому используется <span class="inline-code" id="-566818116#i6omz6_518">LocalViewModelStoreOwner</span>, который при отсутствии значения в <span class="inline-code" id="-566818116#i6omz6_519">current</span> обращается к <span class="inline-code" id="-566818116#i6omz6_520">LocalView.current</span>и уже для него вызывает метод<span class="inline-code" id="-566818116#i6omz6_521">findViewTreeViewModelStoreOwner()</span> &mdash; стандартный способ получить ближайший <span class="inline-code" id="-566818116#i6omz6_522">ViewModelStoreOwner</span> из иерархии <span class="inline-code" id="-566818116#i6omz6_523">View</span>.</p><p id="-566818116#i6omz6_468">Именно поэтому <span class="inline-code" id="-566818116#i6omz6_524">LocalViewModelStoreOwner</span> &mdash; ключевой элемент. Он &mdash; универсальный посредник между Compose и традиционным ViewModel-механизмом Android. И независимо от того, используете ли вы Hilt, Koin или ничего из DI, &mdash; всё работает через него.</p></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="-1282102256">SavedStateHandle и Bundle под капотом: как Android сохраняет состояние</h1><p id="-1282102256#-9vp8ci_3">Это продолжение трех предыдущих статей.</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_4" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_12"><p id="-1282102256#-9vp8ci_15">В первой мы разобрали, где в конечном итоге хранится <span class="inline-code" id="-1282102256#-9vp8ci_16">ViewModelStore</span> в случае с <span class="inline-code" id="-1282102256#-9vp8ci_17">Activity</span>,</p></li><li class="list-item" id="-1282102256#-9vp8ci_13"><p id="-1282102256#-9vp8ci_18">Во второй &mdash; как это устроено во <span class="inline-code" id="-1282102256#-9vp8ci_19">Fragment</span>,</p></li><li class="list-item" id="-1282102256#-9vp8ci_14"><p id="-1282102256#-9vp8ci_20">В третьей где хранятся <span class="inline-code" id="-1282102256#-9vp8ci_21">ViewModel</span>-и, когда мы используем <span class="control" id="-1282102256#-9vp8ci_22">Compose</span> (или даже просто <span class="inline-code" id="-1282102256#-9vp8ci_23">View</span>).</p></li></ol><p id="-1282102256#-9vp8ci_5">В этой статье рассмотрим Где хранится SavedStateHandle, проверим SavedStateHandle vs onSaveInstanceState vs ViewModel(ViewModelStore) Поймем связку SavedStateHandle с ViewModel. И узнаем ответ на главный вопрос, где храниться Bundle. Но, как всегда, начнём с базиса.</p><section class="detached"><h2 id="-1282102256#-9vp8ci_6" data-toc="-9vp8ci_6#saved-state-handle-under-the-hood.md--9vp8ci_6">Базис</h2><p id="-1282102256#-9vp8ci_24">В статье не будет описания того, как работать с этими API, а будет рассказано о том, как они устроены изнутри, поэтому я буду исходить из того, что вы уже работали с ними. Как всегда, начнём с базиса &mdash; дадим определения для SavedStateHandle, onSaveInstanceState и ViewModel:</p><p id="-1282102256#-9vp8ci_25"><span class="control" id="-1282102256#-9vp8ci_31">ViewModel</span> &mdash; компонент архитектурного паттерна MVVM, предоставленный Google как примитив, позволяющий пережить изменение конфигурации. Изменение конфигурации &mdash; это состояние, из-за которого Activity/Fragment пересоздаётся; именно это состояние может пережить ViewModel. Увы, на этом обязанности ViewModel по хранению данных в контексте Android заканчиваются.</p><p id="-1282102256#-9vp8ci_26">Если же процесс приложения умирает или прерывается, ViewModel не справится; тогда на сцену выходят старые добрые методы onSaveInstanceState/onRestoreInstanceState.</p><p id="-1282102256#-9vp8ci_27"><span class="control" id="-1282102256#-9vp8ci_32">onSaveInstanceState/onRestoreInstanceState</span> &mdash; методы жизненного цикла Activity, Fragment и даже View (да, View тоже может сохранять состояние), которые позволяют сохранять и восстанавливать временное состояние пользовательского интерфейса при изменении конфигурации ( например, при повороте экрана) или при полном уничтожении активности из-за нехватки ресурсов. В onSaveInstanceState данные сохраняются в Bundle, который автоматически передаётся в onRestoreInstanceState при восстановлении активности.</p><p id="-1282102256#-9vp8ci_28">Это базовый механизм для хранения примитивных типов (и их массивов), Parcelable/Serializable и ещё пары нативных Android-типов. Эти методы требуют явного указания того, что именно нужно сохранить, а логика прописывается внутри Activity и Fragment. Большинство архитектурных паттернов (MVI, MVVM) гласят, что View (Fragment/Activity/Compose) должны быть максимально простыми и не содержать никакой логики, кроме отображения данных, поэтому прямое использование этих методов сейчас уступает место Saved State API, которое хорошо интегрируется с ViewModel, наделяя её не только возможностью &laquo;спасать&raquo; данные от изменений конфигурации, но и сохранять сериализуемые данные при уничтожении или остановке процесса по инициативе системы.</p><p id="-1282102256#-9vp8ci_29"><span class="control" id="-1282102256#-9vp8ci_33">Saved State API</span> &mdash; современная альтернатива onSaveInstanceState/onRestoreInstanceState, более гибко управляющая состоянием, особенно в связке с ViewModel. <span class="control" id="-1282102256#-9vp8ci_34">SavedStateHandle</span> &mdash; объект, передаваемый в конструктор ViewModel, который позволяет безопасно сохранять и восстанавливать данные даже после уничтожения процесса. В отличие от статичного onSaveInstanceState, SavedStateHandle также позволяет подписываться на Flow и LiveData тех данных, которые он хранит и восстанавливает. Он автоматически интегрирован с ViewModel и поддерживает сохранение состояния при изменениях конфигурации, а также при полном уничтожении процесса приложения. Дополнительное преимущество &mdash; возможность подписываться на изменения значений в SavedStateHandle и получать реактивное поведение прямо в ViewModel.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Под &laquo;уничтожением или прерыванием процесса&raquo;, о котором идёт речь в статье, подразумевается ситуация, когда приложение находится в фоне и сохраняется в стеке задач. Обычно это происходит, когда пользователь сворачивает приложение, не закрывая его. Через некоторое время бездействия система может остановить процесс. Не стоит путать это с кейсом, когда пользователь сам вручную закрывает приложение &mdash; это другой сценарий.</p></div>
</blockquote>
</section><section class="detached"><h2 id="-1282102256#onsaveinstancestate-onrestoreinstancestate" data-toc="onsaveinstancestate-onrestoreinstancestate#saved-state-handle-under-the-hood.md-onsaveinstancestate-onrestoreinstancestate">onSaveInstanceState / onRestoreInstanceState</h2><p id="-1282102256#-9vp8ci_35">Давайте также освежим память о методах onSaveInstanceState и onRestoreInstanceState:</p><div class="detached code-block" id="-1282102256#-9vp8ci_36"><pre><code class="language-kotlin">class RestoreActivity : AppCompatActivity() {

    private var counter = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Восстановление значения при пересоздании
        counter = savedInstanceState?.getInt(&quot;counter_key&quot;) ?: 0
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        // Восстановление значения при пересоздании
        counter = savedInstanceState.getInt(&quot;counter_key&quot;)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // Сохраняем значение
        outState.putInt(&quot;counter_key&quot;, counter)
        Log.d(&quot;RestoreActivity&quot;, &quot;onSaveInstanceState: Counter saved = $counter&quot;)
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_37"><span class="control" id="-1282102256#-9vp8ci_47">onSaveInstanceState</span> &mdash; вызывается для получения состояния Activity перед её уничтожением, чтобы оно могло быть восстановлено в методах <span class="inline-code" id="-1282102256#-9vp8ci_48">onCreate</span> или <span class="inline-code" id="-1282102256#-9vp8ci_49">onRestoreInstanceState</span>. <span class="inline-code" id="-1282102256#-9vp8ci_50">Bundle</span>, заполненный в этом методе, будет передан в оба метода.</p><p id="-1282102256#-9vp8ci_38">Этот метод вызывается до того, как Activity может быть уничтожена, чтобы при повторном создании она могла восстановить своё состояние. Не следует путать его с методами жизненного цикла, такими как <span class="inline-code" id="-1282102256#-9vp8ci_51">onPause</span> (вызывается всегда, вызывается при частичной потере фокуса Activity) или <span class="inline-code" id="-1282102256#-9vp8ci_52">onStop</span> (когда Activity становится невидимой).</p><ul class="list" id="-1282102256#-9vp8ci_39" start="1"><li class="list-item" id="-1282102256#-9vp8ci_53"><p id="-1282102256#-9vp8ci_55"><span class="control" id="-1282102256#-9vp8ci_56">Пример</span>, когда <span class="inline-code" id="-1282102256#-9vp8ci_57">onPause</span> и <span class="inline-code" id="-1282102256#-9vp8ci_58">onStop</span> вызываются, но <span class="inline-code" id="-1282102256#-9vp8ci_59">onSaveInstanceState</span> &mdash; нет: при возвращении из Activity B в Activity A. В этом случае состояние B не требуется восстанавливать, поэтому <span class="inline-code" id="-1282102256#-9vp8ci_60">onSaveInstanceState</span> для B не вызывается.</p></li><li class="list-item" id="-1282102256#-9vp8ci_54"><p id="-1282102256#-9vp8ci_61"><span class="control" id="-1282102256#-9vp8ci_62">Другой пример</span>: если Activity B запускается поверх Activity A, но A остаётся в памяти, то <span class="inline-code" id="-1282102256#-9vp8ci_63">onSaveInstanceState</span> для A также не вызывается, так как Activity остаётся в памяти и не требуется сохранять её состояние.</p></li></ul><p id="-1282102256#-9vp8ci_40">Реализация по умолчанию этого метода автоматически сохраняет большую часть состояния пользовательского интерфейса, <span class="control" id="-1282102256#-9vp8ci_64">вызывая <span class="inline-code" id="-1282102256#-9vp8ci_66">onSaveInstanceState()</span> у каждого <span class="inline-code" id="-1282102256#-9vp8ci_67">View</span> в иерархии, у которого есть ID</span>, а также сохраняет ID элемента, находившегося в фокусе. Восстановление этих данных происходит в стандартной реализации <span class="inline-code" id="-1282102256#-9vp8ci_65">onRestoreInstanceState()</span>. Если вы переопределяете метод для сохранения дополнительной информации, рекомендуется вызвать реализацию по умолчанию через</p><div class="detached code-block" id="-1282102256#-9vp8ci_41"><pre><code class="language-kotlin">super.onSaveInstanceState(outState)</code></pre></div><p id="-1282102256#-9vp8ci_42">&mdash; иначе придётся вручную сохранять состояние всех <span class="inline-code" id="-1282102256#-9vp8ci_68">View</span>.</p><p id="-1282102256#-9vp8ci_43">Если метод вызывается, то это произойдёт <span class="control" id="-1282102256#-9vp8ci_69">после <span class="inline-code" id="-1282102256#-9vp8ci_72">onStop</span></span> для приложений, нацеленных на платформы, начиная с Android P. Для более ранних версий Android этот метод будет вызван <span class="control" id="-1282102256#-9vp8ci_70">до <span class="inline-code" id="-1282102256#-9vp8ci_73">onStop</span></span>, и нет никаких гарантий, будет ли он вызван до или после <span class="inline-code" id="-1282102256#-9vp8ci_71">onPause</span>.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p">
    <div class="prompt-title">Документация гласит:</div>
<p>If called, this method will occur after onStop for applications targeting platforms starting with android.os.Build.VERSION_CODES.P. For applications targeting earlier platform versions this method will occur before onStop and there are no guarantees about whether it will occur before or after onPause.</p>  </div>
</blockquote>
<p id="-1282102256#-9vp8ci_45"><span class="control" id="-1282102256#-9vp8ci_74">onRestoreInstanceState</span> &mdash; этот метод вызывается <span class="control" id="-1282102256#-9vp8ci_75">после</span> <span class="inline-code" id="-1282102256#-9vp8ci_76">onStart</span>, когда активность повторно инициализируется из ранее сохранённого состояния, переданного в <span class="inline-code" id="-1282102256#-9vp8ci_77">savedInstanceState</span>. Большинство реализаций используют для восстановления состояния метод <span class="inline-code" id="-1282102256#-9vp8ci_78">onCreate</span>, но иногда бывает удобнее делать это здесь, после того как завершена вся инициализация, или чтобы подклассы могли решить, использовать ли вашу реализацию по умолчанию. Стандартная реализация этого метода восстанавливает состояние представлений (View), которое было ранее заморожено методом <span class="inline-code" id="-1282102256#-9vp8ci_79">onSaveInstanceState</span>. Этот метод вызывается <span class="control" id="-1282102256#-9vp8ci_80">между <span class="inline-code" id="-1282102256#-9vp8ci_84">onStart</span> и <span class="inline-code" id="-1282102256#-9vp8ci_85">onPostCreate</span></span>. Он срабатывает <span class="control" id="-1282102256#-9vp8ci_81">только при повторном создании активности</span>; метод <span class="control" id="-1282102256#-9vp8ci_82">не вызывается</span>, если <span class="inline-code" id="-1282102256#-9vp8ci_83">onStart</span> был вызван по любой другой причине (например, при переходе из фона на передний план).</p><p id="-1282102256#-9vp8ci_46">На этом примере временно забываем о них, чуть позже мы их снова встретим в более низкоуровневых цепочках вызовов.</p></section><section class="detached"><h2 id="-1282102256#saved-state-api" data-toc="saved-state-api#saved-state-handle-under-the-hood.md-saved-state-api">Saved State Api</h2><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>С версии 1.3.0-alpha02 androidx.savedstate:savedstate стала поддерживать Kotlin Multiplatform. Теперь SavedState работает не только на Android (Bundle), но и на iOS, JVM, Linux и macOS Map&lt;String, Any&gt;, сохраняя совместимость.</p></div>
</blockquote>
<p id="-1282102256#-9vp8ci_87">Что бы понять работу <span class="control" id="-1282102256#-9vp8ci_237">Saved State Api</span> перепишем пример выше с <span class="inline-code" id="-1282102256#-9vp8ci_238">onSaveInstanceState</span> и <span class="inline-code" id="-1282102256#-9vp8ci_239">onRestoreInstanceState</span> используя Saved State Api, делает ровно тоже самое:</p><div class="detached code-block" id="-1282102256#-9vp8ci_88"><pre><code class="language-kotlin">class RestoreActivity : AppCompatActivity() {

    private var counter = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Восстановление значения при пересоздании
        counter = savedStateRegistry.consumeRestoredStateForKey(&quot;counter_key&quot;)?.getInt(&quot;counter&quot;, 0) ?: 0

        savedStateRegistry.registerSavedStateProvider(
            key = &quot;counter_key&quot;,
            provider = object : SavedStateRegistry.SavedStateProvider {
                override fun saveState(): SavedState {
                    return SavedState(bundleOf(&quot;counter&quot; to counter))
                }
            }
        )
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_89">Мы вызываем у объекта <span class="inline-code" id="-1282102256#-9vp8ci_240">savedStateRegistry</span> метод <span class="inline-code" id="-1282102256#-9vp8ci_241">registerSavedStateProvider</span> куда передаем <span class="inline-code" id="-1282102256#-9vp8ci_242">key</span> и анонимный объект <span class="inline-code" id="-1282102256#-9vp8ci_243">SavedStateRegistry.SavedStateProvider</span> который возвращает <span class="inline-code" id="-1282102256#-9vp8ci_244">Bundle</span> обернутый в объект <span class="inline-code" id="-1282102256#-9vp8ci_245">SavedState</span>, давайте сейчас же определим что из себя представляет этот тип <span class="inline-code" id="-1282102256#-9vp8ci_246">SavedState</span>, если зайти в исходники, а именно в <span class="inline-code" id="-1282102256#-9vp8ci_247">expect</span> логику, то тип описан следующим образом: <span class="control" id="-1282102256#-9vp8ci_248">androidx.savedstate.SavedState.kt</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_90"><pre><code class="language-kotlin">/**
 * An opaque (empty) common type that holds saveable values to be saved and restored by native
 * platforms that have a concept of System-initiated Process Death.
 *
 * That means, the OS will give the chance for the process to keep the state of the application
 * (normally using a serialization mechanism), and allow the app to restore its state later. That is
 * commonly referred to as &quot;state restoration&quot;.
 * ...
 */
public expect class SavedState</code></pre></div><p id="-1282102256#-9vp8ci_91">В контексте <span class="inline-code" id="-1282102256#-9vp8ci_249">android</span> нас интересует именно <span class="inline-code" id="-1282102256#-9vp8ci_250">actual</span> реализация, по этому далее специфичная для android <span class="inline-code" id="-1282102256#-9vp8ci_251">actual</span></p><p id="-1282102256#-9vp8ci_92"><span class="control" id="-1282102256#-9vp8ci_252">androidx.savedstate.SavedState.android.kt</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_93"><pre><code class="language-kotlin">public actual typealias SavedState = android.os.Bundle</code></pre></div><p id="-1282102256#-9vp8ci_94">Как видим в <span class="inline-code" id="-1282102256#-9vp8ci_253">Android</span> нет на самом деле какого-то типа как <span class="inline-code" id="-1282102256#-9vp8ci_254">SavedState</span>, в <span class="inline-code" id="-1282102256#-9vp8ci_255">actual</span> реализаций это просто <span class="inline-code" id="-1282102256#-9vp8ci_256">typealias</span> который ссылается на тот же старый добрый родной класс <span class="inline-code" id="-1282102256#-9vp8ci_257">Bundle</span>, по этому всегда представляйте что там где используется <span class="inline-code" id="-1282102256#-9vp8ci_258">SavedState</span> - на самом деле используется класс <span class="inline-code" id="-1282102256#-9vp8ci_259">Bundle</span>, поэтому ничто не мешает нам отказаться от лишней обёртки и вернуть <span class="inline-code" id="-1282102256#-9vp8ci_260">Bundle</span> напрямую:</p><div class="detached code-block" id="-1282102256#-9vp8ci_95"><pre><code class="language-kotlin">savedStateRegistry.registerSavedStateProvider(
    key = &quot;counter_key&quot;,
    provider = object : SavedStateRegistry.SavedStateProvider {
        override fun saveState(): Bundle {
            return bundleOf(&quot;counter&quot; to counter)
        }
    }
)</code></pre></div><p id="-1282102256#-9vp8ci_96">Раз с этим разобрались, дальше давайте зайдем в исходники метода <span class="inline-code" id="-1282102256#-9vp8ci_261">registerSavedStateProvider</span> и <span class="inline-code" id="-1282102256#-9vp8ci_262">consumeRestoredStateForKey</span>, эти методы вызывается у переменной <span class="inline-code" id="-1282102256#-9vp8ci_263">savedStateRegistry</span> которая имеет тип <span class="inline-code" id="-1282102256#-9vp8ci_264">SavedStateRegistry</span>, давайте быстро узнаем определение этого класса:</p><p id="-1282102256#-9vp8ci_97"><span class="control" id="-1282102256#-9vp8ci_265"><span class="inline-code" id="-1282102256#-9vp8ci_271">SavedStateRegistry</span></span> - управляет сохранением и восстановлением сохранённого состояния, чтобы данные не терялись при пересоздании компонентов. Реализация привязана к <span class="inline-code" id="-1282102256#-9vp8ci_266">SavedStateRegistryImpl</span>, которая отвечает за фактическое хранение и восстановление данных. Интерфейс для подключения компонентов, которые потребляют и вносят данные в сохранённое состояние. Объект имеет такой же жизненный цикл, как и его владелец (<span class="inline-code" id="-1282102256#-9vp8ci_267">Activity</span> или <span class="inline-code" id="-1282102256#-9vp8ci_268">Fragment</span>): когда <span class="inline-code" id="-1282102256#-9vp8ci_269">Activity</span> или <span class="inline-code" id="-1282102256#-9vp8ci_270">Fragment</span> пересоздаются (например, после уничтожения процесса или изменении конфигурации), создаётся новый экземпляр этого объекта.</p><p id="-1282102256#-9vp8ci_98">Но откуда берется <span class="inline-code" id="-1282102256#-9vp8ci_272">savedStateRegistry</span> переменная внутри <span class="inline-code" id="-1282102256#-9vp8ci_273">Activity</span> мы рассмотрим позже, пока достаточно знать что он есть у <span class="inline-code" id="-1282102256#-9vp8ci_274">Activity</span>, далее исходники метода <span class="inline-code" id="-1282102256#-9vp8ci_275">registerSavedStateProvider</span> и <span class="inline-code" id="-1282102256#-9vp8ci_276">consumeRestoredStateForKey</span> принадлежащий классу <span class="inline-code" id="-1282102256#-9vp8ci_277">SavedStateRegistry</span> (expect): <span class="control" id="-1282102256#-9vp8ci_278">androidx.savedstate.SavedStateRegistry.kt</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_99"><pre><code class="language-kotlin">public expect class SavedStateRegistry internal constructor(
    impl: SavedStateRegistryImpl,
) {

    /** This interface marks a component that contributes to saved state. */
    public fun interface SavedStateProvider {

        public fun saveState(): SavedState
    }

    ...
    public val isRestored: Boolean
    ...
    @MainThread
    public fun consumeRestoredStateForKey(key: String): SavedState?
    ...
    @MainThread
    public fun registerSavedStateProvider(key: String, provider: SavedStateProvider)
    ...
    public fun getSavedStateProvider(key: String): SavedStateProvider?
    ...
    @MainThread
    public fun unregisterSavedStateProvider(key: String)
}</code></pre></div><p id="-1282102256#-9vp8ci_100">Как мы видим на самом деле тут много методов у <span class="inline-code" id="-1282102256#-9vp8ci_279">SavedStateRegistry</span>, для нашей статьи достаточно понимать работу методов <span class="inline-code" id="-1282102256#-9vp8ci_280">registerSavedStateProvider</span> и <span class="inline-code" id="-1282102256#-9vp8ci_281">consumeRestoredStateForKey</span>, но что бы хоть какое-то понимание было, давайте быстро пройдемся по каждому:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_101" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_282"><p id="-1282102256#-9vp8ci_288"><span class="control" id="-1282102256#-9vp8ci_289">consumeRestoredStateForKey</span> &mdash; извлекает и удаляет из памяти <span class="inline-code" id="-1282102256#-9vp8ci_290">SavedState</span> (Bundle), который был зарегистрирован с помощью <span class="inline-code" id="-1282102256#-9vp8ci_291">registerSavedStateProvider</span>. При повторном вызове возвращает <span class="inline-code" id="-1282102256#-9vp8ci_292">null</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_283"><p id="-1282102256#-9vp8ci_293"><span class="control" id="-1282102256#-9vp8ci_294">registerSavedStateProvider</span> &mdash; регистрирует <span class="inline-code" id="-1282102256#-9vp8ci_295">SavedStateProvider</span> с указанным ключом. Этот провайдер будет использоваться для сохранения состояния при вызове <span class="inline-code" id="-1282102256#-9vp8ci_296">onSaveInstanceState</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_284"><p id="-1282102256#-9vp8ci_297"><span class="control" id="-1282102256#-9vp8ci_298">getSavedStateProvider</span> &mdash; возвращает зарегистрированный <span class="inline-code" id="-1282102256#-9vp8ci_299">SavedStateProvider</span> по ключу или <span class="inline-code" id="-1282102256#-9vp8ci_300">null</span>, если он не найден.</p></li><li class="list-item" id="-1282102256#-9vp8ci_285"><p id="-1282102256#-9vp8ci_301"><span class="control" id="-1282102256#-9vp8ci_302">unregisterSavedStateProvider</span> &mdash; удаляет из реестра ранее зарегистрированный <span class="inline-code" id="-1282102256#-9vp8ci_303">SavedStateProvider</span> по переданному ключу.</p></li><li class="list-item" id="-1282102256#-9vp8ci_286"><p id="-1282102256#-9vp8ci_304"><span class="control" id="-1282102256#-9vp8ci_305">SavedStateProvider</span> &mdash; интерфейс, предоставляющий объект <span class="inline-code" id="-1282102256#-9vp8ci_306">SavedState</span> (Bundle) при сохранении состояния.</p></li><li class="list-item" id="-1282102256#-9vp8ci_287"><p id="-1282102256#-9vp8ci_307"><span class="control" id="-1282102256#-9vp8ci_308">isRestored</span> &mdash; возвращает <span class="inline-code" id="-1282102256#-9vp8ci_309">true</span>, если состояние было восстановлено после создания компонента.</p></li></ol><p id="-1282102256#-9vp8ci_102">В <span class="inline-code" id="-1282102256#-9vp8ci_310">expect</span>-версиях отсутствуют реализации &mdash; там только сигнатуры методов. Также мы рассмотрели исходники интерфейса <span class="inline-code" id="-1282102256#-9vp8ci_311">SavedStateProvider</span>, который представляет собой callback для получения <span class="inline-code" id="-1282102256#-9vp8ci_312">Bundle</span>, подлежащего сохранению. Чтобы увидеть реализацию метода <span class="inline-code" id="-1282102256#-9vp8ci_313">registerSavedStateProvider</span>, необходимо найти <span class="control" id="-1282102256#-9vp8ci_314"><span class="inline-code" id="-1282102256#-9vp8ci_317">actual</span>-реализацию</span>, а затем перейти к <span class="inline-code" id="-1282102256#-9vp8ci_315">actual</span>-реализации <span class="inline-code" id="-1282102256#-9vp8ci_316">SavedStateRegistry</span>.</p><p id="-1282102256#-9vp8ci_103"><span class="control" id="-1282102256#-9vp8ci_318">androidx.savedstate.SavedStateRegistry.android.kt</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_104"><pre><code class="language-kotlin">public actual class SavedStateRegistry internal actual constructor(
    private val impl: SavedStateRegistryImpl,
) {

    @get:MainThread
    public actual val isRestored: Boolean
        get() = impl.isRestored

    @MainThread
    public actual fun consumeRestoredStateForKey(key: String): SavedState? =
        impl.consumeRestoredStateForKey(key)

    @MainThread
    public actual fun registerSavedStateProvider(key: String, provider: SavedStateProvider) {
        impl.registerSavedStateProvider(key, provider)
    }

    public actual fun getSavedStateProvider(key: String): SavedStateProvider? =
        impl.getSavedStateProvider(key)

    @MainThread
    public actual fun unregisterSavedStateProvider(key: String) {
        impl.unregisterSavedStateProvider(key)
    }

    public actual fun interface SavedStateProvider {
        public actual fun saveState(): SavedState
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_105"><span class="inline-code" id="-1282102256#-9vp8ci_319">actual</span> реализация <span class="inline-code" id="-1282102256#-9vp8ci_320">SavedStateRegistry</span> делегирует все вызовы своих методов готовой имплементацией <span class="inline-code" id="-1282102256#-9vp8ci_321">SavedStateRegistryImpl</span>, по этому далее рассмотрим именно <span class="inline-code" id="-1282102256#-9vp8ci_322">SavedStateRegistryImpl</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_106"><pre><code class="language-kotlin">internal class SavedStateRegistryImpl(
    private val owner: SavedStateRegistryOwner,
    internal val onAttach: () -&gt; Unit = {},
) {

    private val keyToProviders = mutableMapOf&lt;String, SavedStateProvider&gt;()
    private var restoredState: SavedState? = null

    @MainThread
    fun consumeRestoredStateForKey(key: String): SavedState? {
        ...
        val state = restoredState ?: return null

        val consumed = state.read { if (contains(key)) getSavedState(key) else null }
        state.write { remove(key) }
        if (state.read { isEmpty() }) {
            restoredState = null
        }

        return consumed
    }

    @MainThread
    fun registerSavedStateProvider(key: String, provider: SavedStateProvider) {
        ..
        keyToProviders[key] = provider
        ...
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_107">Основные методы для сохранения, давайте просто поймем что здесь происходит:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_108" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_323"><p id="-1282102256#-9vp8ci_325"><span class="inline-code" id="-1282102256#-9vp8ci_326">consumeRestoredStateForKey</span> - достает значение из <span class="inline-code" id="-1282102256#-9vp8ci_327">restoredState</span> (Bundle) по ключу, после того как достает значение, удаляет из <span class="inline-code" id="-1282102256#-9vp8ci_328">restoredState</span> (Bundle) значение и ключ, <span class="inline-code" id="-1282102256#-9vp8ci_329">restoredState</span> является самым коренным <span class="inline-code" id="-1282102256#-9vp8ci_330">Bundle</span> который внутри себя хранит все другие bundle</p></li><li class="list-item" id="-1282102256#-9vp8ci_324"><p id="-1282102256#-9vp8ci_331"><span class="inline-code" id="-1282102256#-9vp8ci_332">registerSavedStateProvider</span> - просто добавляет объект <span class="inline-code" id="-1282102256#-9vp8ci_333">SavedStateProvider</span> внутрь карты <span class="inline-code" id="-1282102256#-9vp8ci_334">keyToProviders</span></p></li></ol><p id="-1282102256#-9vp8ci_109">Эти методы &mdash; очень верхне уровневые и не раскрывают, как именно в итоге сохраняются данные, поэтому нужно копнуть глубже &mdash; внутри этого же класса <span class="inline-code" id="-1282102256#-9vp8ci_335">SavedStateRegistryImpl</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_110"><pre><code class="language-kotlin">internal class SavedStateRegistryImpl(
    private val owner: SavedStateRegistryOwner,
    internal val onAttach: () -&gt; Unit = {},
) {
    private val keyToProviders = mutableMapOf&lt;String, SavedStateProvider&gt;()
    private var restoredState: SavedState? = null

    @MainThread
    internal fun performRestore(savedState: SavedState?) {
        ...
        restoredState =
            savedState?.read {
                if (contains(SAVED_COMPONENTS_KEY)) getSavedState(SAVED_COMPONENTS_KEY) else null
            }
        isRestored = true
    }

    @MainThread
    internal fun performSave(outBundle: SavedState) {
        val inState = savedState {
            restoredState?.let { putAll(it) }
            synchronized(lock) {
                for ((key, provider) in keyToProviders) {
                    putSavedState(key, provider.saveState())
                }
            }
        }

        if (inState.read { !isEmpty() }) {
            outBundle.write { putSavedState(SAVED_COMPONENTS_KEY, inState) }
        }
    }

    private companion object {
        private const val SAVED_COMPONENTS_KEY =
            &quot;androidx.lifecycle.BundlableSavedStateRegistry.key&quot;
    }
}</code></pre></div><ol class="list list-decimal" id="-1282102256#-9vp8ci_111" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_336"><p id="-1282102256#-9vp8ci_338"><span class="inline-code" id="-1282102256#-9vp8ci_339">performSave</span> &mdash; вызывается, когда <span class="inline-code" id="-1282102256#-9vp8ci_340">Activity</span> или <span class="inline-code" id="-1282102256#-9vp8ci_341">Fragment</span> переходит в состояние <span class="inline-code" id="-1282102256#-9vp8ci_342">pause</span>-&gt; <span class="inline-code" id="-1282102256#-9vp8ci_343">stop</span>, то есть в момент вызова <span class="inline-code" id="-1282102256#-9vp8ci_344">onSaveInstanceState</span>. Этот метод отвечает за сохранение состояния всех <span class="inline-code" id="-1282102256#-9vp8ci_345">SavedStateProvider</span>, зарегистрированных через <span class="inline-code" id="-1282102256#-9vp8ci_346">registerSavedStateProvider</span>. Внутри метода создается объект <span class="inline-code" id="-1282102256#-9vp8ci_347">inState</span> типа SavedState (по сути, это сам <span class="inline-code" id="-1282102256#-9vp8ci_348">Bundle</span>). Если в restoredState уже есть данные, они добавляются в <span class="inline-code" id="-1282102256#-9vp8ci_349">inState</span>. Затем, в синхронизированном блоке, происходит обход всех зарегистрированных <span class="inline-code" id="-1282102256#-9vp8ci_350">SavedStateProvider</span>, вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_351">saveState</span> (), и результаты сохраняются в <span class="inline-code" id="-1282102256#-9vp8ci_352">inState</span>. В конце, если <span class="inline-code" id="-1282102256#-9vp8ci_353">inState</span> не пустой, его содержимое записывается в параметр <span class="inline-code" id="-1282102256#-9vp8ci_354">outBundle</span> под ключом <span class="inline-code" id="-1282102256#-9vp8ci_355">SAVED_COMPONENTS_KEY</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_337"><p id="-1282102256#-9vp8ci_356"><span class="inline-code" id="-1282102256#-9vp8ci_357">performRestore</span> &mdash; вызывается при создании или восстановлении <span class="inline-code" id="-1282102256#-9vp8ci_358">Activity</span> или <span class="inline-code" id="-1282102256#-9vp8ci_359">Fragment</span>. Этот метод просто читает из <span class="inline-code" id="-1282102256#-9vp8ci_360">savedState</span>значение по ключу <span class="inline-code" id="-1282102256#-9vp8ci_361">SAVED_COMPONENTS_KEY</span>, если оно существует. Найденное значение (вложенный <span class="inline-code" id="-1282102256#-9vp8ci_362">SavedState</span>) сохраняется в переменную <span class="inline-code" id="-1282102256#-9vp8ci_363">restoredState</span>, чтобы потом можно было передать его в соответствующие компоненты.</p></li></ol><p id="-1282102256#-9vp8ci_112">На данный момент мы увидели как работает логика сохранения и регистраций, теперь осталось понять кто же вызывает методы <span class="inline-code" id="-1282102256#-9vp8ci_364">performSave</span> и <span class="inline-code" id="-1282102256#-9vp8ci_365">performRestore</span> и в какой момент.</p><p id="-1282102256#-9vp8ci_113">Этой логикой управляет <span class="inline-code" id="-1282102256#-9vp8ci_366">SavedStateRegistryController</span>, в связи с тем что Saved State Api тоже на <span class="inline-code" id="-1282102256#-9vp8ci_367">KMP</span>, по этому лучше сразу посмотрим actual версию:</p><div class="detached code-block" id="-1282102256#-9vp8ci_114"><pre><code class="language-kotlin">public actual class SavedStateRegistryController private actual constructor(
    private val impl: SavedStateRegistryImpl,
) {

    public actual val savedStateRegistry: SavedStateRegistry = SavedStateRegistry(impl)

    @MainThread
    public actual fun performAttach() {
        impl.performAttach()
    }

    @MainThread
    public actual fun performRestore(savedState: SavedState?) {
        impl.performRestore(savedState)
    }

    @MainThread
    public actual fun performSave(outBundle: SavedState) {
        impl.performSave(outBundle)
    }

    public actual companion object {

        @JvmStatic
        public actual fun create(owner: SavedStateRegistryOwner): SavedStateRegistryController {
            val impl =
                SavedStateRegistryImpl(
                    owner = owner,
                    onAttach = { owner.lifecycle.addObserver(Recreator(owner)) },
                )
            return SavedStateRegistryController(impl)
        }
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_115">И видим, что вызовами методов <span class="inline-code" id="-1282102256#-9vp8ci_368">SavedStateRegistryImpl.performSave</span> и <span class="inline-code" id="-1282102256#-9vp8ci_369">SavedStateRegistryImpl.performRestore</span> управляют одноимённые методы из <span class="inline-code" id="-1282102256#-9vp8ci_370">SavedStateRegistryController</span>.</p><p id="-1282102256#-9vp8ci_116">Также видим метод <span class="inline-code" id="-1282102256#-9vp8ci_371">create</span>, который создаёт <span class="inline-code" id="-1282102256#-9vp8ci_372">SavedStateRegistryImpl</span>, передаёт его в конструктор <span class="inline-code" id="-1282102256#-9vp8ci_373">SavedStateRegistryController</span> и возвращает сам <span class="inline-code" id="-1282102256#-9vp8ci_374">SavedStateRegistryController</span>.</p><p id="-1282102256#-9vp8ci_117">Далее остаётся только понять, откуда вызываются сами методы <span class="inline-code" id="-1282102256#-9vp8ci_375">SavedStateRegistryController</span>. В начале статьи мы отложили разбор источника поля <span class="inline-code" id="-1282102256#-9vp8ci_376">savedStateRegistry</span> в <span class="inline-code" id="-1282102256#-9vp8ci_377">Activity</span>. Сейчас самое время разобраться.</p><p id="-1282102256#-9vp8ci_118">Внутри <span class="inline-code" id="-1282102256#-9vp8ci_378">Activity</span> нам доступно поле <span class="inline-code" id="-1282102256#-9vp8ci_379">savedStateRegistry</span>. Это возможно потому, что <span class="inline-code" id="-1282102256#-9vp8ci_380">Activity</span> реализует интерфейс <span class="inline-code" id="-1282102256#-9vp8ci_381">SavedStateRegistryOwner</span>. Если посмотреть исходники, то можно увидеть, что <span class="inline-code" id="-1282102256#-9vp8ci_382">ComponentActivity</span> реализует <span class="inline-code" id="-1282102256#-9vp8ci_383">SavedStateRegistryOwner</span>. На самом деле <span class="inline-code" id="-1282102256#-9vp8ci_384">ComponentActivity</span> реализует множество интерфейсов, но ниже приведён фрагмент с опущенными остальными родителями:</p><div class="detached code-block" id="-1282102256#-9vp8ci_119"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    private val savedStateRegistryController: SavedStateRegistryController =
        SavedStateRegistryController.create(this)

    final override val savedStateRegistry: SavedStateRegistry
        get() = savedStateRegistryController.savedStateRegistry
}</code></pre></div><p id="-1282102256#-9vp8ci_120"><span class="inline-code" id="-1282102256#-9vp8ci_385">SavedStateRegistryOwner</span> - это просто interface который хранит в себе <span class="inline-code" id="-1282102256#-9vp8ci_386">SavedStateRegistry</span>, его реализует <span class="inline-code" id="-1282102256#-9vp8ci_387">Activity</span>, <span class="inline-code" id="-1282102256#-9vp8ci_388">Fragment</span> и <span class="inline-code" id="-1282102256#-9vp8ci_389">NavBackStackEntry</span>, выглядит он следующим образом:</p><div class="detached code-block" id="-1282102256#-9vp8ci_121"><pre><code class="language-kotlin">public interface SavedStateRegistryOwner : androidx.lifecycle.LifecycleOwner {
    /** The [SavedStateRegistry] owned by this SavedStateRegistryOwner */
    public val savedStateRegistry: SavedStateRegistry
}</code></pre></div><p id="-1282102256#-9vp8ci_122"><span class="inline-code" id="-1282102256#-9vp8ci_390">SavedStateRegistry</span> доступен в любом компоненте, реализующем интерфейс <span class="inline-code" id="-1282102256#-9vp8ci_391">SavedStateRegistryOwner</span>. Этим интерфейсом обладают:</p><ul class="list" id="-1282102256#-9vp8ci_123" start="1"><li class="list-item" id="-1282102256#-9vp8ci_392"><p id="-1282102256#-9vp8ci_395"><span class="inline-code" id="-1282102256#-9vp8ci_397">ComponentActivity</span> &mdash; это базовый класс для всех современных <span class="inline-code" id="-1282102256#-9vp8ci_398">Activity</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_396"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    private val savedStateRegistryController: SavedStateRegistryController =
        SavedStateRegistryController.create(this)

    final override val savedStateRegistry: SavedStateRegistry
        get() = savedStateRegistryController.savedStateRegistry
}</code></pre></div></li><li class="list-item" id="-1282102256#-9vp8ci_393"><p id="-1282102256#-9vp8ci_399"><span class="inline-code" id="-1282102256#-9vp8ci_401">Fragment</span> &mdash; любой <span class="inline-code" id="-1282102256#-9vp8ci_402">Fragment</span> также реализует этот интерфейс.</p><div class="detached code-block" id="-1282102256#-9vp8ci_400"><pre><code class="language-java">public class Fragment implements ...SavedStateRegistryOwner,...{

    SavedStateRegistryController mSavedStateRegistryController;

    @NonNull
    @Override
    public final SavedStateRegistry getSavedStateRegistry() {
        return mSavedStateRegistryController.getSavedStateRegistry();
    }
}</code></pre></div></li><li class="list-item" id="-1282102256#-9vp8ci_394"><p id="-1282102256#-9vp8ci_403"><span class="inline-code" id="-1282102256#-9vp8ci_405">NavBackStackEntry</span> - компонент навигаций из Jetpack Navigation</p><div class="detached code-block" id="-1282102256#-9vp8ci_404"><pre><code class="language-kotlin">public expect class NavBackStackEntry : ..., SavedStateRegistryOwner {

    override val savedStateRegistry: SavedStateRegistry

}</code></pre></div></li></ul><p id="-1282102256#-9vp8ci_124">Мы выяснили большую цепочку вызовов, давайте визуально посмотрим:</p><div class="detached code-block" id="-1282102256#-9vp8ci_125"><pre><code class="language-nginx">expect -&gt; SavedStateRegistryController.performSave 
  -&gt; actual SavedStateRegistryController.performSave 
  -&gt; expect SavedStateRegistry 
  -&gt; actual SavedStateRegistry 
  -&gt; SavedStateRegistryImpl.performSave 
  -&gt; SavedStateProvider.saveState() 
  -&gt; // Bundle</code></pre></div><p id="-1282102256#-9vp8ci_126">Углубляться в работу <span class="inline-code" id="-1282102256#-9vp8ci_406">Fragment</span> и <span class="inline-code" id="-1282102256#-9vp8ci_407">NavBackStackEntry</span> не будем &mdash; разберёмся только с <span class="inline-code" id="-1282102256#-9vp8ci_408">Activity</span>. На данный момент мы понимаем, что в конечном итоге все вызовы идут в <span class="inline-code" id="-1282102256#-9vp8ci_409">SavedStateRegistryController</span>. Давай посмотрим, как <span class="inline-code" id="-1282102256#-9vp8ci_410">Activity</span> с ним взаимодействует:</p><p id="-1282102256#-9vp8ci_127">Метод <span class="inline-code" id="-1282102256#-9vp8ci_411">performRestore</span> у <span class="inline-code" id="-1282102256#-9vp8ci_412">SavedStateRegistryController</span>, отвечающий за восстановление данных из <span class="inline-code" id="-1282102256#-9vp8ci_413">Bundle</span>, вызывается внутри <span class="inline-code" id="-1282102256#-9vp8ci_414">ComponentActivity.onCreate</span>, а метод <span class="inline-code" id="-1282102256#-9vp8ci_415">performSave</span>, сохраняющий данные в <span class="inline-code" id="-1282102256#-9vp8ci_416">Bundle</span>, &mdash; внутри <span class="inline-code" id="-1282102256#-9vp8ci_417">ComponentActivity.onSaveInstanceState</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_128"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    override fun onCreate(savedInstanceState: Bundle?) {
        savedStateRegistryController.performRestore(savedInstanceState)
        super.onCreate(savedInstanceState)
        ...
    }

    @CallSuper
    override fun onSaveInstanceState(outState: Bundle) {
        ...
        super.onSaveInstanceState(outState)
        savedStateRegistryController.performSave(outState)
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_129">Здесь та самая точка, где <span class="inline-code" id="-1282102256#-9vp8ci_418">onSaveInstanceState</span>/<span class="inline-code" id="-1282102256#-9vp8ci_419">onRestoreInstanceState</span> объединяются с <span class="inline-code" id="-1282102256#-9vp8ci_420">SavedStateRegistryController</span>/<span class="inline-code" id="-1282102256#-9vp8ci_421">SavedStateRegistry</span>.</p><p id="-1282102256#-9vp8ci_130">Теперь переключимся на <span class="inline-code" id="-1282102256#-9vp8ci_422">ViewModel</span> и его <span class="inline-code" id="-1282102256#-9vp8ci_423">SavedStateHandle</span>, чтобы понять, как он вписывается во всю эту логику. Для начала объявим обычную <span class="inline-code" id="-1282102256#-9vp8ci_424">ViewModel</span>, но в конструкторе передадим <span class="inline-code" id="-1282102256#-9vp8ci_425">SavedStateHandle</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_131"><pre><code class="language-kotlin">class MyViewModel(val savedStateHandle: SavedStateHandle) : ViewModel()</code></pre></div><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Как и говорилось в начале статьи, это не гайд по тому как пользоваться Saved State Api, тут больше ответ на вопрос как это работает под капотом</p></div>
</blockquote>
<p id="-1282102256#-9vp8ci_133">Далее пробуем инициализировать нашу ViewModel в Activity:</p><div class="detached code-block" id="-1282102256#-9vp8ci_134"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel = ViewModelProvider.create(this).get(MyViewModel::class)
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_135">Тут на первый взгляд можно ожидать, что будет краш при запуске приложения, так как если <span class="inline-code" id="-1282102256#-9vp8ci_426">ViewModel</span> на вход принимает какой-либо параметр, то нужна фабрика <span class="inline-code" id="-1282102256#-9vp8ci_427">ViewModel</span>, он же <span class="inline-code" id="-1282102256#-9vp8ci_428">ViewModelProvider.Factory</span>, где мы вручную должны каким-то образом положить требуемый параметр в конструктор. И в нашем примере конструктор не пустой, но если мы запустим этот код, то никакого краша и ошибки не будет, всё запустится и инициализируется должным образом. Почему так?</p><p id="-1282102256#-9vp8ci_136">Разработчики из google знали что часто понадобиться передавать <span class="inline-code" id="-1282102256#-9vp8ci_429">SavedStateHandle</span> в <span class="inline-code" id="-1282102256#-9vp8ci_430">ViewModel</span>, и что бы разработчикам не приходилось каждый раз создавать фабрику для передачи - имеется готовая фабрика которая работает под капотом, так же имеются готовые классы вроде</p><p id="-1282102256#-9vp8ci_137"><span class="inline-code" id="-1282102256#-9vp8ci_431">AbstractSavedStateViewModelFactory</span> - начиная с lifecycle-viewmodel-savedstate-android-<span class="control" id="-1282102256#-9vp8ci_432">2.9.0</span> - обьявлен устаревшим <span class="inline-code" id="-1282102256#-9vp8ci_433">SavedStateViewModelFactory</span> - актуален на данный момент для создания ViewModel с SavedStateHandle</p><p id="-1282102256#-9vp8ci_138">Давайте теперь посмотрим как это работает на уровне <span class="inline-code" id="-1282102256#-9vp8ci_434">Activity</span>, логику <span class="inline-code" id="-1282102256#-9vp8ci_435">ViewModelProvider/ViewModel</span> мы уже рассматривали в прошлых статьях, сейчас просто пройдемся по интересующей нас теме, когда мы обращаемся к <span class="inline-code" id="-1282102256#-9vp8ci_436">ViewModelProvider.create</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_139"><pre><code class="language-kotlin">public expect class ViewModelProvider {
    public companion object {
        ...
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider

    }
}</code></pre></div><p id="-1282102256#-9vp8ci_140">То видим что в качестве factory идет обращение к методу <span class="inline-code" id="-1282102256#-9vp8ci_437">ViewModelProviders.getDefaultFactory(owner)</span>, посмотрим его исходники тоже:</p><div class="detached code-block" id="-1282102256#-9vp8ci_141"><pre><code class="language-kotlin">internal object ViewModelProviders {
    internal fun getDefaultFactory(owner: ViewModelStoreOwner): ViewModelProvider.Factory =
        if (owner is HasDefaultViewModelProviderFactory) {
            owner.defaultViewModelProviderFactory
        } else {
            DefaultViewModelProviderFactory
        }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-1282102256#-9vp8ci_438">ViewModelProvider<span class="control" id="-1282102256#-9vp8ci_439">s</span> &mdash; это утилитный класс, не стоит путать его с <span class="inline-code" id="-1282102256#-9vp8ci_440">ViewModelProvider</span>.</p></div>
</blockquote>
<p id="-1282102256#-9vp8ci_143">В этом методе нас интересует проверка на <span class="inline-code" id="-1282102256#-9vp8ci_441">is HasDefaultViewModelProviderFactory</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_144"><pre><code class="language-kotlin">if (owner is HasDefaultViewModelProviderFactory) {
    owner.defaultViewModelProviderFactory
}</code></pre></div><p id="-1282102256#-9vp8ci_145">Если <span class="inline-code" id="-1282102256#-9vp8ci_442">owner</span> (<span class="inline-code" id="-1282102256#-9vp8ci_443">ViewModelStoreOwner</span>, например <span class="inline-code" id="-1282102256#-9vp8ci_444">Activity</span> или <span class="inline-code" id="-1282102256#-9vp8ci_445">Fragment</span>) реализует интерфейс <span class="inline-code" id="-1282102256#-9vp8ci_446">HasDefaultViewModelProviderFactory</span>, то у него берётся поле <span class="inline-code" id="-1282102256#-9vp8ci_447">defaultViewModelProviderFactory</span>. Интерфейс <span class="inline-code" id="-1282102256#-9vp8ci_448">HasDefaultViewModelProviderFactory</span> выглядит следующим образом: <span class="control" id="-1282102256#-9vp8ci_449">androidx.lifecycle.HasDefaultViewModelProviderFactory.android.kt</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_146"><pre><code class="language-kotlin">public interface HasDefaultViewModelProviderFactory {

    public val defaultViewModelProviderFactory: ViewModelProvider.Factory

    public val defaultViewModelCreationExtras: CreationExtras
        get() = CreationExtras.Empty
}</code></pre></div><p id="-1282102256#-9vp8ci_147">Реализация интерфейса <span class="inline-code" id="-1282102256#-9vp8ci_450">HasDefaultViewModelProviderFactory</span> в <span class="inline-code" id="-1282102256#-9vp8ci_451">Activity</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_148"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, HasDefaultViewModelProviderFactory, ... {
    ...
    override val defaultViewModelProviderFactory: ViewModelProvider.Factory by lazy {
        SavedStateViewModelFactory(application, this, if (intent != null) intent.extras else null)
    }

    @get:CallSuper
    override val defaultViewModelCreationExtras: CreationExtras
        /**
         * {@inheritDoc}
         *
         * The extras of [getIntent] when this is first called will be used as the defaults to any
         * [androidx.lifecycle.SavedStateHandle] passed to a view model created using this extra.
         */
        get() {
            val extras = MutableCreationExtras()
            if (application != null) {
                extras[APPLICATION_KEY] = application
            }
            extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this
            extras[VIEW_MODEL_STORE_OWNER_KEY] = this
            val intentExtras = intent?.extras
            if (intentExtras != null) {
                extras[DEFAULT_ARGS_KEY] = intentExtras
            }
            return extras
        }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_149">Тут происходят два очень важных момента:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_150" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_452"><p id="-1282102256#-9vp8ci_454"><span class="inline-code" id="-1282102256#-9vp8ci_455">defaultViewModelProviderFactory</span> &mdash; в качестве фабрики по умолчанию используется <span class="inline-code" id="-1282102256#-9vp8ci_456">SavedStateViewModelFactory</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_453"><p id="-1282102256#-9vp8ci_457"><span class="inline-code" id="-1282102256#-9vp8ci_458">defaultViewModelCreationExtras</span> &mdash; в <span class="inline-code" id="-1282102256#-9vp8ci_459">CreationExtras</span> кладётся <span class="inline-code" id="-1282102256#-9vp8ci_460">SavedStateRegistryOwner</span> под ключом <span class="inline-code" id="-1282102256#-9vp8ci_461">SAVED_STATE_REGISTRY_OWNER_KEY</span> и <span class="inline-code" id="-1282102256#-9vp8ci_462">ViewModelStoreOwner</span> под ключом <span class="inline-code" id="-1282102256#-9vp8ci_463">VIEW_MODEL_STORE_OWNER_KEY</span>.</p></li></ol><p id="-1282102256#-9vp8ci_151">Это ключевая часть того как в итоге <span class="inline-code" id="-1282102256#-9vp8ci_464">SavedStateHandle</span> подключается к <span class="inline-code" id="-1282102256#-9vp8ci_465">ViewModel</span> и к <span class="inline-code" id="-1282102256#-9vp8ci_466">SavedStateRegistryOwner</span></p><p id="-1282102256#-9vp8ci_152">Чтобы понять, как <span class="inline-code" id="-1282102256#-9vp8ci_467">SavedStateHandle</span> создаётся и восстанавливается для <span class="inline-code" id="-1282102256#-9vp8ci_468">ViewModel</span>, давайте разберёмся, что происходит в <span class="inline-code" id="-1282102256#-9vp8ci_469">SavedStateViewModelFactory</span></p><p id="-1282102256#-9vp8ci_153"><span class="control" id="-1282102256#-9vp8ci_470">androidx.lifecycle.SavedStateViewModelFactory.android.kt:</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_154"><pre><code class="language-kotlin">public actual class SavedStateViewModelFactory :
    ViewModelProvider.OnRequeryFactory, ViewModelProvider.Factory {

    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T {
        ...
        return if (
            extras[SAVED_STATE_REGISTRY_OWNER_KEY] != null &amp;&amp;
            extras[VIEW_MODEL_STORE_OWNER_KEY] != null
        ) {
            ...
            newInstance(modelClass, constructor, extras.createSavedStateHandle())
            ...
        }
        ...
    }
}

internal fun &lt;T : ViewModel?&gt; newInstance(
    modelClass: Class&lt;T&gt;,
    constructor: Constructor&lt;T&gt;,
    vararg params: Any
): T {
    return try {
        constructor.newInstance(*params)
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_155">Тут сокращена логика из исходников, чтобы сосредоточиться на главном. Внутри метода <span class="inline-code" id="-1282102256#-9vp8ci_471">create</span> у фабрики проверяется, содержат ли <span class="inline-code" id="-1282102256#-9vp8ci_472">extras</span>поля с ключами <span class="inline-code" id="-1282102256#-9vp8ci_473">SAVED_STATE_REGISTRY_OWNER_KEY</span> и <span class="inline-code" id="-1282102256#-9vp8ci_474">VIEW_MODEL_STORE_OWNER_KEY</span>. Если содержат &mdash; вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_475">newInstance</span>, который через рефлексию вызывает конструктор и передаёт параметры, одним из которых является <span class="inline-code" id="-1282102256#-9vp8ci_476">SavedStateHandle</span>.</p><p id="-1282102256#-9vp8ci_156">Но нас интересует другой момент. Обратим внимание на вызов <span class="inline-code" id="-1282102256#-9vp8ci_477">createSavedStateHandle()</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_157"><pre><code class="language-kotlin">newInstance(modelClass, constructor, extras.createSavedStateHandle())</code></pre></div><p id="-1282102256#-9vp8ci_158">Что происходит внутри <span class="inline-code" id="-1282102256#-9vp8ci_478">createSavedStateHandle()</span>? Чтобы понять, как создаётся <span class="inline-code" id="-1282102256#-9vp8ci_479">SavedStateHandle</span>, нужно заглянуть в исходный код этого метода:</p><p id="-1282102256#-9vp8ci_159"><span class="control" id="-1282102256#-9vp8ci_480">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_160"><pre><code class="language-kotlin">@MainThread
public fun CreationExtras.createSavedStateHandle(): SavedStateHandle {
    val savedStateRegistryOwner =
        this[SAVED_STATE_REGISTRY_OWNER_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `SAVED_STATE_REGISTRY_OWNER_KEY`&quot;
            )
    val viewModelStateRegistryOwner =
        this[VIEW_MODEL_STORE_OWNER_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `VIEW_MODEL_STORE_OWNER_KEY`&quot;
            )

    val defaultArgs = this[DEFAULT_ARGS_KEY]
    val key =
        this[VIEW_MODEL_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `VIEW_MODEL_KEY`&quot;
            )
    return createSavedStateHandle(
        savedStateRegistryOwner,
        viewModelStateRegistryOwner,
        key,
        defaultArgs
    )
}</code></pre></div><p id="-1282102256#-9vp8ci_161">Здесь из CreationExtras извлекаются три ключевых объекта:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_162" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_481"><p id="-1282102256#-9vp8ci_484">savedStateRegistryOwner &mdash; ссылка на SavedStateRegistry для управления состоянием.</p></li><li class="list-item" id="-1282102256#-9vp8ci_482"><p id="-1282102256#-9vp8ci_485">viewModelStateRegistryOwner &mdash; ссылка на ViewModelStore для привязки к жизненному циклу.</p></li><li class="list-item" id="-1282102256#-9vp8ci_483"><p id="-1282102256#-9vp8ci_486">defaultArgs &mdash; начальные параметры, если они были переданы.</p></li></ol><p id="-1282102256#-9vp8ci_163">Все эти зависимости передаются в другой метод <span class="inline-code" id="-1282102256#-9vp8ci_487">createSavedStateHandle</span>, который как раз и занимается созданием или восстановлением SavedStateHandle для данной ViewModel.</p><p id="-1282102256#-9vp8ci_164"><span class="control" id="-1282102256#-9vp8ci_488">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_165"><pre><code class="language-kotlin">private fun createSavedStateHandle(
    savedStateRegistryOwner: SavedStateRegistryOwner,
    viewModelStoreOwner: ViewModelStoreOwner,
    key: String,
    defaultArgs: SavedState?
): SavedStateHandle {
    val provider = savedStateRegistryOwner.savedStateHandlesProvider
    val viewModel = viewModelStoreOwner.savedStateHandlesVM
    return viewModel.handles[key]
        ?: SavedStateHandle.createHandle(provider.consumeRestoredStateForKey(key), defaultArgs)
            .also { viewModel.handles[key] = it }
}</code></pre></div><p id="-1282102256#-9vp8ci_166">Тут сначала ищется нужный <span class="inline-code" id="-1282102256#-9vp8ci_489">SavedStateHandle</span> внутри <span class="inline-code" id="-1282102256#-9vp8ci_490">SavedStateHandlesVM</span>. Если он не найден &mdash; создаётся новый, сохраняется в <span class="inline-code" id="-1282102256#-9vp8ci_491">SavedStateHandlesVM</span>, а функция <span class="inline-code" id="-1282102256#-9vp8ci_492">createSavedStateHandle</span> возвращает управление обратно в <span class="inline-code" id="-1282102256#-9vp8ci_493">CreationExtras.createSavedStateHandle()</span>, которую мы уже видели. В конечном итоге управление возвращается в фабрику, таким образом создаётся <span class="inline-code" id="-1282102256#-9vp8ci_494">SavedStateHandle</span> для конкретной <span class="inline-code" id="-1282102256#-9vp8ci_495">ViewModel</span>.</p><p id="-1282102256#-9vp8ci_167">Также в этом методе видим вызовы вроде <span class="inline-code" id="-1282102256#-9vp8ci_496">savedStateRegistryOwner.savedStateHandlesProvider</span> и <span class="inline-code" id="-1282102256#-9vp8ci_497">viewModelStoreOwner.savedStateHandlesVM</span>.</p><p id="-1282102256#-9vp8ci_168">Теперь посмотрим, как это связано с провайдером. В коде вызывается <span class="inline-code" id="-1282102256#-9vp8ci_498">savedStateRegistryOwner.savedStateHandlesProvider</span>. На самом деле это просто extension свойство, которая вытаскивает объект (<span class="inline-code" id="-1282102256#-9vp8ci_499">SavedStateProvider</span>) из <span class="inline-code" id="-1282102256#-9vp8ci_500">SavedStateRegistry</span>.</p><p id="-1282102256#-9vp8ci_169">Этот провайдер отвечает за доступ ко всем сохранённым состояниям (<span class="inline-code" id="-1282102256#-9vp8ci_501">SavedStateHandle</span>), привязанным к разным <span class="inline-code" id="-1282102256#-9vp8ci_502">ViewModel</span>. Перейдем к провайдеру: <span class="inline-code" id="-1282102256#-9vp8ci_503">savedStateHandlesProvider</span></p><p id="-1282102256#-9vp8ci_170"><span class="control" id="-1282102256#-9vp8ci_504">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_171"><pre><code class="language-kotlin">internal val SavedStateRegistryOwner.savedStateHandlesProvider: SavedStateHandlesProvider
get() =
    savedStateRegistry.getSavedStateProvider(SAVED_STATE_KEY) as? SavedStateHandlesProvider
        ?: throw IllegalStateException(
            &quot;enableSavedStateHandles() wasn't called &quot; +
                    &quot;prior to createSavedStateHandle() call&quot;
        )

internal class SavedStateHandlesProvider(
    private val savedStateRegistry: SavedStateRegistry,
    viewModelStoreOwner: ViewModelStoreOwner
) : SavedStateRegistry.SavedStateProvider {
    private var restored = false
    private var restoredState: SavedState? = null

    private val viewModel by lazy { viewModelStoreOwner.savedStateHandlesVM }

    override fun saveState(): SavedState {
        return savedState {
            restoredState?.let { putAll(it) }
            viewModel.handles.forEach { (key, handle) -&gt;
                val savedState = handle.savedStateProvider().saveState()
                if (savedState.read { !isEmpty() }) {
                    putSavedState(key, savedState)
                }
            }
            restored = false
        }
    }

    fun performRestore() {
        ...
    }

    fun consumeRestoredStateForKey(key: String): SavedState? {
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_172"><span class="inline-code" id="-1282102256#-9vp8ci_505">SavedStateHandlesProvider</span> &mdash; это прослойка между <span class="inline-code" id="-1282102256#-9vp8ci_506">SavedStateRegistry</span> и <span class="inline-code" id="-1282102256#-9vp8ci_507">SavedStateHandle</span>, обеспечивающая централизованное сохранение и восстановление состояний <span class="inline-code" id="-1282102256#-9vp8ci_508">ViewModel</span>. В методе <span class="inline-code" id="-1282102256#-9vp8ci_509">saveState()</span> собираются все актуальные состояния из <span class="inline-code" id="-1282102256#-9vp8ci_510">viewModel.handles</span>, добавляется возможное ранее восстановленное состояние, и итог сохраняется в <span class="inline-code" id="-1282102256#-9vp8ci_511">SavedStateRegistry</span>.</p><p id="-1282102256#-9vp8ci_173">Для выборочного восстановления используется метод <span class="inline-code" id="-1282102256#-9vp8ci_512">consumeRestoredStateForKey()</span>, позволяющий получить состояние по ключу без необходимости загружать всё сразу. Восстановление и подготовка состояний происходят в <span class="inline-code" id="-1282102256#-9vp8ci_513">performRestore()</span>.</p><p id="-1282102256#-9vp8ci_174">По сути, <span class="inline-code" id="-1282102256#-9vp8ci_514">SavedStateHandlesProvider</span> управляет жизненным циклом всех <span class="inline-code" id="-1282102256#-9vp8ci_515">SavedStateHandle</span> в рамках владельца состояния, поддерживая логику ленивого восстановления и гарантируя корректное сохранение после процесса или конфигурационных изменений.</p><p id="-1282102256#-9vp8ci_175"><span class="control" id="-1282102256#-9vp8ci_516">Взаимодействие с <span class="inline-code" id="-1282102256#-9vp8ci_517">SavedStateHandlesVM</span>:</span></p><p id="-1282102256#-9vp8ci_176">Теперь перейдём к тому, как данные хранятся внутри <span class="inline-code" id="-1282102256#-9vp8ci_518">ViewModel</span>. <span class="inline-code" id="-1282102256#-9vp8ci_519">savedStateHandlesVM</span> &mdash; это расширение, которое создаёт или восстанавливает объект <span class="inline-code" id="-1282102256#-9vp8ci_520">SavedStateHandlesVM</span>, хранящий в себе Map из ключей на <span class="inline-code" id="-1282102256#-9vp8ci_521">SavedStateHandle</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_177"><pre><code class="language-kotlin">internal val ViewModelStoreOwner.savedStateHandlesVM: SavedStateHandlesVM
get() =
    ViewModelProvider.create(
        owner = this,
        factory =
            object : ViewModelProvider.Factory {
                override fun &lt;T : ViewModel&gt; create(
                    modelClass: KClass&lt;T&gt;,
                    extras: CreationExtras
                ): T {
                    @Suppress(&quot;UNCHECKED_CAST&quot;) return SavedStateHandlesVM() as T
                }
            }
    )[VIEWMODEL_KEY, SavedStateHandlesVM::class]

internal class SavedStateHandlesVM : ViewModel() {
    val handles = mutableMapOf&lt;String, SavedStateHandle&gt;()
}</code></pre></div><p id="-1282102256#-9vp8ci_178">Здесь создаётся объект <span class="inline-code" id="-1282102256#-9vp8ci_522">SavedStateHandlesVM</span>, внутри которого поддерживается <span class="inline-code" id="-1282102256#-9vp8ci_523">Map</span>, связывающая ключи с объектами <span class="inline-code" id="-1282102256#-9vp8ci_524">SavedStateHandle</span>. <span class="inline-code" id="-1282102256#-9vp8ci_525">SavedStateHandlesVM</span> нужен для того, чтобы хранить и управлять всеми <span class="inline-code" id="-1282102256#-9vp8ci_526">SavedStateHandle</span> всех <span class="inline-code" id="-1282102256#-9vp8ci_527">ViewModel</span> в рамках одного <span class="inline-code" id="-1282102256#-9vp8ci_528">ViewModelStoreOwner</span> и <span class="inline-code" id="-1282102256#-9vp8ci_529">SavedStateRegistryOwner</span>.</p><p id="-1282102256#-9vp8ci_179"><span class="inline-code" id="-1282102256#-9vp8ci_530">SavedStateHandlesProvider</span> &mdash; класс, реализующий интерфейс <span class="inline-code" id="-1282102256#-9vp8ci_531">SavedStateProvider</span>. Когда <span class="inline-code" id="-1282102256#-9vp8ci_532">SavedStateController</span> вызывает <span class="inline-code" id="-1282102256#-9vp8ci_533">performSave</span>, он также обращается к <span class="inline-code" id="-1282102256#-9vp8ci_534">SavedStateHandlesProvider</span> и вызывает его метод <span class="inline-code" id="-1282102256#-9vp8ci_535">saveState</span>. Далее он кладёт все существующие <span class="inline-code" id="-1282102256#-9vp8ci_536">SavedStateHandle</span> в объект <span class="inline-code" id="-1282102256#-9vp8ci_537">SavedState</span> (<span class="inline-code" id="-1282102256#-9vp8ci_538">Bundle</span>) и возвращает его.</p><p id="-1282102256#-9vp8ci_180">Но чтобы весь этот процесс работал, необходимо зарегистрировать <span class="inline-code" id="-1282102256#-9vp8ci_539">SavedStateHandlesProvider</span> в <span class="inline-code" id="-1282102256#-9vp8ci_540">SavedStateRegistry</span>, однако пока что в коде мы не встретили блок, отвечающий за регистрацию провайдера, то есть вызов метода: <span class="inline-code" id="-1282102256#-9vp8ci_541">savedStateRegistry.registerSavedStateProvider(...)</span></p><p id="-1282102256#-9vp8ci_181">На самом деле такая логика есть, и она триггерится внутри <span class="inline-code" id="-1282102256#-9vp8ci_542">ComponentActivity</span>, <span class="inline-code" id="-1282102256#-9vp8ci_543">Fragment</span> и <span class="inline-code" id="-1282102256#-9vp8ci_544">NavBackStackEntry</span>, то есть во всех <span class="inline-code" id="-1282102256#-9vp8ci_545">SavedStateRegistryOwner</span>. Давайте просто глянем, как это вызывается в <span class="inline-code" id="-1282102256#-9vp8ci_546">ComponentActivity</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_182"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    init {
        ...
        enableSavedStateHandles()
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_183">Видим вызов некого метода <span class="inline-code" id="-1282102256#-9vp8ci_547">enableSavedStateHandles</span> &mdash; само название звучит заманчиво. Далее &mdash; исходники метода <span class="inline-code" id="-1282102256#-9vp8ci_548">enableSavedStateHandles</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_184"><pre><code class="language-kotlin">@MainThread
public fun &lt;T&gt; T.enableSavedStateHandles() where T : SavedStateRegistryOwner, T : ViewModelStoreOwner {
    ...
    if (savedStateRegistry.getSavedStateProvider(SAVED_STATE_KEY) == null) {
        val provider = SavedStateHandlesProvider(savedStateRegistry, this)
        savedStateRegistry.registerSavedStateProvider(SAVED_STATE_KEY, provider)
        lifecycle.addObserver(SavedStateHandleAttacher(provider))
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_185"><span class="inline-code" id="-1282102256#-9vp8ci_549">enableSavedStateHandles</span> &mdash; это типизированный метод, который требует, чтобы вызывающая область одновременно являлась и <span class="inline-code" id="-1282102256#-9vp8ci_550">SavedStateRegistryOwner</span>, и <span class="inline-code" id="-1282102256#-9vp8ci_551">ViewModelStoreOwner</span>. <span class="inline-code" id="-1282102256#-9vp8ci_552">ComponentActivity</span>/<span class="inline-code" id="-1282102256#-9vp8ci_553">Fragment</span>/<span class="inline-code" id="-1282102256#-9vp8ci_554">NavBackStackEntry</span> идеально подходят под это &mdash; все трое реализуют оба интерфейса.</p><p id="-1282102256#-9vp8ci_186">Давайте вкратце поймём, что происходит в этом методе. Для начала у <span class="inline-code" id="-1282102256#-9vp8ci_555">SavedStateRegistry</span> запрашивается сохранённый <span class="inline-code" id="-1282102256#-9vp8ci_556">provider</span> (<span class="inline-code" id="-1282102256#-9vp8ci_557">SavedStateProvider</span>) по ключу <span class="inline-code" id="-1282102256#-9vp8ci_558">SAVED_STATE_KEY</span>. Это ключ для хранения <span class="inline-code" id="-1282102256#-9vp8ci_559">SavedStateHandlesProvider</span> (он же <span class="inline-code" id="-1282102256#-9vp8ci_560">SavedStateProvider</span>).</p><p id="-1282102256#-9vp8ci_187">Если по ключу ничего не найдено, то есть <span class="inline-code" id="-1282102256#-9vp8ci_561">null</span>, это означает, что <span class="inline-code" id="-1282102256#-9vp8ci_562">provider</span> ещё не был зарегистрирован. Тогда создаётся объект <span class="inline-code" id="-1282102256#-9vp8ci_563">SavedStateHandlesProvider</span> (он же <span class="inline-code" id="-1282102256#-9vp8ci_564">SavedStateProvider</span>) и регистрируется в <span class="inline-code" id="-1282102256#-9vp8ci_565">savedStateRegistry</span>.</p><p id="-1282102256#-9vp8ci_188">Мы подробно разобрали, как механизм <span class="inline-code" id="-1282102256#-9vp8ci_566">SavedStateHandle</span> автоматически создаётся и подключается к <span class="inline-code" id="-1282102256#-9vp8ci_567">ViewModel</span>. Это достигается за счёт встроенного механизма фабрики <span class="inline-code" id="-1282102256#-9vp8ci_568">SavedStateViewModelFactory</span>, которая при создании ViewModel извлекает необходимые зависимости из объекта <span class="inline-code" id="-1282102256#-9vp8ci_569">CreationExtras</span>. Эти зависимости включают в себя:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_189" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_570"><p id="-1282102256#-9vp8ci_573"><span class="control" id="-1282102256#-9vp8ci_574">SavedStateRegistryOwner</span> &mdash; для управления сохранением и восстановлением состояния.</p></li><li class="list-item" id="-1282102256#-9vp8ci_571"><p id="-1282102256#-9vp8ci_575"><span class="control" id="-1282102256#-9vp8ci_576">ViewModelStoreOwner</span> &mdash; для привязки жизненного цикла ViewModel.</p></li><li class="list-item" id="-1282102256#-9vp8ci_572"><p id="-1282102256#-9vp8ci_577"><span class="control" id="-1282102256#-9vp8ci_578">DefaultArgs</span> &mdash; начальные параметры, если они были переданы.</p></li></ol><p id="-1282102256#-9vp8ci_190">В момент инициализации ViewModel, фабрика <span class="inline-code" id="-1282102256#-9vp8ci_579">SavedStateViewModelFactory</span> через метод <span class="inline-code" id="-1282102256#-9vp8ci_580">createSavedStateHandle</span> формирует объект <span class="inline-code" id="-1282102256#-9vp8ci_581">SavedStateHandle</span>. Этот объект связывается с <span class="inline-code" id="-1282102256#-9vp8ci_582">SavedStateRegistry</span> и регистрируется в нём посредством специального провайдера &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_583">SavedStateHandlesProvider</span> (SavedStateProvider).</p><p id="-1282102256#-9vp8ci_191">Механизм регистрации провайдера запускается автоматически при создании <span class="inline-code" id="-1282102256#-9vp8ci_584">ComponentActivity</span>, <span class="inline-code" id="-1282102256#-9vp8ci_585">Fragment</span> или <span class="inline-code" id="-1282102256#-9vp8ci_586">NavBackStackEntry</span>. Это обеспечивается вызовом метода <span class="inline-code" id="-1282102256#-9vp8ci_587">enableSavedStateHandles</span>, который регистрирует провайдер в <span class="inline-code" id="-1282102256#-9vp8ci_588">SavedStateRegistry</span> под ключом <span class="inline-code" id="-1282102256#-9vp8ci_589">SAVED_STATE_KEY</span>. В дальнейшем, при вызове <span class="inline-code" id="-1282102256#-9vp8ci_590">onSaveInstanceState</span>, этот провайдер сохраняет все текущие состояния из SavedStateHandle, привязанные к ключам <span class="inline-code" id="-1282102256#-9vp8ci_591">ViewModel</span>.</p><p id="-1282102256#-9vp8ci_192">Таким образом, когда компонент пересоздаётся (например, при смене ориентации экрана или в случае уничтожения и восстановления Activity), механизм восстановления срабатывает автоматически. <span class="inline-code" id="-1282102256#-9vp8ci_592">SavedStateRegistry</span> восстанавливает состояние из провайдера, а <span class="inline-code" id="-1282102256#-9vp8ci_593">SavedStateHandle</span> вновь связывается с ViewModel, обеспечивая прозрачную работу с сохранёнными данными.</p><p id="-1282102256#-9vp8ci_193">Это позволяет нам не заботиться о ручной передаче сохранённого состояния при каждом пересоздании ViewModel. Android-фреймворк делает это за нас, используя мощный механизм фабрик и хранилищ состояний, что делает <span class="inline-code" id="-1282102256#-9vp8ci_594">SavedStateHandle</span> удобным и надежным инструментом для управления состоянием внутри ViewModel.</p><p id="-1282102256#-9vp8ci_194">На текущий момент мы понимаем, как <span class="inline-code" id="-1282102256#-9vp8ci_595">SavedStateHandle</span> работает в связке с <span class="inline-code" id="-1282102256#-9vp8ci_596">ViewModel</span> и как он в итоге соединяется с <span class="inline-code" id="-1282102256#-9vp8ci_597">SavedStateRegistry</span>. Также до этого мы узнали, как работают сам <span class="inline-code" id="-1282102256#-9vp8ci_598">SavedStateRegistry</span> и <span class="inline-code" id="-1282102256#-9vp8ci_599">SavedStateRegistryController</span>, и увидели их связь с методами <span class="inline-code" id="-1282102256#-9vp8ci_600">onSaveInstanceState</span> и <span class="inline-code" id="-1282102256#-9vp8ci_601">onRestoreInstanceState</span>.</p><p id="-1282102256#-9vp8ci_195">Оказалось, что и <span class="inline-code" id="-1282102256#-9vp8ci_602">Saved State API</span>, и древние методы <span class="inline-code" id="-1282102256#-9vp8ci_603">onSaveInstanceState</span>/<span class="inline-code" id="-1282102256#-9vp8ci_604">onRestoreInstanceState</span> в конечном итоге работают по одному и тому же пути. Давайте вернёмся к точке, где они встречаются. Далее &mdash; код, который мы уже видели:</p><div class="detached code-block" id="-1282102256#-9vp8ci_196"><pre><code class="language-kotlin">open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    override fun onCreate(savedInstanceState: Bundle?) {
        savedStateRegistryController.performRestore(savedInstanceState)
        super.onCreate(savedInstanceState)
        ...
    }

    @CallSuper
    override fun onSaveInstanceState(outState: Bundle) {
        ...
        super.onSaveInstanceState(outState)
        savedStateRegistryController.performSave(outState)
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_197">То есть в стандартной практике при использовании механизма сохранения состояния применяются два метода:</p><ul class="list" id="-1282102256#-9vp8ci_198" start="1"><li class="list-item" id="-1282102256#-9vp8ci_605"><p id="-1282102256#-9vp8ci_607"><span class="inline-code" id="-1282102256#-9vp8ci_608">onCreate</span> &mdash; получает на вход параметр <span class="inline-code" id="-1282102256#-9vp8ci_609">savedInstanceState</span> типа <span class="inline-code" id="-1282102256#-9vp8ci_610">Bundle</span>. Именно в этом методе читаются сохранённые значения.</p></li><li class="list-item" id="-1282102256#-9vp8ci_606"><p id="-1282102256#-9vp8ci_611"><span class="inline-code" id="-1282102256#-9vp8ci_612">onSaveInstanceState</span> &mdash; получает на вход параметр <span class="inline-code" id="-1282102256#-9vp8ci_613">outState</span> типа <span class="inline-code" id="-1282102256#-9vp8ci_614">Bundle</span>. В этот параметр записываются значения, которые должны быть сохранены.</p></li></ul><p id="-1282102256#-9vp8ci_199">Давайте разберёмся, каким образом вся эта конструкция работает: как значения, сохранённые в <span class="inline-code" id="-1282102256#-9vp8ci_615">outState</span> метода <span class="inline-code" id="-1282102256#-9vp8ci_616">onSaveInstanceState</span>, переживают изменение конфигурации и даже смерть процесса, и как эти сохранённые данные возвращаются обратно в <span class="inline-code" id="-1282102256#-9vp8ci_617">onCreate</span>.</p><p id="-1282102256#-9vp8ci_200">Посмотрим на реализацию метода <span class="inline-code" id="-1282102256#-9vp8ci_618">onSaveInstanceState</span> в <span class="inline-code" id="-1282102256#-9vp8ci_619">super</span>, то есть в самом классе <span class="inline-code" id="-1282102256#-9vp8ci_620">Activity</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_201"><pre><code class="language-java">public class Activity extends ContextThemeWrapper ...{

final void performSaveInstanceState(@NonNull Bundle outState) {
       ...
    onSaveInstanceState(outState);
       ...
}

protected void onSaveInstanceState(@NonNull Bundle outState) {
       ...
}
}</code></pre></div><p id="-1282102256#-9vp8ci_202">Всё, что происходит внутри этого метода, нас сейчас не волнует. Главное, что <span class="inline-code" id="-1282102256#-9vp8ci_621">onSaveInstanceState</span> вызывает другой финальный метод &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_622">performSaveInstanceState</span>.</p><p id="-1282102256#-9vp8ci_203">Теперь давайте поймём, кто вызывает <span class="inline-code" id="-1282102256#-9vp8ci_623">performSaveInstanceState</span>. Этот вызов инициируется классом <span class="inline-code" id="-1282102256#-9vp8ci_624">Instrumentation</span>:</p><p id="-1282102256#-9vp8ci_204"><span class="control" id="-1282102256#-9vp8ci_625">android.app.Instrumentation.java:</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_205"><pre><code class="language-java">@android.ravenwood.annotation.RavenwoodKeepPartialClass
public class Instrumentation {
   ...

    public void callActivityOnSaveInstanceState(@NonNull Activity activity,
                                                @NonNull Bundle outState) {
        activity.performSaveInstanceState(outState);
    }
   ...
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded note detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M21 12a9 9 0 1 1-9-9 9 9 0 0 1 9 9zM10.5 7.5A1.5 1.5 0 1 0 12 6a1.5 1.5 0 0 0-1.5 1.5zm-.5 3.54v1h1V18h2v-6a.96.96 0 0 0-.96-.96z"></path>
  </svg>
  <div class="prompt-content prompt-content-p">
    <div class="prompt-title">Официальная документация гласит следующее об этом классе:</div>
<p>Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xml's </p><p> tag.</p>  </div>
</blockquote>
<p id="-1282102256#-9vp8ci_207">Теперь нужно понять, кто же вызывает <span class="inline-code" id="-1282102256#-9vp8ci_627">Instrumentation.callActivityOnSaveInstanceState</span>? И тут мы встречаем <span class="inline-code" id="-1282102256#-9vp8ci_628">ActivityThread</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_208"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {
    ...

    private void callActivityOnSaveInstanceState(ActivityClientRecord r) {
        r.state = new Bundle();
        r.state.setAllowFds(false);
        if (r.isPersistable()) {
            r.persistentState = new PersistableBundle();
            mInstrumentation.callActivityOnSaveInstanceState(
                    r.activity, r.state,
                    r.persistentState
            );
        } else {
            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);
        }
    }
   ...
}</code></pre></div><p id="-1282102256#-9vp8ci_209">Что здесь происходит? <span class="inline-code" id="-1282102256#-9vp8ci_629">callActivityOnSaveInstanceState</span> на вход принимает параметр <span class="inline-code" id="-1282102256#-9vp8ci_630">r</span> типа <span class="inline-code" id="-1282102256#-9vp8ci_631">ActivityClientRecord</span>. У этого класса есть поле <span class="inline-code" id="-1282102256#-9vp8ci_632">state</span>, которое является <span class="inline-code" id="-1282102256#-9vp8ci_633">Bundle</span>. Ему присваивается новый объект <span class="inline-code" id="-1282102256#-9vp8ci_634">Bundle</span>.</p><p id="-1282102256#-9vp8ci_210">Класс <span class="inline-code" id="-1282102256#-9vp8ci_635">ActivityClientRecord</span> мы уже встречали, когда рассматривали <span class="inline-code" id="-1282102256#-9vp8ci_636">ViewModelStore</span>. <span class="inline-code" id="-1282102256#-9vp8ci_637">ActivityClientRecord</span> представляет собой запись активности и используется для хранения всей информации, связанной с реальным экземпляром активности. Это своего рода структура данных для учёта активности в процессе выполнения приложения.</p><p id="-1282102256#-9vp8ci_211">Основные поля класса <span class="inline-code" id="-1282102256#-9vp8ci_638">ActivityClientRecord</span>:</p><ul class="list" id="-1282102256#-9vp8ci_212" start="1"><li class="list-item" id="-1282102256#-9vp8ci_639"><p id="-1282102256#-9vp8ci_647"><span class="inline-code" id="-1282102256#-9vp8ci_648">state</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_649">Bundle</span>, содержащий сохраненное состояние активности. Да, да, это тот самый Bundle который мы получаем в методе <span class="inline-code" id="-1282102256#-9vp8ci_650">onCreate</span>, <span class="inline-code" id="-1282102256#-9vp8ci_651">onRestoreInstanceState</span> и <span class="inline-code" id="-1282102256#-9vp8ci_652">onSaveInstanceState</span></p></li><li class="list-item" id="-1282102256#-9vp8ci_640"><p id="-1282102256#-9vp8ci_653"><span class="inline-code" id="-1282102256#-9vp8ci_654">lastNonConfigurationInstances</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_655">Activity#NonConfigurationInstance</span>, в котором хранится <span class="inline-code" id="-1282102256#-9vp8ci_656">ComponentActivity#NonConfigurationInstances</span> в котором хранится<span class="inline-code" id="-1282102256#-9vp8ci_657">ViewModelStore</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_641"><p id="-1282102256#-9vp8ci_658"><span class="inline-code" id="-1282102256#-9vp8ci_659">intent</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_660">Intent</span>, представляющий намерение запуска активности.</p></li><li class="list-item" id="-1282102256#-9vp8ci_642"><p id="-1282102256#-9vp8ci_661"><span class="inline-code" id="-1282102256#-9vp8ci_662">window</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_663">Window</span>, связанный с активностью.</p></li><li class="list-item" id="-1282102256#-9vp8ci_643"><p id="-1282102256#-9vp8ci_664"><span class="inline-code" id="-1282102256#-9vp8ci_665">activity</span> &mdash; сам объект <span class="inline-code" id="-1282102256#-9vp8ci_666">Activity</span>.</p></li><li class="list-item" id="-1282102256#-9vp8ci_644"><p id="-1282102256#-9vp8ci_667"><span class="inline-code" id="-1282102256#-9vp8ci_668">parent</span> &mdash; родительская активность (если есть).</p></li><li class="list-item" id="-1282102256#-9vp8ci_645"><p id="-1282102256#-9vp8ci_669"><span class="inline-code" id="-1282102256#-9vp8ci_670">createdConfig</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_671">Configuration</span>, содержащий настройки, примененные при создании активности.</p></li><li class="list-item" id="-1282102256#-9vp8ci_646"><p id="-1282102256#-9vp8ci_672"><span class="inline-code" id="-1282102256#-9vp8ci_673">overrideConfig</span> &mdash; объект <span class="inline-code" id="-1282102256#-9vp8ci_674">Configuration</span>, содержащий текущие настройки активности.</p></li></ul><p id="-1282102256#-9vp8ci_213">Пока что не будем отвлекаться, и узнаем кто же вызывает <span class="inline-code" id="-1282102256#-9vp8ci_675">callActivityOnSaveInstanceState</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_214"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) {
        final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null
                &amp;&amp; !r.isPreHoneycomb();
        final boolean isPreP = r.isPreP();
        if (shouldSaveState &amp;&amp; isPreP) {
            callActivityOnSaveInstanceState(r);
        }
        ...
    }

    private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason,
                                        PendingTransactionActions pendingActions) {
       ...
        final boolean shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();
        if (shouldSaveState) {
            callActivityOnSaveInstanceState(r);
        }
       ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_215">Метод callActivityOnStop определяет, нужно ли сохранять состояние активности перед остановкой. Проверяется флаг saveState, активность не должна быть завершена (!mFinished), состояние (r.state) должно быть ещё не сохранено, и версия должна быть до Honeycomb (!isPreHoneycomb()). Если все условия выполняются и версия до Android P (isPreP()), вызывается callActivityOnSaveInstanceState, чтобы создать и заполнить Bundle</p><p id="-1282102256#-9vp8ci_216">Метод performPauseActivity проверяет, нужно ли сохранить состояние перед паузой. Здесь условия упрощены: активность не должна быть завершена, версия &mdash; до Honeycomb. Если да, то снова вызывается callActivityOnSaveInstanceState для формирования Bundle.</p><div class="detached code-block" id="-1282102256#-9vp8ci_217"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private void performStopActivityInner(ActivityClientRecord r, StopInfo info,
                                          boolean saveState, boolean finalStateRequest, String reason) {
      ...
        callActivityOnStop(r, saveState, reason);
    }

    private void handleRelaunchActivityInner(@NonNull ActivityClientRecord r,...) {
       ...
        if (!r.stopped) {
            callActivityOnStop(r, true /* saveState */, reason);
        }
       ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_218">performStopActivityInner используется при полной остановке активности. Внутри сразу вызывается callActivityOnStop, который проверяет и, если нужно, инициирует сохранение состояния. Это гарантирует, что состояние активности попадёт в Bundle до того, как активность будет остановлена и уничтожена.</p><p id="-1282102256#-9vp8ci_219">В handleRelaunchActivityInner вызывается callActivityOnStop, если активность ещё не остановлена (!r.stopped). Это важно при пересоздании активности (например, при изменении конфигурации), чтобы сохранить состояние до пересоздания.</p><div class="detached code-block" id="-1282102256#-9vp8ci_220"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {
    @Override
    public void handleRelaunchActivity(@NonNull ActivityClientRecord tmp,
                                       @NonNull PendingTransactionActions pendingActions) {
      ...
        handleRelaunchActivityInner(r, tmp.pendingResults, tmp.pendingIntents,
                pendingActions, tmp.startsNotResumed, tmp.overrideConfig, tmp.mActivityWindowInfo,
                &quot;handleRelaunchActivity&quot;);
    }


    @Override
    public void handleStopActivity(ActivityClientRecord r,
                                   PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) {
      ...
        performStopActivityInner(r, stopInfo, true /* saveState */, finalStateRequest,
                reason);
      ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_221">handleRelaunchActivity &mdash; внешний метод, который вызывает handleRelaunchActivityInner. Используется для обработки полного пересоздания активности. Все проверки и логика сохранения состояния уже находятся внутри handleRelaunchActivityInner.</p><p id="-1282102256#-9vp8ci_222">handleStopActivity вызывает performStopActivityInner, передавая туда флаг saveState = true, чтобы принудительно сохранить состояние перед окончательной остановкой. Это используется, например, при закрытии приложения или выгрузке активности системой.</p><p id="-1282102256#-9vp8ci_223">Последующие вызовы методов <span class="inline-code" id="-1282102256#-9vp8ci_676">performStopActivity</span> и <span class="inline-code" id="-1282102256#-9vp8ci_677">handleRelaunchActivity</span> упираются в классы <span class="inline-code" id="-1282102256#-9vp8ci_678">ActivityRelaunchItem.execute()</span> и <span class="inline-code" id="-1282102256#-9vp8ci_679">StopActivityItem.execute()</span>. Метод <span class="inline-code" id="-1282102256#-9vp8ci_680">performStopActivity</span> вызывается из <span class="inline-code" id="-1282102256#-9vp8ci_681">StopActivityItem.execute()</span>, а <span class="inline-code" id="-1282102256#-9vp8ci_682">handleRelaunchActivity</span> &mdash; из <span class="inline-code" id="-1282102256#-9vp8ci_683">ActivityRelaunchItem.execute()</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_224"><pre><code class="language-java">public class StopActivityItem extends ActivityLifecycleItem {
    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        client.handleStopActivity(r, pendingActions,
                true /* finalStateRequest */, &quot;STOP_ACTIVITY_ITEM&quot;);
        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_225">В методе <span class="inline-code" id="-1282102256#-9vp8ci_684">StopActivityItem.execute</span> видим вызов <span class="inline-code" id="-1282102256#-9vp8ci_685">client.handleStopActivity</span>. Так как <span class="inline-code" id="-1282102256#-9vp8ci_686">client</span> &mdash; это <span class="inline-code" id="-1282102256#-9vp8ci_687">ClientTransactionHandler</span>, а <span class="inline-code" id="-1282102256#-9vp8ci_688">ActivityThread</span> наследуется от него, фактически здесь вызывается <span class="inline-code" id="-1282102256#-9vp8ci_689">ActivityThread.handleStopActivity</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_226"><pre><code class="language-java">public class ActivityRelaunchItem extends ActivityTransactionItem {
    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_227">В методе <span class="inline-code" id="-1282102256#-9vp8ci_690">ActivityRelaunchItem.execute</span> видим вызов <span class="inline-code" id="-1282102256#-9vp8ci_691">client.handleRelaunchActivity</span>. По той же логике, фактически вызывается <span class="inline-code" id="-1282102256#-9vp8ci_692">ActivityThread.handleRelaunchActivity</span>.</p><p id="-1282102256#-9vp8ci_228">На данный момент мы выследили следующую цепочку вызовов:</p><p id="-1282102256#-9vp8ci_229"><span class="inline-code" id="-1282102256#-9vp8ci_693">StopActivityItem.execute</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_694">ActivityThread.handleStopActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_695">ActivityThread.performStopActivityInner</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_696">ActivityThread.callActivityOnStop</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_697">ActivityThread.callActivityOnSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_698">Instrumentation.callActivityOnSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_699">Activity.performSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_700">Activity.onSaveInstanceState</span>.</p><p id="-1282102256#-9vp8ci_230">Это ключевая цепочка, которая обеспечивает сохранение состояния <span class="inline-code" id="-1282102256#-9vp8ci_701">Activity</span> при изменениях конфигурации или её завершении. Обратим внимание, что вызов <span class="inline-code" id="-1282102256#-9vp8ci_702">callActivityOnSaveInstanceState</span> из <span class="inline-code" id="-1282102256#-9vp8ci_703">Instrumentation</span> &mdash; это как раз та точка, где система передаёт управление обратно в <span class="inline-code" id="-1282102256#-9vp8ci_704">Activity</span>, вызывая метод <span class="inline-code" id="-1282102256#-9vp8ci_705">performSaveInstanceState</span>, который инициирует сохранение всех данных в объект <span class="inline-code" id="-1282102256#-9vp8ci_706">Bundle</span>.</p><p id="-1282102256#-9vp8ci_231">Параллельно, в случае изменения конфигурации или пересоздания активности, запускается другая цепочка:</p><p id="-1282102256#-9vp8ci_232"><span class="inline-code" id="-1282102256#-9vp8ci_707">ActivityRelaunchItem.execute</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_708">ActivityThread.handleRelaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_709">ActivityThread.handleRelaunchActivityInner</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_710">ActivityThread.callActivityOnStop</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_711">ActivityThread.callActivityOnSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_712">Instrumentation.callActivityOnSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_713">Activity.performSaveInstanceState</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_714">Activity.onSaveInstanceState</span>.</p><p id="-1282102256#-9vp8ci_233">Эти две цепочки работают независимо, но сходятся в методе <span class="inline-code" id="-1282102256#-9vp8ci_715">callActivityOnStop</span>, который гарантирует сохранение данных в <span class="inline-code" id="-1282102256#-9vp8ci_716">Bundle</span> перед тем, как <span class="inline-code" id="-1282102256#-9vp8ci_717">Activity</span> будет остановлена или пересоздана.</p><p id="-1282102256#-9vp8ci_234">Далее, сформированный объект <span class="inline-code" id="-1282102256#-9vp8ci_718">Bundle</span>, содержащий состояние <span class="inline-code" id="-1282102256#-9vp8ci_719">Activity</span>, сохраняется в объекте <span class="inline-code" id="-1282102256#-9vp8ci_720">ActivityClientRecord</span>. Этот объект представляет собой структуру данных, хранящую всю необходимую информацию о <span class="inline-code" id="-1282102256#-9vp8ci_721">Activity</span> во время её жизненного цикла. Именно в поле <span class="inline-code" id="-1282102256#-9vp8ci_722">state</span> этого класса система сохраняет переданный <span class="inline-code" id="-1282102256#-9vp8ci_723">Bundle</span>, чтобы при пересоздании активности восстановить её состояние. <span class="inline-code" id="-1282102256#-9vp8ci_724">ActivityClientRecord</span> существует в процессе всех вызовов цепочки, перед тем как <span class="inline-code" id="-1282102256#-9vp8ci_725">Activity</span> перейдёт в состояние STOP. Внутри метода <span class="inline-code" id="-1282102256#-9vp8ci_726">ActivityThread.callActivityOnSaveInstanceState</span> полю <span class="inline-code" id="-1282102256#-9vp8ci_727">ActivityClientRecord.state</span> присваивается новый <span class="inline-code" id="-1282102256#-9vp8ci_728">Bundle</span>, в который активити и фрагменты кладут всё нужное &mdash; от состояния иерархий <span class="inline-code" id="-1282102256#-9vp8ci_729">View</span> до любых данных, которые разработчик решил сохранить.</p><p id="-1282102256#-9vp8ci_235">Таким образом, мы видим, что эта цепочка запускается не из самой <span class="inline-code" id="-1282102256#-9vp8ci_730">Activity</span>, а из внутренней логики Android через <span class="inline-code" id="-1282102256#-9vp8ci_731">ActivityThread</span>. Это ещё раз подтверждает, что все жизненные циклы управляются системой через единый механизм клиент-серверных транзакций, а <span class="inline-code" id="-1282102256#-9vp8ci_732">ActivityThread</span> выполняет роль посредника, координирующего вызовы между <span class="inline-code" id="-1282102256#-9vp8ci_733">Activity</span> и системой.</p><p id="-1282102256#-9vp8ci_236">Важный момент здесь &mdash; откуда берётся <span class="inline-code" id="-1282102256#-9vp8ci_734">ActivityClientRecord</span> и как его внутренний <span class="inline-code" id="-1282102256#-9vp8ci_735">Bundle</span> переживает смерть процесса. В случае сохранения между PAUSE/STOP мы увидели, где создаётся чистый <span class="inline-code" id="-1282102256#-9vp8ci_736">Bundle</span>, в который можно сохранять данные. Здесь особых секретов нет. Но то, как этот сохранённый <span class="inline-code" id="-1282102256#-9vp8ci_737">Bundle</span> внутри <span class="inline-code" id="-1282102256#-9vp8ci_738">ActivityClientRecord</span> переживает смерть системы и затем возвращается в <span class="inline-code" id="-1282102256#-9vp8ci_739">Activity.onCreate</span>, мы ещё не знаем. Следующая глава раскроет этот момент.</p></section><section class="detached"><h2 id="-1282102256#oncreate" data-toc="oncreate#saved-state-handle-under-the-hood.md-oncreate">Цепочка вызова onCreate</h2><p id="-1282102256#-9vp8ci_740">Начнем наше движение с самого низа &mdash; с метода <span class="inline-code" id="-1282102256#-9vp8ci_751">onCreate</span>. Как видно из кода, его вызов происходит внутри метода <span class="inline-code" id="-1282102256#-9vp8ci_752">performCreate</span>, который, в свою очередь, вызывается из метода <span class="inline-code" id="-1282102256#-9vp8ci_753">callActivityOnCreate</span> класса <span class="inline-code" id="-1282102256#-9vp8ci_754">Instrumentation</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_741"><pre><code class="language-java">public class Activity extends ContextThemeWrapper ...{

public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) {
    onCreate(savedInstanceState);
}

@MainThread
@CallSuper
protected void onCreate(@Nullable Bundle savedInstanceState) {
            ...
}

final void performCreate(Bundle icicle) {
    performCreate(icicle, null);
}

@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
final void performCreate(Bundle icicle, PersistableBundle persistentState) {
            ...
    if (persistentState != null) {
        onCreate(icicle, persistentState);
    } else {
        onCreate(icicle);
    }
            ...
}
}</code></pre></div><p id="-1282102256#-9vp8ci_742">Метод <span class="inline-code" id="-1282102256#-9vp8ci_755">performCreate</span> является связующим звеном между логикой вызова <span class="inline-code" id="-1282102256#-9vp8ci_756">onCreate</span> и более низкоуровневыми компонентами системы. Сам же вызов <span class="inline-code" id="-1282102256#-9vp8ci_757">performCreate</span> осуществляется в классе <span class="inline-code" id="-1282102256#-9vp8ci_758">Instrumentation</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_743"><pre><code class="language-java">public class Instrumentation {
    ...

    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        ...
        activity.performCreate(icicle);
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_744">Класс <span class="inline-code" id="-1282102256#-9vp8ci_759">Instrumentation</span> управляет жизненным циклом <span class="inline-code" id="-1282102256#-9vp8ci_760">Activity</span> и вызывает <span class="inline-code" id="-1282102256#-9vp8ci_761">performCreate</span>, передавая ему объект <span class="inline-code" id="-1282102256#-9vp8ci_762">Bundle</span> для восстановления состояния. Теперь поднимемся выше. Кто же вызывает <span class="inline-code" id="-1282102256#-9vp8ci_763">callActivityOnCreate</span>? За это отвечает метод <span class="inline-code" id="-1282102256#-9vp8ci_764">performLaunchActivity</span> в классе <span class="inline-code" id="-1282102256#-9vp8ci_765">ActivityThread</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_745"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ...
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
        } else {
            mInstrumentation.callActivityOnCreate(activity, r.state);
        }
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_746">Здесь мы видим, что в зависимости от состояния активности (сохранено ли оно в <span class="inline-code" id="-1282102256#-9vp8ci_766">PersistentState</span>), <span class="inline-code" id="-1282102256#-9vp8ci_767">callActivityOnCreate</span> вызывается с разным количеством параметров, но всегда через <span class="inline-code" id="-1282102256#-9vp8ci_768">Instrumentation</span>.</p><p id="-1282102256#-9vp8ci_747">Далее, этот метод <span class="inline-code" id="-1282102256#-9vp8ci_769">performLaunchActivity</span> вызывается из метода <span class="inline-code" id="-1282102256#-9vp8ci_770">handleLaunchActivity</span> того же класса:</p><div class="detached code-block" id="-1282102256#-9vp8ci_748"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    @Override
    public Activity handleLaunchActivity(ActivityClientRecord r, ...) {
    ...
        final Activity a = performLaunchActivity(r, customIntent);
    ...
    }
}</code></pre></div><section class="detached"><h3 id="-1282102256#activity_1" data-toc="activity_1#saved-state-handle-under-the-hood.md-activity_1">Перезапуск Activity при релаунче (например, при повороте экрана)</h3><p id="-1282102256#-9vp8ci_771">При пересоздании Activity, например, при повороте экрана, срабатывает метод <span class="inline-code" id="-1282102256#-9vp8ci_777">handleRelaunchActivity</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_772"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    @Override
    public void handleRelaunchActivity(@NonNull ActivityClientRecord tmp,
                                       @NonNull PendingTransactionActions pendingActions) {
        ...
        handleRelaunchActivityInner(r, tmp.pendingResults, tmp.pendingIntents,
                pendingActions, tmp.startsNotResumed, tmp.overrideConfig, tmp.mActivityWindowInfo,
                &quot;handleRelaunchActivity&quot;);
    }

    private void handleRelaunchActivityInner(@NonNull ActivityClientRecord r,...) {
    ....
        handleLaunchActivity(r, pendingActions, mLastReportedDeviceId, customIntent);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_773">Вызов метода handleRelaunchActivity иницирует класс команда/транзакция <span class="inline-code" id="-1282102256#-9vp8ci_778">ActivityRelaunchItem</span>, которая действует как маркер для того, чтобы выполнить перезапуск с сохранением состояния:</p><div class="detached code-block" id="-1282102256#-9vp8ci_774"><pre><code class="language-java">public class ActivityRelaunchItem extends ActivityTransactionItem {

    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_775">Эта команда инициирует следующую цепочку вызовов:</p><p id="-1282102256#-9vp8ci_776"><span class="inline-code" id="-1282102256#-9vp8ci_779">ActivityRelaunchItem.execute</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_780">handleRelaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_781">handleRelaunchActivityInner</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_782">handleLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_783">performLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_784">callActivityOnCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_785">performCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_786">onCreate</span>.</p></section><section class="detached"><h3 id="-1282102256#activity" data-toc="activity#saved-state-handle-under-the-hood.md-activity">Создание Activity после уничтожения процесса или при первом запуске</h3><p id="-1282102256#-9vp8ci_787">В случае, если процесс был уничтожен или это первый запуск <span class="inline-code" id="-1282102256#-9vp8ci_852">Activity</span>, используется другая команда &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_853">LaunchActivityItem</span>. Она запускает аналогичную, но отдельную цепочку вызовов:</p><div class="detached code-block" id="-1282102256#-9vp8ci_788"><pre><code class="language-java">public class LaunchActivityItem extends ClientTransactionItem {

    @Nullable
    private final Bundle mState;

    @Nullable
    private final PersistableBundle mPersistentState;

    public LaunchActivityItem(
            // остальные параметры
            @Nullable Bundle state,
            @Nullable PersistableBundle persistentState,
            // остальные параметры
    ) {
        this(
                // передаваемые аргументы до
                state != null ? new Bundle(state) : null,
                persistentState != null ? new PersistableBundle(persistentState) : null,
                // оставшиеся аргументы
        );
    ...
    }


    @Override
    public void execute(@NonNull ClientTransactionHandler client,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        ActivityClientRecord r = new ActivityClientRecord(...,mState, mPersistentState, ...);
        client.handleLaunchActivity(r, pendingActions, mDeviceId, null /* customIntent */);
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_789">Цепочка выглядит так: <span class="inline-code" id="-1282102256#-9vp8ci_854">LaunchActivityItem.execute</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_855">ActivityThread.handleLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_856">ActivityThread.performLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_857">ActivityThread.callActivityOnCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_858">ActivityperformCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_859">ActivityonCreate</span>.</p><p id="-1282102256#-9vp8ci_790">Следует запомнить важную вещь, прежде чем подниматься выше, нужно понимать что <span class="inline-code" id="-1282102256#-9vp8ci_860">LaunchActivityItem</span> &mdash; это транзакция, которая в своём конструкторе принимает<span class="inline-code" id="-1282102256#-9vp8ci_861">Bundle</span> и <span class="inline-code" id="-1282102256#-9vp8ci_862">PersistableBundle</span> (последний мы рассматривать не будем). Класс <span class="inline-code" id="-1282102256#-9vp8ci_863">LaunchActivityItem</span> наследуется от <span class="inline-code" id="-1282102256#-9vp8ci_864">ClientTransactionItem</span>.</p><p id="-1282102256#-9vp8ci_791"><span class="inline-code" id="-1282102256#-9vp8ci_865">ClientTransactionItem</span> &mdash; это абстрактный базовый класс, от которого наследуются все транзакции, связанные с жизненным циклом <span class="inline-code" id="-1282102256#-9vp8ci_866">Activity</span>. В него входят <span class="inline-code" id="-1282102256#-9vp8ci_867">LaunchActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_868">ActivityRelaunchItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_869">ResumeActivityItem</span> (последние &mdash; <span class="control" id="-1282102256#-9vp8ci_870">не прямые</span>, а транзитивные наследники) и другие элементы, участвующие в управлении состоянием <span class="inline-code" id="-1282102256#-9vp8ci_871">Activity</span>.</p><p id="-1282102256#-9vp8ci_792">Мы увидели что создание ActivityClientRecord происходит в <span class="inline-code" id="-1282102256#-9vp8ci_872">LaunchActivityItem.execute</span>, но она использует готовые данные которые бьли переданы ей в конструктор при созданий.</p><p id="-1282102256#-9vp8ci_793">Наша цель дальше &mdash; выяснить два момента:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_794" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_873"><p id="-1282102256#-9vp8ci_875"><span class="control" id="-1282102256#-9vp8ci_876">Кто создаёт <span class="inline-code" id="-1282102256#-9vp8ci_877">LaunchActivityItem</span> и передаёт в него <span class="inline-code" id="-1282102256#-9vp8ci_878">Bundle</span></span>, который как раз и переживает смерть или остановку процесса.</p></li><li class="list-item" id="-1282102256#-9vp8ci_874"><p id="-1282102256#-9vp8ci_879"><span class="control" id="-1282102256#-9vp8ci_880">Кто вызывает метод <span class="inline-code" id="-1282102256#-9vp8ci_887">execute</span> у <span class="inline-code" id="-1282102256#-9vp8ci_888">LaunchActivityItem</span></span> и запускает описанную выше цепочку вызовов : <span class="inline-code" id="-1282102256#-9vp8ci_881">LaunchActivityItem.execute</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_882">handleLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_883">performLaunchActivity</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_884">callActivityOnCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_885">performCreate</span> &rarr; <span class="inline-code" id="-1282102256#-9vp8ci_886">onCreate</span>.</p></li></ol><p id="-1282102256#-9vp8ci_795">И так идем дальше, выше вызова <span class="inline-code" id="-1282102256#-9vp8ci_889">LaunchActivityItem.execute</span>, стоит класс <span class="inline-code" id="-1282102256#-9vp8ci_890">TransactionExecutor</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_796"><pre><code class="language-java">public class TransactionExecutor {

    private final ClientTransactionHandler mTransactionHandler;

    public TransactionExecutor(@NonNull ClientTransactionHandler clientTransactionHandler) {
        mTransactionHandler = clientTransactionHandler;
    }

    public void execute(@NonNull ClientTransaction transaction) {
        ...
        executeTransactionItems(transaction);
        ...
    }

    public void executeTransactionItems(@NonNull ClientTransaction transaction) {
        final List&lt;ClientTransactionItem&gt; items = transaction.getTransactionItems();
        final int size = items.size();
        for (int i = 0; i &lt; size; i++) {
            final ClientTransactionItem item = items.get(i);
            if (item.isActivityLifecycleItem()) {
                executeLifecycleItem(transaction, (ActivityLifecycleItem) item);
            } else {
                executeNonLifecycleItem(transaction, item,
                        shouldExcludeLastLifecycleState(items, i));
            }
        }
    }

    private void executeLifecycleItem(@NonNull ClientTransaction transaction,
                                      @NonNull ActivityLifecycleItem lifecycleItem) {
        ...
        lifecycleItem.execute(mTransactionHandler, mPendingActions);
                ...
    }

    private void executeNonLifecycleItem(@NonNull ClientTransaction transaction,
                                         @NonNull ClientTransactionItem item, boolean shouldExcludeLastLifecycleState) {
        ...
        item.execute(mTransactionHandler, mPendingActions);
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_797"><span class="inline-code" id="-1282102256#-9vp8ci_891">TransactionExecutor</span> - это как раз класс который работает со всеми транзакциями, то есть с ClientTransactionItem, и ClientTransaction - который является массивом или очередью которая хранит ClientTransactionItem-ы,</p><p id="-1282102256#-9vp8ci_798">Конструктор <span class="inline-code" id="-1282102256#-9vp8ci_892">TransactionExecutor</span> принимает на вход <span class="inline-code" id="-1282102256#-9vp8ci_893">ClientTransactionHandler</span>, если вы не забыли, то ActivityThread реализует абстрактный класс <span class="inline-code" id="-1282102256#-9vp8ci_894">ClientTransactionHandler</span>, по этому фактический в конструктор <span class="inline-code" id="-1282102256#-9vp8ci_895">TransactionExecutor</span> прилетает ActivityThread.</p><p id="-1282102256#-9vp8ci_799">У <span class="inline-code" id="-1282102256#-9vp8ci_896">TransactionExecutor</span> есть метод <span class="inline-code" id="-1282102256#-9vp8ci_897">execute</span> который вызывает другой метод <span class="inline-code" id="-1282102256#-9vp8ci_898">executeTransactionItems</span>, <span class="inline-code" id="-1282102256#-9vp8ci_899">executeTransactionItems</span> - в свою очередь пробегается по всем элемента внутри очереди транзакций, то есть в <span class="inline-code" id="-1282102256#-9vp8ci_900">ClientTransaction</span>, и в итоге определяет какой метод вызывать, <span class="inline-code" id="-1282102256#-9vp8ci_901">executeNonLifecycleItem</span> или <span class="inline-code" id="-1282102256#-9vp8ci_902">executeLifecycleItem</span>.</p><p id="-1282102256#-9vp8ci_800">Различие этих методов в том, что <span class="inline-code" id="-1282102256#-9vp8ci_903">executeLifecycleItem</span> вызывается для транзакций, представляющих этапы жизненного цикла активности &mdash; такие как <span class="inline-code" id="-1282102256#-9vp8ci_904">ResumeActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_905">PauseActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_906">StopActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_907">DestroyActivityItem</span>. Эти элементы отвечают за переходы между состояниями уже существующей <span class="inline-code" id="-1282102256#-9vp8ci_908">Activity</span>. Их назначение &mdash; вызвать соответствующие колбэки (<span class="inline-code" id="-1282102256#-9vp8ci_909">onPause</span>, <span class="inline-code" id="-1282102256#-9vp8ci_910">onStop</span>, и так далее) на объекте активности, который уже был создан и существует в памяти.</p><p id="-1282102256#-9vp8ci_801">С другой стороны, <span class="inline-code" id="-1282102256#-9vp8ci_911">executeNonLifecycleItem</span> используется для выполнения транзакций, которые <span class="control" id="-1282102256#-9vp8ci_912">не</span> относятся к жизненному циклу. Главный представитель &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_913">LaunchActivityItem</span>, который отвечает за создание <span class="inline-code" id="-1282102256#-9vp8ci_914">Activity</span> с нуля. Это может происходить либо при первом запуске <span class="inline-code" id="-1282102256#-9vp8ci_915">Activity</span>, либо после того, как система уничтожила процесс, и теперь восстанавливает его. Внутри <span class="inline-code" id="-1282102256#-9vp8ci_916">executeNonLifecycleItem</span> вызывается <span class="inline-code" id="-1282102256#-9vp8ci_917">item.execute(...)</span>, который, в случае <span class="inline-code" id="-1282102256#-9vp8ci_918">LaunchActivityItem</span>, инициирует полную цепочку создания: от <span class="inline-code" id="-1282102256#-9vp8ci_919">ActivityClientRecord</span> до вызова <span class="inline-code" id="-1282102256#-9vp8ci_920">onCreate</span>.</p><p id="-1282102256#-9vp8ci_802">Внутри <span class="inline-code" id="-1282102256#-9vp8ci_921">LaunchActivityItem</span>, в методе <span class="inline-code" id="-1282102256#-9vp8ci_922">executeNonLifecycleItem</span>, мы видим, что у <span class="inline-code" id="-1282102256#-9vp8ci_923">item</span> (экземпляр <span class="inline-code" id="-1282102256#-9vp8ci_924">ClientTransactionItem</span>) вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_925">execute</span>, которому передаются <span class="inline-code" id="-1282102256#-9vp8ci_926">ClientTransactionHandler</span> и <span class="inline-code" id="-1282102256#-9vp8ci_927">PendingTransactionActions</span>. Фактически в этот момент вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_928">execute</span> у <span class="inline-code" id="-1282102256#-9vp8ci_929">LaunchActivityItem</span>. Не забываем, что <span class="inline-code" id="-1282102256#-9vp8ci_930">LaunchActivityItem</span> наследуется от <span class="inline-code" id="-1282102256#-9vp8ci_931">ClientTransactionItem</span>.</p><p id="-1282102256#-9vp8ci_803">Теперь разберёмся, кто вызывает метод <span class="inline-code" id="-1282102256#-9vp8ci_932">execute</span> у <span class="inline-code" id="-1282102256#-9vp8ci_933">TransactionExecutor</span>. Это делает внутренний класс <span class="inline-code" id="-1282102256#-9vp8ci_934">H</span>, являющийся <span class="inline-code" id="-1282102256#-9vp8ci_935">Handler</span>-ом:</p><div class="detached code-block" id="-1282102256#-9vp8ci_804"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    final H mH = new H();
    private final TransactionExecutor mTransactionExecutor = new TransactionExecutor(this);

    class H extends Handler {

        public void handleMessage(Message msg) {
            switch (msg.what) {
                ...
                case EXECUTE_TRANSACTION:
                    final ClientTransaction transaction = (ClientTransaction) msg.obj;
                    final ClientTransactionListenerController controller = ClientTransactionListenerController.getInstance();
                    controller.onClientTransactionStarted();
                    try {
                        mTransactionExecutor.execute(transaction);
                    } finally {
                        controller.onClientTransactionFinished();
                    }
                    ...
                ...
            }
        }
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_805">Напомним, что <span class="inline-code" id="-1282102256#-9vp8ci_936">ClientTransactionHandler</span> &mdash; это абстрактный класс, от которого наследуется <span class="inline-code" id="-1282102256#-9vp8ci_937">ActivityThread</span>. Далее мы видим, что создаётся объект <span class="inline-code" id="-1282102256#-9vp8ci_938">H</span>, а также <span class="inline-code" id="-1282102256#-9vp8ci_939">TransactionExecutor</span>, которому в качестве аргумента передаётся <span class="inline-code" id="-1282102256#-9vp8ci_940">this</span>, то есть <span class="inline-code" id="-1282102256#-9vp8ci_941">ActivityThread</span>, реализующий <span class="inline-code" id="-1282102256#-9vp8ci_942">ClientTransactionHandler</span>.</p><p id="-1282102256#-9vp8ci_806">Теперь обратим внимание на реализацию <span class="inline-code" id="-1282102256#-9vp8ci_943">handleMessage</span> внутри класса <span class="inline-code" id="-1282102256#-9vp8ci_944">H</span>: когда приходит сообщение с типом <span class="inline-code" id="-1282102256#-9vp8ci_945">EXECUTE_TRANSACTION</span>, из объекта <span class="inline-code" id="-1282102256#-9vp8ci_946">Message</span> извлекается <span class="inline-code" id="-1282102256#-9vp8ci_947">ClientTransaction</span>, содержащий в себе список (<span class="inline-code" id="-1282102256#-9vp8ci_948">List</span>) транзакций. Затем вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_949">execute</span> у <span class="inline-code" id="-1282102256#-9vp8ci_950">TransactionExecutor</span>, что и запускает выполнение транзакции.</p><p id="-1282102256#-9vp8ci_807">Сам метод handleMessage у класса H вызывает методы из самого класса ActivityThread:</p><div class="detached code-block" id="-1282102256#-9vp8ci_808"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    final H mH = new H();

    void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1) {
        sendMessage(what, obj, arg1, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2) {
        sendMessage(what, obj, arg1, arg2, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        ...
        mH.sendMessage(msg);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_809">Видим что последний метод sendMessage и вызывает у класса H метод sendMessage, так как класс H наследуетсч от класса Handler, то у него есть метод sendMessage и вызывает метод handleMessage, надо понять кто вызывает sendMessage у ActivityThread,</p><div class="detached code-block" id="-1282102256#-9vp8ci_810"><pre><code class="language-java">public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private class ApplicationThread extends IApplicationThread.Stub {

        @Override
        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
            ActivityThread.this.scheduleTransaction(transaction);
        }
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_811">Этим занимается ApplicationThread, каким образом вызов метода ActivityThread.scheduleTransaction вызывает ActivityThread.sendMessage?</p><p id="-1282102256#-9vp8ci_812">Дело в том что ActivityThread наследуется от ClientTransactionHandler, а ClientTransactionHandler выглядит следующим образом:</p><div class="detached code-block" id="-1282102256#-9vp8ci_813"><pre><code class="language-java">public abstract class ClientTransactionHandler {

    void scheduleTransaction(ClientTransaction transaction) {
        transaction.preExecute(this);
        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
    }

    abstract void sendMessage(int what, Object obj);

}</code></pre></div><p id="-1282102256#-9vp8ci_814">Получается у ApplicationThread вызывается метод scheduleTransaction, он вызывает у ActivityThread метод scheduleTransaction который он унаследовал от ClientTransactionHandler, внутри метода scheduleTransaction у ClientTransactionHandler мы видим что он вызывает метод sendMessage с двумя параметрами, ActivityThread как раз переопредляет этот метод, и далее вызов идет в H.sendMessage.</p><p id="-1282102256#-9vp8ci_815">ApplicationThread - это Proxy который реализует AIDL интерфейс, этот класс отвечает за многие планирования, например сервисы, receiver или binding Application. Так же заметьте что он реализует IApplicationThread.Stub, то есть фактический сам AIDL интерфейс IApplicationThread</p><p id="-1282102256#-9vp8ci_816">Дальше поймем откуда происходит вызов метода ApplicationThread.scheduleTransaction, и вуаля, этим занимается класс:</p><div class="detached code-block" id="-1282102256#-9vp8ci_817"><pre><code class="language-java">public class ClientTransaction implements Parcelable, ObjectPoolItem {

    private IApplicationThread mClient;

    public void schedule() throws RemoteException {
        mClient.scheduleTransaction(this);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_818">Он вызывает у ApplicationThread.scheduleTransaction передавая себя, тем самым запланируя себя и свои внутренние транзакций на выполнение, IApplicationThread это и есть класс ActivityThread.ApplicationThread, далее отследим вызов метода ClientTransaction.schedule(), встречайте еще один класс,</p><div class="detached code-block" id="-1282102256#-9vp8ci_819"><pre><code class="language-java">class ClientLifecycleManager {

    void scheduleTransactionItems(@NonNull IApplicationThread client,
                                  boolean shouldDispatchImmediately,
                                  @NonNull ClientTransactionItem... items) throws RemoteException {
        ...
        final ClientTransaction clientTransaction = getOrCreatePendingTransaction(client);

        final int size = items.length;
        for (int i = 0; i &lt; size; i++) {
            clientTransaction.addTransactionItem(items[i]);
        }

        onClientTransactionItemScheduled(clientTransaction, shouldDispatchImmediately);
    }

    private void onClientTransactionItemScheduled(
            @NonNull ClientTransaction clientTransaction,
            boolean shouldDispatchImmediately) throws RemoteException {
        ...
        scheduleTransaction(clientTransaction);
    }


    void scheduleTransaction(@NonNull ClientTransaction transaction) throws RemoteException {
        ...
        transaction.schedule();
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_820">Внутри него определён метод <span class="inline-code" id="-1282102256#-9vp8ci_951">scheduleTransactionItems</span>, который принимает <span class="inline-code" id="-1282102256#-9vp8ci_952">IApplicationThread</span> и массив <span class="inline-code" id="-1282102256#-9vp8ci_953">ClientTransactionItem</span>. Этот метод создаёт или достаёт транзакцию через <span class="inline-code" id="-1282102256#-9vp8ci_954">getOrCreatePendingTransaction</span>, добавляет в неё все <span class="inline-code" id="-1282102256#-9vp8ci_955">ClientTransactionItem</span> (например, <span class="inline-code" id="-1282102256#-9vp8ci_956">LaunchActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_957">ResumeActivityItem</span>, <span class="inline-code" id="-1282102256#-9vp8ci_958">PauseActivityItem</span> и т.д.), после чего передаёт её в метод <span class="inline-code" id="-1282102256#-9vp8ci_959">onClientTransactionItemScheduled</span>, где вызывается<span class="inline-code" id="-1282102256#-9vp8ci_960">scheduleTransaction</span>.</p><p id="-1282102256#-9vp8ci_821">После чего управление переходит в метод <span class="inline-code" id="-1282102256#-9vp8ci_961">scheduleTransaction</span>, внутри которого вызывается <span class="inline-code" id="-1282102256#-9vp8ci_962">transaction.schedule()</span>. А как мы уже знаем, метод <span class="inline-code" id="-1282102256#-9vp8ci_963">schedule</span> вызывает <span class="inline-code" id="-1282102256#-9vp8ci_964">ApplicationThread.scheduleTransaction</span>, то есть фактически мы возвращаемся обратно к AIDL-вызову, из которого всё и начинается.</p><p id="-1282102256#-9vp8ci_822">Таким образом, <span class="inline-code" id="-1282102256#-9vp8ci_965">ClientLifecycleManager</span> собирает транзакцию, наполняет её нужными <span class="inline-code" id="-1282102256#-9vp8ci_966">ClientTransactionItem</span>, и отправляет её в исполнение. Это класс, который формирует цепочку действий, и делегирует выполнение низкоуровневому слою через AIDL.</p><p id="-1282102256#-9vp8ci_823"><span class="inline-code" id="-1282102256#-9vp8ci_967">ClientLifecycleManager.scheduleTransactionItems</span> - вызовом метода занимается очень важный класс <span class="inline-code" id="-1282102256#-9vp8ci_968">ActivityTaskSupervisor</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_824"><pre><code class="language-java">public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;
    ...

    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
                                    boolean andResume, boolean checkConfig) throws RemoteException {


        // Create activity launch transaction.
        final LaunchActivityItem launchActivityItem = new LaunchActivityItem(r.token,
                ...,r.getSavedState(), r.getPersistentSavedState(), ...,
       );
        ...
        mService.getLifecycleManager().scheduleTransactionItems(
                proc.getThread(),
                // Immediately dispatch the transaction, so that if it fails, the server can
                // restart the process and retry now.
                true /* shouldDispatchImmediately */,
                launchActivityItem, lifecycleItem);
        ...
        return true;
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_825">Видим очень ключевые моменты:</p><ol class="list list-decimal" id="-1282102256#-9vp8ci_826" type="1" start="1"><li class="list-item" id="-1282102256#-9vp8ci_969"><p id="-1282102256#-9vp8ci_972">В методе realStartActivityLocked на вход передается объект класса ActivityRecord, который в себе хранит значения - r.getSavedState()(Bundle) и r.getPersistentSavedState(PersistentBundle) и прочие важные значения и информацию об активити</p></li><li class="list-item" id="-1282102256#-9vp8ci_970"><p id="-1282102256#-9vp8ci_973">Наконецто видим создание транзакций <span class="inline-code" id="-1282102256#-9vp8ci_974">LaunchActivityItem</span> c передачей всех нужных аргументов, в числе и Bundle</p></li><li class="list-item" id="-1282102256#-9vp8ci_971"><p id="-1282102256#-9vp8ci_975">Видим что у класса ActivityTaskManagerService вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_976">getLifecycleManager()</span> который возвращает объект класса <span class="inline-code" id="-1282102256#-9vp8ci_977">ClientLifecycleManager</span> и вызывает у него метод scheduleTransactionItems который мы уже видели, с передачей <span class="inline-code" id="-1282102256#-9vp8ci_978">LaunchActivityItem</span></p></li></ol><p id="-1282102256#-9vp8ci_827">Давай убедимся что метод getLifecycleManager у ActivityTaskManagerService действительно вовзращает ClientLifecycleManager:</p><div class="detached code-block" id="-1282102256#-9vp8ci_828"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    ClientLifecycleManager getLifecycleManager() {
        return mLifecycleManager;
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_829">Убедились, прекрасно, идем дальше, отследим вызов метода <span class="inline-code" id="-1282102256#-9vp8ci_979">realStartActivityLocked</span> класса <span class="inline-code" id="-1282102256#-9vp8ci_980">ActivityTaskSupervisor</span></p><div class="detached code-block" id="-1282102256#-9vp8ci_830"><pre><code class="language-java">class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt; implements DisplayManager.DisplayListener {

    ActivityTaskSupervisor mTaskSupervisor;
    ActivityTaskManagerService mService;

    boolean attachApplication(WindowProcessController app) throws RemoteException {
        final ArrayList&lt;ActivityRecord&gt; activities = mService.mStartingProcessActivities;
        for (int i = activities.size() - 1; i &gt;= 0; i--) {
            final ActivityRecord r = activities.get(i);
            ...
            if (mTaskSupervisor.realStartActivityLocked(r, app, canResume,
                    true /* checkConfig */)) {
                hasActivityStarted = true;
            }
            ...
            return hasActivityStarted;
        }
    }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p">
    <div class="prompt-title">RootWindowContainer...</div>
<p id="-1282102256#-9vp8ci_981"><span class="inline-code" id="-1282102256#-9vp8ci_984">RootWindowContainer</span> &mdash; это центральный компонент в системе управления окнами Android, который содержит в себе всю иерархию окон на всех дисплеях. Он управляет экземплярами <span class="inline-code" id="-1282102256#-9vp8ci_985">DisplayContent</span>, координирует layout, input, фокус, анимации, транзишены, split-screen, <span class="inline-code" id="-1282102256#-9vp8ci_986">picture-in-picture</span> и любые изменения, связанные с конфигурацией экрана. Всё, что должно появиться, исчезнуть, пересчитаться или анимироваться &mdash; сначала проходит через него. Это точка входа для всех транзакций окон, включая запуск и завершение активностей.</p><p id="-1282102256#-9vp8ci_982">Он настолько крут, что может остановить перезапуск activity, если чувствует, что layout всё ещё &quot;в пути&quot;. Ему не нужно подтверждение от <span class="inline-code" id="-1282102256#-9vp8ci_987">WindowManagerService</span> для показа Window и работы с контентом.</p><p id="-1282102256#-9vp8ci_983"><span class="inline-code" id="-1282102256#-9vp8ci_988">RootWindowContainer</span> раньше назывался <span class="inline-code" id="-1282102256#-9vp8ci_989">RootActivityContainer</span></p>  </div>
</blockquote>
<p id="-1282102256#-9vp8ci_832">Видим вызов метода <span class="inline-code" id="-1282102256#-9vp8ci_990">ActivityTaskSupervisor.realStartActivityLocked</span> происходит в классе RootWindowContainer, который в методе <span class="inline-code" id="-1282102256#-9vp8ci_991">attachApplication</span>, получает список ActivityRecord у ActivityTaskManagerService, и в цикле для всех вызывает метод <span class="inline-code" id="-1282102256#-9vp8ci_992">ActivityTaskSupervisor.realStartActivityLocked</span>.</p><p id="-1282102256#-9vp8ci_833">Далее мы снова возвращаемся к <span class="inline-code" id="-1282102256#-9vp8ci_993">ActivityTaskManagerService</span>, потому что именно он вызывает метод attachApplication у RootWindowContainer и передает ему</p><div class="detached code-block" id="-1282102256#-9vp8ci_834"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
   ...

    /** The starting activities which are waiting for their processes to attach. */
    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    @HotPath(caller = HotPath.PROCESS_CHANGE)
    @Override
    public boolean attachApplication(WindowProcessController wpc) throws RemoteException {
        ...
        return mRootWindowContainer.attachApplication(wpc);
    }

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
         ...
        mStartingProcessActivities.add(activity);
         ...
    }


    ClientLifecycleManager getLifecycleManager() {
        return mLifecycleManager;
    }
   ...
}</code></pre></div><p id="-1282102256#-9vp8ci_835">Видим, что он хранит в себе список <span class="inline-code" id="-1282102256#-9vp8ci_994">ActivityRecord</span> в поле <span class="inline-code" id="-1282102256#-9vp8ci_995">mStartingProcessActivities</span> &mdash; вызов которого мы уже видели в <span class="inline-code" id="-1282102256#-9vp8ci_996">RootWindowContainer.attachApplication</span>.</p><p id="-1282102256#-9vp8ci_836">Далее видим, что у него также есть ссылка на <span class="inline-code" id="-1282102256#-9vp8ci_997">RootWindowContainer</span>, и в методе <span class="inline-code" id="-1282102256#-9vp8ci_998">ActivityTaskManagerService.attachApplication</span> происходит вызов метода <span class="inline-code" id="-1282102256#-9vp8ci_999">RootWindowContainer.attachApplication</span>. <span class="inline-code" id="-1282102256#-9vp8ci_1000">startProcessAsync</span> &mdash; также очень важный метод, который добавляет новые <span class="inline-code" id="-1282102256#-9vp8ci_1001">ActivityRecord</span> в список <span class="inline-code" id="-1282102256#-9vp8ci_1002">mStartingProcessActivities</span>, внутри которых хранится <span class="inline-code" id="-1282102256#-9vp8ci_1003">Bundle</span> (его мы разберём позже).</p><p id="-1282102256#-9vp8ci_837">Выше <span class="inline-code" id="-1282102256#-9vp8ci_1004">ActivityTaskManagerService</span> находится класс <span class="inline-code" id="-1282102256#-9vp8ci_1005">ActivityManagerService</span>, он и вызывает <span class="inline-code" id="-1282102256#-9vp8ci_1006">attachApplication</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1007">ActivityTaskManagerService</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_838"><pre><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub {

    public ActivityTaskManagerInternal mAtmInternal;
    final PidMap mPidsSelfLocked = new PidMap();

    @GuardedBy(&quot;this&quot;)
    private void attachApplicationLocked(@NonNull IApplicationThread thread,
                                         int pid, int callingUid, long startSeq) {
        ...
        finishAttachApplicationInner(startSeq, callingUid, pid);
        ...
    }

    private void finishAttachApplicationInner(long startSeq, int uid, int pid) {
        ...
        final ProcessRecord app;
        app = mPidsSelfLocked.get(pid);
        ...

        didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_839">Видим в методе <span class="inline-code" id="-1282102256#-9vp8ci_1008">finishAttachApplicationInner</span> вызов метода <span class="inline-code" id="-1282102256#-9vp8ci_1009">attachApplication</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1010">mAtmInternal</span>, <span class="inline-code" id="-1282102256#-9vp8ci_1011">ActivityTaskManagerInternal</span>, который является абстрактным AIDL-интерфейсом для <span class="inline-code" id="-1282102256#-9vp8ci_1012">ActivityTaskManagerService</span>, поэтому фактически здесь вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1013">ActivityTaskManagerService.attachApplication()</span>.</p><p id="-1282102256#-9vp8ci_840">Сам метод <span class="inline-code" id="-1282102256#-9vp8ci_1014">finishAttachApplicationInner</span> вызывается из <span class="inline-code" id="-1282102256#-9vp8ci_1015">attachApplicationLocked</span>, где процесс извлекается из <span class="inline-code" id="-1282102256#-9vp8ci_1016">mPidsSelfLocked</span> по ключу <span class="inline-code" id="-1282102256#-9vp8ci_1017">pid</span> (то есть process id).</p><p id="-1282102256#-9vp8ci_841">Сам <span class="inline-code" id="-1282102256#-9vp8ci_1018">ActivityManagerService</span> является синглтоном в рамках всей системы Android, у него внутри есть структура <span class="inline-code" id="-1282102256#-9vp8ci_1019">PidMap</span>, которая хранит объекты <span class="inline-code" id="-1282102256#-9vp8ci_1020">ProcessRecord</span> по ключу <span class="inline-code" id="-1282102256#-9vp8ci_1021">pid</span>. То есть вызов <span class="inline-code" id="-1282102256#-9vp8ci_1022">mPidsSelfLocked.get(pid)</span> обращается к <span class="inline-code" id="-1282102256#-9vp8ci_1023">PidMap</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_842"><pre><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub {

    final PidMap mPidsSelfLocked = new PidMap();

    ...

    static final class PidMap {
        private final SparseArray&lt;ProcessRecord&gt; mPidMap = new SparseArray&lt;&gt;();

        ProcessRecord get(int pid) {
            return mPidMap.get(pid);
        }
        ...

        void doAddInternal(int pid, ProcessRecord app) {
            mPidMap.put(pid, app);
        }
       ...
    }

    public void setSystemProcess() {
      ...
        ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName,
                false,
                0,
                false,
                0,
                null,
                new HostingRecord(HostingRecord.HOSTING_TYPE_SYSTEM));
            ...
        addPidLocked(app);
            ...
    }

    void addPidLocked(ProcessRecord app) {
        final int pid = app.getPid();
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.doAddInternal(pid, app);
        }
      ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_843">Видим структуру <span class="inline-code" id="-1282102256#-9vp8ci_1024">PidMap</span>, которая внутри себя хранит список записей процессов приложения.</p><p id="-1282102256#-9vp8ci_844">Также видим методы <span class="inline-code" id="-1282102256#-9vp8ci_1025">setSystemProcess</span> и <span class="inline-code" id="-1282102256#-9vp8ci_1026">addPidLocked</span>. В <span class="inline-code" id="-1282102256#-9vp8ci_1027">setSystemProcess</span> создаётся новый <span class="inline-code" id="-1282102256#-9vp8ci_1028">ProcessRecord</span> и вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_1029">addPidLocked</span>, который кладёт его в <span class="inline-code" id="-1282102256#-9vp8ci_1030">mPidsSelfLocked</span>. Метод <span class="inline-code" id="-1282102256#-9vp8ci_1031">setSystemProcess</span> вызывается из <span class="inline-code" id="-1282102256#-9vp8ci_1032">SystemServer</span> (он же system_service). Ниже краткий стек вызовов:</p><div class="detached code-block" id="-1282102256#-9vp8ci_845"><pre><code class="language-none">1. Загрузчик (Bootloader) → Ядро (Linux Kernel)  
2. Процесс init (первый userspace-процесс)  
   ├─ Запуск zygote (через app_process)  
   │   ├─ ZygoteInit (singleton, подготавливает среду для Java-процессов)  
   │   │   ├─ fork() → создаёт SystemServer  
   │   │   └─ fork() → создаёт приложения  
   └─ SystemServer (singleton, запускает все системные сервисы)  
       ├─ RuntimeInit (инициализирует среду для SystemServer)  
       └─ ActivityManagerService (singleton, включая `setSystemProcess()`)</code></pre></div><p id="-1282102256#-9vp8ci_846">Выше <span class="inline-code" id="-1282102256#-9vp8ci_1033">ActivityManagerService</span> подниматься нет смысла, так как там <span class="inline-code" id="-1282102256#-9vp8ci_1034">Bundle</span> не хранится, большинство этих компонентов &mdash; это синглтоны всей системы и не имеют прямого отношения к конкретному приложению.</p><p id="-1282102256#-9vp8ci_847">На этом моменте уже многое стало ясно: мы рассмотрели очень длинный flow вызовов. Момент, который мы немного пропустили, &mdash; где именно создаются <span class="inline-code" id="-1282102256#-9vp8ci_1035">ActivityRecord</span>. Ранее мы уже видели список <span class="inline-code" id="-1282102256#-9vp8ci_1036">ActivityRecord</span>, получаемый из поля <span class="inline-code" id="-1282102256#-9vp8ci_1037">mStartingProcessActivities</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1038">ActivityTaskManagerService</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_848"><pre><code class="language-java">class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt; implements DisplayManager.DisplayListener {

    ActivityTaskSupervisor mTaskSupervisor;
    ActivityTaskManagerService mService;

    boolean attachApplication(WindowProcessController app) throws RemoteException {
        final ArrayList&lt;ActivityRecord&gt; activities = mService.mStartingProcessActivities;
        for (int i = activities.size() - 1; i &gt;= 0; i--) {
            final ActivityRecord r = activities.get(i);
            ...
            if (mTaskSupervisor.realStartActivityLocked(r, app, canResume,
                    true /* checkConfig */)) {
                hasActivityStarted = true;
            }
            ...
        }
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_849">В <span class="inline-code" id="-1282102256#-9vp8ci_1039">ActivityTaskManagerService</span> это выглядит следующим образом. Как мы уже видели, поле <span class="inline-code" id="-1282102256#-9vp8ci_1040">mStartingProcessActivities</span> является коллекцией, которая хранит объекты <span class="inline-code" id="-1282102256#-9vp8ci_1041">ActivityRecord</span>. Есть один метод, который добавляет <span class="inline-code" id="-1282102256#-9vp8ci_1042">ActivityRecord</span> в эту коллекцию &mdash; это метод <span class="inline-code" id="-1282102256#-9vp8ci_1043">startProcessAsync</span>:</p><div class="detached code-block" id="-1282102256#-9vp8ci_850"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    /** The starting activities which are waiting for their processes to attach. */
    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_851">Следующая глава статьи будет раскрывать этот момент, где создается ActivityRecord и кто его кладет в ActivityTaskManagerService в поле mStartingProcessActivities</p></section></section><section class="detached"><h2 id="-1282102256#bundle" data-toc="bundle#saved-state-handle-under-the-hood.md-bundle">Пересоздание процесса с сохранением Bundle</h2><div class="detached code-block" id="-1282102256#-9vp8ci_1044"><pre><code class="language-none">ActivityManagerService.startActivity()
  → ActivityTaskManagerService.startActivityAsUser()
    → ActivityStartController.obtainStarter()
      → ActivityStarter.execute()
        → executeRequest():
          1. Создание ActivityRecord (новый объект)
          2. startActivityUnchecked()
             → startActivityInner()
               → setInitialState(r) // сохраняем ActivityRecord в mStartActivity
               → RootWindowContainer.resumeFocusedTasksTopActivities(mStartActivity)
                 → Task.resumeTopActivityUncheckedLocked()
                   → ActivityTaskSupervisor.startSpecificActivity(r)
                     → (если процесс не запущен)
                        → ActivityTaskManagerService.startProcessAsync(r)
                          → mStartingProcessActivities.add(r) // финальная точка</code></pre></div><p id="-1282102256#-9vp8ci_1045"><span class="inline-code" id="-1282102256#-9vp8ci_1088">ActivityRecord</span> (с <span class="inline-code" id="-1282102256#-9vp8ci_1089">Bundle</span>) умеет переживать смерть процесса или его прерывание. Подразумевается ситуация, когда приложение уходит в фон и сохраняется в стеке задач (Recents), система через какое-то время убивает процесс. Когда пользователь возвращается, система вызывает метод <span class="inline-code" id="-1282102256#-9vp8ci_1090">startActivityFromRecents</span>, чтобы восстановить задачу (Task) и поднять процесс. Каждая задача, как правило, соответствует одной корневой Activity, но внутри может хранить дочерние Activity, которые тоже связаны с компонентами.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1046"><pre><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub {

    @Override
    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        return mActivityTaskManager.startActivityFromRecents(taskId, bOptions);
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1047">Метод <span class="inline-code" id="-1282102256#-9vp8ci_1091">startActivityFromRecents</span> внутри <span class="inline-code" id="-1282102256#-9vp8ci_1092">ActivityManagerService</span> напрямую делегирует вызов в <span class="inline-code" id="-1282102256#-9vp8ci_1093">ActivityTaskManagerService</span>. Сам по себе он ничего не делает, просто перекидывает управление дальше.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1048"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    ActivityTaskSupervisor mTaskSupervisor;

    @Override
    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        ...
        return mTaskSupervisor.startActivityFromRecents(callingPid, callingUid, taskId, safeOptions);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1049">В <span class="inline-code" id="-1282102256#-9vp8ci_1094">ActivityTaskManagerService.startActivityFromRecents</span> происходит подготовка: извлекаются PID, UID, формируются безопасные опции запуска ( SafeActivityOptions). Далее метод сразу передаёт выполнение в <span class="inline-code" id="-1282102256#-9vp8ci_1095">ActivityTaskSupervisor</span>, где происходит основная логика обработки задачи.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1050"><pre><code class="language-java">public class ActivityTaskSupervisor implements RecentTasks.Callbacks {

    final ActivityTaskManagerService mService;
    RootWindowContainer mRootWindowContainer;

    int startActivityFromRecents(int callingPid, int callingUid, int taskId,
                                 SafeActivityOptions options) {
        final Task task;

        task = mRootWindowContainer.anyTaskForId(taskId, MATCH_ATTACHED_TASK_OR_RECENT_TASKS_AND_RESTORE, activityOptions, ON_TOP);

        if (!mService.mAmInternal.shouldConfirmCredentials(task.mUserId) &amp;&amp; task.getRootActivity() != null) {
            final ActivityRecord targetActivity = task.getTopNonFinishingActivity();
         ...
            mService.moveTaskToFrontLocked(...);
         ...
            return ActivityManager.START_TASK_TO_FRONT;
        }
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1051">Внутри <span class="inline-code" id="-1282102256#-9vp8ci_1096">startActivityFromRecents</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1097">ActivityTaskSupervisor</span> происходит уже настоящий разбор: сначала ищется нужная задача через <span class="inline-code" id="-1282102256#-9vp8ci_1098">mRootWindowContainer.anyTaskForId(...)</span>, где передаются различные флаги (например, <span class="inline-code" id="-1282102256#-9vp8ci_1099">MATCH_ATTACHED_TASK_OR_RECENT_TASKS_AND_RESTORE</span>), чтобы восстановить задачу из списка недавних. Затем проверяется, нужно ли подтверждать учётные данные пользователя (например, если включён режим защиты профиля). После этого смотрится, есть ли у задачи root Activity (<span class="inline-code" id="-1282102256#-9vp8ci_1100">getRootActivity()</span>), и извлекается верхняя невыполненная Activity через <span class="inline-code" id="-1282102256#-9vp8ci_1101">getTopNonFinishingActivity()</span>.</p><p id="-1282102256#-9vp8ci_1052">Если все условия подходят, вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1102">moveTaskToFrontLocked(...)</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1103">ActivityTaskManagerService</span>, который отвечает за перенос задачи в передний план и дальнейший запуск. Всё это нужно для того, чтобы корректно восстановить состояние приложения из стека задач без необходимости полного пересоздания Activity с нуля.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1053"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    void moveTaskToFrontLocked(@Nullable IApplicationThread appThread,
                               @Nullable String callingPackage, int taskId, ...) {

        final Task task = mRootWindowContainer.anyTaskForId(taskId);
        ...
        mTaskSupervisor.findTaskToMoveToFront(task, flags, ...);
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1054">Метод <span class="inline-code" id="-1282102256#-9vp8ci_1104">moveTaskToFrontLocked</span> после проверки передаёт управление в <span class="inline-code" id="-1282102256#-9vp8ci_1105">findTaskToMoveToFront</span>. Здесь задача не просто находится, а действительно перемещается на передний план. В начале вытаскивается корневой контейнер задачи через <span class="inline-code" id="-1282102256#-9vp8ci_1106">getRootTask()</span>. Если задача ещё не была &laquo;переподвешена&raquo; (reparented), вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1107">moveHomeRootTaskToFrontIfNeeded</span>, чтобы при необходимости поднять домашнюю задачу (например, если приложение долго не запускалось).</p><p id="-1282102256#-9vp8ci_1055">Далее через <span class="inline-code" id="-1282102256#-9vp8ci_1108">getTopNonFinishingActivity()</span> достаётся верхняя невыполненная ActivityRecord(Activity) в задаче. Затем вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1109">currentRootTask.moveTaskToFront</span>, куда передаётся сама задача, опции анимации и другие параметры</p><div class="detached code-block" id="-1282102256#-9vp8ci_1056"><pre><code class="language-java">public class ActivityTaskSupervisor implements RecentTasks.Callbacks {

    void findTaskToMoveToFront(Task task, int flags, ActivityOptions options, String reason,
                               boolean forceNonResizeable) {
        Task currentRootTask = task.getRootTask();

        if (!reparented) {
            moveHomeRootTaskToFrontIfNeeded(flags, currentRootTask.getDisplayArea(), reason);
        }

        final ActivityRecord r = task.getTopNonFinishingActivity();
        currentRootTask.moveTaskToFront(task, false /* noAnimation */, options,
                r == null ? null : r.appTimeTracker, reason);
        ...
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1057">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1110">moveTaskToFront</span> внутри класса <span class="inline-code" id="-1282102256#-9vp8ci_1111">Task</span> мы видим финальный шаг &mdash; вызов <span class="inline-code" id="-1282102256#-9vp8ci_1112">mRootWindowContainer.resumeFocusedTasksTopActivities()</span>. Этот вызов отвечает за то, чтобы на уровне контейнера окон (WindowContainer) запустить или возобновить верхнюю активность, сделать её активной и отрисовать.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1058"><pre><code class="language-java">class Task extends TaskFragment {

    final void moveTaskToFront(Task tr, boolean noAnimation, ActivityOptions options,
                               AppTimeTracker timeTracker, boolean deferResume, String reason) {
        ...
        mRootWindowContainer.resumeFocusedTasksTopActivities();
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1059">Метод <span class="inline-code" id="-1282102256#-9vp8ci_1113">resumeFocusedTasksTopActivities</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1114">RootWindowContainer</span> проходит по всем дисплеям, чтобы определить, какая задача должна быть запущена или возобновлена. Для каждого дисплея вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1115">forAllRootTasks</span>, внутри которого берётся верхняя активность (<span class="inline-code" id="-1282102256#-9vp8ci_1116">topRunningActivity</span>). Если она уже в состоянии <span class="inline-code" id="-1282102256#-9vp8ci_1117">RESUMED</span>, то просто выполняется переход приложения (executeAppTransition). В противном случае активность активируется через <span class="inline-code" id="-1282102256#-9vp8ci_1118">makeActiveIfNeeded</span>.</p><p id="-1282102256#-9vp8ci_1060">Если на дисплее не оказалось ни одной подходящей активности, вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1119">resumeTopActivityUncheckedLocked</span> у фокусной задачи. А если вообще нет фокусных задач, система запускает домашнюю Activity через <span class="inline-code" id="-1282102256#-9vp8ci_1120">resumeHomeActivity</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1061"><pre><code class="language-java">class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;
        implements DisplayManager.DisplayListener {

    boolean resumeFocusedTasksTopActivities(
            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,
            boolean deferPause) {

        for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) {
            final DisplayContent display = getChildAt(displayNdx);
            final boolean curResult = result;
            boolean[] resumedOnDisplay = new boolean[1];
            final ActivityRecord topOfDisplay = display.topRunningActivity();
            display.forAllRootTasks(rootTask -&gt; {
                final ActivityRecord topRunningActivity = rootTask.topRunningActivity();
                if (!rootTask.isFocusableAndVisible() || topRunningActivity == null) {
                    return;
                }
                if (rootTask == targetRootTask) {
                    resumedOnDisplay[0] |= curResult;
                    return;
                }
                if (topRunningActivity.isState(RESUMED) &amp;&amp; topRunningActivity == topOfDisplay) {
                    rootTask.executeAppTransition(targetOptions);
                } else {
                    resumedOnDisplay[0] |= topRunningActivity.makeActiveIfNeeded(target);
                }
            });
            result |= resumedOnDisplay[0];
            if (!resumedOnDisplay[0]) {

                final Task focusedRoot = display.getFocusedRootTask();
                if (focusedRoot != null) {
                    result |= focusedRoot.resumeTopActivityUncheckedLocked(
                            target, targetOptions, false /* skipPause */);
                } else if (targetRootTask == null) {
                    result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;,
                            display.getDefaultTaskDisplayArea());
                }
            }
        }

        return result;
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1062">Таким образом, когда пользователь возвращается к приложению из Recents, система шаг за шагом поднимает задачу из стека, подготавливает корневую Activity и доводит её до состояния RESUMED. Всё это происходит последовательно: от поиска задачи в стеке &mdash; до финального вызова <span class="inline-code" id="-1282102256#-9vp8ci_1121">makeActiveIfNeeded</span>, который, по сути, завершает процесс восстановления.</p><p id="-1282102256#-9vp8ci_1063">После того как контейнер окон выбрал задачу для возобновления, управление переходит в метод <span class="inline-code" id="-1282102256#-9vp8ci_1122">resumeTopActivityUncheckedLocked</span> внутри класса <span class="inline-code" id="-1282102256#-9vp8ci_1123">Task</span>. Здесь вызывается внутренний метод <span class="inline-code" id="-1282102256#-9vp8ci_1124">resumeTopActivityInnerLocked</span>, который уже окончательно определяет, какую Activity нужно запустить.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1064"><pre><code class="language-java">class Task extends TaskFragment {

    @GuardedBy(&quot;mService&quot;)
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options,
                                             boolean deferPause) {
        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);
    }

    @GuardedBy(&quot;mService&quot;)
    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options,
                                                 boolean deferPause) {
        final TaskFragment topFragment = topActivity.getTaskFragment();
        resumed[0] = topFragment.resumeTopActivity(prev, options, deferPause);
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1065">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1125">resumeTopActivityInnerLocked</span> вытаскивается фрагмент задачи (<span class="inline-code" id="-1282102256#-9vp8ci_1126">TaskFragment</span>), к которому привязана верхняя Activity. Именно тут начинается конкретная подготовка к запуску компонента приложения.</p><p id="-1282102256#-9vp8ci_1066">Дальше вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1127">resumeTopActivity</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1128">TaskFragment</span>. Здесь происходит поиск верхней активности (<span class="inline-code" id="-1282102256#-9vp8ci_1129">topRunningActivity</span>) и запуск метода <span class="inline-code" id="-1282102256#-9vp8ci_1130">startSpecificActivity</span>. По сути, <span class="inline-code" id="-1282102256#-9vp8ci_1131">startSpecificActivity</span> &mdash; это последняя точка внутри ядра системы, где принимается решение: запустить новый процесс для активности или использовать уже существующий.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1067"><pre><code class="language-java">class TaskFragment extends WindowContainer&lt;WindowContainer&gt; {

    final boolean resumeTopActivity(ActivityRecord prev, ActivityOptions options,
                                    boolean skipPause) {
        ActivityRecord next = topRunningActivity(true /* focusableOnly */);
        mTaskSupervisor.startSpecificActivity(next, true, false);
        ...
        return true;
        ...
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1068">Далее метод <span class="inline-code" id="-1282102256#-9vp8ci_1132">startSpecificActivity</span> внутри <span class="inline-code" id="-1282102256#-9vp8ci_1133">ActivityTaskSupervisor</span>. Здесь анализируется состояние процесса: если процесс уже существует и привязан, то активити будет сразу запущена. Если же процесс отсутствует или был завершён системой, тогда вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1134">startProcessAsync</span>, чтобы создать новый процесс для этой активности.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1069"><pre><code class="language-java">public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;

    void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
        ...
        mService.startProcessAsync(r, knownToBeDead, isTop,
                isTop ? HostingRecord.HOSTING_TYPE_TOP_ACTIVITY
                        : HostingRecord.HOSTING_TYPE_ACTIVITY);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1070">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1135">startProcessAsync</span> активити добавляется в список <span class="inline-code" id="-1282102256#-9vp8ci_1136">mStartingProcessActivities</span>. Это своего рода &laquo;очередь на запуск&raquo;, куда система кладёт активности, пока ожидает, что процесс для них будет создан и привязан.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1071"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_1072">Таким образом, когда мы доходим до финальной стадии, встает важный вопрос: <span class="control" id="-1282102256#-9vp8ci_1137">где в конечном итоге хранится <span class="inline-code" id="-1282102256#-9vp8ci_1138">ActivityRecord</span> и как устроены связи между ключевыми сущностями &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_1139">DisplayContent</span>, <span class="inline-code" id="-1282102256#-9vp8ci_1140">WindowContainer</span>, <span class="inline-code" id="-1282102256#-9vp8ci_1141">Task</span> (и <span class="inline-code" id="-1282102256#-9vp8ci_1142">TaskFragment</span>)?</span> Это поможет окончательно понять, как именно система управляет состоянием и &laquo;жизнью&raquo; Activity на стороне System Server.</p><p id="-1282102256#-9vp8ci_1073"><span class="control" id="-1282102256#-9vp8ci_1143">Общая структура иерархии</span> Android управляет активностями и окнами в виде <span class="control" id="-1282102256#-9vp8ci_1144">иерархического дерева контейнеров</span>, где каждый контейнер реализован через базовый класс <span class="inline-code" id="-1282102256#-9vp8ci_1145">WindowContainer</span>. Вся структура начинается с корневого контейнера <span class="inline-code" id="-1282102256#-9vp8ci_1146">RootWindowContainer</span>, внутри которого для каждого физического или виртуального дисплея создается <span class="inline-code" id="-1282102256#-9vp8ci_1147">DisplayContent</span>.</p><p id="-1282102256#-9vp8ci_1074"><span class="control" id="-1282102256#-9vp8ci_1148">DisplayContent</span> <span class="inline-code" id="-1282102256#-9vp8ci_1149">DisplayContent</span> представляет отдельный физический или виртуальный дисплей. Он является прямым потомком <span class="inline-code" id="-1282102256#-9vp8ci_1150">RootWindowContainer</span> и внутри себя хранит так называемые <span class="control" id="-1282102256#-9vp8ci_1151">DisplayAreas</span>, в которых сегментируются разные типы окон (например, область приложений, область системных оверлеев и т.д.). Внутри DisplayContent находится <span class="control" id="-1282102256#-9vp8ci_1152">TaskDisplayArea</span>, которая отвечает за размещение пользовательских задач (Tasks).</p><p id="-1282102256#-9vp8ci_1075"><span class="control" id="-1282102256#-9vp8ci_1153">TaskDisplayArea</span> <span class="inline-code" id="-1282102256#-9vp8ci_1154">TaskDisplayArea</span> &mdash; это область дисплея, куда добавляются задачи (<span class="inline-code" id="-1282102256#-9vp8ci_1155">Task</span>). В большинстве случаев, если нет multi-window или особых режимов, используется один <span class="control" id="-1282102256#-9vp8ci_1156">DefaultTaskDisplayArea</span>, где и размещаются все задачи приложения. В иерархии путь выглядит так: <span class="control" id="-1282102256#-9vp8ci_1157">DisplayContent &rarr; TaskDisplayArea &rarr; Task</span>.</p><p id="-1282102256#-9vp8ci_1076"><span class="control" id="-1282102256#-9vp8ci_1158">Task</span> <span class="inline-code" id="-1282102256#-9vp8ci_1159">Task</span> (по сути, &laquo;стек задач&raquo;) группирует одну или несколько активити, которые пользователь воспринимает как одно приложение в списке Recents. В Android <span class="inline-code" id="-1282102256#-9vp8ci_1160">Task</span> наследуется от <span class="inline-code" id="-1282102256#-9vp8ci_1161">TaskFragment</span>, что делает его контейнером, способным содержать дочерние <span class="inline-code" id="-1282102256#-9vp8ci_1162">WindowContainer</span>. Обычно внутри задачи размещаются именно <span class="inline-code" id="-1282102256#-9vp8ci_1163">ActivityRecord</span>, каждая из которых представляет конкретную активити. В более сложных случаях, например при split-screen, <span class="inline-code" id="-1282102256#-9vp8ci_1164">Task</span> может содержать и другие задачи или TaskFragments. Однако в стандартном сценарии (одиночный экран без split) задача содержит список ActivityRecords напрямую.</p><p id="-1282102256#-9vp8ci_1077"><span class="emphasis" id="-1282102256#-9vp8ci_1165">Здесь ключевой момент</span>: <span class="control" id="-1282102256#-9vp8ci_1166"><span class="inline-code" id="-1282102256#-9vp8ci_1168">Task</span> является прямым родителем для <span class="inline-code" id="-1282102256#-9vp8ci_1169">ActivityRecord</span></span>. Это значит, что все состояния и контекст конкретной Activity хранятся внутри её <span class="inline-code" id="-1282102256#-9vp8ci_1167">ActivityRecord</span>, который в свою очередь всегда находится внутри задачи. Таким образом, при возврате пользователя к приложению через Recents, система восстанавливает задачу, а вместе с ней и все вложенные ActivityRecords.</p><p id="-1282102256#-9vp8ci_1078"><span class="control" id="-1282102256#-9vp8ci_1170">TaskFragment</span> <span class="inline-code" id="-1282102256#-9vp8ci_1171">TaskFragment</span> &mdash; это базовый класс, который используется для создания под-контейнеров внутри задачи. В обычных сценариях мы его напрямую не видим, потому что работаем с <span class="inline-code" id="-1282102256#-9vp8ci_1172">Task</span>, который уже является расширением <span class="inline-code" id="-1282102256#-9vp8ci_1173">TaskFragment</span>. В некоторых режимах (например, Activity Embedding) могут создаваться отдельные TaskFragments, чтобы разделить экран между несколькими активити. Но если таких сценариев нет, <span class="inline-code" id="-1282102256#-9vp8ci_1174">Task</span> сам по себе содержит ActivityRecords, и дополнительных TaskFragments не используется.</p><p id="-1282102256#-9vp8ci_1079"><span class="control" id="-1282102256#-9vp8ci_1175">ActivityRecord</span> <span class="inline-code" id="-1282102256#-9vp8ci_1176">ActivityRecord</span> представляет конкретный экземпляр Activity в системе. Он наследуется от <span class="inline-code" id="-1282102256#-9vp8ci_1177">WindowToken</span>, который в свою очередь является дочерним классом <span class="inline-code" id="-1282102256#-9vp8ci_1178">WindowContainer</span>. Таким образом, <span class="inline-code" id="-1282102256#-9vp8ci_1179">ActivityRecord</span> &mdash; это одновременно и контейнер для окон активити, и токен, который WindowManager использует для управления окнами. Обычно внутри <span class="inline-code" id="-1282102256#-9vp8ci_1180">ActivityRecord</span> размещается один основной <span class="inline-code" id="-1282102256#-9vp8ci_1181">WindowState</span> (окно приложения), а также любые дочерние окна (например, диалоги).</p><p id="-1282102256#-9vp8ci_1080"><span class="control" id="-1282102256#-9vp8ci_1182">Путь в иерархии выглядит так</span>: <span class="inline-code" id="-1282102256#-9vp8ci_1183">RootWindowContainer &rarr; DisplayContent &rarr; TaskDisplayArea &rarr; Task &rarr; ActivityRecord &rarr; WindowState</span>.</p><p id="-1282102256#-9vp8ci_1081">Это означает, что <span class="inline-code" id="-1282102256#-9vp8ci_1184">ActivityRecord</span> <span class="control" id="-1282102256#-9vp8ci_1185">всегда живёт внутри задачи</span> и никогда не существует сам по себе или в глобальном списке. Именно поэтому при возврате из Recents задача сначала поднимается целиком (<span class="inline-code" id="-1282102256#-9vp8ci_1186">Task</span>), а затем уже внутри неё активируются нужные активности (<span class="inline-code" id="-1282102256#-9vp8ci_1187">ActivityRecord</span>).</p><p id="-1282102256#-9vp8ci_1082">Такое дерево контейнеров позволяет системе Android централизованно управлять всей иерархией окон и задач. Например, при изменении конфигурации или выгрузке процесса, состояние активности остаётся &laquo;привязанным&raquo; к её <span class="inline-code" id="-1282102256#-9vp8ci_1188">ActivityRecord</span>, который живёт внутри <span class="inline-code" id="-1282102256#-9vp8ci_1189">Task</span>. Когда задача возвращается на экран, все объекты дерева последовательно восстанавливаются, и Activity получает свои данные обратно через <span class="inline-code" id="-1282102256#-9vp8ci_1190">Bundle</span>, связанный с её <span class="inline-code" id="-1282102256#-9vp8ci_1191">ActivityRecord</span>.</p><p id="-1282102256#-9vp8ci_1083">Сделаем краткий итог</p><ul class="list" id="-1282102256#-9vp8ci_1084" start="1"><li class="list-item" id="-1282102256#-9vp8ci_1192"><p id="-1282102256#-9vp8ci_1198"><span class="control" id="-1282102256#-9vp8ci_1199">DisplayContent</span> &mdash; верхний контейнер для дисплея, включает TaskDisplayArea.</p></li><li class="list-item" id="-1282102256#-9vp8ci_1193"><p id="-1282102256#-9vp8ci_1200"><span class="control" id="-1282102256#-9vp8ci_1201">TaskDisplayArea</span> &mdash; область дисплея для задач.</p></li><li class="list-item" id="-1282102256#-9vp8ci_1194"><p id="-1282102256#-9vp8ci_1202"><span class="control" id="-1282102256#-9vp8ci_1203">Task</span> &mdash; контейнер, группирующий одну или несколько ActivityRecords.</p></li><li class="list-item" id="-1282102256#-9vp8ci_1195"><p id="-1282102256#-9vp8ci_1204"><span class="control" id="-1282102256#-9vp8ci_1205">TaskFragment</span> &mdash; промежуточный контейнер, используется при embedding или split, обычно не нужен в базовом сценарии.</p></li><li class="list-item" id="-1282102256#-9vp8ci_1196"><p id="-1282102256#-9vp8ci_1206"><span class="control" id="-1282102256#-9vp8ci_1207">ActivityRecord</span> &mdash; контейнер и токен конкретной Activity, всегда находится внутри Task.</p></li><li class="list-item" id="-1282102256#-9vp8ci_1197"><p id="-1282102256#-9vp8ci_1208"><span class="control" id="-1282102256#-9vp8ci_1209">WindowState</span> &mdash; дочерние окна Activity, живут внутри ActivityRecord.</p></li></ul><p id="-1282102256#-9vp8ci_1085">Таким образом, вопрос <span class="emphasis" id="-1282102256#-9vp8ci_1210">&laquo;где хранится ActivityRecord&raquo;</span> можно чётко ответить: <span class="control" id="-1282102256#-9vp8ci_1211">внутри Task</span>, как дочерний элемент в дереве контейнеров.</p><p id="-1282102256#-9vp8ci_1086">Эта архитектура делает поведение задач предсказуемым и позволяет системе сохранять, приостанавливать и восстанавливать активности, не нарушая общую структуру приложения в памяти. Именно поэтому пользователь всегда видит &laquo;цельную&raquo; задачу в Recents, а не отдельные активности.</p><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p id="-1282102256#-9vp8ci_1212">Для более наглядного понимания иерархии можно посмотреть диаграмму ниже, которая отлично иллюстрирует дерево контейнеров в Android WindowManager (начиная с Android 12).</p><div class="container"><figure class="image-container"><img class="center image image-size" id="-1282102256#-9vp8ci_1213" alt="Android WindowManager Hierarchy" title="Android WindowManager Hierarchy" src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/15/8e302de71ed649b7aab54919ae455e61.png"><figcaption class="center-text">Android WindowManager Hierarchy</figcaption></figure></div><p id="-1282102256#-9vp8ci_1214"><span class="emphasis" id="-1282102256#-9vp8ci_1215">Диаграмма взята с sobyte.net &mdash; Android 12 WMS Hierarchy (<a href="https://www.sobyte.net/post/2022-02/android-12-wms-hierarchy/#:~:text=%2A%20RootWindowContainer%3A%20The%20top,%E2%80%A6">https://www.sobyte.net/post/2022-02/android-12-wms-hierarchy/#:~:text=%2A%20RootWindowContainer%3A%20The%20top,%E2%80%A6</a>) для иллюстрации иерархии WindowManager.</span></p></div>
</blockquote>
</section><section class="detached"><h2 id="-1282102256#activityrecord" data-toc="activityrecord#saved-state-handle-under-the-hood.md-activityrecord">Где и когда создается ActivityRecord в первые</h2><p id="-1282102256#-9vp8ci_1217">После того как мы разобрали, где именно хранится <span class="inline-code" id="-1282102256#-9vp8ci_1248">ActivityRecord</span> в иерархии контейнеров, возникает следующий важный вопрос: <span class="control" id="-1282102256#-9vp8ci_1249">а когда и как этот объект вообще появляется в системе?</span></p><p id="-1282102256#-9vp8ci_1218">Все предыдущие главы показывали нам, как система управляет уже существующими <span class="inline-code" id="-1282102256#-9vp8ci_1250">ActivityRecord</span> &mdash; как они восстанавливаются из стека задач ( Recents), как переходят между состояниями, как сохраняются их состояния. Но откуда берётся первый экземпляр <span class="inline-code" id="-1282102256#-9vp8ci_1251">ActivityRecord</span>, когда Activity запускается впервые, например, при самом первом запуске приложения или при старте новой Activity через интент?</p><p id="-1282102256#-9vp8ci_1219">Именно этот момент &mdash; создание <span class="inline-code" id="-1282102256#-9vp8ci_1252">ActivityRecord</span> &mdash; можно считать точкой входа активности в &laquo;жизнь&raquo; на стороне system server. На этом этапе создаётся основная структура, к которой в дальнейшем будут привязаны всё: и окна (<span class="inline-code" id="-1282102256#-9vp8ci_1253">WindowState</span>), и состояния (<span class="inline-code" id="-1282102256#-9vp8ci_1254">Bundle</span>), и привязки к задаче (<span class="inline-code" id="-1282102256#-9vp8ci_1255">Task</span>).</p><p id="-1282102256#-9vp8ci_1220">Дальше система начинает &laquo;разворачивать&raquo; процесс по цепочке вызовов, начиная с верхнего уровня &mdash; <span class="inline-code" id="-1282102256#-9vp8ci_1256">ActivityManagerService</span>. Когда приложение или другой компонент системы вызывает <span class="inline-code" id="-1282102256#-9vp8ci_1257">startActivity(...)</span>, эта команда сначала попадает в публичный API <span class="inline-code" id="-1282102256#-9vp8ci_1258">ActivityManagerService</span>, а уже оттуда прокладывает путь вниз через слои system server, где и подготавливаются все объекты, необходимые для старта.</p><p id="-1282102256#-9vp8ci_1221">Вот как выглядит эта цепочка вызовов на первых уровнях:</p><div class="detached code-block" id="-1282102256#-9vp8ci_1222"><pre><code class="language-java">public class ActivityManagerService extends IActivityManager.Stub,...{

@Override
public int startActivityWithFeature(IApplicationThread caller, String callingPackage,...) {
    return mActivityTaskManager.startActivity(caller, callingPackage, callingFeatureId, intent,...);
}

}</code></pre></div><p id="-1282102256#-9vp8ci_1223">Здесь <span class="inline-code" id="-1282102256#-9vp8ci_1259">ActivityManagerService</span> лишь перенаправляет вызов в <span class="inline-code" id="-1282102256#-9vp8ci_1260">ActivityTaskManagerService</span>, где начинается более детальная работа с профилями пользователей, флагами интентов и прочими проверками.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1224"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    @Override
    public final int startActivity(IApplicationThread caller, String callingPackage, ...) {
        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, ...);
    }

    private int startActivityAsUser(IApplicationThread caller, String callingPackage, ...) {

        return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;)
              ...
              .execute();
    }

    ActivityStartController getActivityStartController() {
        return mActivityStartController;
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1225">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1261">startActivityAsUser</span> мы уже видим обращение к <span class="inline-code" id="-1282102256#-9vp8ci_1262">ActivityStartController</span>, который управляет процессом создания и конфигурации старта активности. Метод <span class="inline-code" id="-1282102256#-9vp8ci_1263">obtainStarter</span> возвращает объект <span class="inline-code" id="-1282102256#-9vp8ci_1264">ActivityStarter</span>, который можно назвать настоящим &laquo;дирижёром&raquo; запуска. Он собирает все параметры, проверяет, нужна ли новая задача (<span class="inline-code" id="-1282102256#-9vp8ci_1265">Task</span>) или можно использовать существующую, проверяет конфигурацию и наконец подготавливает <span class="inline-code" id="-1282102256#-9vp8ci_1266">ActivityRecord</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1226"><pre><code class="language-java">public class ActivityStartController {

    ActivityStarter obtainStarter(Intent intent, String reason) {
        return mFactory.obtain().setIntent(intent).setReason(reason);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1227">После того как мы получаем <span class="inline-code" id="-1282102256#-9vp8ci_1267">ActivityStarter</span> через <span class="inline-code" id="-1282102256#-9vp8ci_1268">obtainStarter</span>, именно здесь происходит создание нового объекта <span class="inline-code" id="-1282102256#-9vp8ci_1269">ActivityRecord</span>. <span class="inline-code" id="-1282102256#-9vp8ci_1270">ActivityStarter</span> формирует все ключевые параметры запуска: интент, флаги, целевой <span class="inline-code" id="-1282102256#-9vp8ci_1271">Task</span>, конфигурацию окна, а также решает, нужно ли создать новую задачу или использовать существующую.</p><p id="-1282102256#-9vp8ci_1228">Созданный <span class="inline-code" id="-1282102256#-9vp8ci_1272">ActivityRecord</span> связывается с задачей, добавляется в иерархию контейнеров и становится частью общей структуры <span class="inline-code" id="-1282102256#-9vp8ci_1273">RootWindowContainer</span>. После создания <span class="inline-code" id="-1282102256#-9vp8ci_1274">ActivityRecord</span> хранится в дереве контейнеров до завершения активности или её удаления системой.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1230"><pre><code class="language-java">class ActivityStarter {

    private final ActivityTaskManagerService mService;
    private final RootWindowContainer mRootWindowContainer;
    ActivityRecord mStartActivity;

    int execute() {
        ...
        res = executeRequest(mRequest);
        ...
    }

    private int executeRequest(Request request) {
        final ActivityRecord r = new ActivityRecord.Builder(mService)
                 ... // параметры через билдер
                .build();

        mLastStartActivityResult = startActivityUnchecked(r, ...);
        ...
    }

    private int startActivityUnchecked(final ActivityRecord r, ...) {
        ...
        result = startActivityInner(r, ...);
        ...
    }

    int startActivityInner(final ActivityRecord r, ...) {
        setInitialState(r, ...);

        mRootWindowContainer.resumeFocusedTasksTopActivities(
                mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);
    }

    private void setInitialState(ActivityRecord r, ...) {
        ...
        mStartActivity = r;
        ...
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1231">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1275">executeRequest</span> через билдер создаётся объект <span class="inline-code" id="-1282102256#-9vp8ci_1276">ActivityRecord</span>. После инициализации передаётся в <span class="inline-code" id="-1282102256#-9vp8ci_1277">startActivityUnchecked</span>, а затем в <span class="inline-code" id="-1282102256#-9vp8ci_1278">startActivityInner</span>, где вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_1279">setInitialState</span>. Здесь объект сохраняется в <span class="inline-code" id="-1282102256#-9vp8ci_1280">mStartActivity</span> &mdash; это ссылка на текущую активность, которая будет запущена.</p><p id="-1282102256#-9vp8ci_1232">Далее активити подготавливается к запуску через вызов <span class="inline-code" id="-1282102256#-9vp8ci_1281">resumeFocusedTasksTopActivities</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1282">RootWindowContainer</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1234"><pre><code class="language-java">class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;
        implements DisplayManager.DisplayListener {

    boolean resumeFocusedTasksTopActivities(
            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,
            boolean deferPause) {

        for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) {
            final DisplayContent display = getChildAt(displayNdx);
            final boolean curResult = result;
            boolean[] resumedOnDisplay = new boolean[1];
            final ActivityRecord topOfDisplay = display.topRunningActivity();
            display.forAllRootTasks(rootTask -&gt; {
                final ActivityRecord topRunningActivity = rootTask.topRunningActivity();
                if (!rootTask.isFocusableAndVisible() || topRunningActivity == null) {
                    return;
                }
                if (rootTask == targetRootTask) {
                    resumedOnDisplay[0] |= curResult;
                    return;
                }
                if (topRunningActivity.isState(RESUMED) &amp;&amp; topRunningActivity == topOfDisplay) {
                    rootTask.executeAppTransition(targetOptions);
                } else {
                    resumedOnDisplay[0] |= topRunningActivity.makeActiveIfNeeded(target);
                }
            });
            result |= resumedOnDisplay[0];
            if (!resumedOnDisplay[0]) {
                final Task focusedRoot = display.getFocusedRootTask();
                if (focusedRoot != null) {
                    result |= focusedRoot.resumeTopActivityUncheckedLocked(
                            target, targetOptions, false /* skipPause */);
                } else if (targetRootTask == null) {
                    result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;,
                            display.getDefaultTaskDisplayArea());
                }
            }
        }

        return result;
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1235">В методе <span class="inline-code" id="-1282102256#-9vp8ci_1283">resumeFocusedTasksTopActivities</span> происходит обход всех дисплеев и корневых задач. Для каждой задачи выбирается верхняя активити, проверяется её состояние и возможность активации. Если задача содержит целевую активити (<span class="inline-code" id="-1282102256#-9vp8ci_1284">target</span>), она активируется вызовом <span class="inline-code" id="-1282102256#-9vp8ci_1285">resumeTopActivityUncheckedLocked</span>.</p><p id="-1282102256#-9vp8ci_1236">Таким образом, после создания <span class="inline-code" id="-1282102256#-9vp8ci_1286">ActivityRecord</span>, система полностью подготавливает задачу и активирует верхнюю активити, переводя её в состояние RESUMED. Отлично, продолжим ровно в том же техническом, &laquo;ровном&raquo; стиле, учитывая, что эти методы мы действительно уже подробно разбирали ранее.</p><p id="-1282102256#-9vp8ci_1237">После того как контейнер окон выбрал задачу для возобновления, управление переходит в метод <span class="inline-code" id="-1282102256#-9vp8ci_1287">resumeTopActivityUncheckedLocked</span> внутри класса <span class="inline-code" id="-1282102256#-9vp8ci_1288">Task</span>. Мы уже встречали этот метод раньше &mdash; он отвечает за выбор и финальную подготовку верхней активити внутри задачи перед запуском. Внутри него вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1289">resumeTopActivityInnerLocked</span>, который в свою очередь извлекает нужный <span class="inline-code" id="-1282102256#-9vp8ci_1290">TaskFragment</span>.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1238"><pre><code class="language-java">class Task extends TaskFragment {

    @GuardedBy(&quot;mService&quot;)
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options,
                                             boolean deferPause) {
        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);
    }

    @GuardedBy(&quot;mService&quot;)
    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options,
                                                 boolean deferPause) {
        final TaskFragment topFragment = topActivity.getTaskFragment();
        resumed[0] = topFragment.resumeTopActivity(prev, options, deferPause);
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1239">Как мы помним, в методе <span class="inline-code" id="-1282102256#-9vp8ci_1291">resumeTopActivityInnerLocked</span> вытаскивается верхний фрагмент задачи (объект <span class="inline-code" id="-1282102256#-9vp8ci_1292">TaskFragment</span>), который содержит активити, готовую к запуску.</p><p id="-1282102256#-9vp8ci_1240">Далее вызывается <span class="inline-code" id="-1282102256#-9vp8ci_1293">resumeTopActivity</span> у <span class="inline-code" id="-1282102256#-9vp8ci_1294">TaskFragment</span>. Этот метод ищет верхнюю активити в контейнере (<span class="inline-code" id="-1282102256#-9vp8ci_1295">topRunningActivity</span>) и инициирует вызов <span class="inline-code" id="-1282102256#-9vp8ci_1296">startSpecificActivity</span>. Здесь принимается решение, нужно ли запускать новый процесс или использовать уже существующий.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1241"><pre><code class="language-java">class TaskFragment extends WindowContainer&lt;WindowContainer&gt; {

    final boolean resumeTopActivity(ActivityRecord prev, ActivityOptions options,
                                    boolean skipPause) {
        ActivityRecord next = topRunningActivity(true /* focusableOnly */);
        mTaskSupervisor.startSpecificActivity(next, true, false);
        ...
        return true;
        ...
    }

}</code></pre></div><p id="-1282102256#-9vp8ci_1242">Мы уже видели метод <span class="inline-code" id="-1282102256#-9vp8ci_1297">startSpecificActivity</span> внутри <span class="inline-code" id="-1282102256#-9vp8ci_1298">ActivityTaskSupervisor</span> в предыдущих главах. Он проверяет, существует ли уже процесс для текущей активности. Если процесс жив и активити привязана, то система продолжает её запуск напрямую. Если процесс отсутствует или был выгружен системой, вызывается метод <span class="inline-code" id="-1282102256#-9vp8ci_1299">startProcessAsync</span>, который отвечает за асинхронный старт нового процесса.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1243"><pre><code class="language-java">public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;

    void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
        ...
        mService.startProcessAsync(r, knownToBeDead, isTop,
                isTop ? HostingRecord.HOSTING_TYPE_TOP_ACTIVITY
                        : HostingRecord.HOSTING_TYPE_ACTIVITY);
    }
}</code></pre></div><p id="-1282102256#-9vp8ci_1244">Внутри <span class="inline-code" id="-1282102256#-9vp8ci_1300">startProcessAsync</span>, как мы уже подробно разбирали, активити добавляется в список <span class="inline-code" id="-1282102256#-9vp8ci_1301">mStartingProcessActivities</span>. Это очередь для тех активити, которые ждут, пока процесс будет создан и привязан системой. Такая очередь позволяет системе контролировать порядок запуска и управлять ресурсами без потерь состояний.</p><div class="detached code-block" id="-1282102256#-9vp8ci_1245"><pre><code class="language-java">public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}</code></pre></div><p id="-1282102256#-9vp8ci_1246">Таким образом, вся эта цепочка методов, которые мы уже встречали ранее, замыкается именно здесь: от вызова из контейнеров окон до финального решения о создании нового процесса или продолжении в текущем. В результате создаётся, сохраняется и активируется <span class="inline-code" id="-1282102256#-9vp8ci_1302">ActivityRecord</span>, и именно он становится ключевым звеном между системой и пользовательским интерфейсом. Что происходит после вызова этого метода и последующую логику обработки мы уже подробно разбирали в предыдущих главах.</p><p id="-1282102256#-9vp8ci_1247">На этом, пожалуй, всё &mdash; это конец статьи.</p></section></article></div></section><section class="topic"><div><article class="article"><h1 class="main-title" id="1175324909">Decompose и Essenty: под капотом сохранения состояния без ViewModel</h1><section class="detached"><h2 id="1175324909#-jggmpr_3" data-toc="-jggmpr_3#decompose-save-state-internal.md--jggmpr_3">Введение</h2><p id="1175324909#-jggmpr_10">Это продолжение четырех предыдущих статей.</p><ol class="list list-decimal" id="1175324909#-jggmpr_11" type="1" start="1"><li class="list-item" id="1175324909#-jggmpr_15"><p id="1175324909#-jggmpr_19">В первой мы разобрали, где в конечном итоге хранится <span class="inline-code" id="1175324909#-jggmpr_20">ViewModelStore</span> в случае с <span class="inline-code" id="1175324909#-jggmpr_21">Activity</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_16"><p id="1175324909#-jggmpr_22">Во второй &mdash; как это устроено во <span class="inline-code" id="1175324909#-jggmpr_23">Fragment</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_17"><p id="1175324909#-jggmpr_24">В третьей &mdash; где хранятся <span class="inline-code" id="1175324909#-jggmpr_25">ViewModel</span>-и, когда мы используем <span class="control" id="1175324909#-jggmpr_26">Compose</span> (или даже просто <span class="inline-code" id="1175324909#-jggmpr_27">View</span>).</p></li><li class="list-item" id="1175324909#-jggmpr_18"><p id="1175324909#-jggmpr_28">В четвёртой &mdash; как работают методы <span class="inline-code" id="1175324909#-jggmpr_29">onSaveInstanceState</span>/<span class="inline-code" id="1175324909#-jggmpr_30">onRestoreInstanceState</span>, Saved State API и где хранится <span class="inline-code" id="1175324909#-jggmpr_31">Bundle</span>.</p></li></ol><p id="1175324909#-jggmpr_12">В этой статье разберёмся, как широко используемая в KMP библиотека <span class="control" id="1175324909#-jggmpr_32">Decompose</span> справляется без <span class="inline-code" id="1175324909#-jggmpr_33">ViewModel</span> и методов <span class="inline-code" id="1175324909#-jggmpr_34">onSaveInstanceState</span>, ведь она является кроссплатформенной (KMP) библиотекой.</p><p id="1175324909#-jggmpr_13">Статья не о том, <span class="emphasis" id="1175324909#-jggmpr_35">как</span> использовать эти API, а о том, <span class="emphasis" id="1175324909#-jggmpr_36">как</span> они работают изнутри. Поэтому я буду полагаться на то, что вы уже знакомы с ними или хотя бы имеете общее представление.</p><p id="1175324909#-jggmpr_14">Как всегда, начнём с базиса. Давайте сначала дадим определение Decompose:</p></section><section class="detached"><h2 id="1175324909#-jggmpr_4" data-toc="-jggmpr_4#decompose-save-state-internal.md--jggmpr_4">Базис</h2><p id="1175324909#-jggmpr_37"><span class="control" id="1175324909#-jggmpr_48">Decompose</span> &mdash; это мультиплатформенная библиотека для разделения бизнес-логики и UI, разработанная Аркадием Ивановым. Она работает поверх <span class="inline-code" id="1175324909#-jggmpr_49">ComponentContext</span>, который управляет жизненным циклом, состоянием и навигацией между компонентами.</p><p id="1175324909#-jggmpr_38">Поддерживает: Android, iOS, JS, JVM, macOS, watchOS, tvOS.</p><p id="1175324909#-jggmpr_39">Зачем использовать:</p><ul class="list" id="1175324909#-jggmpr_40" start="1"><li class="list-item" id="1175324909#-jggmpr_50"><p id="1175324909#-jggmpr_55">логика отделена от UI и легко тестируется</p></li><li class="list-item" id="1175324909#-jggmpr_51"><p id="1175324909#-jggmpr_56">работает с Compose, SwiftUI, React и др.</p></li><li class="list-item" id="1175324909#-jggmpr_52"><p id="1175324909#-jggmpr_57">навигация и состояние &mdash; кроссплатформенные</p></li><li class="list-item" id="1175324909#-jggmpr_53"><p id="1175324909#-jggmpr_58">компоненты переживают конфигурационные изменения (как <span class="inline-code" id="1175324909#-jggmpr_59">ViewModel</span>)</p></li><li class="list-item" id="1175324909#-jggmpr_54"><p id="1175324909#-jggmpr_60">можно расширять и кастомизировать <span class="inline-code" id="1175324909#-jggmpr_61">ComponentContext</span> под свои задачи</p></li></ul><p id="1175324909#-jggmpr_41"><span class="control" id="1175324909#-jggmpr_62">Decompose</span> &mdash; это не фреймворк, а мощный инструмент, на котором можно построить свой API. Кратко говоря, это швейцарский нож.</p><p id="1175324909#-jggmpr_42">В Android сложно представить приложение без стандартной <span class="inline-code" id="1175324909#-jggmpr_63">ViewModel</span>, и удивительно, что в <span class="control" id="1175324909#-jggmpr_64">Decompose</span> её нет, но при этом она умеет сохранять данные как при изменении конфигурации, так и при уничтожении процесса.</p><p id="1175324909#-jggmpr_43">Давайте быстро разберёмся с сущностями, на которых основана Decompose:</p><p id="1175324909#-jggmpr_44">Всё в <span class="control" id="1175324909#-jggmpr_65">Decompose</span> крутится вокруг <span class="inline-code" id="1175324909#-jggmpr_66">ComponentContext</span> &mdash; компонента, связанного с определённым экраном или набором дочерних компонентов. У каждого компонента есть свой <span class="inline-code" id="1175324909#-jggmpr_67">ComponentContext</span>, который реализует следующие интерфейсы:</p><ul class="list" id="1175324909#-jggmpr_45" start="1"><li class="list-item" id="1175324909#-jggmpr_68"><p id="1175324909#-jggmpr_72"><span class="control" id="1175324909#-jggmpr_73">LifecycleOwner</span> &mdash; предоставляется библиотекой <span class="control" id="1175324909#-jggmpr_74">Essenty</span>, даёт каждому компоненту собственный жизненный цикл.</p></li><li class="list-item" id="1175324909#-jggmpr_69"><p id="1175324909#-jggmpr_75"><span class="control" id="1175324909#-jggmpr_76">StateKeeperOwner</span> &mdash; позволяет сохранять любое состояние при конфигурационных изменениях и/или смерти процесса.</p></li><li class="list-item" id="1175324909#-jggmpr_70"><p id="1175324909#-jggmpr_77"><span class="control" id="1175324909#-jggmpr_78">InstanceKeeperOwner</span> &mdash; даёт возможность сохранять любые объекты внутри компонента (аналог <span class="inline-code" id="1175324909#-jggmpr_79">ViewModel</span> в AndroidX).</p></li><li class="list-item" id="1175324909#-jggmpr_71"><p id="1175324909#-jggmpr_80"><span class="control" id="1175324909#-jggmpr_81">BackHandlerOwner</span> &mdash; позволяет каждому компоненту обрабатывать нажатие кнопки &laquo;назад&raquo;.</p></li></ul><p id="1175324909#-jggmpr_46">Основное внимание мы уделим именно <span class="inline-code" id="1175324909#-jggmpr_82">StateKeeperOwner</span> (<span class="inline-code" id="1175324909#-jggmpr_83">StateKeeper</span>) и <span class="inline-code" id="1175324909#-jggmpr_84">InstanceKeeperOwner</span> (<span class="inline-code" id="1175324909#-jggmpr_85">InstanceKeeper</span>). Как видно, они на самом деле тянутся из библиотеки <span class="control" id="1175324909#-jggmpr_86">Essenty</span>, которая также была создана Аркадием Ивановым. Однако особую популярность эта библиотека получила именно благодаря <span class="control" id="1175324909#-jggmpr_87">Decompose</span>.</p><p id="1175324909#-jggmpr_47">Начнём углубляться в работу <span class="inline-code" id="1175324909#-jggmpr_88">StateKeeperOwner</span> (<span class="inline-code" id="1175324909#-jggmpr_89">StateKeeper</span>). Я буду полагаться на то, что вы уже читали предыдущие статьи. Давайте начнём.</p></section><section class="detached"><h2 id="1175324909#statekeeperowner" data-toc="statekeeperowner#decompose-save-state-internal.md-statekeeperowner">StateKeeperOwner</h2><p id="1175324909#-jggmpr_90">Чтобы понять, как он работает, давайте реализуем простой экран <span class="inline-code" id="1175324909#-jggmpr_113">Counter</span>. Цель &mdash; увидеть, как счётчик умеет переживать изменение конфигурации и даже смерть процесса.</p><p id="1175324909#-jggmpr_91">Начнём с создания компонента для счетчика:</p><div class="detached code-block" id="1175324909#-jggmpr_92"><pre><code class="language-kotlin">class DefaultCounterComponent(
    componentContext: ComponentContext
) : ComponentContext by componentContext {

    val model: StateFlow&lt;Int&gt; field = MutableStateFlow(stateKeeper.consume(KEY, Int.serializer()) ?: 0)

    init {
        stateKeeper.register(KEY, Int.serializer()) { model.value }
    }

    fun increase() {
        model.value++
    }

    fun decrease() {
        model.value--
    }

    companion object {
        private const val KEY = &quot;counter_state&quot;
    }
}</code></pre></div><p id="1175324909#-jggmpr_93">Довольно простая логика: у нас есть <span class="inline-code" id="1175324909#-jggmpr_114">model</span>, который хранит текущее значение счётчика, и два метода для его изменения. При инициализации переменной мы получаем значение из <span class="inline-code" id="1175324909#-jggmpr_115">stateKeeper</span> через <span class="inline-code" id="1175324909#-jggmpr_116">consume</span>, если оно отсутствует &mdash; используем <span class="inline-code" id="1175324909#-jggmpr_117">0</span> по умолчанию.</p><p id="1175324909#-jggmpr_94">А в <span class="inline-code" id="1175324909#-jggmpr_118">init</span> блоке мы регистрируем лямбду, которая будет вызвана при сохранении состояния. Пока просто запомните этот момент &mdash; позже разберёмся, как и когда она срабатывает.</p><p id="1175324909#-jggmpr_95">Теперь экран счетчика, который работает с <span class="inline-code" id="1175324909#-jggmpr_119">DefaultCounterComponent</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_96"><pre><code class="language-kotlin">@Composable
fun CounterScreen(component: DefaultCounterComponent) {
    val count by component.model.collectAsState()

    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Text(text = count.toString(), style = MaterialTheme.typography.headlineLarge)
        Row(horizontalArrangement = Arrangement.spacedBy(40.dp)) {
            FloatingActionButton(onClick = { component.decrease() }) { Text(&quot;-&quot;, fontSize = 56.sp) }
            FloatingActionButton(onClick = { component.increase() }) { Text(&quot;+&quot;, fontSize = 56.sp) }
        }
    }
}</code></pre></div><p id="1175324909#-jggmpr_97">И, наконец, <span class="inline-code" id="1175324909#-jggmpr_120">Activity</span>, в которой инициализируется <span class="inline-code" id="1175324909#-jggmpr_121">ComponentContext</span> и вызывается экран <span class="inline-code" id="1175324909#-jggmpr_122">CounterScreen</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_98"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        val counterComponent = DefaultCounterComponent(defaultComponentContext())
        setContent { CounterScreen(component = counterComponent) }
    }
}</code></pre></div><p id="1175324909#-jggmpr_99">Теперь давайте проверим поведение визуально:</p><ol class="list list-decimal" id="1175324909#-jggmpr_100" type="1" start="1"><li class="list-item" id="1175324909#-jggmpr_123"><p id="1175324909#-jggmpr_125">Как будет вести себя счётчик при изменении конфигурации (именно повороте экрана).</p></li><li class="list-item" id="1175324909#-jggmpr_124"><p id="1175324909#-jggmpr_126">Как будет вести себя счётчик при уничтожении процесса, когда приложение находится в фоне.</p></li></ol><div class="container"><figure class="image-container"><img class="center bordered-element image image-size" id="1175324909#-jggmpr_101" alt="Screenshot" title="Screenshot" src="/Users/osman/jetbrains/WritersideProjects/insider/Writerside/images/stateKeeper.gif" width="800" height="758"><figcaption class="center-text">Screenshot</figcaption></figure></div><p id="1175324909#-jggmpr_102">Как видим, всё работает ровно так, как ожидалось. Значение счётчика сохраняется как при повороте экрана, так и после полного убийства процесса. При этом мы не видим здесь ни методов <span class="inline-code" id="1175324909#-jggmpr_127">onSaveInstanceState</span>, ни <span class="inline-code" id="1175324909#-jggmpr_128">ViewModel</span>. Давайте снова взглянем на компонент счётчика:</p><div class="detached code-block" id="1175324909#-jggmpr_103"><pre><code class="language-kotlin">class DefaultCounterComponent(
    componentContext: ComponentContext
) : ComponentContext by componentContext {

    val model: StateFlow&lt;Int&gt; field = MutableStateFlow(stateKeeper.consume(KEY, Int.serializer()) ?: 0)

    init {
        stateKeeper.register(KEY, Int.serializer()) { model.value }
    }
    ...

    companion object {
        private const val KEY = &quot;counter_state&quot;
    }
}</code></pre></div><p id="1175324909#-jggmpr_104">При пересоздании активности &mdash; как из-за изменения конфигурации, так и после смерти процесса &mdash; <span class="inline-code" id="1175324909#-jggmpr_129">DefaultCounterComponent</span> будет создаваться заново, и вместе с ним создаётся и поле <span class="inline-code" id="1175324909#-jggmpr_130">model</span>. В таком случае мы обращаемся к <span class="inline-code" id="1175324909#-jggmpr_131">stateKeeper</span> и, вызывая у него метод <span class="inline-code" id="1175324909#-jggmpr_132">consume</span>, получаем по ключу сохранённое значение. Если сохранённого значения нет, используем значение по умолчанию &mdash; <span class="inline-code" id="1175324909#-jggmpr_133">0</span>.</p><p id="1175324909#-jggmpr_105">В <span class="inline-code" id="1175324909#-jggmpr_134">init</span>-блоке мы регистрируем коллбэк через метод <span class="inline-code" id="1175324909#-jggmpr_135">stateKeeper.register</span>, передавая ему ключ, стратегию сериализации из <span class="inline-code" id="1175324909#-jggmpr_136">kotlinx.serialization</span> и лямбду, возвращающую текущее значение <span class="inline-code" id="1175324909#-jggmpr_137">model</span>.</p><p id="1175324909#-jggmpr_106">Посмотрим на исходники, чтобы понять, откуда берётся поле <span class="inline-code" id="1175324909#-jggmpr_138">stateKeeper</span>. Наш <span class="inline-code" id="1175324909#-jggmpr_139">DefaultCounterComponent</span> реализует интерфейс <span class="inline-code" id="1175324909#-jggmpr_140">ComponentContext</span>, а поле <span class="inline-code" id="1175324909#-jggmpr_141">stateKeeper</span> приходит из <span class="inline-code" id="1175324909#-jggmpr_142">StateKeeperOwner</span>. Полная цепочка наследования следующая:</p><div class="detached code-block" id="1175324909#-jggmpr_107"><pre><code class="language-kotlin">interface StateKeeperOwner {

    val stateKeeper: StateKeeper
}

interface GenericComponentContext&lt;out T : Any&gt; :
    LifecycleOwner,
    StateKeeperOwner,
    InstanceKeeperOwner,
    BackHandlerOwner,
    ComponentContextFactoryOwner&lt;T&gt;


interface ComponentContext : GenericComponentContext&lt;ComponentContext&gt;</code></pre></div><p id="1175324909#-jggmpr_108">Таким образом, цепочка наследования выглядит так: <span class="inline-code" id="1175324909#-jggmpr_143">StateKeeperOwner</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_144">GenericComponentContext</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_145">ComponentContext</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_146">DefaultCounterComponent</span>.</p><p id="1175324909#-jggmpr_109">Мы реализуем <span class="inline-code" id="1175324909#-jggmpr_147">ComponentContext</span>, делегируя его переданному в конструктор параметру <span class="inline-code" id="1175324909#-jggmpr_148">componentContext</span>.</p><div class="detached code-block" id="1175324909#-jggmpr_110"><pre><code class="language-kotlin">class DefaultCounterComponent(
    componentContext: ComponentContext
) : ComponentContext by componentContext {
    ...
}</code></pre></div><p id="1175324909#-jggmpr_111">А в <span class="inline-code" id="1175324909#-jggmpr_149">MainActivity</span> создаём <span class="inline-code" id="1175324909#-jggmpr_150">ComponentContext</span>, используя готовую extension-функцию <span class="inline-code" id="1175324909#-jggmpr_151">defaultComponentContext</span>, которая за нас уже создаёт <span class="inline-code" id="1175324909#-jggmpr_152">ComponentContext</span> со всеми нужными компонентами, вроде <span class="inline-code" id="1175324909#-jggmpr_153">StateKeeper</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_112"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        val counterComponent = DefaultCounterComponent(defaultComponentContext())
        ...
    }
}</code></pre></div></section><section class="detached"><h2 id="1175324909#-jggmpr_6" data-toc="-jggmpr_6#decompose-save-state-internal.md--jggmpr_6">Продолжаем разбор: цепочка до настоящего хранилища</h2><p id="1175324909#-jggmpr_154">Итак, мы уже увидели, как в компоненте вызываются <span class="inline-code" id="1175324909#-jggmpr_160">stateKeeper.consume()</span> и <span class="inline-code" id="1175324909#-jggmpr_161">stateKeeper.register()</span>, и знаем, что сам компонент получает <span class="inline-code" id="1175324909#-jggmpr_162">stateKeeper</span> через свой <span class="inline-code" id="1175324909#-jggmpr_163">ComponentContext</span>. Но что именно происходит между вызовом в <span class="inline-code" id="1175324909#-jggmpr_164">Activity</span>/<span class="inline-code" id="1175324909#-jggmpr_165">Fragment</span> и конечным хранилищем? Пройдёмся по цепочке, которую мы только что вывели из исходников.</p><section class="detached"><h3 id="1175324909#statekeeper" data-toc="statekeeper#decompose-save-state-internal.md-statekeeper">Как создаётся StateKeeper</h3><p id="1175324909#-jggmpr_167">В <span class="inline-code" id="1175324909#-jggmpr_174">Activity</span> (или <span class="inline-code" id="1175324909#-jggmpr_175">Fragment</span>) создаётся <span class="inline-code" id="1175324909#-jggmpr_176">DefaultComponentContext</span>, и ему передаётся результат вызова <span class="inline-code" id="1175324909#-jggmpr_177">defaultComponentContext()</span>. Заглянем внутрь:</p><div class="detached code-block" id="1175324909#-jggmpr_168"><pre><code class="language-kotlin">fun &lt;T&gt; T.defaultComponentContext(
    discardSavedState: Boolean = false,
    isStateSavingAllowed: () -&gt; Boolean = { true },
): DefaultComponentContext where
        T : SavedStateRegistryOwner, T : OnBackPressedDispatcherOwner, T : ViewModelStoreOwner, T : LifecycleOwner =
    defaultComponentContext(
        backHandler = BackHandler(onBackPressedDispatcher),
        discardSavedState = discardSavedState,
        isStateSavingAllowed = isStateSavingAllowed,
    )</code></pre></div><p id="1175324909#-jggmpr_169">Обратите внимание, что функция является расширением для <span class="inline-code" id="1175324909#-jggmpr_178">T</span>, где <span class="inline-code" id="1175324909#-jggmpr_179">T</span> должен быть объектом, реализующим интерфейсы <span class="inline-code" id="1175324909#-jggmpr_180">SavedStateRegistryOwner</span>, <span class="inline-code" id="1175324909#-jggmpr_181">OnBackPressedDispatcherOwner</span>, <span class="inline-code" id="1175324909#-jggmpr_182">ViewModelStoreOwner</span>, <span class="inline-code" id="1175324909#-jggmpr_183">LifecycleOwner</span>. Классы <span class="inline-code" id="1175324909#-jggmpr_184">ComponentActivity</span>, <span class="inline-code" id="1175324909#-jggmpr_185">FragmentActivity</span>, <span class="inline-code" id="1175324909#-jggmpr_186">AppCompatActivity</span> идеально подходят под эти требования.</p><p id="1175324909#-jggmpr_170">Внутри по сути просто собираются все нужные зависимости и прокидываются чуть дальше &mdash; в ещё одну функцию-обёртку, где уже инициализируется всё, что нужно для хранения состояния:</p><div class="detached code-block" id="1175324909#-jggmpr_171"><pre><code class="language-kotlin">private fun &lt;T&gt; T.defaultComponentContext(
    backHandler: BackHandler?,
    discardSavedState: Boolean,
    isStateSavingAllowed: () -&gt; Boolean,
): DefaultComponentContext where
        T : SavedStateRegistryOwner, T : ViewModelStoreOwner, T : LifecycleOwner {
    val stateKeeper = stateKeeper(discardSavedState = discardSavedState, isSavingAllowed = isStateSavingAllowed)
    ...
    return DefaultComponentContext(
        lifecycle = lifecycle.asEssentyLifecycle(),
        stateKeeper = stateKeeper,
        instanceKeeper = instanceKeeper(discardRetainedInstances = marker == null),
        backHandler = backHandler,
    )
}</code></pre></div><p id="1175324909#-jggmpr_172">Вот тут и начинается самое интересное &mdash; создаётся объект <span class="inline-code" id="1175324909#-jggmpr_187">StateKeeper</span> вызовом функции <span class="inline-code" id="1175324909#-jggmpr_188">stateKeeper</span> и пробрасывается дальше.</p></section><section class="detached"><h3 id="1175324909#statekeeper" data-toc="statekeeper#decompose-save-state-internal.md-statekeeper">Как создаётся сам StateKeeper</h3><p id="1175324909#-jggmpr_190">Теперь посмотрим, откуда взялся этот объект. Всё упирается в extension-функцию <span class="inline-code" id="1175324909#-jggmpr_196">stateKeeper</span>, которая является расширением для <span class="inline-code" id="1175324909#-jggmpr_197">SavedStateRegistryOwner</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_191"><pre><code class="language-kotlin">private const val KEY_STATE = &quot;STATE_KEEPER_STATE&quot;

fun SavedStateRegistryOwner.stateKeeper(
    discardSavedState: Boolean = false,
    isSavingAllowed: () -&gt; Boolean = { true },
): StateKeeper =
    stateKeeper(
        key = KEY_STATE,
        discardSavedState = discardSavedState,
        isSavingAllowed = isSavingAllowed,
    )</code></pre></div><p id="1175324909#-jggmpr_192">Здесь просто прокидывается ключ (по умолчанию <span class="inline-code" id="1175324909#-jggmpr_198">&quot;STATE_KEEPER_STATE&quot;</span>), и происходит вызов другого метода <span class="inline-code" id="1175324909#-jggmpr_199">stateKeeper</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_193"><pre><code class="language-kotlin">fun SavedStateRegistryOwner.stateKeeper(
    key: String,
    discardSavedState: Boolean = false,
    isSavingAllowed: () -&gt; Boolean = { true },
): StateKeeper =
    StateKeeper(
        savedStateRegistry = savedStateRegistry,
        key = key,
        discardSavedState = discardSavedState,
        isSavingAllowed = isSavingAllowed
    )</code></pre></div><p id="1175324909#-jggmpr_194">Тут мы уже явно вызываем конструктор <span class="inline-code" id="1175324909#-jggmpr_200">StateKeeper</span> (на самом деле это функция, а не класс). Сюда подаётся главный объект &mdash; <span class="inline-code" id="1175324909#-jggmpr_201">savedStateRegistry</span>. Да-да, тот самый из AndroidX, который находится внутри <span class="inline-code" id="1175324909#-jggmpr_202">Activity</span> и <span class="inline-code" id="1175324909#-jggmpr_203">Fragment</span> и используется системой для всех вызовов <span class="inline-code" id="1175324909#-jggmpr_204">onSaveInstanceState</span>.</p></section><section class="detached"><h3 id="1175324909#statekeeper" data-toc="statekeeper#decompose-save-state-internal.md-statekeeper">Что реально происходит внутри StateKeeper</h3><p id="1175324909#-jggmpr_206">Вот теперь мы приблизились к сути. <span class="inline-code" id="1175324909#-jggmpr_227">StateKeeper</span> &mdash; это функция, которая создаёт реальный объект интерфейса <span class="inline-code" id="1175324909#-jggmpr_228">StateKeeper</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_207"><pre><code class="language-kotlin">fun StateKeeper(
    savedStateRegistry: SavedStateRegistry,
    key: String,
    discardSavedState: Boolean = false,
    isSavingAllowed: () -&gt; Boolean = { true },
): StateKeeper {
    val dispatcher =
        StateKeeperDispatcher(
            savedState = savedStateRegistry
                .consumeRestoredStateForKey(key = key)
                ?.getSerializableContainer(key = KEY_STATE)
                ?.takeUnless { discardSavedState },
        )

    savedStateRegistry.registerSavedStateProvider(key = key) {
        Bundle().apply {
            if (isSavingAllowed()) {
                putSerializableContainer(key = KEY_STATE, value = dispatcher.save())
            }
        }
    }

    return dispatcher
}</code></pre></div><p id="1175324909#-jggmpr_208">Вот он &mdash; наш главный гейтвей между миром Android и системой сохранения состояния в Essenty/Decompose. Давайте по строчкам:</p><ul class="list" id="1175324909#-jggmpr_209" start="1"><li class="list-item" id="1175324909#-jggmpr_229"><p id="1175324909#-jggmpr_232">Извлекается ранее сохранённое состояние из <span class="inline-code" id="1175324909#-jggmpr_233">SavedStateRegistry</span> по ключу &mdash; по сути, из стандартного <span class="inline-code" id="1175324909#-jggmpr_234">Bundle</span>, в который Android сохраняет данные при onPause/onStop</p></li><li class="list-item" id="1175324909#-jggmpr_230"><p id="1175324909#-jggmpr_235">Создаётся объект <span class="inline-code" id="1175324909#-jggmpr_236">StateKeeperDispatcher</span> &mdash; это конкретная реализация интерфейса <span class="inline-code" id="1175324909#-jggmpr_237">StateKeeper</span>, которая умеет хранить сериализованные значения, зарегистрированные вручную, и при необходимости возвращать их обратно через <span class="inline-code" id="1175324909#-jggmpr_238">consume</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_231"><p id="1175324909#-jggmpr_239">Регистрируется новый <span class="inline-code" id="1175324909#-jggmpr_240">SavedStateProvider</span> &mdash; это лямбда, которую Android вызовет при необходимости сохранить состояние. Именно в ней <span class="inline-code" id="1175324909#-jggmpr_241">dispatcher.save()</span> собирает зарегистрированные значения и подготавливает их к сохранению.</p></li></ul><p id="1175324909#-jggmpr_210">Вызов <span class="inline-code" id="1175324909#-jggmpr_242">SavedStateRegistry.registerSavedStateProvider</span> здесь &mdash; точка подключения к системе восстановления Android. Он позволяет сохранить состояние <span class="inline-code" id="1175324909#-jggmpr_243">StateKeeperDispatcher</span> в <span class="inline-code" id="1175324909#-jggmpr_244">Bundle</span>, чтобы при следующем запуске его можно было восстановить. Весь этот механизм &mdash; адаптер между KMP-механикой сохранения и Android API.</p><p id="1175324909#-jggmpr_211">И вот тут вступает в игру <span class="inline-code" id="1175324909#-jggmpr_245">SerializableContainer</span>.</p><p id="1175324909#-jggmpr_212">Когда вызывается <span class="inline-code" id="1175324909#-jggmpr_246">dispatcher.save()</span>, все значения, зарегистрированные через <span class="inline-code" id="1175324909#-jggmpr_247">stateKeeper.register(...)</span>, сериализуются и оборачиваются в <span class="inline-code" id="1175324909#-jggmpr_248">SerializableContainer</span>.</p><p id="1175324909#-jggmpr_213">Это универсальная обёртка, которая хранит данные в виде <span class="inline-code" id="1175324909#-jggmpr_249">ByteArray</span>, а затем превращает их в строку с помощью <span class="inline-code" id="1175324909#-jggmpr_250">Base64</span>. Благодаря этому результат можно безопасно сохранить в <span class="inline-code" id="1175324909#-jggmpr_251">Bundle</span> как обычную строку &mdash; без <span class="inline-code" id="1175324909#-jggmpr_252">Parcelable</span>, <span class="inline-code" id="1175324909#-jggmpr_253">putSerializable()</span> и без Java <span class="inline-code" id="1175324909#-jggmpr_254">Serializable</span>. При восстановлении этот путь проходит в обратную сторону: строка &rarr; байты &rarr; объект через <span class="inline-code" id="1175324909#-jggmpr_255">kotlinx.serialization</span>.</p><p id="1175324909#-jggmpr_214">Таким образом, при вызове <span class="inline-code" id="1175324909#-jggmpr_256">dispatcher.save()</span> мы получаем сериализуемый контейнер, который можно безопасно положить в <span class="inline-code" id="1175324909#-jggmpr_257">Bundle</span>. И вот здесь важна не просто сериализация, а то, как именно она устроена. Это не <span class="inline-code" id="1175324909#-jggmpr_258">Parcelable</span>, и не <span class="inline-code" id="1175324909#-jggmpr_259">Serializable</span> &mdash; это <span class="inline-code" id="1175324909#-jggmpr_260">SerializableContainer</span>.</p><p id="1175324909#-jggmpr_215"><span class="inline-code" id="1175324909#-jggmpr_261">SerializableContainer</span> &mdash; это отдельная сущность, которая оборачивает объект и умеет работать с <span class="inline-code" id="1175324909#-jggmpr_262">kotlinx.serialization</span> напрямую. Она сама сериализуема, поскольку реализует <span class="inline-code" id="1175324909#-jggmpr_263">KSerializer</span>, и может быть сохранена в <span class="inline-code" id="1175324909#-jggmpr_264">Bundle</span> без дополнительных усилий. Ниже &mdash; её внутренняя реализация:</p><div class="detached code-block" id="1175324909#-jggmpr_216"><pre><code class="language-kotlin">@Serializable(with = SerializableContainer.Serializer::class)
class SerializableContainer private constructor(
    private var data: ByteArray?,
) {
    constructor() : this(data = null)

    private var holder: Holder&lt;*&gt;? = null

    fun &lt;T : Any&gt; consume(strategy: DeserializationStrategy&lt;T&gt;): T? {
        val consumedValue: Any? = holder?.value ?: data?.deserialize(strategy)
        holder = null
        data = null
        @Suppress(&quot;UNCHECKED_CAST&quot;) return consumedValue as T?
    }

    fun &lt;T : Any&gt; set(value: T?, strategy: SerializationStrategy&lt;T&gt;) {
        holder = Holder(value = value, strategy = strategy)
        data = null
    }

    private class Holder&lt;T : Any&gt;(
        val value: T?,
        val strategy: SerializationStrategy&lt;T&gt;,
    )

    internal object Serializer : KSerializer&lt;SerializableContainer&gt; {
        private const val NULL_MARKER = &quot;.&quot;
        override val descriptor = PrimitiveSerialDescriptor(&quot;SerializableContainer&quot;, PrimitiveKind.STRING)

        override fun serialize(encoder: Encoder, value: SerializableContainer) {
            val bytes = value.holder?.serialize() ?: value.data
            encoder.encodeString(bytes?.toBase64() ?: NULL_MARKER)
        }

        override fun deserialize(decoder: Decoder): SerializableContainer =
            SerializableContainer(data = decoder.decodeString().takeUnless { it == NULL_MARKER }?.base64ToByteArray())
    }
}</code></pre></div><p id="1175324909#-jggmpr_217">Что здесь важно:</p><ul class="list" id="1175324909#-jggmpr_218" start="1"><li class="list-item" id="1175324909#-jggmpr_265"><p id="1175324909#-jggmpr_268">В методе <span class="inline-code" id="1175324909#-jggmpr_269">set(...)</span> сохраняется объект и соответствующая стратегия сериализации, но не происходит немедленной сериализации.</p></li><li class="list-item" id="1175324909#-jggmpr_266"><p id="1175324909#-jggmpr_270">Только при вызове сериализатора (<span class="inline-code" id="1175324909#-jggmpr_271">Serializer</span>) объект превращается в <span class="inline-code" id="1175324909#-jggmpr_272">ByteArray</span>, а затем в строку.</p></li><li class="list-item" id="1175324909#-jggmpr_267"><p id="1175324909#-jggmpr_273">После восстановления &mdash; <span class="inline-code" id="1175324909#-jggmpr_274">decodeString()</span> &rarr; <span class="inline-code" id="1175324909#-jggmpr_275">ByteArray</span> &rarr; десериализация с использованием заранее известной стратегии.</p></li></ul><p id="1175324909#-jggmpr_219">Это даёт контроль над моментом сериализации и возможность отложенной обработки.</p><p id="1175324909#-jggmpr_220">Теперь о том, как это всё оказывается внутри <span class="inline-code" id="1175324909#-jggmpr_276">Bundle</span>. Ниже &mdash; вспомогательные функции, которые используются внутри библиотеки Essenty/Decompose для сериализации и десериализации <span class="inline-code" id="1175324909#-jggmpr_277">SerializableContainer</span> и произвольных объектов, вызовы которых мы уже встречали в фукнций StateKeeper:</p><div class="detached code-block" id="1175324909#-jggmpr_221"><pre><code class="language-kotlin">fun &lt;T : Any&gt; Bundle.putSerializable(key: String?, value: T?, strategy: SerializationStrategy&lt;T&gt;) {
    putParcelable(key, ValueHolder(value = value, bytes = lazy { value?.serialize(strategy) }))
}

fun &lt;T : Any&gt; Bundle.getSerializable(key: String?, strategy: DeserializationStrategy&lt;T&gt;): T? =
    getParcelableCompat&lt;ValueHolder&lt;T&gt;&gt;(key)?.let { holder -&gt;
        holder.value ?: holder.bytes.value?.deserialize(strategy)
    }

@Suppress(&quot;DEPRECATION&quot;)
private inline fun &lt;reified T : Parcelable&gt; Bundle.getParcelableCompat(key: String?): T? =
    classLoader.let { savedClassLoader -&gt;
        try {
            classLoader = T::class.java.classLoader
            getParcelable(key) as T?
        } finally {
            classLoader = savedClassLoader
        }
    }

fun Bundle.putSerializableContainer(key: String?, value: SerializableContainer?) {
    putSerializable(key = key, value = value, strategy = SerializableContainer.serializer())
}

fun Bundle.getSerializableContainer(key: String?): SerializableContainer? =
    getSerializable(key = key, strategy = SerializableContainer.serializer())</code></pre></div><p id="1175324909#-jggmpr_222">Отдельно стоит упомянуть сущность <span class="inline-code" id="1175324909#-jggmpr_278">ValueHolder</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_223"><pre><code class="language-kotlin">private class ValueHolder&lt;out T : Any&gt;(
    val value: T?,
    val bytes: Lazy&lt;ByteArray?&gt;,
) : Parcelable {
    override fun writeToParcel(dest: Parcel, flags: Int) {
        dest.writeByteArray(bytes.value)
    }

    override fun describeContents(): Int = 0

    companion object CREATOR : Parcelable.Creator&lt;ValueHolder&lt;Any&gt;&gt; {
        override fun createFromParcel(parcel: Parcel): ValueHolder&lt;Any&gt; =
            ValueHolder(value = null, bytes = lazyOf(parcel.createByteArray()))

        override fun newArray(size: Int): Array&lt;ValueHolder&lt;Any&gt;?&gt; =
            arrayOfNulls(size)
    }
}</code></pre></div><p id="1175324909#-jggmpr_224"><span class="inline-code" id="1175324909#-jggmpr_279">ValueHolder</span> здесь нужен для безопасной упаковки сериализованных байт в <span class="inline-code" id="1175324909#-jggmpr_280">Bundle</span> через <span class="inline-code" id="1175324909#-jggmpr_281">Parcelable</span>. Он не сериализует объект напрямую &mdash; он сохраняет только <span class="inline-code" id="1175324909#-jggmpr_282">ByteArray</span>, который позже может быть развёрнут обратно в объект через <span class="inline-code" id="1175324909#-jggmpr_283">kotlinx.serialization</span>. Истинная причина по которой нужен этот объект в том что Bundle может хранит Parcleable и Java Serializeble, но он не умеет напрямую работать с <span class="inline-code" id="1175324909#-jggmpr_284">kotlinx.serialization</span>, по этому он служит в качестве обертки.</p><p id="1175324909#-jggmpr_225">Таким образом, <span class="inline-code" id="1175324909#-jggmpr_285">SerializableContainer</span> + <span class="inline-code" id="1175324909#-jggmpr_286">ValueHolder</span> &mdash; это низкоуровневая инфраструктура сериализации, которая позволяет сохранить произвольные значения Kotlin Multiplatform без зависимостей на Android-специфичные интерфейсы, сохраняя кроссплатформенность и контроль над сериализацией.</p></section><section class="detached"><h3 id="1175324909#-jggmpr_158" data-toc="-jggmpr_158#decompose-save-state-internal.md--jggmpr_158">К чему это всё ведёт</h3><p id="1175324909#-jggmpr_287">То есть, по факту, <span class="inline-code" id="1175324909#-jggmpr_301">StateKeeper</span> &mdash; это просто адаптер между внутренней системой хранения состояния в Essenty/Decompose и системным <span class="inline-code" id="1175324909#-jggmpr_302">SavedStateRegistry</span> (а значит &mdash; тем самым <span class="inline-code" id="1175324909#-jggmpr_303">onSaveInstanceState</span> в <span class="inline-code" id="1175324909#-jggmpr_304">Activity</span>/<span class="inline-code" id="1175324909#-jggmpr_305">Fragment</span>, только более удобно и декларативно, и с поддержкой сериализации через <span class="inline-code" id="1175324909#-jggmpr_306">kotlinx.serialization</span>).</p><p id="1175324909#-jggmpr_288">Кратко по цепочке:</p><ol class="list list-decimal" id="1175324909#-jggmpr_289" type="1" start="1"><li class="list-item" id="1175324909#-jggmpr_307"><p id="1175324909#-jggmpr_311">В компоненте <span class="inline-code" id="1175324909#-jggmpr_312">DefaultCounterComponent</span> мы вызываем <span class="inline-code" id="1175324909#-jggmpr_313">consume</span>/<span class="inline-code" id="1175324909#-jggmpr_314">register</span> через интерфейс <span class="inline-code" id="1175324909#-jggmpr_315">StateKeeper</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_308"><p id="1175324909#-jggmpr_316"><span class="inline-code" id="1175324909#-jggmpr_317">StateKeeper</span> реализован как <span class="inline-code" id="1175324909#-jggmpr_318">StateKeeperDispatcher</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_309"><p id="1175324909#-jggmpr_319"><span class="inline-code" id="1175324909#-jggmpr_320">StateKeeperDispatcher</span> внутри себя хранит значения, сериализует их и регистрирует функцию для сохранения в системный <span class="inline-code" id="1175324909#-jggmpr_321">Bundle</span> через <span class="inline-code" id="1175324909#-jggmpr_322">SavedStateRegistry</span>. Важно понять, что значения, которые мы регистрируем в <span class="inline-code" id="1175324909#-jggmpr_323">StateKeeper</span>, не вызывают напрямую <span class="inline-code" id="1175324909#-jggmpr_324">savedStateRegistry.registerSavedStateProvider</span> и не создают отдельные <span class="inline-code" id="1175324909#-jggmpr_325">SavedStateProvider</span>'ы. Всё сохраняется централизованно &mdash; в одном объекте <span class="inline-code" id="1175324909#-jggmpr_326">StateKeeperDispatcher</span>, и только он регистрируется в <span class="inline-code" id="1175324909#-jggmpr_327">SavedStateRegistry</span>.</p></li><li class="list-item" id="1175324909#-jggmpr_310"><p id="1175324909#-jggmpr_328">Всё сериализуется и десериализуется через <span class="inline-code" id="1175324909#-jggmpr_329">kotlinx.serialization</span>, без <span class="inline-code" id="1175324909#-jggmpr_330">Parcelable</span>, <span class="inline-code" id="1175324909#-jggmpr_331">Bundle.putXXX()</span> и прочего boilerplate.</p></li></ol><p id="1175324909#-jggmpr_290">Посмотрим интерфейс <span class="inline-code" id="1175324909#-jggmpr_332">StateKeeper</span> и его прямого наследника <span class="inline-code" id="1175324909#-jggmpr_333">StateKeeperDispatcher</span>:</p><p id="1175324909#-jggmpr_291"><span class="control" id="1175324909#-jggmpr_334">com.arkivanov.essenty.statekeeper.StateKeeper.kt:</span></p><div class="detached code-block" id="1175324909#-jggmpr_292"><pre><code class="language-kotlin">interface StateKeeper {


    fun &lt;T : Any&gt; consume(key: String, strategy: DeserializationStrategy&lt;T&gt;): T?

    fun &lt;T : Any&gt; register(key: String, strategy: SerializationStrategy&lt;T&gt;, supplier: () -&gt; T?)

    fun unregister(key: String)

    fun isRegistered(key: String): Boolean
}</code></pre></div><ol class="list list-decimal" id="1175324909#-jggmpr_293" type="1" start="1"><li class="list-item" id="1175324909#-jggmpr_335"><p id="1175324909#-jggmpr_339"><span class="control" id="1175324909#-jggmpr_340"><span class="inline-code" id="1175324909#-jggmpr_341">consume</span></span> &mdash; извлекает и удаляет ранее сохранённое значение по заданному ключу, используя стратегию десериализации.</p></li><li class="list-item" id="1175324909#-jggmpr_336"><p id="1175324909#-jggmpr_342"><span class="control" id="1175324909#-jggmpr_343"><span class="inline-code" id="1175324909#-jggmpr_344">register</span></span> &mdash; регистрирует поставщика значения, которое будет сериализовано и сохранено при следующем сохранении состояния.</p></li><li class="list-item" id="1175324909#-jggmpr_337"><p id="1175324909#-jggmpr_345"><span class="control" id="1175324909#-jggmpr_346"><span class="inline-code" id="1175324909#-jggmpr_347">unregister</span></span> &mdash; удаляет ранее зарегистрированного поставщика, чтобы его значение больше не сохранялось.</p></li><li class="list-item" id="1175324909#-jggmpr_338"><p id="1175324909#-jggmpr_348"><span class="control" id="1175324909#-jggmpr_349"><span class="inline-code" id="1175324909#-jggmpr_351">isRegistered</span></span> &mdash; возвращает <span class="inline-code" id="1175324909#-jggmpr_350">true</span>, если по указанному ключу уже зарегистрирован поставщик значения.</p></li></ol><p id="1175324909#-jggmpr_294"><span class="control" id="1175324909#-jggmpr_352">com.arkivanov.essenty.statekeeper.StateKeeperDispatcher.kt:</span></p><div class="detached code-block" id="1175324909#-jggmpr_295"><pre><code class="language-kotlin">interface StateKeeperDispatcher : StateKeeper {

    fun save(): SerializableContainer
}

@JsName(&quot;stateKeeperDispatcher&quot;)
fun StateKeeperDispatcher(savedState: SerializableContainer? = null): StateKeeperDispatcher =
    DefaultStateKeeperDispatcher(savedState)</code></pre></div><p id="1175324909#-jggmpr_296">Метод <span class="inline-code" id="1175324909#-jggmpr_353">save()</span> в <span class="inline-code" id="1175324909#-jggmpr_354">StateKeeperDispatcher</span> &mdash; это тот самый метод, который мы уже встречали ранее: <span class="inline-code" id="1175324909#-jggmpr_355">dispatcher.save()</span>. Именно он вызывается в момент, когда Android собирается сохранить состояние активности или фрагмента, и через него сериализуются все зарегистрированные значения. Тут мы снова видим функцию <span class="inline-code" id="1175324909#-jggmpr_356">StateKeeperDispatcher</span>, которую уже встречали ранее. Напомню &mdash; это не класс, а фабричная функция, которая создаёт экземпляр <span class="inline-code" id="1175324909#-jggmpr_357">DefaultStateKeeperDispatcher</span> &mdash; единственную реализацию интерфейса <span class="inline-code" id="1175324909#-jggmpr_358">StateKeeperDispatcher</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_297"><pre><code class="language-kotlin">internal class DefaultStateKeeperDispatcher(
    savedState: SerializableContainer?,
) : StateKeeperDispatcher {

    private val savedState: MutableMap&lt;String, SerializableContainer&gt;? = savedState?.consume(strategy = SavedState.serializer())?.map
    private val suppliers = HashMap&lt;String, Supplier&lt;*&gt;&gt;()

    override fun save(): SerializableContainer {
        val map = savedState?.toMutableMap() ?: HashMap()

        suppliers.forEach { (key, supplier) -&gt;
            supplier.toSerializableContainer()?.also { container -&gt;
                map[key] = container
            }
        }

        return SerializableContainer(value = SavedState(map), strategy = SavedState.serializer())
    }

    private fun &lt;T : Any&gt; Supplier&lt;T&gt;.toSerializableContainer(): SerializableContainer? =
        supplier()?.let { value -&gt;
            SerializableContainer(value = value, strategy = strategy)
        }

    override fun &lt;T : Any&gt; consume(key: String, strategy: DeserializationStrategy&lt;T&gt;): T? =
        savedState
            ?.remove(key)
            ?.consume(strategy = strategy)

    override fun &lt;T : Any&gt; register(key: String, strategy: SerializationStrategy&lt;T&gt;, supplier: () -&gt; T?) {
        check(!isRegistered(key)) { &quot;Another supplier is already registered with the key: $key&quot; }
        suppliers[key] = Supplier(strategy = strategy, supplier = supplier)
    }

    override fun unregister(key: String) {
        check(isRegistered(key)) { &quot;No supplier is registered with the key: $key&quot; }
        suppliers -= key
    }

    override fun isRegistered(key: String): Boolean = key in suppliers

    private class Supplier&lt;T : Any&gt;(
        val strategy: SerializationStrategy&lt;T&gt;,
        val supplier: () -&gt; T?,
    )

    @Serializable
    private class SavedState(
        val map: MutableMap&lt;String, SerializableContainer&gt;
    )
}</code></pre></div><p id="1175324909#-jggmpr_298">Эта реализация управляет двумя основными структурами:</p><ul class="list" id="1175324909#-jggmpr_299" start="1"><li class="list-item" id="1175324909#-jggmpr_359"><p id="1175324909#-jggmpr_361"><span class="inline-code" id="1175324909#-jggmpr_362">savedState</span> &mdash; карта уже восстановленных значений из <span class="inline-code" id="1175324909#-jggmpr_363">SavedStateRegistry</span>, если они были сохранены ранее;</p></li><li class="list-item" id="1175324909#-jggmpr_360"><p id="1175324909#-jggmpr_364"><span class="inline-code" id="1175324909#-jggmpr_365">suppliers</span> &mdash; все зарегистрированные поставщики значений, которые должны быть сериализованы при следующем сохранении состояния.</p></li></ul><p id="1175324909#-jggmpr_300">Когда вызывается метод <span class="inline-code" id="1175324909#-jggmpr_366">save()</span>, он собирает все текущие значения из <span class="inline-code" id="1175324909#-jggmpr_367">suppliers</span>, сериализует их и упаковывает в <span class="inline-code" id="1175324909#-jggmpr_368">SerializableContainer</span>, который затем сохраняется системой. Восстановление происходит через метод <span class="inline-code" id="1175324909#-jggmpr_369">consume()</span>, где по ключу извлекается значение из <span class="inline-code" id="1175324909#-jggmpr_370">savedState</span> и десериализуется с помощью переданной стратегии.</p></section><section class="detached"><h3 id="1175324909#-jggmpr_159" data-toc="-jggmpr_159#decompose-save-state-internal.md--jggmpr_159">Вывод</h3><p id="1175324909#-jggmpr_371">Мы прошли весь путь &mdash; от компонента, использующего <span class="inline-code" id="1175324909#-jggmpr_379">stateKeeper.consume()</span> и <span class="inline-code" id="1175324909#-jggmpr_380">register()</span>, до конечного объекта, сериализуемого в <span class="inline-code" id="1175324909#-jggmpr_381">Bundle</span>. Разобрали, как <span class="inline-code" id="1175324909#-jggmpr_382">StateKeeper</span> цепляется к <span class="inline-code" id="1175324909#-jggmpr_383">SavedStateRegistry</span>, как значения хранятся внутри <span class="inline-code" id="1175324909#-jggmpr_384">StateKeeperDispatcher</span>, и как именно они сохраняются и восстанавливаются через сериализацию.</p><p id="1175324909#-jggmpr_372"><span class="inline-code" id="1175324909#-jggmpr_385">StateKeeper</span> &mdash; в android это обёртка над Android Saved State API, которая пришла на замену <span class="inline-code" id="1175324909#-jggmpr_386">onSaveInstanceState</span>, но реализована декларативно и кроссплатформенно. Она позволяет сохранять произвольные значения через <span class="inline-code" id="1175324909#-jggmpr_387">kotlinx.serialization</span>, без использования <span class="inline-code" id="1175324909#-jggmpr_388">Parcelable</span>, <span class="inline-code" id="1175324909#-jggmpr_389">Bundle.putX</span>, reflection и других низкоуровневых деталей.</p><p id="1175324909#-jggmpr_373">Давайте визуально глянем на цепочку вызовов что бы понять работу StateKeeper:</p><p id="1175324909#-jggmpr_374"><span class="control" id="1175324909#-jggmpr_390"><span class="inline-code" id="1175324909#-jggmpr_391">StateKeeper.register(...)</span></span>:</p><div class="detached code-block" id="1175324909#-jggmpr_375"><pre><code class="language-none">DefaultCounterComponent  
  └── stateKeeper.register(...)  
        └── StateKeeper (интерфейс)  
              └── StateKeeperDispatcher (интерфейс)  
                    └── DefaultStateKeeperDispatcher.register(...)  
                          └── suppliers[key] = Supplier(...)

StateKeeper(...) // создание при инициализации  
  └── SavedStateRegistry.registerSavedStateProvider(&quot;state_keeper_key&quot;)  
        └── dispatcher.save()  
              └── сериализация значений через kotlinx.serialization  
                    └── оборачивание в SerializableContainer  
                          └── Bundle.putSerializable(&quot;state&quot;, ...)</code></pre></div><p id="1175324909#-jggmpr_376"><span class="control" id="1175324909#-jggmpr_392"><span class="inline-code" id="1175324909#-jggmpr_393">StateKeeper.consume(...)</span></span>:</p><div class="detached code-block" id="1175324909#-jggmpr_377"><pre><code class="language-none">defaultComponentContext()  
  └── stateKeeper(...)  
        └── StateKeeper(...)  
              └── StateKeeperDispatcher(savedState = ...)  
                    └── DefaultStateKeeperDispatcher.consume(key, strategy)  
                          └── savedState.remove(key)?.consume(strategy)  
                                └── SerializableContainer.consume(strategy)  
                                      └── kotlinx.serialization.decodeFromByteArray(...)</code></pre></div><p id="1175324909#-jggmpr_378">Теперь разберём другой механизм сохранения состояния в Decompose &mdash; точнее, в библиотеке <span class="control" id="1175324909#-jggmpr_394">Essenty</span>, на которой всё построено.</p></section></section><section class="detached"><h2 id="1175324909#instancekeeper" data-toc="instancekeeper#decompose-save-state-internal.md-instancekeeper">InstanceKeeper</h2><p id="1175324909#-jggmpr_395"><span class="control" id="1175324909#-jggmpr_448">InstanceKeeper</span> &mdash; это один из &quot;всадников&quot; <span class="inline-code" id="1175324909#-jggmpr_449">ComponentContext</span>. Его задача &mdash; сохранять произвольные объекты, которые не должны уничтожаться при конфигурационных изменениях (например, при повороте экрана). Это аналог <span class="inline-code" id="1175324909#-jggmpr_450">ViewModel</span> из Android Jetpack, но в контексте кроссплатформенной разработки (KMP).</p><p id="1175324909#-jggmpr_396">Переделаем наш компонент <span class="inline-code" id="1175324909#-jggmpr_451">DefaultCounterComponent</span>, чтобы вместо <span class="inline-code" id="1175324909#-jggmpr_452">StateKeeper</span> использовать <span class="inline-code" id="1175324909#-jggmpr_453">InstanceKeeper</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_397"><pre><code class="language-kotlin">class DefaultCounterComponent(
    componentContext: ComponentContext
) : ComponentContext by componentContext {

    val model: StateFlow&lt;Int&gt; field = instanceKeeper.getOrCreate(
        key = KEY,
        factory = {
            object : InstanceKeeper.Instance {
                val state = MutableStateFlow(0)
            }
        }
    ).state

    fun increase() {
        model.value++
    }

    fun decrease() {
        model.value--
    }

    companion object {
        private const val KEY = &quot;counter_state&quot;
    }
}</code></pre></div><blockquote class="prompt flex bordered-element-rounded tip detached">
  <svg xmlns="http://www.w3.org/2000/svg" class="prompt-icon">
    <path d="M12.946 3.552L21.52 18.4c.424.735.33 1.6-.519 1.6H3.855c-.85 0-1.817-.865-1.392-1.6l8.573-14.848a1.103 1.103 0 0 1 1.91 0zm.545 12.948a1.5 1.5 0 1 0-1.5 1.5 1.5 1.5 0 0 0 1.5-1.5zM13 8h-2v5h2z"></path>
  </svg>
  <div class="prompt-content prompt-content-p"><p>Обратите внимание: блок `init` был удалён, а изменена только переменная `model`. Всё остальное осталось без изменений.</p></div>
</blockquote>
<p id="1175324909#-jggmpr_399">Теперь давайте проверим поведение визуально:</p><ol class="list list-decimal" id="1175324909#-jggmpr_400" type="1" start="1"><li class="list-item" id="1175324909#-jggmpr_454"><p id="1175324909#-jggmpr_456">Как будет вести себя счётчик при изменении конфигурации (именно повороте экрана).</p></li><li class="list-item" id="1175324909#-jggmpr_455"><p id="1175324909#-jggmpr_457">Как будет вести себя счётчик при уничтожении процесса, когда приложение находится в фоне.</p></li></ol><div class="container"><figure class="image-container"><img class="center bordered-element image image-size" id="1175324909#-jggmpr_401" alt="Screenshot" title="Screenshot" src="/Users/osman/jetbrains/WritersideProjects/insider/Writerside/images/instanceKeeper.gif" width="800" height="758"><figcaption class="center-text">Screenshot</figcaption></figure></div><p id="1175324909#-jggmpr_402">Что мы видим? Счётчик переживает поворот экрана, но обнуляется при смерти процесса. Это как раз поведение <span class="inline-code" id="1175324909#-jggmpr_458">ViewModel</span>, и именно этого мы ожидаем от <span class="inline-code" id="1175324909#-jggmpr_459">InstanceKeeper</span>.</p><p id="1175324909#-jggmpr_403">Теперь давайте посмотрим, как эта конструкция работает под капотом.</p><p id="1175324909#-jggmpr_404">Для начала определим, кто вообще отвечает за хранение <span class="inline-code" id="1175324909#-jggmpr_460">InstanceKeeper</span>. В Essenty (и, соответственно, в Decompose) это интерфейс:</p><div class="detached code-block" id="1175324909#-jggmpr_405"><pre><code class="language-kotlin">/**
 * Represents a holder of [InstanceKeeper].
 */
interface InstanceKeeperOwner {

    val instanceKeeper: InstanceKeeper
}</code></pre></div><p id="1175324909#-jggmpr_406">Он реализуется в <span class="inline-code" id="1175324909#-jggmpr_461">GenericComponentContext</span>, а значит, и в <span class="inline-code" id="1175324909#-jggmpr_462">ComponentContext</span>, который используется в каждом компоненте:</p><div class="detached code-block" id="1175324909#-jggmpr_407"><pre><code class="language-kotlin">interface GenericComponentContext&lt;out T : Any&gt; :
    LifecycleOwner,
    StateKeeperOwner,
    InstanceKeeperOwner,
    BackHandlerOwner,
    ComponentContextFactoryOwner&lt;T&gt;

interface ComponentContext : GenericComponentContext&lt;ComponentContext&gt;</code></pre></div><p id="1175324909#-jggmpr_408">Таким образом, цепочка наследования выглядит так: <span class="inline-code" id="1175324909#-jggmpr_463">InstanceKeeperOwner</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_464">GenericComponentContext</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_465">ComponentContext</span> &larr; <span class="inline-code" id="1175324909#-jggmpr_466">DefaultCounterComponent</span>.</p><p id="1175324909#-jggmpr_409">Теперь разберёмся, <span class="control" id="1175324909#-jggmpr_467">откуда приходит реализация</span>.</p><p id="1175324909#-jggmpr_410">В <span class="inline-code" id="1175324909#-jggmpr_468">MainActivity</span> мы создаём компонент верхнего уровня через функцию <span class="inline-code" id="1175324909#-jggmpr_469">defaultComponentContext()</span>. Именно она формирует <span class="inline-code" id="1175324909#-jggmpr_470">ComponentContext</span>, внедряя внутрь все нужные зависимости: <span class="inline-code" id="1175324909#-jggmpr_471">Lifecycle</span>, <span class="inline-code" id="1175324909#-jggmpr_472">StateKeeper</span>, <span class="inline-code" id="1175324909#-jggmpr_473">InstanceKeeper</span>, <span class="inline-code" id="1175324909#-jggmpr_474">BackHandler</span>.</p><div class="detached code-block" id="1175324909#-jggmpr_411"><pre><code class="language-kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        val counterComponent = DefaultCounterComponent(defaultComponentContext())
        ...
    }
}</code></pre></div><p id="1175324909#-jggmpr_412">Посмотрим ещё раз на исходники <span class="inline-code" id="1175324909#-jggmpr_475">defaultComponentContext()</span>:</p><div class="detached code-block" id="1175324909#-jggmpr_413"><pre><code class="language-kotlin">fun &lt;T&gt; T.defaultComponentContext(
    discardSavedState: Boolean = false,
    isStateSavingAllowed: () -&gt; Boolean = { true },
): DefaultComponentContext where
        T : SavedStateRegistryOwner, T : OnBackPressedDispatcherOwner, T : ViewModelStoreOwner, T : LifecycleOwner =
    defaultComponentContext(
        backHandler = BackHandler(onBackPressedDispatcher),
        discardSavedState = discardSavedState,
        isStateSavingAllowed = isStateSavingAllowed,
    )</code></pre></div><p id="1175324909#-jggmpr_414">На этом уровне происходит лишь проксирование вызова &mdash; все зависимости собираются и передаются дальше, в приватную функцию:</p><div class="detached code-block" id="1175324909#-jggmpr_415"><pre><code class="language-kotlin">private fun &lt;T&gt; T.defaultComponentContext(
    backHandler: BackHandler?,
    discardSavedState: Boolean,
    isStateSavingAllowed: () -&gt; Boolean,
): DefaultComponentContext where
        T : SavedStateRegistryOwner, T : ViewModelStoreOwner, T : LifecycleOwner {
    ...
    return DefaultComponentContext(
        lifecycle = lifecycle.asEssentyLifecycle(),
        stateKeeper = stateKeeper,
        instanceKeeper = instanceKeeper(discardRetainedInstances = marker == null),
        backHandler = backHandler,
    )
}</code></pre></div><p id="1175324909#-jggmpr_416">Ключевая строка здесь &mdash; <span class="inline-code" id="1175324909#-jggmpr_476">instanceKeeper = instanceKeeper(...)</span>.</p><p id="1175324909#-jggmpr_417">Это и есть та самая точка, где создаётся (или восстанавливается) <span class="inline-code" id="1175324909#-jggmpr_477">InstanceKeeper</span>. Теперь наша задача &mdash; разобраться, что это за функция <span class="inline-code" id="1175324909#-jggmpr_478">instanceKeeper(...)</span>, как она устроена и как реализована логика хранения внутри.</p><p id="1175324909#-jggmpr_418">Начнём с того, что <span class="inline-code" id="1175324909#-jggmpr_479">instanceKeeper</span> &mdash; это функция-расширение для <span class="inline-code" id="1175324909#-jggmpr_480">ViewModelStoreOwner</span>. Она становится доступной внутри <span class="inline-code" id="1175324909#-jggmpr_481">defaultComponentContext</span>, потому что его дженерик явно требует, чтобы вызывающий объект реализовывал интерфейс <span class="inline-code" id="1175324909#-jggmpr_482">ViewModelStoreOwner</span>. Это условие обеспечивает доступ к <span class="inline-code" id="1175324909#-jggmpr_483">ViewModelStore</span>, который и передаётся внутрь <span class="inline-code" id="1175324909#-jggmpr_484">InstanceKeeper(...)</span>. Вот сигнатура этой функции:</p><div class="detached code-block" id="1175324909#-jggmpr_419"><pre><code class="language-kotlin">/**
 * Creates a new instance of [InstanceKeeper] and attaches it to the AndroidX [ViewModelStore].
 *
 * @param discardRetainedInstances a flag indicating whether any previously retained instances should be
 * discarded and destroyed or not, default value is `false`.
 */
fun ViewModelStoreOwner.instanceKeeper(discardRetainedInstances: Boolean = false): InstanceKeeper =
    InstanceKeeper(viewModelStore = viewModelStore, discardRetainedInstances = discardRetainedInstances)</code></pre></div><p id="1175324909#-jggmpr_420">На первый взгляд кажется, что <span class="inline-code" id="1175324909#-jggmpr_485">InstanceKeeper</span> &mdash; это класс, но в данном случае это вовсе не конструктор, а функция, возвращающая реализацию интерфейса <span class="inline-code" id="1175324909#-jggmpr_486">InstanceKeeper</span>. Вот как она устроена:</p><div class="detached code-block" id="1175324909#-jggmpr_421"><pre><code class="language-kotlin">/**
 * Creates a new instance of [InstanceKeeper] and attaches it to the provided AndroidX [ViewModelStore].
 *
 * @param discardRetainedInstances a flag indicating whether any previously retained instances should be
 * discarded and destroyed or not, default value is `false`.
 */
fun InstanceKeeper(
    viewModelStore: ViewModelStore,
    discardRetainedInstances: Boolean = false,
): InstanceKeeper =
    ViewModelProvider(
        viewModelStore,
        object : ViewModelProvider.Factory {
            @Suppress(&quot;UNCHECKED_CAST&quot;)
            override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T = InstanceKeeperViewModel() as T
        }
    )
        .get&lt;InstanceKeeperViewModel&gt;()
        .apply {
            if (discardRetainedInstances) {
                recreate()
            }
        }
        .instanceKeeperDispatcher</code></pre></div><p id="1175324909#-jggmpr_422">Теперь становится понятно: реализация <span class="inline-code" id="1175324909#-jggmpr_487">InstanceKeeper</span> на Android напрямую завязана на <span class="inline-code" id="1175324909#-jggmpr_488">ViewModelStore</span>. Концепция долгоживущих объектов реализована здесь через обёртку вокруг обычной <span class="inline-code" id="1175324909#-jggmpr_489">ViewModel</span>.</p><p id="1175324909#-jggmpr_423">Создаётся <span class="inline-code" id="1175324909#-jggmpr_490">InstanceKeeperViewModel</span>, и далее из неё извлекается <span class="inline-code" id="1175324909#-jggmpr_491">instanceKeeperDispatcher</span>, который и возвращается как <span class="inline-code" id="1175324909#-jggmpr_492">InstanceKeeper</span>.</p><p id="1175324909#-jggmpr_424">Само API на первый взгляд кажется абстрактным и независимым от Android, но под капотом &mdash; чистый <span class="inline-code" id="1175324909#-jggmpr_493">ViewModel</span>. Причём внутри всей этой логики нет даже намёка на то, что используется Android ViewModel &mdash; всё скрыто за интерфейсом <span class="inline-code" id="1175324909#-jggmpr_494">InstanceKeeper</span>.</p><p id="1175324909#-jggmpr_425">Вот как устроена InstanceKeeperViewModel:</p><div class="detached code-block" id="1175324909#-jggmpr_426"><pre><code class="language-kotlin">internal class InstanceKeeperViewModel : ViewModel() {
    var instanceKeeperDispatcher: InstanceKeeperDispatcher = InstanceKeeperDispatcher()
        private set

    override fun onCleared() {
        instanceKeeperDispatcher.destroy()
    }

    fun recreate() {
        instanceKeeperDispatcher.destroy()
        instanceKeeperDispatcher = InstanceKeeperDispatcher()
    }
}</code></pre></div><p id="1175324909#-jggmpr_427">Что здесь важно:</p><ul class="list" id="1175324909#-jggmpr_428" start="1"><li class="list-item" id="1175324909#-jggmpr_495"><p id="1175324909#-jggmpr_498"><span class="inline-code" id="1175324909#-jggmpr_499">instanceKeeperDispatcher</span> &mdash; это и есть хранилище всех зарегистрированных экземпляров (<span class="inline-code" id="1175324909#-jggmpr_500">InstanceKeeper.Instance</span>).</p></li><li class="list-item" id="1175324909#-jggmpr_496"><p id="1175324909#-jggmpr_501">Метод <span class="inline-code" id="1175324909#-jggmpr_502">onCleared()</span> вызывается, когда ViewModel удаляется из <span class="inline-code" id="1175324909#-jggmpr_503">ViewModelStore</span>. Он вызывает <span class="inline-code" id="1175324909#-jggmpr_504">destroy()</span> у <span class="inline-code" id="1175324909#-jggmpr_505">dispatcher</span>, уничтожая все зарегистрированные экземпляры.</p></li><li class="list-item" id="1175324909#-jggmpr_497"><p id="1175324909#-jggmpr_506">Метод <span class="inline-code" id="1175324909#-jggmpr_507">recreate()</span> позволяет вручную сбросить все ранее сохранённые экземпляры &mdash; полезно, если нужно очистить состояние при пересоздании компонента.</p></li></ul><p id="1175324909#-jggmpr_429">После того как мы поняли, что <span class="inline-code" id="1175324909#-jggmpr_508">InstanceKeeperViewModel</span> возвращает <span class="inline-code" id="1175324909#-jggmpr_509">instanceKeeperDispatcher</span>, возникает логичный вопрос &mdash; что он из себя представляет.</p><div class="detached code-block" id="1175324909#-jggmpr_430"><pre><code class="language-kotlin">/**
 * Represents a destroyable [InstanceKeeper].
 */
interface InstanceKeeperDispatcher : InstanceKeeper {

    /**
     * Destroys all existing instances. Instances are not cleared, so that they can be
     * accessed later. Any new instances will be immediately destroyed.
     */
    fun destroy()
}</code></pre></div><p id="1175324909#-jggmpr_431"><span class="inline-code" id="1175324909#-jggmpr_510">InstanceKeeperDispatcher</span> &mdash; это интерфейс, расширяющий <span class="inline-code" id="1175324909#-jggmpr_511">InstanceKeeper</span> и добавляющий к нему жизненно важную функцию <span class="inline-code" id="1175324909#-jggmpr_512">destroy()</span>. Она уничтожает все текущие экземпляры <span class="inline-code" id="1175324909#-jggmpr_513">Instance</span>, но не очищает их из внутреннего хранилища &mdash; к ним всё ещё можно обращаться при необходимости. Однако любые новые экземпляры, созданные после вызова <span class="inline-code" id="1175324909#-jggmpr_514">destroy()</span>, уничтожаются сразу.</p><p id="1175324909#-jggmpr_432">Метод <span class="inline-code" id="1175324909#-jggmpr_515">destroy()</span> вызывается системой тогда, когда жизненный цикл компонента подходит к концу &mdash; например, при полном удалении из back stack. Это позволяет вовремя освободить ресурсы и завершить фоновые задачи.</p><p id="1175324909#-jggmpr_433">Реализация создаётся через фабричную функцию:</p><div class="detached code-block" id="1175324909#-jggmpr_434"><pre><code class="language-kotlin">/**
 * Creates a default implementation of [InstanceKeeperDispatcher].
 */
@JsName(&quot;instanceKeeperDispatcher&quot;)
fun InstanceKeeperDispatcher(): InstanceKeeperDispatcher = DefaultInstanceKeeperDispatcher()</code></pre></div><p id="1175324909#-jggmpr_435">Теперь разберём, что собой представляет сам <span class="inline-code" id="1175324909#-jggmpr_516">InstanceKeeper</span>.</p><div class="detached code-block" id="1175324909#-jggmpr_436"><pre><code class="language-kotlin">/**
 * A generic keyed store of [Instance] objects. Instances are destroyed at the end of the
 * [InstanceKeeper]'s scope, which is typically tied to the scope of a back stack entry.
 * E.g. instances are retained over Android configuration changes, and destroyed when the
 * corresponding back stack entry is popped.
 */
interface InstanceKeeper {

    fun get(key: Any): Instance?

    fun put(key: Any, instance: Instance)

    fun remove(key: Any): Instance?

    interface Instance {
        fun onDestroy() {}
    }

    class SimpleInstance&lt;out T&gt;(val instance: T) : Instance
}</code></pre></div><p id="1175324909#-jggmpr_437"><span class="inline-code" id="1175324909#-jggmpr_517">InstanceKeeper</span> &mdash; это ключевое хранилище долгоживущих объектов, которые переживают конфигурационные изменения, но уничтожаются при окончательном завершении жизненного цикла компонента. Типичный пример &mdash; удаление элемента из back stack.</p><p id="1175324909#-jggmpr_438">Хранилище работает по принципу <span class="inline-code" id="1175324909#-jggmpr_518">key -&gt; Instance</span> и предоставляет методы для получения, сохранения и удаления объектов.</p><p id="1175324909#-jggmpr_439">Сам интерфейс <span class="inline-code" id="1175324909#-jggmpr_519">Instance</span> минимален: чтобы объект стал управляемым, нужно реализовать единственный метод <span class="inline-code" id="1175324909#-jggmpr_520">onDestroy()</span>. Он будет вызван системой при уничтожении компонента &mdash; это аналог <span class="inline-code" id="1175324909#-jggmpr_521">onCleared()</span> у <span class="inline-code" id="1175324909#-jggmpr_522">ViewModel</span>, но с более гибким контролем.</p><p id="1175324909#-jggmpr_440">А для случаев, когда никакая очистка не требуется, можно использовать обёртку <span class="inline-code" id="1175324909#-jggmpr_523">SimpleInstance</span>. Она реализует <span class="inline-code" id="1175324909#-jggmpr_524">Instance</span>, но ничего не делает в <span class="inline-code" id="1175324909#-jggmpr_525">onDestroy()</span> &mdash; просто превращает любой объект в совместимый с <span class="inline-code" id="1175324909#-jggmpr_526">InstanceKeeper</span>.</p><p id="1175324909#-jggmpr_441">Теперь давай посмотрим, как работает сама реализация хранилища:</p><div class="detached code-block" id="1175324909#-jggmpr_442"><pre><code class="language-kotlin">internal class DefaultInstanceKeeperDispatcher : InstanceKeeperDispatcher {

    private val map = HashMap&lt;Any, Instance&gt;()
    private var isDestroyed = false

    override fun get(key: Any): Instance? =
        map[key]

    override fun put(key: Any, instance: Instance) {
        check(key !in map) { &quot;Another instance is already associated with the key: $key&quot; }

        map[key] = instance

        if (isDestroyed) {
            instance.onDestroy()
        }
    }

    override fun remove(key: Any): Instance? =
        map.remove(key)

    override fun destroy() {
        if (!isDestroyed) {
            isDestroyed = true
            map.values.toList().forEach(Instance::onDestroy)
        }
    }
}</code></pre></div><p id="1175324909#-jggmpr_443"><span class="inline-code" id="1175324909#-jggmpr_527">DefaultInstanceKeeperDispatcher</span> &mdash; это конкретная реализация <span class="inline-code" id="1175324909#-jggmpr_528">InstanceKeeperDispatcher</span>. Внутри у него обычная <span class="inline-code" id="1175324909#-jggmpr_529">HashMap</span>, где по ключу хранятся все текущие <span class="inline-code" id="1175324909#-jggmpr_530">Instance</span>. Метод <span class="inline-code" id="1175324909#-jggmpr_531">put()</span> добавляет объект, предварительно проверяя, что ключ не занят. Флаг <span class="inline-code" id="1175324909#-jggmpr_532">isDestroyed</span> позволяет отслеживать, завершена ли уже работа хранилища &mdash; если <span class="inline-code" id="1175324909#-jggmpr_533">true</span>, то даже только что добавленный объект сразу уничтожается через <span class="inline-code" id="1175324909#-jggmpr_534">onDestroy()</span>.</p><p id="1175324909#-jggmpr_444">Метод <span class="inline-code" id="1175324909#-jggmpr_535">destroy()</span> проходит по всем зарегистрированным объектам и вызывает <span class="inline-code" id="1175324909#-jggmpr_536">onDestroy()</span> у каждого. При этом сами объекты остаются в <span class="inline-code" id="1175324909#-jggmpr_537">map</span>, чтобы, если нужно, можно было к ним обратиться позже &mdash; хотя новые уже не будут жить.</p><p id="1175324909#-jggmpr_445">Теперь &mdash; о том, что мы используем в нашем компоненте <span class="inline-code" id="1175324909#-jggmpr_538">DefaultCounterComponent</span>. Там вызывается не <span class="inline-code" id="1175324909#-jggmpr_539">put</span>, а <span class="inline-code" id="1175324909#-jggmpr_540">getOrCreate</span>, и вот как он работает:</p><div class="detached code-block" id="1175324909#-jggmpr_446"><pre><code class="language-kotlin">inline fun &lt;T : InstanceKeeper.Instance&gt; InstanceKeeper.getOrCreate(key: Any, factory: () -&gt; T): T {
    @Suppress(&quot;UNCHECKED_CAST&quot;)
    var instance: T? = get(key) as T?
    if (instance == null) {
        instance = factory()
        put(key, instance)
    }

    return instance
}</code></pre></div><p id="1175324909#-jggmpr_447">Метод <span class="inline-code" id="1175324909#-jggmpr_541">getOrCreate()</span> &mdash; это удобный хелпер: сначала он пробует достать объект по ключу, и если такого ещё нет, &mdash; создаёт его через <span class="inline-code" id="1175324909#-jggmpr_542">factory()</span> и сохраняет. Используется он в 90% случаев, потому что избавляет от ручной проверки наличия и двойного кода.</p></section><section class="detached"><h2 id="1175324909#defaultcomponentcontext" data-toc="defaultcomponentcontext#decompose-save-state-internal.md-defaultcomponentcontext">DefaultComponentContext</h2><p id="1175324909#-jggmpr_543">На протяжении всей статьи мы много раз касались функции <span class="inline-code" id="1175324909#-jggmpr_549">defaultComponentContext()</span> &mdash; именно она выступает точкой входа, где собираются все зависимости компонента:</p><div class="detached code-block" id="1175324909#-jggmpr_544"><pre><code class="language-kotlin">private fun &lt;T&gt; T.defaultComponentContext(
    backHandler: BackHandler?,
    discardSavedState: Boolean,
    isStateSavingAllowed: () -&gt; Boolean,
): DefaultComponentContext where
        T : SavedStateRegistryOwner, T : ViewModelStoreOwner, T : LifecycleOwner {
    val stateKeeper = stateKeeper(discardSavedState = discardSavedState, isSavingAllowed = isStateSavingAllowed)
    val marker = stateKeeper.consume(key = KEY_STATE_MARKER, strategy = String.serializer())
    stateKeeper.register(key = KEY_STATE_MARKER, strategy = String.serializer()) { &quot;marker&quot; }

    return DefaultComponentContext(
        lifecycle = lifecycle.asEssentyLifecycle(),
        stateKeeper = stateKeeper,
        instanceKeeper = instanceKeeper(discardRetainedInstances = marker == null),
        backHandler = backHandler,
    )
}

private const val KEY_STATE_MARKER = &quot;DefaultComponentContext_state_marker&quot;</code></pre></div><p id="1175324909#-jggmpr_545">Мы уже детально разобрали, откуда здесь берётся <span class="inline-code" id="1175324909#-jggmpr_550">StateKeeper</span>, как создаётся <span class="inline-code" id="1175324909#-jggmpr_551">InstanceKeeper</span>, и какую роль играет <span class="inline-code" id="1175324909#-jggmpr_552">marker</span>. Но до сих пор мы не смотрели внутрь самого <span class="inline-code" id="1175324909#-jggmpr_553">DefaultComponentContext</span> &mdash; давай это исправим:</p><div class="detached code-block" id="1175324909#-jggmpr_546"><pre><code class="language-kotlin">class DefaultComponentContext(
    override val lifecycle: Lifecycle,
    stateKeeper: StateKeeper? = null,
    instanceKeeper: InstanceKeeper? = null,
    backHandler: BackHandler? = null,
) : ComponentContext {

    override val stateKeeper: StateKeeper = stateKeeper ?: StateKeeperDispatcher()
    override val instanceKeeper: InstanceKeeper = instanceKeeper ?: InstanceKeeperDispatcher().attachTo(lifecycle)
    override val backHandler: BackHandler = backHandler ?: BackDispatcher()
    override val componentContextFactory: ComponentContextFactory&lt;ComponentContext&gt; =
        ComponentContextFactory(::DefaultComponentContext)

    constructor(lifecycle: Lifecycle) : this(
        lifecycle = lifecycle,
        stateKeeper = null,
        instanceKeeper = null,
        backHandler = null,
    )
}</code></pre></div><p id="1175324909#-jggmpr_547">Как видно, <span class="inline-code" id="1175324909#-jggmpr_554">DefaultComponentContext</span> &mdash; это просто удобный бандл, который объединяет в себе <span class="inline-code" id="1175324909#-jggmpr_555">Lifecycle</span>, <span class="inline-code" id="1175324909#-jggmpr_556">StateKeeper</span>, <span class="inline-code" id="1175324909#-jggmpr_557">InstanceKeeper</span> и <span class="inline-code" id="1175324909#-jggmpr_558">BackHandler</span>. Если какие-то зависимости не были переданы извне &mdash; он сам создаёт дефолтные реализации. Всё это обёрнуто в единый объект <span class="inline-code" id="1175324909#-jggmpr_559">ComponentContext</span>, который дальше передаётся в компоненты и навигационные структуры.</p><p id="1175324909#-jggmpr_548">Таким образом, <span class="inline-code" id="1175324909#-jggmpr_560">DefaultComponentContext</span> можно считать связующим звеном между Android-инфраструктурой и кроссплатформенной архитектурой Decompose &mdash; он превращает низкоуровневые сущности в универсальный интерфейс.</p></section><section class="detached"><h2 id="1175324909#-jggmpr_9" data-toc="-jggmpr_9#decompose-save-state-internal.md--jggmpr_9">Финал</h2><p id="1175324909#-jggmpr_561">Если вы дошли до этого момента &mdash; значит, прошли со мной весь путь по хранению состояний в Android на глубоком, подкапотном уровне: от того, где реально живёт <span class="inline-code" id="1175324909#-jggmpr_565">ViewModelStore</span> в <span class="inline-code" id="1175324909#-jggmpr_566">Activity</span> и <span class="inline-code" id="1175324909#-jggmpr_567">Fragment</span>, до того, как <span class="inline-code" id="1175324909#-jggmpr_568">ViewModel</span> хранятся в <span class="inline-code" id="1175324909#-jggmpr_569">Compose</span> и <span class="inline-code" id="1175324909#-jggmpr_570">View</span>, как работает <span class="inline-code" id="1175324909#-jggmpr_571">Saved State API</span>, чем отличается от <span class="inline-code" id="1175324909#-jggmpr_572">onSaveInstanceState</span>, и где в итоге оказывается <span class="inline-code" id="1175324909#-jggmpr_573">Bundle</span>.</p><p id="1175324909#-jggmpr_562">В последней части мы разобрали, как устроена логика сохранения состояния в <span class="inline-code" id="1175324909#-jggmpr_574">Decompose</span> и <span class="inline-code" id="1175324909#-jggmpr_575">Essenty</span>, чтобы снять иллюзию &quot;магии&quot; и показать, что под капотом &mdash; всё те же стандартные механизмы Android, просто обёрнутые в более универсальный API. Всё это рассматривалось строго через призму хранения и восстановления данных.</p><p id="1175324909#-jggmpr_563">Эта статья завершает серию. Всё, что здесь написано &mdash; не документация и не руководство. Это просто попытка заглянуть внутрь, разобраться и собрать цельную картину.</p><p id="1175324909#-jggmpr_564">Если посчитаете, что это может быть полезно кому-то ещё &mdash; можете поделиться. Если захотите обсудить или предложить правки &mdash; я открыт.</p></section></article></div></section></div></body></html>