<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-link-color="#57B747" data-content-max-width="1600" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-10-29T00:01:30.422812"><title>ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов | insider</title><script type="application/json" id="virtual-toc-data">[{"id":"kiv32_6","level":0,"title":"Вводная","anchor":"#kiv32_6"},{"id":"viewmodelstore-fragment","level":0,"title":"Как сохраняется ViewModelStore у Fragment?","anchor":"#viewmodelstore-fragment"},{"id":"retain","level":0,"title":"Как Retain-фрагменты переживают изменение конфигурации?","anchor":"#retain"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/style.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://iili.io/3eop8YX.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов | insider"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="insider Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/fragment-viewmodelstore-and-retain-fragment.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов | insider"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/fragment-viewmodelstore-and-retain-fragment.html#webpage",
    "url": "writerside-documentation//1.0/fragment-viewmodelstore-and-retain-fragment.html",
    "name": "ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов | insider",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "insider Help"
}</script><!-- End Schema.org --></head><body data-id="fragment-viewmodelstore-and-retain-fragment" data-main-title="ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Android///ViewModel"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>insider 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="fragment-viewmodelstore-and-retain-fragment" id="fragment-viewmodelstore-and-retain-fragment.md">ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов</h1><p id="kiv32_3">В предыдущей статье мы рассмотрели <a href="view-model-under-the-hood-store.html" id="kiv32_9" data-tooltip="В статье не рассматривается работа с ViewModel, предполагается, что эта тема уже знакома. Основное внимание уделяется тому, как ViewModel переживает изменение конфигурации. Но для начала — небольшое введение в ViewModel.">ViewModelStore</a> и изучили полный путь от создания <code class="code" id="kiv32_10">ViewModel</code> до его хранения в <code class="code" id="kiv32_11">ViewModelStore</code>. Мы выяснили, где хранится сам <code class="code" id="kiv32_12">ViewModelStore</code>, но рассматривали это в контексте <code class="code" id="kiv32_13">ComponentActivity</code> и его родителя <code class="code" id="kiv32_14">Activity</code>.</p><p id="kiv32_4">А как обстоят дела у <code class="code" id="kiv32_15">Fragment</code>-ов? В этой статье мы ответим на вопрос:</p><p id="kiv32_5"><span class="control" id="kiv32_16">Где хранятся <code class="code" id="kiv32_17">ViewModelStore</code> для <code class="code" id="kiv32_18">Fragment</code>-ов и как <code class="code" id="kiv32_19">Retain</code>-фрагменты переживают изменение конфигурации?</span></p><section class="chapter"><h2 id="kiv32_6" data-toc="kiv32_6">Вводная</h2><p id="kiv32_20"><span class="control" id="kiv32_25">ViewModelStore</span> &mdash; это класс, который содержит внутри себя коллекцию <code class="code" id="kiv32_26">Map&lt;String, ViewModel&gt;</code>. <br> ViewModel-и хранятся в этой коллекции по ключу, а <code class="code" id="kiv32_28">ViewModelStoreOwner</code> - в лице <code class="code" id="kiv32_29">Fragment</code>, <code class="code" id="kiv32_30">ComponentActivity</code> и <code class="code" id="kiv32_31">NavBackStackEntry</code> может очистить их при необходимости.</p><p id="kiv32_21"><span class="control" id="kiv32_32">Fragment(Фрагменты)</span> &mdash; это части UI, которые могут жить внутри активности или в другом фрагменте, обеспечивая гибкость и переиспользуемость интерфейса. Фрагменты управляются активностью и её жизненным циклом, а навигация часто строится на базе фрагментов с использованием подхода <code class="code" id="kiv32_33">SingleActivity</code>. Прямые наследники &mdash; <code class="code" id="kiv32_34">DialogFragment</code>, <code class="code" id="kiv32_35">BottomSheetDialogFragment</code> и <code class="code" id="kiv32_36">AppCompatDialogFragment</code> &mdash; используются для отображения диалогов и нижних листов.</p><p id="kiv32_22"><span class="control" id="kiv32_37">Retain Fragment</span><span class="emphasis" id="kiv32_38">(<span id="kiv32_42"><span class="text-line-through">@Deprecated</span></span>)</span> &mdash; это фрагмент, который сохраняется при изменении конфигурации активности, <br> вместо того чтобы пересоздаваться. Это достигается вызовом метода <code class="code" id="kiv32_40">setRetainInstance(true)</code> у Fragment, который указывает системе <span class="control" id="kiv32_41">не уничтожать фрагмент</span> при пересоздании активности.</p><p id="kiv32_23">Раньше механизм Retain Fragment использовался для хранения данных и фоновых операций, так как если жив фрагмент, то живы все его данные. Но сейчас он считается устаревшим и не рекомендуется к использованию. В современных приложениях его заменяет <code class="code" id="kiv32_43">ViewModel</code>.</p></section><section class="chapter"><h2 id="viewmodelstore-fragment" data-toc="viewmodelstore-fragment">Как сохраняется ViewModelStore у Fragment?</h2><p id="kiv32_44">В этой статье я рассчитываю, что вы уже ознакомились со статьей <a href="view-model-under-the-hood-store.html" id="kiv32_133" data-tooltip="В статье не рассматривается работа с ViewModel, предполагается, что эта тема уже знакома. Основное внимание уделяется тому, как ViewModel переживает изменение конфигурации. Но для начала — небольшое введение в ViewModel.">ViewModelStore</a>.</p><p id="kiv32_45">В предыдущей статье мы <span class="control" id="kiv32_134">детально</span> рассмотрели процесс сохранения <code class="code" id="kiv32_135">ViewModelStore</code> для <code class="code" id="kiv32_136">Activity</code>. <br> Цепочка вызовов содержала все шаги до конечной точки <code class="code" id="kiv32_138">ActivityThread</code> и даже выше.</p><p id="kiv32_46">Однако в случае <code class="code" id="kiv32_139">Fragment</code>-ов цепочка вызовов к счастью <span class="control" id="kiv32_140">короче</span> и проще. <br> Поэтому мы рассмотрим сохранение <code class="code" id="kiv32_142">ViewModelStore</code> для <code class="code" id="kiv32_143">Fragment</code> и <code class="code" id="kiv32_144">Retain Fragment</code> отталкиваясь от следующей диаграммы и дополним ее для Fragment-ов:</p><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 671.6171875 549"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="671.6171875" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="306" width="655.6171875" y="8" x="8" style=""></rect><g transform="translate(258.19921875, 8)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="560.78125" y="161" x="82.8359375" style=""></rect><g transform="translate(257.3203125, 161)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigurationInstances.kt_0" d="M208.227,111L208.227,115.167C208.227,119.333,208.227,127.667,208.227,133.917C208.227,140.167,208.227,144.333,208.227,147.833C208.227,151.333,208.227,154.167,208.227,155.583L208.227,157"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_R_ViewModelStore.kt_1" d="M478.617,264L478.617,268.167C478.617,272.333,478.617,280.667,478.617,289C478.617,297.333,478.617,305.667,478.617,314C478.617,322.333,478.617,330.667,478.617,336.917C478.617,343.167,478.617,347.333,478.617,350.833C478.617,354.333,478.617,357.167,478.617,358.583L478.617,360"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(305.6171875, 356)" class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="177" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 96.5)" id="flowchart-MAP-4" class="node default"><rect height="102" width="260" y="-51" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -36)" style="" class="label"><rect></rect><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf&lt;String, ViewModel&gt;()</p></span></div></foreignObject></g></g></g></g><g transform="translate(208.2265625, 72)" id="flowchart-RetainMethod-0" class="node default"><rect height="78" width="330.453125" y="-39" x="-165.2265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-135.2265625, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="270.453125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance(): NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(208.2265625, 225)" id="flowchart-Q-2" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(478.6171875, 225)" id="flowchart-R-3" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g></g></g></g></svg><p id="kiv32_48">Начнём работу с фрагментами. В этой статье мы не будем углубляться в работу <code class="code" id="kiv32_145">FragmentManager</code> и транзакциями &mdash; вместо этого сосредоточимся на том, <span class="control" id="kiv32_146">где и как хранятся <code class="code" id="kiv32_147">ViewModel</code> и <code class="code" id="kiv32_148">ViewModelStore</code></span> в случае с фрагментами.</p><p id="kiv32_49">Как мы знаем, фрагменты не существуют сами по себе &mdash; они запускаются внутри <span class="control" id="kiv32_149">активити</span> или даже <span class="control" id="kiv32_150">внутри других фрагментов</span>.</p><p id="kiv32_50">Рассмотрим простой пример <code class="code" id="kiv32_151">Activity</code>, которая добавляет фрагмент в контейнер(FrameLayout):</p><div class="code-block" data-lang="kotlin">
class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        ...
        supportFragmentManager
            .beginTransaction()
            .add(R.id.frameLayoutContainer, FirstFragment())
            .commit()
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_52"><p id="kiv32_152"><span class="control" id="kiv32_153">Важно:</span> Код в статье предназначен исключительно для демонстрации и <span class="control" id="kiv32_154">не претендует на best practices</span>. Примеры упрощены для лучшего понимания.</p></aside><p id="kiv32_53">Теперь имея Activity и транзакцию создадим сам фрагмент и инициализируем в нём <code class="code" id="kiv32_155">ViewModel</code> стандартным способ:</p><div class="code-block" data-lang="kotlin">
class FirstFragment : Fragment() {

    private lateinit var viewModel: MyViewModel
    ...
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        viewModel = ViewModelProvider.create(owner = this).get(MyViewModel::class)
    }
}
</div><p id="kiv32_55">Здесь, как и в предыдущих примерах (в прошлой статье), используется <code class="code" id="kiv32_156">ViewModelProvider.create</code>, который требует в качестве параметра <span class="control" id="kiv32_157"><code class="code" id="kiv32_164">owner</code></span>. Это означает, что класс <code class="code" id="kiv32_158">Fragment</code> должен реализовывать некий интерфейс, позволяющий ему выступать в роли владельца <code class="code" id="kiv32_159">ViewModel</code>. Таким интерфейсом является <code class="code" id="kiv32_160">ViewModelStoreOwner</code>, который реализуют такие классы, как <code class="code" id="kiv32_161">Fragment</code>, <code class="code" id="kiv32_162">ComponentActivity</code> и <code class="code" id="kiv32_163">NavBackStackEntry</code>.</p><p id="kiv32_56">В исходном коде метода <code class="code" id="kiv32_165">create</code> у <code class="code" id="kiv32_166">ViewModelProvider</code> явно требуется именно этот интерфейс. Поскольку <code class="code" id="kiv32_167">ViewModelProvider</code> был переписан для KMP, его <code class="code" id="kiv32_168">expect</code>-объявление находится в <code class="code" id="kiv32_169">commonMain</code>:</p><div class="code-block" data-lang="kotlin">
public expect class ViewModelProvider {
    ....
    public companion object {
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider
    }
}
</div><p id="kiv32_58">Раз мы это выяснили, давайте сразу посмотрим, как <span class="control" id="kiv32_170"><code class="code" id="kiv32_177">Fragment</code></span> реализует интерфейс <code class="code" id="kiv32_171">ViewModelStoreOwner</code>. <br> Это важно, потому что такие классы, как <code class="code" id="kiv32_173">DialogFragment</code>, <code class="code" id="kiv32_174">BottomSheetDialogFragment</code>, <code class="code" id="kiv32_175">AppCompatDialogFragment</code> &mdash; наследуются от <code class="code" id="kiv32_176">Fragment</code>, и среди них только он реализует этот интерфейс:</p><div class="code-block" data-lang="java">

@NonNull
@Override
public ViewModelStore getViewModelStore() {
    if (mFragmentManager == null) {
        throw new IllegalStateException(&quot;Can't access ViewModels from detached fragment&quot;);
    }
    if (getMinimumMaxLifecycleState() == Lifecycle.State.INITIALIZED.ordinal()) {
        throw new IllegalStateException(&quot;Calling getViewModelStore() before a Fragment &quot;
                + &quot;reaches onCreate() when using setMaxLifecycle(INITIALIZED) is not &quot;
                + &quot;supported&quot;);
    }
    return mFragmentManager.getViewModelStore(this);
}
</div><p id="kiv32_60">Как видим, фрагмент для получения своего <code class="code" id="kiv32_178">ViewModelStore</code> обращается к <code class="code" id="kiv32_179">FragmentManager</code> и запрашивает у него нужный ViewModelStore, передавая <span class="control" id="kiv32_180">самого себя</span> в качестве ключа:</p><div class="code-block" data-lang="java">
...
        return mFragmentManager.getViewModelStore(this);
...
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_62"><p id="kiv32_181"><span class="control" id="kiv32_183">Напоминание:</span></p><p id="kiv32_182"><code class="code" id="kiv32_184">FragmentManager</code> &mdash; это основной компонент, управляющий фрагментами. Он управляет их стеком и позволяет добавлять фрагменты в back stack.</p></aside><p id="kiv32_63">Далее нас интересует метод <code class="code" id="kiv32_185">getViewModelStore</code>, который есть у класса <code class="code" id="kiv32_186">FragmentManager.java</code>:</p><div class="code-block" data-lang="java">

@NonNull
ViewModelStore getViewModelStore(@NonNull Fragment f) {
    return mNonConfig.getViewModelStore(f);
}
</div><p id="kiv32_65">Оказывается, тут есть ещё один вложенный вызов: у объекта <code class="code" id="kiv32_187">mNonConfig</code> вызывается метод <code class="code" id="kiv32_188">getViewModelStore</code>, куда передаётся фрагмент в качестве ключа. Давайте посмотрим, что это за объект <code class="code" id="kiv32_189">mNonConfig</code>:</p><div class="code-block" data-lang="java">
private FragmentManagerViewModel mNonConfig;
</div><p id="kiv32_67">Вот это интересно: <code class="code" id="kiv32_190">FragmentManager</code> использует свою <span class="control" id="kiv32_191">ViewModel</span>, чтобы хранить информацию о <code class="code" id="kiv32_192">ViewModelStore</code> фрагментов которые он запускал. <br> И это логично &mdash; ведь ему нужно как-то сохранять состояние фрагментов и их ViewModel-и при изменениях конфигурации.</p><p id="kiv32_68">Итак, мы выяснили следующий стек вызовов (по порядку):</p><ol class="list _decimal" id="kiv32_69" type="1"><li class="list__item" id="kiv32_194"><p id="kiv32_198"><code class="code" id="kiv32_199">ViewModelProvider.create(owner = this).get(MyViewModel::class)</code></p></li><li class="list__item" id="kiv32_195"><p id="kiv32_200"><code class="code" id="kiv32_201">Fragment.getViewModelStore()</code></p></li><li class="list__item" id="kiv32_196"><p id="kiv32_202"><code class="code" id="kiv32_203">FragmentManager.getViewModelStore(fragment)</code></p></li><li class="list__item" id="kiv32_197"><p id="kiv32_204"><code class="code" id="kiv32_205">FragmentManagerViewModel.getViewModelStore(fragment)</code></p></li></ol><p id="kiv32_70"><span class="control" id="kiv32_206">Поэтому дальше нас будет интересовать класс <code class="code" id="kiv32_208">FragmentManagerViewModel</code>.</span> Свой путь начнем с его вызова метода <code class="code" id="kiv32_207">FragmentManagerViewModel.getViewModelStore(fragment)</code>:</p><p id="kiv32_71"><span class="control" id="kiv32_209">FragmentManagerViewModel.java:</span></p><div class="code-block" data-lang="java">
final class FragmentManagerViewModel extends ViewModel {
    ...

    @NonNull
    ViewModelStore getViewModelStore(@NonNull Fragment f) {
        ViewModelStore viewModelStore = mViewModelStores.get(f.mWho);
        if (viewModelStore == null) {
            viewModelStore = new ViewModelStore();
            mViewModelStores.put(f.mWho, viewModelStore);
        }
        return viewModelStore;
    }
    ...
}
</div><p id="kiv32_73">Как это работает? <br> Внутри <code class="code" id="kiv32_211">FragmentManagerViewModel</code> есть коллекция <code class="code" id="kiv32_212">HashMap&lt;String, ViewModelStore&gt;()</code>, которая хранит <code class="code" id="kiv32_213">ViewModelStore</code> для каждого фрагмента, принадлежащего <code class="code" id="kiv32_214">FragmentManager</code>'у. <br> То есть все фрагменты, которые были добавлены с помощью <code class="code" id="kiv32_216">FragmentManager</code>'а &mdash; при попытке получить <code class="code" id="kiv32_217">ViewModelStore</code>, сначала ищут его по ключу (<code class="code" id="kiv32_218">f.mWho</code>).</p><p id="kiv32_74">Если <code class="code" id="kiv32_219">ViewModelStore</code> не найден &mdash; это означает, что фрагмент впервые внутри себя создает <code class="code" id="kiv32_220">ViewModel</code>, и, соответственно, впервые ему требуется <code class="code" id="kiv32_221">ViewModelStore</code>. <br> В этом случае <code class="code" id="kiv32_223">ViewModelStore</code> создается и помещается в HashMap <code class="code" id="kiv32_224">mViewModelStores</code>.</p><div class="code-block" data-lang="java">
final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_76"><p id="kiv32_225"><span class="control" id="kiv32_226"><code class="code" id="kiv32_234">mViewModelStores</code></span> &mdash; это <code class="code" id="kiv32_227">HashMap</code>, в которой хранятся <code class="code" id="kiv32_228">ViewModelStore</code> всех фрагментов, находящихся * <span class="emphasis" id="kiv32_229">внутри <code class="code" id="kiv32_235">Activity</code> или вложенных в родительский фрагмент</span>*. <br> Каждый <code class="code" id="kiv32_231">ViewModelStore</code> связан с конкретным фрагментом по его уникальному ключу (<code class="code" id="kiv32_232">fragment.mWho</code>) и используется для хранения <code class="code" id="kiv32_233">ViewModel</code>, привязанных к жизненному циклу соответствующего фрагмента.</p></aside><p id="kiv32_77">Что нам известно в данный момент? <br> Когда мы создаем <code class="code" id="kiv32_237">ViewModel</code> внутри нашего <code class="code" id="kiv32_238">Fragment</code>'а, то его <code class="code" id="kiv32_239">ViewModelStore</code> хранится внутри <code class="code" id="kiv32_240">FragmentManager</code>, точнее &mdash; внутри его <code class="code" id="kiv32_241">ViewModel</code>'ки (<code class="code" id="kiv32_242">FragmentManagerViewModel</code>).</p><p id="kiv32_78">Вроде бы всё ясно: наша <code class="code" id="kiv32_243">ViewModel</code> хранится внутри <code class="code" id="kiv32_244">ViewModelStore</code>, который сам хранится внутри <code class="code" id="kiv32_245">FragmentManagerViewModel</code> (который тоже является <code class="code" id="kiv32_246">ViewModel</code>). <br> И тут возникает логичный вопрос &mdash; <span class="control" id="kiv32_248">а где хранится сам <code class="code" id="kiv32_252">FragmentManagerViewModel</code>?</span><br> Он ведь тоже <code class="code" id="kiv32_250">ViewModel</code>, а значит должен храниться внутри какого-то <code class="code" id="kiv32_251">ViewModelStore</code>.</p><p id="kiv32_79">Краткий ответ: он хранится внутри <code class="code" id="kiv32_253">ViewModelStore</code>, который принадлежит самой <code class="code" id="kiv32_254">Activity</code>.</p><p id="kiv32_80"><span class="control" id="kiv32_255">Хочешь убедиться? Тогда читай дальше.</span></p><p id="kiv32_81">Чтобы ответить на наш вопрос, начнём с основ &mdash; с того, как работают фрагменты и откуда берётся <code class="code" id="kiv32_256">FragmentManager</code>. Но перед этим давайте взглянем на иерархию всех существующих видов Activity, чтобы понять, с какой цепочки мы начнём работу:</p><p id="kiv32_82"><span class="control" id="kiv32_257">Иерархия Activity</span>:</p><div class="code-block" data-lang="none">
Activity
└── ComponentActivity
    └── FragmentActivity
        └── AppCompatActivity
</div><div class="table-wrapper"><table class="wide" id="kiv32_84"><thead><tr class="ijRowHead" id="kiv32_258"><th id="kiv32_263"><p>Класс</p></th><th id="kiv32_264"><p>Назначение</p></th></tr></thead><tbody><tr id="kiv32_259"><td id="kiv32_265"><p><code class="code" id="kiv32_267">Activity</code></p></td><td id="kiv32_266"><p>Базовый низкоуровневый класс экрана в Android SDK. Напрямую использовать не рекомендуется.</p></td></tr><tr id="kiv32_260"><td id="kiv32_268"><p><code class="code" id="kiv32_270">ComponentActivity</code></p></td><td id="kiv32_269"><p>Современная основа для Jetpack компонентов: <code class="code" id="kiv32_271">ViewModel</code>, <code class="code" id="kiv32_272">SavedState</code>, <code class="code" id="kiv32_273">ActivityResult API</code>, <code class="code" id="kiv32_274">OnBackPressedDispatcher</code></p></td></tr><tr id="kiv32_261"><td id="kiv32_275"><p><code class="code" id="kiv32_277">FragmentActivity</code></p></td><td id="kiv32_276"><p>Добавляет поддержку фрагментов (через AndroidX). Фрагменты из <code class="code" id="kiv32_278">android.app.Fragment</code> больше не поддерживаются.</p></td></tr><tr id="kiv32_262"><td id="kiv32_279"><p><code class="code" id="kiv32_281">AppCompatActivity</code></p></td><td id="kiv32_280"><p>Поддержка старых версий Android c <code class="code" id="kiv32_282">Deprecated Api</code>, <code class="code" id="kiv32_283">AppCompatDelegate</code> <code class="code" id="kiv32_284">ActionBar</code>, тем <code class="code" id="kiv32_285">AppCompat</code>, <code class="code" id="kiv32_286">Material UI</code>, .</p></td></tr></tbody></table></div><p id="kiv32_85">Как вы наверняка догадались, нас будет интересовать именно <code class="code" id="kiv32_287">FragmentActivity</code>. <code class="code" id="kiv32_288">FragmentActivity</code> &mdash; это базовый класс, предоставляющий интеграцию с системой фрагментов. Именно он отвечает за создание и управление <code class="code" id="kiv32_289">FragmentManager</code>. На его основе построен и более часто используемый <code class="code" id="kiv32_290">AppCompatActivity</code>, который расширяет функциональность за счёт поддержки компонентов из библиотеки поддержки (AppCompat).</p><p id="kiv32_86">Именно <code class="code" id="kiv32_291">FragmentActivity</code> (или его наследник <code class="code" id="kiv32_292">AppCompatActivity</code>) позволяет полноценно работать с фрагментами и <code class="code" id="kiv32_293">FragmentManager</code>. Остальные способы взаимодействия с фрагментами считаются устаревшими.</p><p id="kiv32_87">Рассмотрим исходный код <code class="code" id="kiv32_294">FragmentActivity</code>:</p><p id="kiv32_88"><span class="control" id="kiv32_295">FragmentActivity.java</span></p><div class="code-block" data-lang="java">
public class FragmentActivity extends ComponentActivity {
    ...
    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());

    class HostCallbacks extends FragmentHostCallback&lt;FragmentActivity&gt; implements ViewModelStoreOwner {
        ...

        public ViewModelStore getViewModelStore() {
            return FragmentActivity.this.getViewModelStore();
        }
        ...
    }
    ...
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_90"><p id="kiv32_296"><code class="code" id="kiv32_297">HostCallbacks</code> реализует множество интерфейсов помимо <code class="code" id="kiv32_298">ViewModelStoreOwner</code>, но в статье они опущены, чтобы не отвлекать от сути.</p></aside><p id="kiv32_91">Мы видим переменную <code class="code" id="kiv32_299">mFragments</code>, которая имеет тип <code class="code" id="kiv32_300">FragmentController</code>. <br> Этой переменной присваивается результат вызова статического метода <code class="code" id="kiv32_302">createController</code>, куда передаётся новый экземпляр <code class="code" id="kiv32_303">HostCallbacks()</code>.</p><p id="kiv32_92"><code class="code" id="kiv32_304">HostCallbacks</code> &mdash; это класс, реализующий интерфейс <code class="code" id="kiv32_305">ViewModelStoreOwner</code>. В своём методе <code class="code" id="kiv32_306">getViewModelStore()</code> он возвращает <code class="code" id="kiv32_307">ViewModelStore</code>, принадлежащий самому <code class="code" id="kiv32_308">FragmentActivity</code>.</p><p id="kiv32_93">Кроме того, <code class="code" id="kiv32_309">HostCallbacks</code> наследуется от класса <code class="code" id="kiv32_310">FragmentHostCallback</code>, который выглядит следующим образом:</p><div class="code-block" data-lang="kotlin">
@Suppress(&quot;deprecation&quot;)
abstract class FragmentHostCallback&lt;H&gt; internal constructor(
    ...
) : FragmentContainer() {

    @get:RestrictTo(RestrictTo.Scope.LIBRARY)
    val fragmentManager: FragmentManager = FragmentManagerImpl()
    ...
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_95"><p>`FragmentHostCallback` был переписан с Java на Kotlin, начиная с версии `androidx.fragment:fragment:*:1.7.0-beta01`.</p></aside><p id="kiv32_96">Внутри <code class="code" id="kiv32_311">FragmentHostCallback</code> создаётся объект <code class="code" id="kiv32_312">FragmentManager</code>. Зная это, возвращаемся к исходникам <code class="code" id="kiv32_313">FragmentActivity</code>, <br> где есть поле <code class="code" id="kiv32_315">mFragments</code>:</p><div class="code-block" data-lang="java">
    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());
</div><p id="kiv32_98">Здесь создаётся объект <code class="code" id="kiv32_316">HostCallbacks</code>, который наследуется от <code class="code" id="kiv32_317">FragmentHostCallback</code> и реализует интерфейс<br><code class="code" id="kiv32_319">ViewModelStoreOwner</code>, в конечном итоге возвращая <code class="code" id="kiv32_320">ViewModelStore</code>, принадлежащий самой активности.</p><p id="kiv32_99">Посмотрим на исходники статического метода <code class="code" id="kiv32_321">FragmentController.createController()</code>:</p><div class="code-block" data-lang="java">
public class FragmentController {

    private final FragmentHostCallback&lt;?&gt; mHost;

    /**
     * Returns a {@link FragmentController}.
     */
    @NonNull
    public static FragmentController createController(@NonNull FragmentHostCallback&lt;?&gt; callbacks) {
        return new FragmentController(checkNotNull(callbacks, &quot;callbacks == null&quot;));
    }

    private FragmentController(FragmentHostCallback&lt;?&gt; callbacks) {
        mHost = callbacks;
    }

}
</div><p id="kiv32_101">Мы видим, что внутри <code class="code" id="kiv32_322">FragmentActivity</code> создаётся <code class="code" id="kiv32_323">FragmentController</code> посредством вызова метода <code class="code" id="kiv32_324">createController()</code>. <br> Метод принимает объект <code class="code" id="kiv32_326">FragmentHostCallback</code> &mdash; в нашем случае это подкласс <code class="code" id="kiv32_327">HostCallbacks</code>, который реализует <code class="code" id="kiv32_328">ViewModelStoreOwner</code> и предоставляет <code class="code" id="kiv32_329">ViewModelStore</code> самой активности.</p><p id="kiv32_102">Чтобы лучше понять цепочку создания и передачи зависимостей, посмотрим на схему:</p><div class="code-block" data-lang="none">
FragmentActivity
    └── Has a → FragmentController (mFragments)
           └── Created with → HostCallbacks
                   ├── Implements → ViewModelStoreOwner (delegates to FragmentActivity)
                   └── Extends → FragmentHostCallback
                            └── Has a → FragmentManagerImpl (as fragmentManager)
</div><p id="kiv32_104">Эта структура позволяет <code class="code" id="kiv32_330">FragmentActivity</code> делегировать управление фрагментами специальному помощнику &mdash; <code class="code" id="kiv32_331">FragmentController</code>. <br> Таким образом, <code class="code" id="kiv32_333">FragmentActivity</code> не занимается напрямую логикой работы с фрагментами, но при этом сохраняет доступ к ключевым компонентам: <code class="code" id="kiv32_334">FragmentManager</code> и <code class="code" id="kiv32_335">ViewModelStore</code>, благодаря вспомогательному классу <code class="code" id="kiv32_336">HostCallbacks</code>.</p><p id="kiv32_105">Теперь давайте подробнее рассмотрим, как создаётся и инициализируется <code class="code" id="kiv32_337">FragmentController</code>. Обратим внимание на следующую строку:</p><div class="code-block" data-lang="java">
final FragmentController mFragments = FragmentController.createController(new HostCallbacks());
</div><p id="kiv32_107">Здесь создаётся экземпляр <code class="code" id="kiv32_338">FragmentController</code>, которому в качестве параметра передаётся объект <code class="code" id="kiv32_339">HostCallbacks</code>. Именно этот объект предоставляет необходимые зависимости, такие как <code class="code" id="kiv32_340">FragmentManager</code>.</p><p id="kiv32_108">Далее обратимся к конструктору <code class="code" id="kiv32_341">FragmentActivity</code>. В нём вызывается метод <code class="code" id="kiv32_342">init</code>, внутри которого регистрируется слушатель <code class="code" id="kiv32_343">OnContextAvailableListener</code>. Этот слушатель срабатывает, когда контекст становится доступен, и в этот момент вызывается метод <code class="code" id="kiv32_344">attachHost</code> у <code class="code" id="kiv32_345">FragmentController</code>:</p><p id="kiv32_109"><span class="control" id="kiv32_346">FragmentActivity.java:</span></p><div class="code-block" data-lang="java">
public class FragmentActivity extends ComponentActivity {
    ...
    final FragmentController mFragments = FragmentController.createController(new HostCallbacks());

    public FragmentActivity() {
        super();
        init();
    }

    private void init() {
        ...
        addOnContextAvailableListener(context -&gt; mFragments.attachHost(null /*parent*/));
    }
}
</div><p id="kiv32_111">Теперь заглянем внутрь самого метода <code class="code" id="kiv32_347">attachHost</code>, который реализован в классе <code class="code" id="kiv32_348">FragmentController</code>.</p><p id="kiv32_112"><span class="control" id="kiv32_349">FragmentController.java:</span></p><div class="code-block" data-lang="java">
/**
 * Attaches the host to the FragmentManager for this controller. The host must be
 * attached before the FragmentManager can be used to manage Fragments.
 */
public void attachHost(@Nullable Fragment parent) {
    mHost.getFragmentManager().attachController(
            mHost, mHost /*container*/, parent);
}
</div><p id="kiv32_114">Внутри этого метода вызывается <code class="code" id="kiv32_350">getFragmentManager()</code> у переменной <code class="code" id="kiv32_351">mHost</code>. Эта переменная представляет собой объект типа <code class="code" id="kiv32_352">FragmentHostCallback&lt;?&gt;</code>, а если точнее, то передается именно его наследник - объект <code class="code" id="kiv32_353">HostCallbacks</code>. Получив <code class="code" id="kiv32_354">FragmentManager</code>, у него вызывается метод <code class="code" id="kiv32_355">attachController</code>, которому передаются: сам <code class="code" id="kiv32_356">HostCallbacks</code> как хост, он же как контейнер, и опционально &mdash; родительский фрагмент (в данном случае <code class="code" id="kiv32_357">null</code>).</p><p id="kiv32_115">Сама переменная <code class="code" id="kiv32_358">mHost</code>, используемая внутри <code class="code" id="kiv32_359">FragmentController</code>, выглядит следующим образом:</p><p id="kiv32_116"><span class="control" id="kiv32_360">FragmentController.java:</span></p><div class="code-block" data-lang="java">
private final FragmentHostCallback&lt;?&gt; mHost;
</div><p id="kiv32_118">На этапе инициализации <code class="code" id="kiv32_361">FragmentActivity</code> создаётся экземпляр <code class="code" id="kiv32_362">FragmentController</code>, которому делегируется управление фрагментами. Этот контроллер получает в конструктор объект <code class="code" id="kiv32_363">HostCallbacks</code>, обеспечивая тем самым связку между <code class="code" id="kiv32_364">FragmentManager</code> и жизненным циклом активити.</p><p id="kiv32_119">Мы уже вскользь рассмотрели, как инициализируется эта переменная, но давай коротко повторим:</p><p id="kiv32_120">Класс <code class="code" id="kiv32_365">HostCallbacks</code> &mdash; это внутренний класс <code class="code" id="kiv32_366">FragmentActivity</code>, который наследуется от <code class="code" id="kiv32_367">FragmentHostCallback</code> и одновременно реализует интерфейс <code class="code" id="kiv32_368">ViewModelStoreOwner</code>. Когда создаётся объект <code class="code" id="kiv32_369">FragmentController</code>, он получает в качестве параметра экземпляр <code class="code" id="kiv32_370">HostCallbacks</code>. Этот объект сохраняется во внутреннем поле <code class="code" id="kiv32_371">mHost</code> типа <code class="code" id="kiv32_372">FragmentHostCallback&lt;?&gt;</code>.</p><p id="kiv32_121">Поскольку <code class="code" id="kiv32_373">HostCallbacks</code> является потомком <code class="code" id="kiv32_374">FragmentHostCallback</code>, ему также доступны методы родителя &mdash; в частности, <code class="code" id="kiv32_375">getFragmentManager()</code> (точнее, поле <code class="code" id="kiv32_376">fragmentManager</code>, полученное через геттер). В Java оно вызывается как <code class="code" id="kiv32_377">getFragmentManager()</code>, хотя в Kotlin это просто свойство. Далее мы уже можем передавать <code class="code" id="kiv32_378">mHost</code> в методы <code class="code" id="kiv32_379">FragmentManager</code>.</p><p id="kiv32_122">Теперь давай посмотрим, как именно <code class="code" id="kiv32_380">FragmentManager</code> получает доступ к <code class="code" id="kiv32_381">FragmentManagerViewModel</code>. Это происходит в методе <code class="code" id="kiv32_382">attachController</code>, который вызывается внутри <code class="code" id="kiv32_383">FragmentManager</code>:</p><p id="kiv32_123"><span class="control" id="kiv32_384">FragmentManager.java:</span></p><div class="code-block" data-lang="java">
void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container, @Nullable final Fragment parent) {
    ...
    // Get the FragmentManagerViewModel
    if (parent != null) {
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        mNonConfig = new FragmentManagerViewModel(false);
    }
    ...
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_125"><p id="kiv32_385"><span class="control" id="kiv32_387">Цепочка инициализации:</span><br><span class="control" id="kiv32_389"><code class="code" id="kiv32_390">FragmentActivity</code> &rarr; <code class="code" id="kiv32_391">HostCallbacks</code> &rarr; <code class="code" id="kiv32_392">FragmentManager</code> &rarr; <code class="code" id="kiv32_393">FragmentManagerViewModel</code></span></p><p id="kiv32_386">Эта последовательность отражает, как создаются и связываются между собой ключевые компоненты фреймворка фрагментов.</p></aside><p id="kiv32_126">Теперь разберём, что именно происходит внутри метода <code class="code" id="kiv32_394">attachController</code>:</p><section class="chapter"><h3 id="1-parent-null" data-toc="1-parent-null">1. <span class="control" id="kiv32_399">Если <code class="code" id="kiv32_400">parent != null</code></span></h3><p id="kiv32_396">Это означает, что мы имеем дело с <span class="control" id="kiv32_401">вложенными фрагментами</span>, которые управляются через <code class="code" id="kiv32_402">childFragmentManager</code>. <br> В таком случае <code class="code" id="kiv32_404">FragmentManager</code> обращается к своему полю <code class="code" id="kiv32_405">mChildNonConfigs</code>, где хранятся <code class="code" id="kiv32_406">FragmentManagerViewModel</code>-ки для вложенных фрагментов. <br> Если нужной <code class="code" id="kiv32_408">FragmentManagerViewModel</code> ещё нет, она будет создана и сохранена в <code class="code" id="kiv32_409">HashMap</code>, используя идентификатор родительского фрагмента в качестве ключа.</p><div class="code-block" data-lang="java">
private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
</div></section><section class="chapter"><h3 id="2-parent-null-host-instanceof-viewmodelstoreowner" data-toc="2-parent-null-host-instanceof-viewmodelstoreowner">2. <span class="control" id="kiv32_414">Если <code class="code" id="kiv32_415">parent == null</code>, и <code class="code" id="kiv32_416">host instanceof ViewModelStoreOwner</code></span></h3><p id="kiv32_411">Это основной путь при работе с <code class="code" id="kiv32_417">FragmentActivity</code> и <code class="code" id="kiv32_418">AppCompatActivity</code>, потому что <code class="code" id="kiv32_419">HostCallbacks</code> реализует <code class="code" id="kiv32_420">ViewModelStoreOwner</code>. <br> В этом случае <code class="code" id="kiv32_422">FragmentManager</code> получает <code class="code" id="kiv32_423">ViewModelStore</code>, привязанный к <code class="code" id="kiv32_424">FragmentActivity</code>, и передаёт его в <code class="code" id="kiv32_425">FragmentManagerViewModel.getInstance()</code>.</p><p id="kiv32_412">Таким образом, <code class="code" id="kiv32_426">FragmentManagerViewModel</code> сохраняется в **том же <code class="code" id="kiv32_427">ViewModelStore</code>, что и остальные ViewModel-ки Activity **, и будет жить столько же, сколько и сама <code class="code" id="kiv32_428">Activity</code>.</p></section><section class="chapter"><h3 id="3-host-viewmodelstoreowner" data-toc="3-host-viewmodelstoreowner">3. <span class="control" id="kiv32_455">Если <code class="code" id="kiv32_456">host</code> не реализует <code class="code" id="kiv32_457">ViewModelStoreOwner</code></span></h3><p id="kiv32_430">Это <span class="control" id="kiv32_458">устаревший сценарий</span>, когда <code class="code" id="kiv32_459">Activity</code> напрямую наследуется от <code class="code" id="kiv32_460">Activity</code> или <code class="code" id="kiv32_461">ComponentActivity</code>, минуя <code class="code" id="kiv32_462">FragmentActivity</code>/<code class="code" id="kiv32_463">AppCompatActivity</code>.</p><p id="kiv32_431">В этом случае <code class="code" id="kiv32_464">FragmentManager</code> создаёт <code class="code" id="kiv32_465">FragmentManagerViewModel</code> без использования <code class="code" id="kiv32_466">ViewModelStore</code>. Такая ViewModel сохраняется через механизм <code class="code" id="kiv32_467">NonConfigurationInstances</code>, который Android применял до появления архитектурных компонентов.</p><p id="kiv32_432">Этот подход уже <span class="control" id="kiv32_468">не рекомендуется</span>, и с современными <code class="code" id="kiv32_469">androidx.fragment.app.Fragment</code> он <span class="control" id="kiv32_470">не работает</span>. Он применим только для старых <code class="code" id="kiv32_471">android.app.Fragment</code> и только при активном флаге <code class="code" id="kiv32_472">setRetainInstance(true)</code>. Когда мы добавляем фрагмент в активити через <code class="code" id="kiv32_473">supportFragmentManager</code>, мы всегда попадаем под <span class="control" id="kiv32_474">второе условие</span>, описанное выше: <br><code class="code" id="kiv32_476">host instanceof ViewModelStoreOwner</code>. В этой ситуации <code class="code" id="kiv32_477">FragmentManager</code> получает <code class="code" id="kiv32_478">ViewModelStore</code> у <code class="code" id="kiv32_479">host</code> (то есть <code class="code" id="kiv32_480">FragmentActivity</code>) и передаёт его в метод <code class="code" id="kiv32_481">FragmentManagerViewModel.getInstance()</code>.</p><p id="kiv32_433">Внутри этого метода создаётся <code class="code" id="kiv32_482">FragmentManagerViewModel</code>, который сохраняется в <code class="code" id="kiv32_483">ViewModelStore</code>. Как мы уже говорили ранее, этот <code class="code" id="kiv32_484">ViewModelStore</code> принадлежит <code class="code" id="kiv32_485">FragmentActivity</code> (или её наследнику <code class="code" id="kiv32_486">AppCompatActivity</code>).</p><p id="kiv32_434"><span class="control" id="kiv32_487">FragmentManagerViewModel.java:</span></p><div class="code-block" data-lang="java">

@NonNull
static FragmentManagerViewModel getInstance(ViewModelStore viewModelStore) {
    ViewModelProvider viewModelProvider = new ViewModelProvider(viewModelStore, FACTORY);
    return viewModelProvider.get(FragmentManagerViewModel.class);
}
</div><p id="kiv32_437">Теперь соберём <span class="control" id="kiv32_488">всю цепочку шагов</span>, которая выполняется при создании <code class="code" id="kiv32_489">ViewModel</code> внутри фрагмента:</p><div class="code-block" data-lang="kotlin">
viewmodel = ViewModelProvider(owner = this).get(MyViewModel::class)
</div><ol class="list _decimal" id="kiv32_439" type="1"><li class="list__item" id="kiv32_490"><p id="kiv32_496"><code class="code" id="kiv32_497">ViewModelProvider</code> запрашивает у <code class="code" id="kiv32_498">ViewModelStoreOwner</code> его <code class="code" id="kiv32_499">ViewModelStore</code>. <br> В данном случае <code class="code" id="kiv32_501">owner = this</code>, и это фрагмент.</p></li><li class="list__item" id="kiv32_491"><p id="kiv32_502">У фрагмента вызывается <code class="code" id="kiv32_503">getViewModelStore()</code>, поскольку он реализует интерфейс <code class="code" id="kiv32_504">ViewModelStoreOwner</code>.</p></li><li class="list__item" id="kiv32_492"><p id="kiv32_505">Внутри <code class="code" id="kiv32_506">Fragment.getViewModelStore()</code> происходит обращение к <code class="code" id="kiv32_507">FragmentManager</code>, в котором зарегистрирован этот фрагмент. <br> Вызов: <code class="code" id="kiv32_509">FragmentManager.getViewModelStore(fragment)</code>.</p></li><li class="list__item" id="kiv32_493"><p id="kiv32_510"><code class="code" id="kiv32_511">FragmentManager</code> делегирует дальше и обращается к своей ViewModel-ке &mdash; <code class="code" id="kiv32_512">FragmentManagerViewModel</code>.</p></li><li class="list__item" id="kiv32_494"><p id="kiv32_513">Внутри <code class="code" id="kiv32_514">FragmentManagerViewModel.getViewModelStore(fragment)</code> происходит поиск <code class="code" id="kiv32_515">ViewModelStore</code> по <code class="code" id="kiv32_516">fragment.mWho</code> в <code class="code" id="kiv32_517">HashMap&lt;String, ViewModelStore&gt;</code>.</p></li><li class="list__item" id="kiv32_495"><p id="kiv32_518">Если <code class="code" id="kiv32_519">ViewModelStore</code> уже есть, он возвращается. Если нет &mdash; создаётся новый, сохраняется в мапу и возвращается.</p></li></ol><div class="code-block" data-lang="scss">
FragmentActivity
     │
     ▼
HostCallbacks (наследуетcя от FragmentHostCallback &amp; ViewModelStoreOwner)
     │
     ▼
FragmentController
     │
     ▼
FragmentManager.attachController(...)
     │
     ├─ Если есть parent:Fragment → используем его childFragmentManager
     │
     └─ Если host is ViewModelStoreOwner → берём ViewModelStore из host (Activity)
               │
               ▼
      FragmentManagerViewModel (ViewModel, хранится в Activity's ViewModelStore)
               │
               ▼
    ┌─────────────────────────────────────────────┐
    │ HashMap&lt;String, ViewModelStore&gt;             │
    │ └─ ключ: fragment.mWho                      │
    │ └─ значение: ViewModelStore конкретного Fragment-а │
    └─────────────────────────────────────────────┘
               │
               ▼
     ViewModelProvider(fragment).get(MyViewModel::class)
</div><p id="kiv32_442">В упрощённом виде, схема ниже иллюстрирует, как устроено взаимодействие между <code class="code" id="kiv32_520">Activity</code>, <code class="code" id="kiv32_521">FragmentManager</code> и <code class="code" id="kiv32_522">ViewModelStore</code>. Заметьте что это диаграмма продолжение диаграммы которая была в начале статьи</p><p id="kiv32_443">У нас есть <code class="code" id="kiv32_523">Activity</code>, которая наследуется от <code class="code" id="kiv32_524">FragmentActivity</code> (а чаще &mdash; от его расширенного потомка <code class="code" id="kiv32_525">AppCompatActivity</code>). При создании <code class="code" id="kiv32_526">Activity</code> инициализируется <code class="code" id="kiv32_527">FragmentController</code>, которому передаётся <code class="code" id="kiv32_528">FragmentHostCallback</code> &mdash; точнее, его наследник <code class="code" id="kiv32_529">HostCallbacks</code>.</p><p id="kiv32_444"><code class="code" id="kiv32_530">HostCallbacks</code> реализует интерфейс <code class="code" id="kiv32_531">ViewModelStoreOwner</code>, но при этом <span class="control" id="kiv32_532">не создаёт</span> новый <code class="code" id="kiv32_533">ViewModelStore</code>, а возвращает уже существующий &mdash; тот, что принадлежит <code class="code" id="kiv32_534">Activity</code>.</p><p id="kiv32_445">Далее <code class="code" id="kiv32_535">FragmentController</code> прикрепляет <code class="code" id="kiv32_536">FragmentManager</code> к своему хосту (<code class="code" id="kiv32_537">Activity</code> или <code class="code" id="kiv32_538">ParentFragment</code>). <code class="code" id="kiv32_539">FragmentManager</code> создаёт <code class="code" id="kiv32_540">FragmentManagerViewModel</code> и сохраняет его во <code class="code" id="kiv32_541">ViewModelStore</code>, предоставленном <code class="code" id="kiv32_542">HostCallbacks</code>, то есть &mdash; в <code class="code" id="kiv32_543">ViewModelStore</code>, принадлежащем <code class="code" id="kiv32_544">Activity</code>.</p><p id="kiv32_446">Теперь, когда внутри <code class="code" id="kiv32_545">Activity</code> мы добавляем фрагмент через <code class="code" id="kiv32_546">supportFragmentManager</code>, инициализация <code class="code" id="kiv32_547">MyViewModel</code> во фрагменте приводит к тому, что <code class="code" id="kiv32_548">ViewModelProvider</code> запрашивает у фрагмента его <code class="code" id="kiv32_549">ViewModelStore</code>.</p><p id="kiv32_447">Фрагмент, в свою очередь, обращается к своему <code class="code" id="kiv32_550">FragmentManager</code> &mdash; <span class="emphasis" id="kiv32_551">&quot;дай мой <code class="code" id="kiv32_557">ViewModelStore</code> &quot;</span>. <code class="code" id="kiv32_552">FragmentManager</code>, имея прямую ссылку на <code class="code" id="kiv32_553">FragmentManagerViewModel</code>, запрашивает у него <code class="code" id="kiv32_554">ViewModelStore</code> по ключу (обычно это <code class="code" id="kiv32_555">fragment.mWho</code>) &mdash; и возвращает <code class="code" id="kiv32_556">ViewModelStore</code>, связанный с этим фрагментом.</p><p id="kiv32_448">Именно туда, в этот <code class="code" id="kiv32_558">ViewModelStore</code>, и будет помещён <code class="code" id="kiv32_559">MyViewModel</code>.</p><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 1658.98046875 981"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="1658.98046875" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="Fragment.kt" class="cluster"><rect height="356" width="399.890625" y="617" x="607.97265625" style=""></rect><g transform="translate(763.56640625, 617)" class="cluster-label"><foreignObject height="24" width="88.703125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Fragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="FragmentActivity.java" class="cluster"><rect height="381" width="749.890625" y="8" x="373" style=""></rect><g transform="translate(668.9453125, 8)" class="cluster-label"><foreignObject height="24" width="158"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentActivity.java</p></span></div></foreignObject></g></g><g data-look="classic" id="FragmentManagerViewModel" class="cluster"><rect height="128" width="632.8359375" y="439" x="705.41796875" style=""></rect><g transform="translate(919.2265625, 439)" class="cluster-label"><foreignObject height="24" width="205.21875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="585.50390625" y="617" x="1027.86328125" style=""></rect><g transform="translate(1214.708984375, 617)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="381" width="400.453125" y="8" x="1250.52734375" style=""></rect><g transform="translate(1373.14453125, 8)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="HostCallbacks.java" class="cluster"><rect height="128" width="709.890625" y="236" x="393" style=""></rect><g transform="translate(679.9921875, 236)" class="cluster-label"><foreignObject height="24" width="135.90625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HostCallbacks.java</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigRef_0" d="M1457.522,148.5L1459.329,158.917C1461.137,169.333,1464.752,190.167,1466.56,204.75C1468.367,219.333,1468.367,227.667,1468.367,233.917C1468.367,240.167,1468.367,244.333,1468.367,247.833C1468.367,251.333,1468.367,254.167,1468.367,255.583L1468.367,257"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_NonConfigRef_VMStoreField_1" d="M1468.367,339L1468.367,343.167C1468.367,347.333,1468.367,355.667,1468.367,364C1468.367,372.333,1468.367,380.667,1468.367,389C1468.367,397.333,1468.367,405.667,1468.367,414C1468.367,422.333,1468.367,430.667,1468.367,445.5C1468.367,460.333,1468.367,481.667,1468.367,503C1468.367,524.333,1468.367,545.667,1468.367,560.5C1468.367,575.333,1468.367,583.667,1468.367,592C1468.367,600.333,1468.367,608.667,1467.716,614.917C1467.065,621.167,1465.763,625.333,1464.66,628.864C1463.557,632.394,1462.652,635.288,1462.2,636.735L1461.748,638.182"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FMStoreMap_fgetViewModelStore_6" d="M858.689,542L850.227,546.167C841.765,550.333,824.841,558.667,816.38,567C807.918,575.333,807.918,583.667,807.918,592C807.918,600.333,807.918,608.667,807.918,615.917C807.918,623.167,807.918,629.333,807.918,634.833C807.918,640.333,807.918,645.167,807.918,647.583L807.918,650"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_fgetViewModelStore_MyViewModel_7" d="M807.918,708L807.918,714.167C807.918,720.333,807.918,732.667,807.918,743C807.918,753.333,807.918,761.667,807.918,772.042C807.918,782.417,807.918,794.833,807.918,806.583C807.918,818.333,807.918,829.417,807.918,834.958L807.918,840.5"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_VMStoreField_ViewModelStore.kt_2" d="M1448.367,720L1448.367,724.167C1448.367,728.333,1448.367,736.667,1448.367,745C1448.367,753.333,1448.367,761.667,1448.367,767.917C1448.367,774.167,1448.367,778.333,1448.367,781.833C1448.367,785.333,1448.367,788.167,1448.367,789.583L1448.367,791"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentController_HostCallbacks.java_3" d="M592.945,148.5L592.945,158.917C592.945,169.333,592.945,190.167,592.945,202.667C592.945,215.167,592.945,219.333,592.945,222.833C592.945,226.333,592.945,229.167,592.945,230.583L592.945,232"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_overidenFragmentManager_FragmentManagerViewModel_4" d="M937.891,339L937.891,343.167C937.891,347.333,937.891,355.667,937.891,364C937.891,372.333,937.891,380.667,937.891,389C937.891,397.333,937.891,405.667,937.891,411.917C937.891,418.167,937.891,422.333,937.891,425.833C937.891,429.333,937.891,432.167,937.891,433.583L937.891,435"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentHostCallback.kt_HostCallbacks.java_5" d="M338,160.254L365.495,168.712C392.991,177.169,447.982,194.085,475.477,204.626C502.973,215.167,502.973,219.333,502.973,222.833C502.973,226.333,502.973,229.167,502.973,230.583L502.973,232"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ComponentActivity.kt_FragmentActivity.java_8" d="M1250.527,252.336L1239.891,253.51C1229.255,254.685,1207.982,257.033,1187.372,259.309C1166.761,261.585,1146.814,263.787,1136.84,264.888L1126.866,265.99"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_FragmentManagerViewModel_VMStoreField_9" d="M1245.754,567L1245.754,571.167C1245.754,575.333,1245.754,583.667,1245.754,592C1245.754,600.333,1245.754,608.667,1252.349,614.917C1258.945,621.167,1272.136,625.333,1284.691,629.299C1297.246,633.265,1309.166,637.03,1315.126,638.913L1321.085,640.795"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(0, 25)" class="root"><g class="clusters"><g data-look="classic" id="FragmentHostCallback.kt" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(82.203125, 8)" class="cluster-label"><foreignObject height="24" width="181.59375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentHostCallback.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-fragmentManager-98" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManager fragmentManager</p></span></div></foreignObject></g></g></g></g><g transform="translate(1275.3671875, 787)" class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-MAP-81" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(1450.75390625, 109.5)" id="flowchart-RetainMethod-77" class="node default"><rect height="78" width="330.453125" y="-39" x="-165.2265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-135.2265625, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="270.453125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance(): NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(1468.3671875, 300)" id="flowchart-NonConfigRef-78" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>val lastNonConfigInstance: NonConfigurationInstances?</p></span></div></foreignObject></g></g><g transform="translate(1153.25390625, 681)" id="flowchart-Custom-79" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(1448.3671875, 681)" id="flowchart-VMStoreField-80" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g><g transform="translate(937.890625, 503)" id="flowchart-FMStoreMap-88" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashMap&lt;String, ViewModelStore&gt;</p></span></div></foreignObject></g></g><g transform="translate(592.9453125, 109.5)" id="flowchart-FragmentController-89" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentController mFragments</p></span></div></foreignObject></g></g><g transform="translate(592.9453125, 300)" id="flowchart-getViewModelStore-92" class="node default"><rect height="54" width="329.890625" y="-27" x="-164.9453125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-134.9453125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="269.890625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>getViewModelStore():ViewModelStore</p></span></div></foreignObject></g></g><g transform="translate(937.890625, 300)" id="flowchart-overidenFragmentManager-93" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManager fragmentManager</p></span></div></foreignObject></g></g><g transform="translate(807.91796875, 681)" id="flowchart-fgetViewModelStore-99" class="node default"><rect height="54" width="329.890625" y="-27" x="-164.9453125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-134.9453125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="269.890625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>getViewModelStore():ViewModelStore</p></span></div></foreignObject></g></g><g transform="translate(807.91796875, 871.5)" id="flowchart-MyViewModel-103" class="node default"><rect height="54" width="156.109375" y="-27" x="-78.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-48.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MyViewModel</p></span></div></foreignObject></g></g></g></g></g></svg><p id="kiv32_451">Наконец, давайте убедимся, что <code class="code" id="kiv32_560">FragmentManagerViewModel</code>, привязанный к <code class="code" id="kiv32_561">FragmentManager</code> активити, действительно хранится внутри <code class="code" id="kiv32_562">ViewModelStore</code>, который принадлежит самой активити. Для этого в методе <code class="code" id="kiv32_563">onCreate()</code> можно залогировать все ключи, содержащиеся в <code class="code" id="kiv32_564">viewModelStore</code> активити:</p><div class="code-block" data-lang="kotlin">
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)

    supportFragmentManager
        .beginTransaction()
        .add(R.id.frameLayoutContainer, FirstFragment())
        .commit()

    Log.d(&quot;MainActivity&quot;, &quot;onCreate: ${viewModelStore.keys()}&quot;)
    // Output: onCreate: [androidx.lifecycle.ViewModelProvider.DefaultKey:androidx.fragment.app.FragmentManagerViewModel]
}
</div><p id="kiv32_453"><span class="emphasis" id="kiv32_565">Скриншот: ключ FragmentManagerViewModel, зарегистрированный в ViewModelStore активити</span><br><figure id="kiv32_567"><img alt="Screenshot" src="images/studio1.png" title="Screenshot" width="2442" height="597"></figure></p><p id="kiv32_454">На этом этапе мы полностью проследили весь флоу в случае, когда у нас есть <code class="code" id="kiv32_568">Activity</code>, поверх которой запускается <code class="code" id="kiv32_569">Fragment</code>, и внутри этого фрагмента инициализируется <code class="code" id="kiv32_570">ViewModel</code>. Мы дошли до конечной точки &mdash; увидели, где именно хранятся <code class="code" id="kiv32_571">ViewModel</code>-ы.</p></section><section class="chapter"><h3 id="childfragmentmanager" data-toc="childfragmentmanager">Вложенные фрагменты и <code class="code" id="kiv32_579">childFragmentManager</code></h3><p id="kiv32_573">Остался один важный кейс &mdash; <span class="control" id="kiv32_580">вложенные фрагменты</span>. То есть ситуация, когда мы запускаем один <code class="code" id="kiv32_581">Fragment</code> внутри другого с помощью <code class="code" id="kiv32_582">childFragmentManager</code>. До сих пор мы рассматривали только добавление фрагмента через <code class="code" id="kiv32_583">FragmentManager</code> активити (<code class="code" id="kiv32_584">supportFragmentManager</code>).</p><p id="kiv32_574">Напомню, мы уже сталкивались с этим кейсом при разборе метода <code class="code" id="kiv32_585">attachController()</code>, в котором реализуется логика выбора источника <code class="code" id="kiv32_586">FragmentManagerViewModel</code>.</p><p id="kiv32_575"><span class="control" id="kiv32_587">FragmentManager.java:</span></p><div class="code-block" data-lang="java">
void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container,
                      @Nullable final Fragment parent) {
    ...
    // Получение FragmentManagerViewModel
    if (parent != null) {
        mNonConfig = parent.mFragmentManager.getChildNonConfig(parent);
    } else if (host instanceof ViewModelStoreOwner) {
        ViewModelStore viewModelStore = ((ViewModelStoreOwner) host).getViewModelStore();
        mNonConfig = FragmentManagerViewModel.getInstance(viewModelStore);
    } else {
        mNonConfig = new FragmentManagerViewModel(false);
    }
    ...
}
</div><p id="kiv32_577">В случае, когда мы добавляем фрагмент поверх другого фрагмента через <code class="code" id="kiv32_588">childFragmentManager</code>, создавая вложенность, срабатывает первое условие, а именно &mdash; проверка <code class="code" id="kiv32_589">parent != null</code>. Ранее мы уже выяснили, в каких случаях это условие выполняется, но для понимания продублируем ещё раз:</p><section class="chapter"><h4 id="parent-null" data-toc="parent-null"><span class="control" id="kiv32_600">Если <code class="code" id="kiv32_601">parent != null</code></span></h4><p id="kiv32_591">Это означает, что мы имеем дело с <span class="control" id="kiv32_602">вложенными фрагментами</span>, которые управляются через <code class="code" id="kiv32_603">childFragmentManager</code>. <br> В таком случае <code class="code" id="kiv32_605">FragmentManager</code> обращается к своему полю <code class="code" id="kiv32_606">mChildNonConfigs</code>, где хранятся <code class="code" id="kiv32_607">FragmentManagerViewModel</code> для вложенных фрагментов. <br> Если нужной <code class="code" id="kiv32_609">FragmentManagerViewModel</code> ещё нет, она создаётся и сохраняется в <code class="code" id="kiv32_610">HashMap</code>, используя <code class="code" id="kiv32_611">fragment.mWho</code> родительского фрагмента в качестве ключа.</p><p id="kiv32_592">При таком кейсе <code class="code" id="kiv32_612">FragmentManager</code> обращается к <code class="code" id="kiv32_613">parent</code>, вызывает у него метод <code class="code" id="kiv32_614">getChildNonConfig</code>, и попадает в следующий код: <span class="control" id="kiv32_615">FragmentManager.java:</span></p><div class="code-block" data-lang="java">

@NonNull
private FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
    return mNonConfig.getChildNonConfig(f);
}
</div><p id="kiv32_594">Здесь <code class="code" id="kiv32_616">mNonConfig</code> &mdash; это <code class="code" id="kiv32_617">FragmentManagerViewModel</code>, привязанный к родительскому <code class="code" id="kiv32_618">FragmentManager</code>. У него вызывается <code class="code" id="kiv32_619">getChildNonConfig(f)</code>, и происходит следующее в <span class="control" id="kiv32_620">FragmentManagerViewModel.java</span></p><div class="code-block" data-lang="java">
final class FragmentManagerViewModel extends ViewModel {

    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();

    @NonNull
    FragmentManagerViewModel getChildNonConfig(@NonNull Fragment f) {
        FragmentManagerViewModel childNonConfig = mChildNonConfigs.get(f.mWho);
        if (childNonConfig == null) {
            childNonConfig = new FragmentManagerViewModel(mStateAutomaticallySaved);
            mChildNonConfigs.put(f.mWho, childNonConfig);
        }
        return childNonConfig;
    }
}
</div><p id="kiv32_596">В этом методе мы пытаемся получить <code class="code" id="kiv32_621">FragmentManagerViewModel</code> для <code class="code" id="kiv32_622">childFragmentManager</code> родительского фрагмента, чтобы у <code class="code" id="kiv32_623">childFragmentManager</code> была собственная <code class="code" id="kiv32_624">FragmentManagerViewModel</code>, в которой можно будет хранить <code class="code" id="kiv32_625">ViewModelStore</code> всех фрагментов, которые будут запущены внутри <code class="code" id="kiv32_626">childFragmentManager</code>.</p><p id="kiv32_597">Если такого <code class="code" id="kiv32_627">FragmentManagerViewModel</code> ещё не существует, он создаётся, кладётся в <code class="code" id="kiv32_628">mChildNonConfigs</code>, и затем возвращается обратно в метод <code class="code" id="kiv32_629">attachController</code>, где продолжает использоваться для инициализации <code class="code" id="kiv32_630">childFragmentManager</code>.</p><p id="kiv32_598">Отличный запрос. Вот как можно лаконично и понятно сформулировать это как завершение или рефлексивный блок &mdash; с пояснением про дерево <code class="code" id="kiv32_631">FragmentManagerViewModel</code> и как оно строится:</p></section></section><section class="chapter"><h3 id="fragmentmanagerviewmodel" data-toc="fragmentmanagerviewmodel">Как формируется дерево <code class="code" id="kiv32_659">FragmentManagerViewModel</code></h3><p id="kiv32_633">Чтобы понять полную картину, важно представить, как строится иерархия <code class="code" id="kiv32_660">FragmentManagerViewModel</code> в реальном приложении:</p><ul class="list _bullet" id="kiv32_634"><li class="list__item" id="kiv32_661"><p id="kiv32_663">В начале у нас есть <code class="code" id="kiv32_664">Activity</code>, у которой есть <code class="code" id="kiv32_665">FragmentManager</code> (чаще всего это <code class="code" id="kiv32_666">supportFragmentManager</code>).</p></li><li class="list__item" id="kiv32_662"><p id="kiv32_667">У этого <code class="code" id="kiv32_668">FragmentManager</code> создаётся собственный <code class="code" id="kiv32_669">FragmentManagerViewModel</code>. Он сохраняется внутри <code class="code" id="kiv32_670">ViewModelStore</code>, который принадлежит самой <code class="code" id="kiv32_671">Activity</code>.</p></li></ul><p id="kiv32_635">Теперь, если мы добавляем фрагменты через <code class="code" id="kiv32_672">FragmentManager</code> который принадлежит <code class="code" id="kiv32_673">Activity</code> (<code class="code" id="kiv32_674">supportFragmentManager</code>), то для каждого такого фрагмента будет создан свой <code class="code" id="kiv32_675">ViewModelStore</code>. Эти <code class="code" id="kiv32_676">ViewModelStore</code> будут храниться <span class="control" id="kiv32_677">внутри</span> <code class="code" id="kiv32_678">FragmentManagerViewModel</code>, связанного с <code class="code" id="kiv32_679">FragmentManager</code> самой <code class="code" id="kiv32_680">Activity</code>, в поле <code class="code" id="kiv32_681">FragmentManagerViewModel#mViewModelStores</code>:</p><div class="code-block" data-lang="java">
final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}
</div><p id="kiv32_637">Каждый такой фрагмент, в свою очередь, тоже имеет собственный <code class="code" id="kiv32_682">FragmentManager</code> &mdash; это <code class="code" id="kiv32_683">childFragmentManager</code>. Он используется, если мы хотим внутри фрагмента запускать другие фрагменты (вложенность, локальный стек навигации).</p><ul class="list _bullet" id="kiv32_638"><li class="list__item" id="kiv32_684"><p id="kiv32_686">У <code class="code" id="kiv32_687">childFragmentManager</code> тоже должен быть свой <code class="code" id="kiv32_688">FragmentManagerViewModel</code> (как у всех <code class="code" id="kiv32_689">FragmentManager</code>-ов), чтобы он мог хранить <code class="code" id="kiv32_690">ViewModelStore</code> для фрагментов, запущенных внутри родительского фрагмента, то есть внутри него.</p></li><li class="list__item" id="kiv32_685"><p id="kiv32_691">Эти <code class="code" id="kiv32_692">FragmentManagerViewModel</code> хранятся в <code class="code" id="kiv32_693">mChildNonConfigs</code> &mdash; это <code class="code" id="kiv32_694">Map&lt;String, FragmentManagerViewModel&gt;</code> внутри <code class="code" id="kiv32_695">FragmentManagerViewModel</code> родителя.</p></li></ul><p id="kiv32_639">Таким образом, формируется дерево:</p><ul class="list _bullet" id="kiv32_640"><li class="list__item" id="kiv32_696"><p id="kiv32_699">Корень &mdash; это <code class="code" id="kiv32_700">FragmentManagerViewModel</code>, привязанный к <code class="code" id="kiv32_701">FragmentManager</code> самой <code class="code" id="kiv32_702">Activity</code> и хранящийся в её <code class="code" id="kiv32_703">ViewModelStore</code>.</p></li><li class="list__item" id="kiv32_697"><p id="kiv32_704">Далее &mdash; <code class="code" id="kiv32_705">FragmentManagerViewModel</code> для каждого вложенного <code class="code" id="kiv32_706">childFragmentManager</code>, сохранённые внутри <code class="code" id="kiv32_707">mChildNonConfigs</code>.</p></li><li class="list__item" id="kiv32_698"><p id="kiv32_708">Это дерево может быть сколь угодно глубоким, повторяя структуру вложенности фрагментов в приложении. Каждый узел в этом дереве это <code class="code" id="kiv32_709">FragmentManagerViewModel</code></p></li></ul><p id="kiv32_641">Именно такая структура позволяет корректно управлять <code class="code" id="kiv32_710">ViewModel</code>, сохраняя их сквозь конфигурационные изменения и обеспечивая жизненный цикл, привязанный к конкретному фрагменту.</p><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 2751 1231"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="2751" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="SubChildFragment.kt" class="cluster"><rect height="203" width="1400" y="1020" x="613" style=""></rect><g transform="translate(1237.6171875, 1020)" class="cluster-label"><foreignObject height="24" width="150.765625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>SubChildFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="SecondChildFragment.kt" class="cluster"><rect height="253" width="1750" y="717" x="628" style=""></rect><g transform="translate(1414.96875, 717)" class="cluster-label"><foreignObject height="24" width="176.0625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>SecondChildFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ParentFragment.kt" class="cluster"><rect height="253" width="2425" y="414" x="318" style=""></rect><g transform="translate(1462.765625, 414)" class="cluster-label"><foreignObject height="24" width="135.46875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ParentFragment.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="MainActivity.kt" class="cluster"><rect height="356" width="2720" y="8" x="8" style=""></rect><g transform="translate(1314.6640625, 8)" class="cluster-label"><foreignObject height="24" width="106.671875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MainActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="SecondChildFragmentFragmentManagerViewModel" class="cluster"><rect height="203" width="1330" y="742" x="648" style=""></rect><g transform="translate(1179.7109375, 742)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ParentFragmentFragmentManagerViewModel" class="cluster"><rect height="203" width="2005" y="439" x="338" style=""></rect><g transform="translate(1207.2109375, 439)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityFragmentManagerViewModel" class="cluster"><rect height="128" width="2680" y="211" x="28" style=""></rect><g transform="translate(1234.7109375, 211)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри supportFragmentManager)</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityViewModelStore" class="cluster"><rect height="128" width="330" y="33" x="28" style=""></rect><g transform="translate(125.5625, 33)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_MAP_ActivityFragmentManagerViewModel_0" d="M193,136L193,140.167C193,144.333,193,152.667,193,161C193,169.333,193,177.667,193,183.917C193,190.167,193,194.333,193,197.833C193,201.333,193,204.167,193,205.583L193,207"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ViewModelStores1_ParentFragmentViewModelStore_1" d="M2543,314L2543,318.167C2543,322.333,2543,330.667,2543,339C2543,347.333,2543,355.667,2543,364C2543,372.333,2543,380.667,2543,389C2543,397.333,2543,405.667,2543,414C2543,422.333,2543,430.667,2543,436.917C2543,443.167,2543,447.333,2543,450.833C2543,454.333,2543,457.167,2543,458.583L2543,460"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ChildNonConfigs1_ParentFragmentFragmentManagerViewModel_2" d="M503,314L503,318.167C503,322.333,503,330.667,503,339C503,347.333,503,355.667,503,364C503,372.333,503,380.667,503,389C503,397.333,503,405.667,503,411.917C503,418.167,503,422.333,503,425.833C503,429.333,503,432.167,503,433.583L503,435"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ParentChildNonConfigs_SecondChildFragmentFragmentManagerViewModel_3" d="M813,579.5L813,589.917C813,600.333,813,621.167,813,635.75C813,650.333,813,658.667,813,667C813,675.333,813,683.667,813,692C813,700.333,813,708.667,813,714.917C813,721.167,813,725.333,813,728.833C813,732.333,813,735.167,813,736.583L813,738"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ParentViewModelStores_SecondChildFragmentViewModelStore_4" d="M2178,579.5L2178,589.917C2178,600.333,2178,621.167,2178,635.75C2178,650.333,2178,658.667,2178,667C2178,675.333,2178,683.667,2178,692C2178,700.333,2178,708.667,2178,717C2178,725.333,2178,733.667,2178,739.917C2178,746.167,2178,750.333,2178,753.833C2178,757.333,2178,760.167,2178,761.583L2178,763"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_SecondChildNonConfigs_SubChildFragmentFragmentManagerViewModel_5" d="M1123,882.5L1123,892.917C1123,903.333,1123,924.167,1123,938.75C1123,953.333,1123,961.667,1123,970C1123,978.333,1123,986.667,1123,995C1123,1003.333,1123,1011.667,1123,1017.917C1123,1024.167,1123,1028.333,1123,1031.833C1123,1035.333,1123,1038.167,1123,1039.583L1123,1041"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_SecondChildViewModelStores_SubChildFragmentViewModelStore_6" d="M1813,882.5L1813,892.917C1813,903.333,1813,924.167,1813,938.75C1813,953.333,1813,961.667,1813,970C1813,978.333,1813,986.667,1813,995C1813,1003.333,1813,1011.667,1813,1017.917C1813,1024.167,1813,1028.333,1813,1031.833C1813,1035.333,1813,1038.167,1813,1039.583L1813,1041"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(640, 1037)" class="root"><g class="clusters"><g data-look="classic" id="SubChildFragmentFragmentManagerViewModel" class="cluster"><rect height="153" width="950" y="8" x="8" style=""></rect><g transform="translate(349.7109375, 8)" class="cluster-label"><foreignObject height="48" width="266.578125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerViewModel(внутри childFragmentManager)</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SubChildRetained-131" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(483, 84.5)" id="flowchart-SubChildNonConfigs-132" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(793, 84.5)" id="flowchart-SubChildViewModelStores-133" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g></g></g><g transform="translate(1640, 1037)" class="root"><g class="clusters"><g data-look="classic" id="SubChildFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SubChildMAP-130" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(2005, 759)" class="root"><g class="clusters"><g data-look="classic" id="SecondChildFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-SecondChildMAP-122" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(2370, 456)" class="root"><g class="clusters"><g data-look="classic" id="ParentFragmentViewModelStore" class="cluster"><rect height="153" width="330" y="8" x="8" style=""></rect><g transform="translate(105.5625, 8)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"></g><g class="edgeLabels"></g><g class="nodes"><g transform="translate(173, 84.5)" id="flowchart-ParentMAP-114" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g></g></g><g transform="translate(193, 97)" id="flowchart-MAP-108" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf()</p></span></div></foreignObject></g></g><g transform="translate(193, 275)" id="flowchart-Retained1-109" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(503, 275)" id="flowchart-ChildNonConfigs1-110" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(2543, 275)" id="flowchart-ViewModelStores1-111" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g><g transform="translate(503, 540.5)" id="flowchart-ParentRetained-115" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(813, 540.5)" id="flowchart-ParentChildNonConfigs-116" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(2178, 540.5)" id="flowchart-ParentViewModelStores-117" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g><g transform="translate(813, 843.5)" id="flowchart-SecondChildRetained-123" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mRetainedFragments: HashMap</p></span></div></foreignObject></g></g><g transform="translate(1123, 843.5)" id="flowchart-SecondChildNonConfigs-124" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mChildNonConfigs: HashMap</p></span></div></foreignObject></g></g><g transform="translate(1813, 843.5)" id="flowchart-SecondChildViewModelStores-125" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mViewModelStores: HashMap</p></span></div></foreignObject></g></g></g></g></g></svg><p id="kiv32_643">Думаю, теперь весь флоу хранения <code class="code" id="kiv32_711">ViewModelStore</code> должен быть полностью понятен.</p><p id="kiv32_644">Если у нас есть <code class="code" id="kiv32_712">FragmentActivity</code> или <code class="code" id="kiv32_713">AppCompatActivity</code>, то у неё есть свой собственный <code class="code" id="kiv32_714">ViewModelStore</code>. Когда мы добавляем фрагмент через её <code class="code" id="kiv32_715">FragmentManager</code>, для этого фрагмента создаётся отдельный <code class="code" id="kiv32_716">ViewModelStore</code>. Этот <code class="code" id="kiv32_717">ViewModelStore</code> будет храниться внутри <code class="code" id="kiv32_718">FragmentManagerViewModel</code>, который, в свою очередь, лежит внутри <code class="code" id="kiv32_719">ViewModelStore</code>, принадлежащего активности.</p><aside class="prompt" data-type="tip" data-title="" id="kiv32_645"><p id="kiv32_720"><code class="code" id="kiv32_721">FragmentManagerViewModel</code> создаётся автоматически при инициализации <code class="code" id="kiv32_722">FragmentManager</code> и регистрируется как обычный <code class="code" id="kiv32_723">ViewModel</code> в <code class="code" id="kiv32_724">ViewModelStoreOwner</code> (например, в активности). Он предназначен именно для хранения <code class="code" id="kiv32_725">ViewModelStore</code>-ов всех дочерних фрагментов.</p></aside><p id="kiv32_646">Если мы добавим ещё один фрагмент на тот же уровень &mdash; всё повторится: новый <code class="code" id="kiv32_726">ViewModelStore</code> &rarr; в <code class="code" id="kiv32_727">FragmentManagerViewModel</code> &rarr; в <code class="code" id="kiv32_728">ViewModelStore</code> активности.</p><p id="kiv32_647">Но фишка в том, что каждый фрагмент имеет свой <code class="code" id="kiv32_729">childFragmentManager</code>, то есть может быть контейнером для других фрагментов. И <code class="code" id="kiv32_730">childFragmentManager</code>, как и любой <code class="code" id="kiv32_731">FragmentManager</code>, имеет свой <code class="code" id="kiv32_732">FragmentManagerViewModel</code>.</p><aside class="prompt" data-type="tip" data-title="" id="kiv32_648"><p id="kiv32_733">При каждом вызове <code class="code" id="kiv32_734">getChildFragmentManager()</code> фреймворк создаёт или использует уже существующий <code class="code" id="kiv32_735">FragmentManagerViewModel</code>. Это гарантирует, что даже при пересоздании фрагмента <code class="code" id="kiv32_736">ViewModelStore</code> вложенных фрагментов не теряется.</p></aside><p id="kiv32_649">Это значит: при добавлении вложенных фрагментов, <code class="code" id="kiv32_737">ViewModelStore</code> каждого из них будет храниться во внутренней <code class="code" id="kiv32_738">FragmentManagerViewModel</code>, принадлежащей <code class="code" id="kiv32_739">childFragmentManager</code> родительского фрагмента.</p><aside class="prompt" data-type="tip" data-title="" id="kiv32_650"><p id="kiv32_740">Внутри <code class="code" id="kiv32_741">FragmentManagerViewModel</code> используются ключи <code class="code" id="kiv32_742">Fragment.mWho</code>, чтобы сохранить и потом правильно восстановить соответствие между <code class="code" id="kiv32_743">Fragment</code> и его <code class="code" id="kiv32_744">ViewModelStore</code>.</p></aside><p id="kiv32_651">Чем глубже вложенность, тем больше разрастается дерево.</p><p id="kiv32_652">Например:</p><div class="code-block" data-lang="none">
Activity
└── ParentFragment1
    └── ParentFragment2
        ├── ChildFragment1
        └── ChildFragment2
</div><p id="kiv32_654">В таком дереве:</p><ul class="list _bullet" id="kiv32_655"><li class="list__item" id="kiv32_745"><p id="kiv32_749"><code class="code" id="kiv32_750">ChildFragment1</code> и <code class="code" id="kiv32_751">ChildFragment2</code> &mdash; их <code class="code" id="kiv32_752">ViewModelStore</code> хранятся в <code class="code" id="kiv32_753">FragmentManagerViewModel</code>, принадлежащем <code class="code" id="kiv32_754">childFragmentManager</code> <code class="code" id="kiv32_755">ParentFragment2</code>.</p></li><li class="list__item" id="kiv32_746"><p id="kiv32_756"><code class="code" id="kiv32_757">ParentFragment2</code> &mdash; его <code class="code" id="kiv32_758">ViewModelStore</code> хранится в <code class="code" id="kiv32_759">FragmentManagerViewModel</code>, принадлежащем <code class="code" id="kiv32_760">childFragmentManager</code> <code class="code" id="kiv32_761">ParentFragment1</code>.</p></li><li class="list__item" id="kiv32_747"><p id="kiv32_762"><code class="code" id="kiv32_763">ParentFragment1</code> &mdash; его <code class="code" id="kiv32_764">ViewModelStore</code> лежит в <code class="code" id="kiv32_765">FragmentManagerViewModel</code> от <code class="code" id="kiv32_766">supportFragmentManager</code> активности.</p></li><li class="list__item" id="kiv32_748"><p id="kiv32_767">А сама <code class="code" id="kiv32_768">FragmentManagerViewModel</code> из <code class="code" id="kiv32_769">supportFragmentManager</code> &mdash; хранится в <code class="code" id="kiv32_770">ViewModelStore</code> самой активности.</p></li></ul><p id="kiv32_656">Такой флоу помогает сохранить <code class="code" id="kiv32_771">ViewModel</code> даже при сложной навигации и вложенности фрагментов.</p><aside class="prompt" data-type="tip" data-title="" id="kiv32_657"><p id="kiv32_772">Зачем вся эта сложность? Такой флоу помогает сохранить ViewModel даже при сложной навигации и глубокой вложенности фрагментов. Такая структура сохраняет иерархию ViewModelStore, обеспечивая корректное восстановление ViewModel даже при пересоздании компонентов.</p></aside><p id="kiv32_658">Итак, мы рассмотрели весь флоу хранения <code class="code" id="kiv32_773">ViewModelStore</code> для фрагментов. Пора двигаться дальше, ведь тема Retain-фрагментов осталась нераскрытой &mdash; поэтому переходим к следующей части статьи.</p></section></section><section class="chapter"><h2 id="retain" data-toc="retain">Как Retain-фрагменты переживают изменение конфигурации?</h2><p id="kiv32_774">Напоминаю ещё раз: Retain-фрагменты устарели довольно давно, и на практике их использование не рекомендуется. О них хорошо помнят разработчики, которые ещё писали на Java &mdash; Retain-фрагменты существовали задолго до появления <code class="code" id="kiv32_824">ViewModel</code>. Когда <code class="code" id="kiv32_825">ViewModel</code> стала стандартом, Retain-фрагменты официально объявили устаревшими. <br> Но знать о них всё же полезно. Итак, начнём.</p><p id="kiv32_775">В начале статьи уже было дано определение Retain-фрагментам. А при разборе &laquo;внутренностей&raquo; FragmentManagerViewModel внимательные глаза могли заметить нечто, связанное с Retain-фрагментами &mdash; а именно, вот этот блок кода, который появлялся в статье уже не раз:</p><div class="code-block" data-lang="java">
final class FragmentManagerViewModel extends ViewModel {
    ...
    private final HashMap&lt;String, Fragment&gt; mRetainedFragments = new HashMap&lt;&gt;();
    private final HashMap&lt;String, FragmentManagerViewModel&gt; mChildNonConfigs = new HashMap&lt;&gt;();
    private final HashMap&lt;String, ViewModelStore&gt; mViewModelStores = new HashMap&lt;&gt;();
    ...
}
</div><p id="kiv32_777">Здесь есть три поля. Два из них мы уже подробно разобрали:</p><ul class="list _bullet" id="kiv32_778"><li class="list__item" id="kiv32_827"><p id="kiv32_829"><code class="code" id="kiv32_830">mViewModelStores</code> &mdash; для хранения <code class="code" id="kiv32_831">ViewModelStore</code> на одном уровне в дереве,</p></li><li class="list__item" id="kiv32_828"><p id="kiv32_832"><code class="code" id="kiv32_833">mChildNonConfigs</code> &mdash; для хранения вложенных <code class="code" id="kiv32_834">FragmentManagerViewModel</code>, соответствующих дочерним фрагментам / <code class="code" id="kiv32_835">FragmentManager</code>.</p></li></ul><p id="kiv32_779">Но вот поле, которому мы до сих пор не уделяли внимания &mdash; это самое верхнее: <code class="code" id="kiv32_836">mRetainedFragments</code>. Это коллекция, которая хранит фрагменты по ключу. <br> Стоп&hellip; что? Фрагменты <span class="control" id="kiv32_838">внутри</span> <code class="code" id="kiv32_839">ViewModel</code>?! Именно так.</p><p id="kiv32_780">Все фрагменты, у которых установлен флаг <code class="code" id="kiv32_840">setRetainInstance(true)</code>, попадают именно туда. <br> Заинтриговал? Тогда давай разбираться глубже.</p><p id="kiv32_781">Как создать Retain Fragment? <br> Retain-фрагменты &mdash; это не какой-то отдельный класс, наследник <code class="code" id="kiv32_843">Fragment</code>. Это всё тот же старый добрый <code class="code" id="kiv32_844">Fragment</code>, но с активированным флагом <code class="code" id="kiv32_845">setRetainInstance</code>:</p><div class="code-block" data-lang="kotlin">
class MyFragment : Fragment() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setRetainInstance(true)
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="kiv32_783"><p id="kiv32_846">Так как Retain-фрагменты устарели, метод <code class="code" id="kiv32_847">setRetainInstance</code> также помечен аннотацией <code class="code" id="kiv32_848">@Deprecated</code>.</p></aside><p id="kiv32_784">С этого момента наш фрагмент становится <span class="emphasis" id="kiv32_849">Retain</span>, и он сможет пережить изменение конфигурации &mdash; по той же схеме, по которой выживают <code class="code" id="kiv32_850">ViewModel</code>. <br> Как именно? Мы уже немного знаем, но всё же давай проследим путь целиком &mdash; от вызова <code class="code" id="kiv32_852">setRetainInstance()</code> до хранения внутри <code class="code" id="kiv32_853">FragmentManagerViewModel#mRetainedFragments</code>.</p><p id="kiv32_785">Для этого заглянем в исходники метода <code class="code" id="kiv32_854">setRetainInstance</code>: <span class="control" id="kiv32_855">Fragment.java:</span></p><div class="code-block" data-lang="java">

@Deprecated
public void setRetainInstance(boolean retain) {
    ...
    if (retain) {
        mFragmentManager.addRetainedFragment(this);
    } else {
        mFragmentManager.removeRetainedFragment(this);
    }
    ...
}
</div><p id="kiv32_787">Логика простая: если флаг <code class="code" id="kiv32_856">retain</code> установлен в <code class="code" id="kiv32_857">true</code>, фрагмент передаётся в <code class="code" id="kiv32_858">FragmentManager</code> как <span class="emphasis" id="kiv32_859">Retain</span> &mdash; через метод <code class="code" id="kiv32_860">addRetainedFragment</code>. <br> Если <code class="code" id="kiv32_862">false</code> &mdash; наоборот, удаляется из списка Retain-фрагментов через <code class="code" id="kiv32_863">removeRetainedFragment</code>.</p><p id="kiv32_788">Давайте продолжим и заглянем в сам <code class="code" id="kiv32_864">FragmentManager</code> и рассмотрим метод его <code class="code" id="kiv32_865">addRetainedFragment</code>:</p><p id="kiv32_789"><span class="control" id="kiv32_866">FragmentManager.java</span>:</p><div class="code-block" data-lang="java">
void addRetainedFragment(@NonNull Fragment f) {
    mNonConfig.addRetainedFragment(f);
}
</div><p id="kiv32_791">Как по старинке, метод передает управление на <code class="code" id="kiv32_867">mNonConfig</code>, который, как мы уже знаем, является экземпляром <code class="code" id="kiv32_868">FragmentManagerViewModel</code>.</p><p id="kiv32_792"><span class="control" id="kiv32_869">FragmentManager.java</span>:</p><div class="code-block" data-lang="java">
private FragmentManagerViewModel mNonConfig;
</div><p id="kiv32_794">Теперь давайте взглянем на метод <code class="code" id="kiv32_870">addRetainedFragment</code> внутри <code class="code" id="kiv32_871">FragmentManagerViewModel</code>:</p><p id="kiv32_795"><span class="control" id="kiv32_872">FragmentManagerViewModel.java</span>:</p><div class="code-block" data-lang="java">
void addRetainedFragment(@NonNull Fragment fragment) {
    ...
    if (mRetainedFragments.containsKey(fragment.mWho)) {
        return;
    }
    mRetainedFragments.put(fragment.mWho, fragment);
    ...
}
</div><p id="kiv32_797">Вот и все: мы разобрались, как фрагмент становится <span class="emphasis" id="kiv32_873">Retain</span> и как его хранение работает в <code class="code" id="kiv32_874">FragmentManagerViewModel</code>.</p><p id="kiv32_798">Теперь рассмотрим метод удаления фрагмента из Retain-списка, который работает по аналогичному принципу &mdash; через тот же flow: <span class="control" id="kiv32_875">Fragment -&gt; FragmentManager -&gt; FragmentManagerViewModel</span>:</p><p id="kiv32_799"><span class="control" id="kiv32_876">FragmentManagerViewModel.java</span>:</p><div class="code-block" data-lang="java">
void removeRetainedFragment(@NonNull Fragment fragment) {
    ...
    boolean removed = mRetainedFragments.remove(fragment.mWho) != null;
    ...
}
</div><p id="kiv32_801">Осталось понять как же потом эти фрагменты восстанавливаются после изменения конфигураций, одного их хранения не достаточно ведь их нужно обратно вернуть после того как Activity пересоздается, все фрагменты пересоздаются, FragmentManager тоже, но Retain фрагменты не должны пересоздаваться, а должны браться из <code class="code" id="kiv32_877">mRetainedFragments</code>, мы уже в начале статьи видели метод attachController у <code class="code" id="kiv32_878">FragmentManager</code>:</p><div class="code-block" data-lang="java">

@SuppressLint(&quot;SyntheticAccessor&quot;)
void attachController(@NonNull FragmentHostCallback&lt;?&gt; host,
                      @NonNull FragmentContainer container, @Nullable final Fragment parent) {

    ...

    if (savedInstanceState != null) {
        restoreSaveStateInternal(savedInstanceState);
    }
    ...
}
</div><p id="kiv32_803">Видим что идет обращение к методу restoreSaveStateInternal:</p><div class="code-block" data-lang="java">
void restoreSaveStateInternal(@Nullable Parcelable state) {
    ...
    Bundle bundle = (Bundle) state;
    ...
    FragmentManagerState fms = bundle.getParcelable(FRAGMENT_MANAGER_STATE_KEY);
    ...

    for (String who : fms.mActive) {
        ...
        Fragment retainedFragment = mNonConfig.findRetainedFragmentByWho(fs.mWho);
        ...
        mFragmentStore.makeActive(fragmentStateManager);
        ...
    }
}
</div><p id="kiv32_805">Нас интересует это строка, очередное обращение к <code class="code" id="kiv32_879">mNonConfig</code>:</p><div class="code-block" data-lang="java">
Fragment retainedFragment = mNonConfig.findRetainedFragmentByWho(fs.mWho);
</div><p id="kiv32_807">Вот и сам метод findRetainedFragmentByWho внутри FragmentManagerViewModel:</p><div class="code-block" data-lang="java">

@Nullable
Fragment findRetainedFragmentByWho(String who) {
    return mRetainedFragments.get(who);
}
</div><p id="kiv32_809">Таким образом, при восстановлении <code class="code" id="kiv32_880">FragmentManager</code> и пересоздании <code class="code" id="kiv32_881">Activity</code>, <span class="control" id="kiv32_882">Retain-фрагменты</span> переживают это пересоздание: они открепляются, а после восстановления <code class="code" id="kiv32_883">FragmentManager</code> и <code class="code" id="kiv32_884">Activity</code> &mdash; снова подключаются.</p><p id="kiv32_810">Ранее я упоминал, что <span class="control" id="kiv32_885">Retain-фрагменты</span> существовали до появления <code class="code" id="kiv32_886">ViewModel</code>. Но в текущей реализации мы видим, что они переживают пересоздание <code class="code" id="kiv32_887">Activity</code> благодаря хранению в <code class="code" id="kiv32_888">FragmentManagerViewModel</code>, и именно там они поддерживаются. Но как они работали до появления <code class="code" id="kiv32_889">ViewModel</code> в Android?</p><p id="kiv32_811">Кратко напомню: это было во времена <code class="code" id="kiv32_890">android.app.Fragment</code>. Сейчас они устарели и заменены на <code class="code" id="kiv32_891">androidx.fragment.app.Fragment</code>. В старой реализации механизм напоминал работу с <code class="code" id="kiv32_892">NonConfigurationInstances</code>. Если кратко, то для <span class="control" id="kiv32_893">Retain-фрагментов</span> в <code class="code" id="kiv32_894">android.app.Fragment</code> использовался следующий механизм &mdash; они хранились здесь:</p><div class="code-block" data-lang="kotlin">
@Deprecated
public class FragmentManagerNonConfig {
    private final List&lt;Fragment&gt; mFragments;
    private final List&lt;FragmentManagerNonConfig&gt; mChildNonConfigs;

    FragmentManagerNonConfig(List&lt;Fragment&gt; fragments,
    List&lt;FragmentManagerNonConfig&gt; childNonConfigs)
    {
        mFragments = fragments;
        mChildNonConfigs = childNonConfigs;
    }

    /**
     * @return the retained instance fragments returned by a FragmentManager
     */
    List&lt;Fragment&gt; getFragments()
    {
        return mFragments;
    }

    /**
     * @return the FragmentManagerNonConfigs from any applicable fragment's child FragmentManager
     */
    List&lt;FragmentManagerNonConfig&gt; getChildNonConfigs()
    {
        return mChildNonConfigs;
    }
}
</div><p id="kiv32_813">Далее объект <code class="code" id="kiv32_895">FragmentManagerNonConfig</code> хранился внутри <code class="code" id="kiv32_896">NonConfigurationInstances</code> в поле <code class="code" id="kiv32_897">fragments</code> и переживал изменения конфигураций ровно по той же схеме, которую мы уже рассмотрели в первой статье:</p><div class="code-block" data-lang="java">
public class Activity extends ContextThemeWrapper ...{

static final class NonConfigurationInstances {
    Object activity;
    HashMap&lt;String, Object&gt; children;
    FragmentManagerNonConfig fragments;
    ArrayMap&lt;String, LoaderManager&gt; loaders;
    VoiceInteractor voiceInteractor;
}
}
</div><p id="kiv32_815">Мы кратко рассмотрели этот механизм, потому что он представляет собой тройное устаревание:</p><ul class="list _bullet" id="kiv32_816"><li class="list__item" id="kiv32_898"><p id="kiv32_901">сами <code class="code" id="kiv32_902">android.app.Fragment</code> устарели и были заменены на <code class="code" id="kiv32_903">androidx.fragment.app.Fragment</code>;</p></li><li class="list__item" id="kiv32_899"><p id="kiv32_904">концепция <span class="control" id="kiv32_905">Retain-фрагментов</span>, которая позволяла фрагментам переживать пересоздание <code class="code" id="kiv32_906">Activity</code>, устарела, и теперь вместо неё рекомендуется использовать <code class="code" id="kiv32_907">ViewModel</code>;</p></li><li class="list__item" id="kiv32_900"><p id="kiv32_908">способ хранения этих фрагментов через <code class="code" id="kiv32_909">FragmentManagerNonConfig</code> также устарел &mdash; его заменил более современный механизм с использованием <code class="code" id="kiv32_910">FragmentManagerViewModel</code>, несмотря на то, что концепция <span class="control" id="kiv32_911">Retain-фрагментов</span> уже не считается актуальной.</p></li></ul><p id="kiv32_817">Таким образом, это не просто устаревшая реализация, а целая цепочка из трёх устаревших технологий, которые были полностью переработаны в современных версиях Android.</p><p id="kiv32_818">На этом, пожалуй, всё. В этой статье мы рассмотрели некоторые смежные моменты и пересечения, подведём итоги.</p><section class="chapter"><h3 id="viewmodel-fragment" data-toc="viewmodel-fragment"><span class="control" id="kiv32_916">ViewModel в Fragment</span></h3><div class="code-block" data-lang="none">
MyViewModel -&gt; ViewModelStore -&gt; FragmentManagerViewModel -&gt; ViewModelStore(Activity's) -&gt; 
ComponentActivity.NonConfigurationInstances -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord
</div><p id="kiv32_914">Современный способ хранения состояний в <code class="code" id="kiv32_917">Fragment</code> основан на использовании <code class="code" id="kiv32_918">ViewModel</code>, которая помещается в <code class="code" id="kiv32_919">ViewModelStore</code>. Управление этим хранилищем осуществляется через <code class="code" id="kiv32_920">FragmentManagerViewModel</code>. В свою очередь, <code class="code" id="kiv32_921">FragmentManagerViewModel</code> привязан к <code class="code" id="kiv32_922">ViewModelStore</code> активности, которая сохраняет его в <code class="code" id="kiv32_923">NonConfigurationInstances</code>. Эта цепочка позволяет сохранять состояние фрагмента даже при изменении конфигурации, избегая пересоздания объектов, которые критичны для долгосрочного хранения данных.</p></section><section class="chapter"><h3 id="retainfragment-androidx-fragment-app-fragment" data-toc="retainfragment-androidx-fragment-app-fragment"><span class="control" id="kiv32_928">RetainFragment в <code class="code" id="kiv32_929">androidx.fragment.app.Fragment</code></span></h3><div class="code-block" data-lang="none">
MyRetainFragment -&gt; FragmentManagerViewModel -&gt; ViewModelStore(Activity's) -&gt; 
ComponentActivity.NonConfigurationInstances -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord
</div><p id="kiv32_926">Термин <span class="control" id="kiv32_930">RetainFragment</span> в <code class="code" id="kiv32_931">androidx.fragment.app.Fragment</code> &mdash; это скорее пережиток старых версий API. В современных реализациях <code class="code" id="kiv32_932">androidx</code>, фрагменты с сохранением состояния через <code class="code" id="kiv32_933">setRetainInstance(true)</code> фактически больше не рекомендуется использовать. Вместо этого управление состоянием переместилось в <code class="code" id="kiv32_934">ViewModel</code>, которая синхронизируется с жизненным циклом фрагмента через <code class="code" id="kiv32_935">FragmentManagerViewModel</code>. Сохранение происходит в <code class="code" id="kiv32_936">ViewModelStore</code> активности, которая, как и в первом случае, попадает в <code class="code" id="kiv32_937">NonConfigurationInstances</code> при пересоздании <code class="code" id="kiv32_938">Activity</code>. Таким образом, <span class="control" id="kiv32_939">RetainFragment</span> в классическом понимании уже не используется, его роль полностью взяла на себя связка <code class="code" id="kiv32_940">Fragment</code> + <code class="code" id="kiv32_941">ViewModel</code>.</p></section><section class="chapter"><h3 id="retainfragment-android-app-fragment" data-toc="retainfragment-android-app-fragment"><span class="control" id="kiv32_946">RetainFragment в <code class="code" id="kiv32_947">android.app.Fragment</code> (устаревший механизм)</span></h3><div class="code-block" data-lang="none">
MyRetainFragment -&gt; FragmentManagerNonConfig -&gt; Activity.NonConfigurationInstances -&gt; 
ActivityThread.ActivityClientRecord
</div><p id="kiv32_944">В старой реализации Android, когда использовались <code class="code" id="kiv32_948">android.app.Fragment</code>, механизм пересоздания фрагментов реализовывался через <code class="code" id="kiv32_949">FragmentManagerNonConfig</code>. Объекты <code class="code" id="kiv32_950">RetainFragment</code> помещались в специальный контейнер, который сохранялся в <code class="code" id="kiv32_951">NonConfigurationInstances</code>. При пересоздании активности, эта структура восстанавливалась из <code class="code" id="kiv32_952">ActivityClientRecord</code> в <code class="code" id="kiv32_953">ActivityThread</code>. Этот механизм сейчас полностью устарел и был заменён на использование <code class="code" id="kiv32_954">ViewModel</code>, так как это более надёжный и гибкий способ сохранить данные на время изменения конфигурации.</p></section><section class="chapter"><h3 id="kiv32_823" data-toc="kiv32_823"><span class="control" id="kiv32_960">Итоги</span></h3><p id="kiv32_956">Эволюция механизмов хранения состояний в <code class="code" id="kiv32_961">Fragment</code> прошла несколько стадий:</p><ol class="list _decimal" id="kiv32_957" type="1"><li class="list__item" id="kiv32_962"><p id="kiv32_965"><span class="control" id="kiv32_966">android.app.Fragment</span> с <code class="code" id="kiv32_967">FragmentManagerNonConfig</code> &rarr; полностью устарел, более не поддерживается.</p></li><li class="list__item" id="kiv32_963"><p id="kiv32_968"><span class="control" id="kiv32_969">RetainFragment</span> в <code class="code" id="kiv32_970">androidx.fragment.app.Fragment</code> &rarr; больше не рекомендуется, его заменяет связка с <code class="code" id="kiv32_971">ViewModel</code>.</p></li><li class="list__item" id="kiv32_964"><p id="kiv32_972"><span class="control" id="kiv32_973">Современный подход</span> &mdash; <code class="code" id="kiv32_974">ViewModelStore</code> внутри <code class="code" id="kiv32_975">FragmentManagerViewModel</code>, который напрямую привязан к жизненному циклу фрагмента и сохраняется в <code class="code" id="kiv32_976">Activity</code>.</p></li></ol><p id="kiv32_958">Теперь вместо устаревших концепций рекомендуется использовать обычные фрагменты в паре с <code class="code" id="kiv32_977">ViewModel</code>, что делает код более предсказуемым и легко поддерживаемым.</p></section></section><div class="last-modified">01 July 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="view-model-under-the-hood-store.html" class="navigation-links__prev">ViewModel под капотом: как она выживает при пересоздании Activity</a><a href="view-model-under-the-hood-сompose.html" class="navigation-links__next">ViewModel под капотом: как работает в Compose и View</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>