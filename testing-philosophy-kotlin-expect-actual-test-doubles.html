<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-link-color="#57B747" data-content-max-width="1600" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2026-01-03T19:01:12.938109"><title>Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | insider</title><script type="application/json" id="virtual-toc-data">[{"id":"1","level":0,"title":"1. Введение: почему тесты это модель поведения","anchor":"#1"},{"id":"2","level":0,"title":"2. Базис: Лексикон тестирования","anchor":"#2"},{"id":"3","level":0,"title":"3. Концепция: Что вообще мы тестируем?","anchor":"#3"},{"id":"4-expect-actual","level":0,"title":"4. Expect / Actual: Слова, которые всё говорят","anchor":"#4-expect-actual"},{"id":"5-test-doubles-mocks-stubs-fakes-spies-dummy","level":0,"title":"5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies, Dummy","anchor":"#5-test-doubles-mocks-stubs-fakes-spies-dummy"},{"id":"6-unit-vs-junit","level":0,"title":"6. Unit vs JUnit: Что действительно стоит за словами","anchor":"#6-unit-vs-junit"},{"id":"junit-5-test","level":0,"title":"Как JUnit 5 запускает ваш @Test: от команды до метода","anchor":"#junit-5-test"},{"id":"7-kotlin-test-kotest","level":0,"title":"7. Kotlin Test: Строгая минималистика или Kotest","anchor":"#7-kotlin-test-kotest"},{"id":"8","level":0,"title":"8. Заключение: Тесты как мышление, а не как процедура","anchor":"#8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/style.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://iili.io/3eop8YX.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | insider"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="insider Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | insider"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html#webpage",
    "url": "writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html",
    "name": "Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | insider",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "insider Help"
}</script><!-- End Schema.org --></head><body data-id="testing_philosophy_kotlin_expect_actual_test_doubles" data-main-title="Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Kotlin///Test"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>insider 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="testing_philosophy_kotlin_expect_actual_test_doubles" id="testing_philosophy_kotlin_expect_actual_test_doubles.md">Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles</h1><section class="chapter"><h2 id="1" data-toc="1">1. Введение: почему тесты это модель поведения</h2><p id="z61r5e_11">Эта статья открывает серию &laquo;Android под капотом: Тестирование без иллюзий&raquo;. Первая часть посвящена базовым концепциям тестирования. Тесты это реализация моделей поведения в виде исполняемого кода. Когда мы пишем тест, мы создаём контролируемое окружение, где зависимости управляются явно, а система ведёт себя предсказуемо. Тест фиксирует то, как система должна работать в заданных условиях.</p><p id="z61r5e_12">Тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется, тест падает. Не потому, что код стал хуже, а потому, что изменились требования. Тест фиксирует границы допустимого. Каждый <code class="code" id="z61r5e_14">assertEquals(expected, actual)</code> это акт утверждения: если <code class="code" id="z61r5e_15">actual == expected</code>, то всё хорошо. Это соглашение между кодом и ожиданиями.</p><p id="z61r5e_13">Kotlin хорошо подходит для тестирования благодаря тем же инструментам, что и для основного кода: лямбды, DSL, расширения, корутины, строгая типизация. Тесты на Kotlin пишутся теми же средствами, в той же парадигме. Во всей серии примеры будут на Kotlin, так как это стандарт Android-разработки и полноценный язык для продакшена, независимо от платформы.</p></section><section class="chapter"><h2 id="2" data-toc="2">2. Базис: Лексикон тестирования</h2><p id="z61r5e_16">Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Ниже представлен минимум, на который будет опираться вся серия.</p><section class="chapter"><h3 id="assertion" data-toc="assertion">Assertion</h3><p id="z61r5e_25">Assertion это программное утверждение, выражающее ожидание. Если оно не выполняется, тест считается неуспешным. В большинстве фреймворков assertion реализован как функция, выбрасывающая исключение при расхождении:</p><div class="code-block" data-lang="kotlin">
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
</div><p id="z61r5e_27">Важно понимать: assertion фиксирует поведение. Это финальная точка сценария, где тест явно заявляет: <span class="emphasis" id="z61r5e_28">вот то, что я считаю допустимым</span>. Всё остальное лишь подготовка к этому моменту.</p></section><section class="chapter"><h3 id="test-case" data-toc="test-case">Test Case</h3><p id="z61r5e_29">Test Case это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и проверка результата (assert). В Kotlin это обычно функция с аннотацией <code class="code" id="z61r5e_32">@Test</code>.</p><div class="code-block" data-lang="kotlin">
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login(&quot;admin&quot;, &quot;wrong&quot;)
    assertFalse(result.success)
}
</div><p id="z61r5e_31">Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения, он быстро теряет свою надёжность.</p></section><section class="chapter"><h3 id="test-suite" data-toc="test-suite">Test Suite</h3><p id="z61r5e_33">Test Suite это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно это класс, файл или структура DSL. Назначение suite-а собрать родственные кейсы и запускать их совместно, например, при CI-сборке или нагрузочном прогоне.</p><p id="z61r5e_34">Хорошо организованный suite это карта покрытия. Он показывает, где есть тесты, а где только надежда на интуицию разработчиков.</p></section><section class="chapter"><h3 id="test-runner" data-toc="test-runner">Test Runner</h3><p id="z61r5e_35">Test Runner это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение, репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через Gradle (или build system IDE), где runner интегрирован в пайплайн.</p><p id="z61r5e_36">Хороший runner не замечается. Плохой ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.</p></section><section class="chapter"><h3 id="test-double" data-toc="test-double">Test Double</h3><p id="z61r5e_37">Test Double это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.</p><p id="z61r5e_38">Существует несколько типов Test Double-ов, и каждый из них решает свою задачу.</p><p id="z61r5e_39"><span class="control" id="z61r5e_45">Stub</span> используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем. Его задача быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.</p><p id="z61r5e_40"><span class="control" id="z61r5e_46">Mock</span> применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.</p><p id="z61r5e_41"><span class="control" id="z61r5e_47">Fake</span> это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В отличие от stub-ов и mock-ов, фейк умеет &laquo;жить&raquo;, накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.</p><p id="z61r5e_42"><span class="control" id="z61r5e_48">Spy</span> похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.</p><p id="z61r5e_43"><span class="control" id="z61r5e_49">Dummy</span>: самый простой и самый бесполезный на первый взгляд Test Double. Он ничего не делает, ничего не возвращает и никак не влияет на поведение теста. Его задача : просто быть. Dummy нужен в тех случаях, когда метод требует обязательного параметра, но в тесте этот параметр не играет никакой роли. Например, когда нужно передать объект логгера или callback, но сам лог не важен. Это форма синтаксического шума, которую мы осознанно заглушаем.</p><p id="z61r5e_44">Test Double это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения. И если код не поддаётся тестированию с такими объектами, проблема обычно в архитектуре.</p></section><section class="chapter"><h3 id="z61r5e_22" data-toc="z61r5e_22">Типы тестов</h3><p id="z61r5e_50">Тестирование программного обеспечения не ограничивается единым понятием &laquo;тест&raquo;. Система проверки качества строится по уровням, и каждый из них отвечает за свою область: минимальные единицы кода, взаимодействие модулей, целостные сценарии работы и пользовательский интерфейс.</p><p id="z61r5e_51">На практике выделяют четыре фундаментальных типа: <span class="control" id="z61r5e_58">Unit tests</span>, <span class="control" id="z61r5e_59">Integration tests</span>, <span class="control" id="z61r5e_60">End-to-End tests</span> и <span class="control" id="z61r5e_61">UI tests</span>. Эти уровни образуют основу так называемой пирамиды тестирования. Чем ниже уровень, тем тесты быстрее и дешевле, но тем уже их охват. Чем выше уровень, тем дороже исполнение, зато ближе к реальному поведению системы.</p><p id="z61r5e_52">Поверх этих уровней накладываются подтипы, например <span class="control" id="z61r5e_62">Regression testing</span>, <span class="control" id="z61r5e_63">Smoke testing</span>, <span class="control" id="z61r5e_64">Property-based testing</span>, <span class="control" id="z61r5e_65">Mutation testing</span>, <span class="control" id="z61r5e_66">Accessibility testing</span>. Они уточняют цель проверки: устойчивость изменений, работу под нагрузкой, соблюдение контрактов, корректность визуального отображения.</p><p id="z61r5e_53">Такое разделение позволяет выстраивать баланс: большая часть тестов должна находиться на нижних уровнях ради скорости и покрытия, а верхние уровни должны фиксировать критические пользовательские сценарии и визуальное качество.</p><section class="chapter"><h4 id="unit-tests" data-toc="unit-tests">Unit tests</h4><p id="z61r5e_67">Модульные тесты представляют собой фундамент любого процесса тестирования. Их задача проста в формулировке и сложна в реализации: убедиться, что каждая минимальная единица программы (функция, метод или класс) выполняет свои обязанности корректно и предсказуемо. Важно уточнить термин: слово &laquo;модульные&raquo; здесь относится к самостоятельной единице кода, а не к модулю сборки или библиотеке. Если представить систему как здание, то unit-тесты проверяют прочность каждого кирпича до того, как они будут объединены в стены и этажи.</p><p id="z61r5e_68">Технически модульные тесты должны выполняться в полной изоляции. Это означает отсутствие зависимостей от сети, базы данных или файловой системы. Всё, что может замедлить или сделать тест нестабильным, выносится наружу через подмены (mocks, fakes, stubs). Такая изоляция обеспечивает высокую скорость обратной связи: хорошо построенная база unit-тестов выполняется за секунды, даже если речь идёт о сотнях проверок, что делает их незаменимыми в ежедневном цикле разработки.</p><p id="z61r5e_69">На этом уровне тесты максимально близки к исходному коду. Здесь особенно ценятся property-based подходы и тесты граничных условий. Простая проверка &laquo;3 + 4 = 7&raquo; полезна, но не даёт уверенности, что метод сложения работает всегда. Гораздо эффективнее задать универсальное свойство, например &laquo;сложение коммутативно, то есть a + b всегда равно b + a&raquo;, и прогнать его на случайных входных данных.</p><p id="z61r5e_70">Пример компактного unit-теста на калькуляторе:</p><div class="code-block" data-lang="kotlin">
class Calculator {
    fun sum(a: Int, b: Int): Int = a + b
}

class CalculatorTest {
    @Test
    fun sum_twoNumbers_returnsCorrectResult() {
        val calc = Calculator()
        assertEquals(7, calc.sum(3, 4))
    }
}
</div><p id="z61r5e_72">Такой тест демонстрирует принцип изоляции и быстрой проверки. В реальной практике набор расширяют проверками на нуль, отрицательные значения, большие числа, а также свойствами наподобие коммутативности и ассоциативности для обнаружения скрытых дефектов.</p><p id="z61r5e_73">Подтипы, которые особенно характерны для этого уровня:</p><ul class="list _bullet" id="z61r5e_74"><li class="list__item" id="z61r5e_76"><p id="z61r5e_79"><span class="control" id="z61r5e_80">Property-based testing</span> позволяет формулировать универсальные свойства функций и автоматически проверять их на широком спектре случайных входных данных, что помогает обнаружить скрытые граничные случаи.</p></li><li class="list__item" id="z61r5e_77"><p id="z61r5e_81"><span class="control" id="z61r5e_82">Boundary testing</span> концентрируется на тестировании крайних значений, пустых коллекций, нулевых указателей и других нештатных входных данных, которые часто становятся источником ошибок в продакшене.</p></li><li class="list__item" id="z61r5e_78"><p id="z61r5e_83"><span class="control" id="z61r5e_84">Mutation testing</span> представляет собой метод проверки качества самих тестов путем искусственного внесения ошибок в исходный код и контроля того, что существующие тесты действительно обнаруживают эти намеренно созданные дефекты.</p></li></ul><p id="z61r5e_75">Цель unit-тестов состоит в обеспечении надёжности базовой логики, чтобы более высокие уровни тестирования могли концентрироваться на взаимодействиях и пользовательских сценариях.</p></section><section class="chapter"><h4 id="integration-tests" data-toc="integration-tests">Integration tests</h4><p id="z61r5e_85">Интеграционные тесты проверяют, как разные части системы работают вместе. Если unit-тесты гарантируют корректность отдельных кирпичей, то интеграционные фиксируют качество швов между ними. Это может быть взаимодействие сервиса с базой данных, репозитория с API или модуля с внешней библиотекой.</p><p id="z61r5e_86">Ключевая особенность интеграционных тестов состоит в отсутствии полной изоляции. Здесь допустимо участие файловой системы, базы или даже сетевых запросов (чаще в контролируемом окружении). Главное правило состоит в том, чтобы ограничиться проверкой конкретного взаимодействия, не уходя в масштаб всей системы. Такие тесты выполняются дольше unit-тестов, но дают уверенность, что компоненты корректно связаны.</p><div class="code-block" data-lang="kotlin">
data class User(val name: String)

class UserRepository(private val db: Database) {
    fun find(name: String): User? = db.query(name)
}

@Test
fun repository_returnsUserFromDatabase() {
    val db = InMemoryDatabase()
    db.insert(User(&quot;osman&quot;))
    val repo = UserRepository(db)

    val result = repo.find(&quot;osman&quot;)
    assertEquals(&quot;osman&quot;, result?.name)
}
</div><p id="z61r5e_88">Здесь мы не тестируем внутреннюю логику метода <code class="code" id="z61r5e_92">find</code> и не проверяем базу как отдельный продукт. Цель в том, чтобы убедиться: репозиторий и база данных действительно понимают друг друга.</p><p id="z61r5e_89">Стоит подчеркнуть, что граница между unit- и integration-тестами не является жёсткой. Unit-тест полностью контролирует окружение: все внешние зависимости заменены на подставные объекты (test doubles), состояние стабильно, внешних эффектов нет. Integration-тест допускает реальные зависимости: базу, файловую систему, сеть. Между ними существует шкала. Например, использование реального генератора UUID или системного времени формально выводит тест из категории unit, но это может быть допустимым компромиссом. Критерий здесь в уровне изоляции: чем больше зависимостей контролируется, тем ближе тест к unit; чем больше задействуются реальные компоненты, тем ближе он к integration.</p><p id="z61r5e_90">Подтипы, часто относимые к интеграционным тестам:</p><ul class="list _bullet" id="z61r5e_91"><li class="list__item" id="z61r5e_93"><p id="z61r5e_96"><span class="control" id="z61r5e_97">Contract testing</span> обеспечивает проверку того, что различные сервисы общаются по строго согласованному контракту, включая форматы данных, структуру API и ожидаемые ответы, что особенно важно в микросервисной архитектуре.</p></li><li class="list__item" id="z61r5e_94"><p id="z61r5e_98"><span class="control" id="z61r5e_99">Compatibility testing</span> проверяет работоспособность модуля с различными версиями зависимостей, операционных систем или внешних сервисов, помогая выявить проблемы совместимости до релиза в продакшен.</p></li><li class="list__item" id="z61r5e_95"><p id="z61r5e_100"><span class="control" id="z61r5e_101">Integration with in-memory DB</span> представляет собой компромиссный подход, который ускоряет выполнение тестов за счет использования легких in-memory реализаций баз данных вместо полноценных серверов, сохраняя при этом логику взаимодействия с хранилищем.</p></li></ul></section><section class="chapter"><h4 id="end-to-end-tests" data-toc="end-to-end-tests">End-to-End tests</h4><p id="z61r5e_102">Термин <span class="emphasis" id="z61r5e_109">End-to-End</span> буквально переводится как &laquo;от конца до конца&raquo; и означает прохождение полного пути от начального действия пользователя до конечного результата в системе. Такой тест не ограничивается проверкой одной функции или даже пары модулей: он прогоняет сценарий через весь стек, включая интерфейс, бизнес-логику, базу данных и внешние сервисы.</p><p id="z61r5e_103">Главное отличие от интеграционных тестов в том, что здесь проверяется весь пользовательский сценарий целиком. Это именно имитация реальной работы: пользователь авторизуется, выбирает товар, оформляет заказ, система сохраняет его в базе и возвращает подтверждение.</p><p id="z61r5e_104">Пример:</p><div class="code-block" data-lang="kotlin">
@Test
fun user_canLoginAndCheckout() {
    launchApp()
    login(&quot;demo&quot;, &quot;password&quot;)
    addProductToCart(&quot;Laptop&quot;)
    checkout()
    assertOrderHistoryContains(&quot;Laptop&quot;)
}
</div><p id="z61r5e_106">Такой тест охватывает весь цикл: интерфейс для логина и выбора товара, бизнес-логику корзины, работу хранилища или API и проверку конечного состояния.</p><p id="z61r5e_107">Подтипы End-to-End тестирования:</p><ul class="list _bullet" id="z61r5e_108"><li class="list__item" id="z61r5e_110"><p id="z61r5e_113"><span class="control" id="z61r5e_114">Regression testing</span> представляет собой повторную проверку ранее работающих пользовательских сценариев после внесения изменений в код, чтобы убедиться, что новые функции не сломали существующую функциональность.</p></li><li class="list__item" id="z61r5e_111"><p id="z61r5e_115"><span class="control" id="z61r5e_116">Smoke testing</span> включает в себя минимальный набор критически важных тестов, которые быстро подтверждают, что система корректно запускается и выполняет основные бизнес-функции без глубокой детализации.</p></li><li class="list__item" id="z61r5e_112"><p id="z61r5e_117"><span class="control" id="z61r5e_118">Sanity testing</span> фокусируется на точечной проверке конкретного изменения, новой функции или исправления бага, обеспечивая быстрое подтверждение того, что внесенные изменения работают как ожидается.</p></li></ul></section><section class="chapter"><h4 id="ui-tests" data-toc="ui-tests">UI tests</h4><p id="z61r5e_119">UI-тесты проверяют корректность работы пользовательского интерфейса: отображение элементов, тексты, навигацию, реакции на действия. Если <span class="emphasis" id="z61r5e_126">End-to-End</span> тест фиксирует весь сценарий использования целиком, то UI-тест концентрируется на уровне экрана. Важно, что пользователь может выполнить сценарий, и что интерфейс реагирует предсказуемо и не искажает опыт.</p><p id="z61r5e_120">Термин <span class="emphasis" id="z61r5e_127">UI test</span> (User Interface test) означает, что точкой входа является именно взаимодействие с визуальными элементами: кнопками, формами, списками, навигацией. Такой тест может запускаться на реальном устройстве или в эмуляторе и симулировать действия пользователя.</p><p id="z61r5e_121">Пример:</p><div class="code-block" data-lang="kotlin">
@Test
fun buttonClick_changesText() {
    onView(withId(R.id.button)).perform(click())
    onView(withId(R.id.button)).check(matches(withText(&quot;Clicked!&quot;)))
}
</div><p id="z61r5e_123">Здесь проверяется, что кнопка существует, кликается и меняет текст после нажатия. Такой тест затрагивает весь стек от отображения на экране до вызова обработчика события, но цель остаётся узкой: убедиться, что пользовательский интерфейс работает так, как задумано.</p><p id="z61r5e_124">Подтипы, часто относимые к UI-тестированию:</p><ul class="list _bullet" id="z61r5e_125"><li class="list__item" id="z61r5e_128"><p id="z61r5e_131"><span class="control" id="z61r5e_132">Visual regression testing</span> обеспечивает автоматизированное сравнение текущего состояния пользовательского интерфейса со скриншотами эталонной версии, позволяя быстро обнаружить нежелательные изменения в визуальном оформлении или макете.</p></li><li class="list__item" id="z61r5e_129"><p id="z61r5e_133"><span class="control" id="z61r5e_134">Accessibility testing</span> проверяет доступность интерфейса для людей с ограниченными возможностями, включая корректность работы с программами чтения экрана, достаточную контрастность текста, наличие альтернативных текстов для изображений и навигацию с клавиатуры.</p></li><li class="list__item" id="z61r5e_130"><p id="z61r5e_135"><span class="control" id="z61r5e_136">Cross-browser / cross-device testing</span> гарантирует одинаковую работу пользовательского интерфейса на различных браузерах, операционных системах, размерах экранов и типах устройств, выявляя специфичные для платформы проблемы отображения.</p></li></ul></section></section><section class="chapter"><h3 id="z61r5e_23" data-toc="z61r5e_23">Пирамида в тестирований</h3><p id="z61r5e_137">После того как мы разобрали четыре фундаментальных уровня тестирования (Unit, Integration, End-to-End и UI), логично встает вопрос: как распределять усилия между ними? Можно ли просто писать по чуть-чуть каждого вида тестов и считать систему покрытой? Здесь появляется концепция &laquo;тестовой пирамиды&raquo;.</p><section class="chapter"><h4 id="test-pyramid" data-toc="test-pyramid">Test Pyramid</h4><p id="z61r5e_141"><span class="emphasis" id="z61r5e_143">Test Pyramid</span> представляет собой модель, предложенную Майком Коэном, которая иллюстрирует баланс между разными уровнями тестов. Основание пирамиды занимают <span class="control" id="z61r5e_144">Unit tests</span>: их должно быть много, они быстрые, изолированные и дают мгновенную обратную связь. Выше идут <span class="control" id="z61r5e_145">Integration tests</span>: их меньше, они медленнее, но подтверждают, что модули действительно работают вместе. Ещё выше находятся <span class="control" id="z61r5e_146">End-to-End tests</span> и <span class="control" id="z61r5e_147">UI tests</span>: самые дорогие, ресурсоёмкие и нестабильные, поэтому их доля должна быть минимальной, ограниченной критически важными сценариями.</p><p id="z61r5e_142">Идея пирамиды проста: чем выше уровень теста, тем он дороже и сложнее в поддержке, и тем меньше их должно быть в наборе.</p></section><section class="chapter"><h4 id="test-trophy" data-toc="test-trophy">Test Trophy</h4><p id="z61r5e_148">Противоположная точка зрения представлена концепцией <span class="emphasis" id="z61r5e_152">Test Trophy</span>, предложенной Кентом Сибертом (создателем Testing Library для JavaScript). Он утверждает, что пирамида слишком консервативна: в реальных проектах на первый план выходят <span class="control" id="z61r5e_153">Integration tests</span>, потому что именно они проверяют связки между модулями, а не только изолированную логику.</p><p id="z61r5e_149">Форма &laquo;трофея&raquo; отражает это смещение:</p><ul class="list _bullet" id="z61r5e_150"><li class="list__item" id="z61r5e_154"><p id="z61r5e_157">Основание остаётся за Unit tests, но их меньше, чем в классической пирамиде.</p></li><li class="list__item" id="z61r5e_155"><p id="z61r5e_158">Основная масса приходится на Integration tests.</p></li><li class="list__item" id="z61r5e_156"><p id="z61r5e_159">End-to-End и UI тесты по-прежнему на вершине, но в ограниченном количестве.</p></li></ul><p id="z61r5e_151">Аргумент в пользу трофея в том, что чрезмерное количество unit-тестов часто приводит к проверке деталей реализации вместо поведения. При этом интеграционные тесты лучше фиксируют реальное использование системы.</p></section><section class="chapter"><h4 id="test-pyramid-vs-test-trophy" data-toc="test-pyramid-vs-test-trophy">Test Pyramid vs Test Trophy</h4><p id="z61r5e_160">На практике ни одна модель не является абсолютной. Пирамида подчёркивает важность дешёвых и быстрых unit-тестов, а трофей акцентирует ценность интеграционных проверок. Оптимальный подход зависит от проекта:</p><ul class="list _bullet" id="z61r5e_161"><li class="list__item" id="z61r5e_162"><p id="z61r5e_164">для библиотек и SDK, где критична математическая точность и надёжность алгоритмов, ближе модель пирамиды;</p></li><li class="list__item" id="z61r5e_163"><p id="z61r5e_165">для пользовательских приложений и веб-сервисов, где важна связка компонентов и взаимодействие слоёв, полезнее ориентироваться на трофей.</p></li></ul></section></section><section class="chapter"><h3 id="z61r5e_24" data-toc="z61r5e_24">Принципы тестирования</h3><p id="z61r5e_166">Когда мы обсуждаем пирамиду или трофей, речь идёт о том, <span class="control" id="z61r5e_169">сколько</span> тестов должно быть на каждом уровне. Но распределение представляет собой только часть картины. Сам тест может существовать на правильном уровне и при этом не давать доверия. Причина в том, что важны форма набора тестов и качество каждого из них.</p><p id="z61r5e_167">Чтобы тест приносил пользу, он должен подчиняться ряду принципов: изоляция, детерминированность, повторяемость и независимость. Эти принципы универсальны и одинаково применимы к unit-тестам, интеграционным тестам и end-to-end проверкам.</p><ul class="list _bullet" id="z61r5e_168"><li class="list__item" id="z61r5e_170"><p id="z61r5e_174"><span class="control" id="z61r5e_175">Изоляция</span> означает, что тест полностью управляет своим окружением и не полагается на неконтролируемые внешние факторы. База данных, сетевые вызовы, файловая система, глобальное состояние приложения должны быть либо под полным контролем теста, либо заменены на предсказуемые test doubles. В противном случае результат теста будет зависеть от случайных факторов окружения, а не от качества кода.</p></li><li class="list__item" id="z61r5e_171"><p id="z61r5e_176"><span class="control" id="z61r5e_177">Детерминированность</span> гарантирует, что один и тот же тест при неизменном коде всегда будет давать идентичный результат. Если тест иногда проходит, а иногда падает без каких-либо изменений в бизнес-логике, это подрывает доверие ко всей системе тестирования. Для обеспечения детерминированности необходимо устранять источники случайности, фиксировать значения времени и обеспечивать воспроизводимость входных данных.</p></li><li class="list__item" id="z61r5e_172"><p id="z61r5e_178"><span class="control" id="z61r5e_179">Повторяемость</span> позволяет запускать тест любое количество раз в различных средах: локально у разработчика, на CI-сервере, в staging-окружении или в облачной инфраструктуре, при этом результат всегда остается одинаковым. Это критически важно для систем непрерывной интеграции, где один и тот же набор проверок должен надежно срабатывать сотни раз в день.</p></li><li class="list__item" id="z61r5e_173"><p id="z61r5e_180"><span class="control" id="z61r5e_181">Независимость</span> обеспечивает полную изоляцию тестов друг от друга: каждый тест самостоятельно подготавливает необходимые данные и полностью очищает за собой тестовое окружение. Если корректность выполнения одного теста зависит от успешного запуска другого теста, вся система становится хрупкой и непредсказуемой: падение одного метода может вызвать каскад ошибок в остальных тестах.</p></li></ul></section></section><section class="chapter"><h2 id="3" data-toc="3">3. Концепция: Что вообще мы тестируем?</h2><p id="z61r5e_182">Если упростить до предела, то тест это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно. Он подтверждает, что <span class="control" id="z61r5e_187">в заданных условиях</span> она ведёт себя <span class="control" id="z61r5e_188">определённым образом</span>. Мы не тестируем &quot;истину&quot;. Мы тестируем поведение в симулированной среде.</p><section class="chapter"><h3 id="z61r5e_183" data-toc="z61r5e_183">Симуляция, а не доказательство</h3><p id="z61r5e_189">Распространённая ошибка считать, что наличие тестов означает корректность системы. Это не так. Тест это ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.</p><p id="z61r5e_190">Если поведение системы изменилось, но тесты всё ещё проходят, это не значит, что поведение правильное. Это значит, что тест об этом не знает.</p><p id="z61r5e_191">Например: раньше <code class="code" id="z61r5e_193">isPremiumUser</code> возвращал <code class="code" id="z61r5e_194">true</code>, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь <code class="code" id="z61r5e_195">true</code> возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними и продолжают проходить. Только теперь они подтверждают совсем не то, что раньше. Просто не знают, что смысл <code class="code" id="z61r5e_196">true</code> изменился.</p><p id="z61r5e_192">Тест проверяет <span class="control" id="z61r5e_197">конкретный срез</span>: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось &laquo;допустимым&raquo;. Если позже меняется бизнес-логика, интерфейс или требования, тест становится устаревшим. Это свойство теста как инструмента.</p></section><section class="chapter"><h3 id="z61r5e_184" data-toc="z61r5e_184">Контролируемое окружение</h3><p id="z61r5e_198">Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время, потоки, гонки, кеши. Тест же создаёт <span class="control" id="z61r5e_200">контролируемое окружение</span>, где всё поведение заранее известно и управляется вручную: от стабов и фейков до фиктивного времени и UUID.</p><p id="z61r5e_199">Разница принципиальна. В production ошибки могут быть случайными. В тестах они либо детерминированы, либо не обнаруживаются вовсе. Поэтому тест никогда не может гарантировать &quot;всё работает&quot;. Он может только сказать: <span class="emphasis" id="z61r5e_201">в этих условиях да</span>.</p></section><section class="chapter"><h3 id="z61r5e_185" data-toc="z61r5e_185">Уровень доверия</h3><p id="z61r5e_202">Каждый тест даёт разработчику определённый уровень уверенности. Но важно понимать, откуда именно эта уверенность берётся. Unit-тесты дают быструю обратную связь: запускаются мгновенно, падения легко локализуются, работают стабильно. Но они покрывают только локальную логику, изолированную от остальной системы. Их надёжность держится на том, что окружение подменено, а поведение строго контролируется.</p><p id="z61r5e_203">Интеграционные тесты покрывают больше связей. Они проверяют, как компоненты работают вместе: контроллер, сервис, база, кэш, очередь. Они ближе к реальности, но требуют больше инфраструктуры, сложнее в запуске, и их падения труднее отлаживать. Тем не менее, именно они ловят те ошибки, которые unit-прогон никогда не заметит.</p><p id="z61r5e_204">Это всегда компромисс. Между скоростью и полнотой. Между удобством и точностью. Между временем отклика и глубиной сигнала. И пока эти компромиссы не осознаны, ни одно число покрытия не имеет смысла. &laquo;100% покрытие&raquo; может означать как надёжную защиту, так и пустой ритуал, всё зависит от того, <span class="emphasis" id="z61r5e_205">что именно</span> вы покрыли, и <span class="emphasis" id="z61r5e_206">зачем</span>.</p></section><section class="chapter"><h3 id="z61r5e_186" data-toc="z61r5e_186">Что мы действительно тестируем</h3><p id="z61r5e_207">На практике, когда мы пишем тест, мы проверяем конкретное поведение в конкретной ситуации. Например: что при определённых входных данных метод вызывает другой компонент с нужным параметром. Или что система возвращает ожидаемый результат. Или что в случае ошибки происходит fallback, а не крэш. Или что состояние сохраняется при переходе экрана.</p><p id="z61r5e_208">Это фрагмент поведения, проверенный в специально собранном окружении, со стабами, фейками и полной симуляцией контекста. Мы руками собираем эту модель и утверждаем: <span class="emphasis" id="z61r5e_211">вот в таких условиях система должна вести себя так-то</span>.</p><p id="z61r5e_209">Чем ближе этот контекст к продакшену, тем ценнее тест. Чем дальше, тем он быстрее, дешевле и проще, но локальнее по смыслу. И в этом нет ничего плохого. Главное понимать, что именно мы тестируем, и почему.</p><p id="z61r5e_210">Тест это способ убедиться, что <span class="control" id="z61r5e_212">в заданных условиях</span> ничего не сломано. И если условия выбраны правильно, этого уже достаточно, чтобы тест выполнял свою работу честно.</p></section></section><section class="chapter"><h2 id="4-expect-actual" data-toc="4-expect-actual">4. Expect / Actual: Слова, которые всё говорят</h2><p id="z61r5e_213">Почти в каждом тесте есть одна и та же сцена: мы сравниваем то, что получилось, с тем, что мы ожидали. Чаще всего через <code class="code" id="z61r5e_218">assertEquals(expected, actual)</code>, <code class="code" id="z61r5e_219">assertTrue(condition)</code>, <code class="code" id="z61r5e_220">assertFailsWith&lt;SomeException&gt;()</code> или их аналоги. И вроде бы всё очевидно: проверяем, что результат совпадает с ожиданием. Но даже в этих простых вызовах есть неочевидный момент.</p><section class="chapter"><h3 id="z61r5e_214" data-toc="z61r5e_214">Утверждение через сравнение</h3><p id="z61r5e_221">Когда мы вызываем <code class="code" id="z61r5e_223">assertEquals(expected, actual)</code>, мы делаем утверждение. Мы говорим: <span class="emphasis" id="z61r5e_224">если actual не совпадает с expected, значит, нарушен контракт</span>. Это <span class="control" id="z61r5e_225">тест на согласие с нашей моделью</span>.</p><p id="z61r5e_222">Важно понимать: <code class="code" id="z61r5e_226">assert*</code> это декларация, а не отладка или исследование. Тест либо пройден, либо нет. Нет &laquo;почти&raquo;, нет &laquo;предупреждения&raquo;. И если условие не выполняется, значит <span class="control" id="z61r5e_227">наши ожидания не совпали с реальностью</span>.</p></section><section class="chapter"><h3 id="expected-actual" data-toc="expected-actual">Expected/Actual порядок, который важен</h3><p id="z61r5e_228">Почти все assert-функции следуют одному и тому же порядку: сначала <code class="code" id="z61r5e_230">expected</code>, потом <code class="code" id="z61r5e_231">actual</code>. И это не случайность. Это отражение позиции: &laquo;мы считаем, что вот это правильно, а теперь проверим, совпадает ли с тем, что вышло&raquo;. В этом смысле <code class="code" id="z61r5e_232">actual</code> первичен. Он результат. Он реальность. А <code class="code" id="z61r5e_233">expected</code> это наша гипотеза.</p><p id="z61r5e_229">Если местами их перепутать, тест всё равно будет работать. Но смысл высказывания становится неявным. Падает читаемость. И, главное, исчезает ощущение, <span class="control" id="z61r5e_234">что именно</span> пошло не так: мы ошиблись в модели или код нарушил контракт.</p></section><section class="chapter"><h3 id="asserttrue-assertfalse" data-toc="asserttrue-assertfalse">assertTrue / assertFalse примитив, но с той же логикой</h3><p id="z61r5e_235">Функции <code class="code" id="z61r5e_237">assertTrue</code> и <code class="code" id="z61r5e_238">assertFalse</code> не используют expected/actual явно, но логика та же: вы передаёте условие, которое считаете * *допустимым**. Если оно ложно, тест не пройден. Значит, что-то пошло не так в коде, в контракте или в наших представлениях о корректности.</p><p id="z61r5e_236">По сути, каждая <code class="code" id="z61r5e_239">assert*</code> это бинарный фильтр: либо да, либо нет. Это инструмент для фиксации допусков, а не для поиска ошибок. И чем яснее мы это осознаём, тем точнее пишем тесты.</p></section><section class="chapter"><h3 id="kotlin-native" data-toc="kotlin-native">Ключевые слова Kotlin Native? Не об этом речь</h3><p id="z61r5e_240">Да, в Kotlin Native действительно есть ключевые слова <code class="code" id="z61r5e_243">expect</code> и <code class="code" id="z61r5e_244">actual</code>. Они используются в механизме мультиплатформенности: <code class="code" id="z61r5e_245">expect</code> задаёт интерфейс, <code class="code" id="z61r5e_246">actual</code> реализацию для конкретной платформы. Это может сбить с толку, особенно начинающих. Но в контексте тестирования мы говорим совсем о другом. Здесь <code class="code" id="z61r5e_247">expected</code> и <code class="code" id="z61r5e_248">actual</code> это <span class="control" id="z61r5e_249">соглашение на уровне мышления</span>, а не синтаксиса. Это структура суждения: &quot;я ожидаю X, и вижу Y, совпали ли они?&quot;</p><p id="z61r5e_241">Если воспринимать тест как акт сверки, <code class="code" id="z61r5e_250">expected</code> и <code class="code" id="z61r5e_251">actual</code> не более чем параметры. Но если понимать, что тест это <span class="control" id="z61r5e_252">артефакт соглашения</span>, то <code class="code" id="z61r5e_253">expected</code> это наш манифест. А <code class="code" id="z61r5e_254">actual</code> это отражение реальности. И когда они не совпадают, вопрос в расхождении между тем, что система делает, и тем, что мы от неё хотели.</p><p id="z61r5e_242">Писать тест значит формализовать ожидания. А <code class="code" id="z61r5e_255">assertEquals(expected, actual)</code> это фраза. Она что-то утверждает. И если её читать именно как утверждение, структура начинает играть значение.</p></section></section><section class="chapter"><h2 id="5-test-doubles-mocks-stubs-fakes-spies-dummy" data-toc="5-test-doubles-mocks-stubs-fakes-spies-dummy">5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies, Dummy</h2><figure id="z61r5e_256"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles5.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles5.png" title="testing_philosophy_kotlin_expect_actual_test_doubles5.png" width="3000" height="800"></figure><p id="z61r5e_257">Когда мы говорим о Test Double, мы имеем в виду объекты, которые заменяют настоящие зависимости в тесте. Они позволяют запускать код в изоляции, без доступа к базе, сети, времени или другим внешним эффектам. Это делает тесты контролируемыми. Но важно понимать, что Double это модель. И выбор модели влияет на то, <span class="emphasis" id="z61r5e_281">что именно</span> мы тестируем.</p><p id="z61r5e_258">Есть четыре основных типа Test Double, и у каждого своя цель.</p><p id="z61r5e_259"><span class="control" id="z61r5e_282">Stub</span> самый простой тестовый двойник. Он всегда возвращает заранее заданные значения и никак не реагирует на входные данные. Stub не проверяет, что ему передали, не логирует вызовы и не участвует в бизнес-логике, он просто стабилизирует поведение зависимости. Используется, когда зависимость нужна &laquo;для галочки&raquo;: достаточно вернуть нужное значение, чтобы тест мог продолжиться. Stub это фон, а не часть сцены. Например, в тесте сервиса пользователей можно создать заглушку репозитория, которая всегда возвращает одного и того же пользователя, игнорируя запрошенный ID:</p><div class="code-block" data-lang="kotlin">
interface UserRepository {
    fun findById(id: String): User
}

class UserRepositoryStub : UserRepository {
    override fun findById(id: String): User {
        // Намеренно игнорируем id, Stub всегда возвращает одно и то же
        return User(id = &quot;stub-id&quot;, name = &quot;John Doe&quot;)
    }
}

// Использование в тесте
val stubRepo = UserRepositoryStub()
val service = UserService(stubRepo)
val user = service.getUser(&quot;123&quot;)
check(user.name == &quot;John Doe&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_261"><p id="z61r5e_283"><span class="control" id="z61r5e_284">В примере выше поведение Stub проявляется в том, что <code class="code" id="z61r5e_285">UserRepositoryStub</code> всегда возвращает один и тот же результат (<code class="code" id="z61r5e_286">John Doe</code>), независимо от входного параметра <code class="code" id="z61r5e_287">id</code>. Он не анализирует, что ему передали, и служит лишь для стабилизации окружения.</span></p></aside><p id="z61r5e_262"><span class="control" id="z61r5e_288">Mock</span> объект, который фиксирует, как с ним взаимодействовали. Он запоминает, какие методы вызвали, с какими параметрами и сколько раз. Задача mock-объекта подтвердить, что код выполнил определённые действия. Mock используют там, где важно проверить, <span class="emphasis" id="z61r5e_289">как</span> происходило взаимодействие: был ли вызван логгер, ушло ли письмо, вызвался ли callback. Это объект-наблюдатель, с помощью которого тест проверяет поведение. Например, можно создать фальшивый логгер, который будет сохранять записанные сообщения вместо реального вывода, а затем убедиться в тесте, что нужный метод вызывался с ожидаемыми параметрами:</p><div class="code-block" data-lang="kotlin">
interface Logger {
    fun log(message: String)
}

class LoggerMock : Logger {
    val receivedMessages = mutableListOf&lt;String&gt;()

    override fun log(message: String) {
        receivedMessages.add(message)
    }
}

// Использование
val logger = LoggerMock()
val service = UserService(logger = logger)
service.createUser(&quot;Alice&quot;)
check(logger.receivedMessages.size == 1)
check(logger.receivedMessages.first() == &quot;User created&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_264"><p id="z61r5e_290"><span class="control" id="z61r5e_291">В примере выше поведение Mock проявляется в том, что <code class="code" id="z61r5e_292">LoggerMock</code> запоминает все вызовы метода <code class="code" id="z61r5e_293">log</code>. В тесте мы проверяем, что сообщение действительно было зафиксировано. Это и есть суть mock, проверка взаимодействия.</span></p></aside><p id="z61r5e_265"><span class="emphasis" id="z61r5e_294">Mock часто реализуют с помощью библиотек вроде Mockito или MockK, но здесь он показан вручную, чтобы разобрать суть концепции.</span></p><p id="z61r5e_266"><span class="control" id="z61r5e_295">Fake</span> рабочая подделка. Это полноценная, но упрощённая реализация зависимости. Например, in-memory база данных или фейковый API, который хранит данные в памяти. Fake действительно ведёт себя как настоящая система, только без использования реальных ресурсов. Его используют, когда нужна реальная логика взаимодействия, но не нужна тяжелая инфраструктура. Например, вместо обращения к настоящей базе данных можно использовать фейковый репозиторий, который хранит пользователей в памяти:</p><div class="code-block" data-lang="kotlin">
interface UserRepository {
    fun save(user: User)
    fun findById(id: String): User?
}

class FakeUserRepository : UserRepository {
    private val users = mutableMapOf&lt;String, User&gt;()

    override fun save(user: User) {
        users[user.id] = user
    }

    override fun findById(id: String): User? {
        return users[id]
    }
}

// Использование
val repo = FakeUserRepository()
repo.save(User(&quot;1&quot;, &quot;Alice&quot;))
val result = repo.findById(&quot;1&quot;)
check(result?.name == &quot;Alice&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_268"><p id="z61r5e_296"><span class="control" id="z61r5e_297">В примере выше поведение Fake проявляется в том, что <code class="code" id="z61r5e_298">FakeUserRepository</code> действительно сохраняет и возвращает данные, как настоящий репозиторий, но без настоящей базы данных. Это полноценная логика, только in-memory.</span></p></aside><p id="z61r5e_269"><span class="control" id="z61r5e_299">Spy</span> &laquo;двойной агент&raquo;. Он оборачивает реальный объект, но отслеживает, что с ним происходило. Spy не подменяет поведение (как mock) и не заменяет всю реализацию (как fake). Вместо этого он делегирует вызовы настоящему объекту и параллельно фиксирует обращения (например, считает вызовы или сохраняет параметры). Это компромисс между прозрачным поведением и возможностью анализировать взаимодействие. Например, можно обернуть реальный (или фейковый) репозиторий в класс-Spy, который будет делегировать вызовы базовому объекту и считать, сколько раз вызывался метод поиска пользователя:</p><div class="code-block" data-lang="kotlin">
class UserRepositorySpy(private val realRepo: UserRepository) : UserRepository {
    var findByIdCallCount = 0
    val capturedIds = mutableListOf&lt;String&gt;()

    override fun save(user: User) {
        realRepo.save(user)
    }

    override fun findById(id: String): User? {
        findByIdCallCount++
        capturedIds.add(id)
        return realRepo.findById(id)
    }
}

// Использование
val realRepo = FakeUserRepository()
realRepo.save(User(&quot;1&quot;, &quot;Bob&quot;))
val spy = UserRepositorySpy(realRepo)
val user = spy.findById(&quot;1&quot;)
check(user?.name == &quot;Bob&quot;)
check(spy.findByIdCallCount == 1)
check(spy.capturedIds.contains(&quot;1&quot;))
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_271"><p id="z61r5e_300"><span class="control" id="z61r5e_301">В примере выше поведение Spy проявляется в том, что <code class="code" id="z61r5e_302">UserRepositorySpy</code> делегирует вызовы <code class="code" id="z61r5e_303">realRepo</code>, но при этом фиксирует: сколько раз вызывался метод <code class="code" id="z61r5e_304">findById</code>, какие значения передавались.</span></p></aside><p id="z61r5e_272"><span class="emphasis" id="z61r5e_305">Spy полезен там, где поведение важно сохранить, но при этом нужно наблюдать за взаимодействиями. Мы видим как &quot;что вызвали&quot;, так и &quot;что реально произошло&quot;.</span></p><p id="z61r5e_273"><span class="control" id="z61r5e_306">Dummy</span> - &laquo;молчаливый статист&raquo;. Он существует только потому, что <span class="control" id="z61r5e_307">метод требует аргумента</span>, но сам по себе <span class="control" id="z61r5e_308">в тесте не используется</span>. Dummy не выполняет действий, не хранит состояния и не участвует в логике - его задача одна: <span class="emphasis" id="z61r5e_309">быть на месте, где требуется объект</span>. Это самый простой и безопасный тип Test Double, позволяющий явно показать: &laquo;этот параметр здесь не важен&raquo;.</p><p id="z61r5e_274">Например, если метод требует <code class="code" id="z61r5e_310">Logger</code>, но логирование в тесте не играет роли, можно передать dummy-реализацию:</p><div class="code-block" data-lang="kotlin">
class DummyLogger : Logger {
    override fun info(message: String) = Unit
    override fun error(message: String, throwable: Throwable?) = Unit
}

// Использование
val logger = DummyLogger()
val service = UserService(logger) // здесь логер не используется
val result = service.doSomething()
check(result == ExpectedResult)
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_276"><p id="z61r5e_311"><span class="control" id="z61r5e_312">В примере выше <code class="code" id="z61r5e_315">DummyLogger</code> никак не влияет на результат <code class="code" id="z61r5e_316">doSomething()</code>.</span> Он передаётся только потому, что <code class="code" id="z61r5e_313">UserService</code> требует <code class="code" id="z61r5e_314">Logger</code> в конструкторе.</p></aside><p id="z61r5e_277"><span class="emphasis" id="z61r5e_317">Dummy полезен там, где важна только сигнатура, а не смысл. Он делает зависимости явными, но без побочных эффектов или логики. Это форма честной заглушки, мы прямо говорим: &laquo;этот объект не играет роли, просто позвольте тесту выполниться&raquo;.</span></p><p id="z61r5e_278">Иногда выбор типа Double кажется техническим: что проще заиспользовать, что быстрее написать. Но на самом деле он отражает <span class="control" id="z61r5e_318">подход к архитектуре</span>. Если мы используем stub, мы говорим: эта зависимость не важна. Если fake, мы признаём, что логика важна, но инфраструктура нет. Если mock, мы хотим проконтролировать, как именно система взаимодействует. Spy, мы хотим знать детали, но не мешать процессу.</p><p id="z61r5e_279">Это выбор: <span class="control" id="z61r5e_319">моделировать поведение или структуру</span>. Проверять результат или отслеживать путь. Упростить окружение или сохранить его поведение. И когда Double выбран неправильно, тест может быть зелёным, но бессмысленным.</p><p id="z61r5e_280">Поэтому вопрос в том, <span class="emphasis" id="z61r5e_320">что именно мы хотим зафиксировать в этом тесте</span>.</p></section><section class="chapter"><h2 id="6-unit-vs-junit" data-toc="6-unit-vs-junit">6. Unit vs JUnit: Что действительно стоит за словами</h2><p id="z61r5e_321">Слово <span class="control" id="z61r5e_329">unit</span> в программировании означает <span class="emphasis" id="z61r5e_330">единицу поведения</span> минимальный фрагмент системы, который можно протестировать изолированно. Это может быть функция, метод, модуль или класс. Главное он должен быть <span class="control" id="z61r5e_331">самодостаточным</span>: то есть его поведение можно проверить без запуска всей системы.</p><p id="z61r5e_322">Тест такого фрагмента называют <span class="control" id="z61r5e_332">unit-тестом</span> он фокусируется на <span class="control" id="z61r5e_333">наименьшей значимой части</span> программы, изолируя внешние зависимости (через stub, mock, fake и т. д.).</p><aside class="prompt" data-type="tip" data-title="" id="z61r5e_323"><p id="z61r5e_334">Unit = Единица (поведения) , Unit Test = Проверка этой единицы , JUnit = Java Unit Testing Framework</p></aside><p id="z61r5e_324"><span class="control" id="z61r5e_335">JUnit</span> это инструмент, изначально созданный для того, чтобы <span class="control" id="z61r5e_336">писать и запускать unit-тесты на Java</span>. Название это сокращение от <span class="emphasis" id="z61r5e_337">Java + Unit</span>. За 20 лет JUnit стал полноценной <span class="control" id="z61r5e_338">тестовой платформой</span>, которую можно использовать для чего угодно: от простейших проверок до интеграционных и property-based тестов.</p><p id="z61r5e_325">Чтобы понимать, как писать хорошие тесты, важно разобраться не только в коде, но и в истории, как JUnit развивался, и какие идеи он принёс.</p><section class="chapter"><h3 id="junit-dsl" data-toc="junit-dsl">История JUnit: от процедур до DSL</h3><p id="z61r5e_339"><span class="control" id="z61r5e_351">JUnit 3</span> появился в начале 2000-х. Это был процедурный фреймворк, построенный на соглашениях, а не на аннотациях или конфигурациях. Чтобы метод считался тестом, он должен был начинаться с <code class="code" id="z61r5e_352">test</code>, а класс расширять <code class="code" id="z61r5e_353">TestCase</code>. Всё наследовалось напрямую, никакой инверсии, никакой метаинформации.</p><div class="code-block" data-lang="java">
public class UserServiceTest extends TestCase {
    public void testUserIsCreated() {
        UserService service = new UserService();
        User user = service.create(&quot;Alice&quot;);
        assertEquals(&quot;Alice&quot;, user.getName());
    }
}
</div><p id="z61r5e_341">Никакой магии. JUnit по имени искал методы, начинал их выполнять и сигнализировал о падениях через <code class="code" id="z61r5e_354">AssertionFailedError</code> или исключения. Всё держалось на соглашениях и строгом порядке.</p><p id="z61r5e_342"><span class="control" id="z61r5e_355">JUnit 4</span> стал поворотной точкой. Он избавился от необходимости наследования <code class="code" id="z61r5e_356">TestCase</code> и перешёл к декларативному стилю на базе аннотаций. Метод помечался <code class="code" id="z61r5e_357">@Test</code>, и это было достаточно, чтобы фреймворк понял перед ним тест.</p><div class="code-block" data-lang="kotlin">
class UserServiceTest {

    @Test
    fun userIsCreated() {
        val service = UserService()
        val user = service.create(&quot;Alice&quot;)
        assertEquals(&quot;Alice&quot;, user.name)
    }
}
</div><p id="z61r5e_344">Появились <code class="code" id="z61r5e_358">@Before</code>, <code class="code" id="z61r5e_359">@After</code>, <code class="code" id="z61r5e_360">@Ignore</code>, а также возможность писать кастомные раннеры. Но при всём этом JUnit 4 оставался процедурным. Каждый тест по сути обычная функция, просто обёрнутая инфраструктурой.</p><p id="z61r5e_345"><span class="control" id="z61r5e_361">JUnit 5</span> это <span class="control" id="z61r5e_362">платформа</span>. Он разделён на три части: <code class="code" id="z61r5e_363">Platform</code>, <code class="code" id="z61r5e_364">Jupiter</code> и <code class="code" id="z61r5e_365">Vintage</code>.</p><p id="z61r5e_346"><code class="code" id="z61r5e_366">JUnit Platform</code> это базовый механизм обнаружения и запуска тестов. Он взаимодействует с Gradle, Maven, IDE и CI-системами. Через него тесты регистрируются, исполняются и репортуются. Это слой интеграции, а не логики. <code class="code" id="z61r5e_367">JUnit Jupiter</code> это современный API и тестовый движок. Он поддерживает всё, что появилось в JUnit 5: вложенные тестовые классы (<code class="code" id="z61r5e_368">@Nested</code>), настраиваемые названия (<code class="code" id="z61r5e_369">@DisplayName</code>), параметризованные и динамические тесты (<code class="code" id="z61r5e_370">@ParameterizedTest</code>, <code class="code" id="z61r5e_371">@TestFactory</code>). Jupiter делает тесты декларативными и выразительными, приближая их к DSL. <code class="code" id="z61r5e_372">JUnit Vintage</code> это адаптер. Он позволяет запускать старые тесты, написанные на JUnit 3 и 4, внутри новой платформы. Благодаря Vintage проекты могут мигрировать постепенно, без полного переписывания.</p><p id="z61r5e_347">Синтаксис стал выразительным. Теперь тесты можно строить как декларации поведения, использовать параметры, вводить структуры.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@ValueSource(strings = [&quot;admin&quot;, &quot;user&quot;, &quot;guest&quot;])
fun `roles should not be empty`(role: String) {
    val system = RoleService()
    val permissions = system.getPermissions(role)
    assertTrue(permissions.isNotEmpty())
}
</div><p id="z61r5e_349">JUnit 5 перестал быть &quot;юнит&quot;-фреймворком в узком смысле. Он стал каркасом для любых тестов: юнитов, интеграций, property-based подхода, контрактных проверок. Всё, что можно выразить в виде исполняемого DSL с проверками теперь помещается внутрь.</p><p id="z61r5e_350">JUnit не только принял декларативность, но и сам стал частью архитектурного мышления. И теперь, говоря <code class="code" id="z61r5e_373">@Test</code>, мы инициируем часть тестового пайплайна, где поведение фиксируется как артефакт.</p></section><section class="chapter"><h3 id="ci" data-toc="ci">Почему это важно в CI</h3><p id="z61r5e_374">JUnit-интеграции в IDE, Gradle, Maven, Bazel и CI-системы (например, GitHub Actions) ожидают строго определённую структуру: <code class="code" id="z61r5e_375">@Test</code>-методы автоматически индексируются, изолируются и репортятся. Без этой аннотации метод просто функция, недоступная для раннера.</p></section><section class="chapter"><h3 id="junit-5" data-toc="junit-5">Знакомство с основами JUnit 5</h3><figure id="z61r5e_376"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles4.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles4.png" title="testing_philosophy_kotlin_expect_actual_test_doubles4.png" width="1257" height="403"></figure><p id="z61r5e_377">Если в JUnit 4 аннотации были просто флажками, то в JUnit 5 они стали формализованными элементами контракта. Через них описывается жизненный цикл, поведение, параметры и точки интеграции тестов. Ниже минимально необходимый набор аннотаций, чтобы уверенно ориентироваться в Jupiter.</p><p id="z61r5e_378"><code class="code" id="z61r5e_412">@Test</code> Это главная точка входа. Без неё метод просто функция. С ней полноценный тест, который JUnit включит в жизненный цикл: вызовет <code class="code" id="z61r5e_413">@BeforeEach</code>, сам тест, <code class="code" id="z61r5e_414">@AfterEach</code>, соберёт результат и отобразит в отчёте.</p><p id="z61r5e_379">Метод с <code class="code" id="z61r5e_415">@Test</code> должен быть открытым (<code class="code" id="z61r5e_416">public</code>), без параметров, без возвращаемого значения (<code class="code" id="z61r5e_417">Unit</code>) и не <code class="code" id="z61r5e_418">static</code> (в Java) или <code class="code" id="z61r5e_419">companion</code> (в Kotlin). Если тест бросает исключение он считается проваленным. Если нет прошёл успешно.</p><div class="code-block" data-lang="kotlin">
@Test
fun `user is created`() {
    val service = UserService()
    val user = service.create(&quot;Alice&quot;)
    assertEquals(&quot;Alice&quot;, user.name)
}
</div><p id="z61r5e_381">JUnit вызывает этот метод как автономную единицу отдельно от других, в новом инстансе класса (если не указано иначе). Это часть контракта: тест не должен зависеть от других тестов и делиться с ними состоянием.</p><p id="z61r5e_382"><code class="code" id="z61r5e_420">@BeforeEach</code>/<code class="code" id="z61r5e_421">@AfterEach</code> Вызываются перед и после каждого <code class="code" id="z61r5e_422">@Test</code>. Используются для настройки окружения и его очистки: создание файлов, сброс состояний, закрытие ресурсов. Каждый тест запускается на новом экземпляре класса, так что состояния между методами не сохраняются.</p><div class="code-block" data-lang="kotlin">
@BeforeEach
fun setUp() {
    initDatabase()
}

@AfterEach
fun tearDown() {
    cleanupTempFiles()
}
</div><p id="z61r5e_384"><code class="code" id="z61r5e_423">@BeforeAll</code>/<code class="code" id="z61r5e_424">@AfterAll</code> Запускаются один раз до и после всех тестов в классе. Используются для тяжёлой инициализации (например, поднятие embedded Redis, Kafka, Docker-контейнеров). В Kotlin требуют <code class="code" id="z61r5e_425">@TestInstance(PER_CLASS)</code>.</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@BeforeAll
fun initSuite() {
    EmbeddedRedis.start()
}
</div><p id="z61r5e_386"><code class="code" id="z61r5e_426">@TestInstance(...)</code> Определяет, как JUnit создаёт экземпляры тестового класса.</p><p id="z61r5e_387">По умолчанию используется <code class="code" id="z61r5e_427">PER_METHOD</code>, при котором <span class="control" id="z61r5e_428">для каждого метода с <code class="code" id="z61r5e_429">@Test</code> создаётся отдельный объект</span>. Это обеспечивает изоляцию между тестами, но не позволяет сохранять общее состояние между ними.</p><p id="z61r5e_388">Если указать <code class="code" id="z61r5e_430">PER_CLASS</code>, то <span class="control" id="z61r5e_431">один объект создаётся на весь класс</span>. Это позволяет использовать <code class="code" id="z61r5e_432">@BeforeAll</code> и <code class="code" id="z61r5e_433">@AfterAll</code> как обычные методы (не в <code class="code" id="z61r5e_434">companion object</code>), а также делиться состоянием между тестами.</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ConfiguredTestLifecycle {

    private var counter = 0

    @BeforeAll
    fun initOnce() {
        counter = 10
    }

    @Test
    fun testA() {
        assert(counter &gt;= 10)
    }

    @Test
    fun testB() {
        counter++ // состояние сохраняется между тестами
    }
}
</div><p id="z61r5e_390">Такой подход используют, когда инициализация тяжёлая или состояние нужно сохранить между тестами. Но в большинстве случаев <code class="code" id="z61r5e_435">PER_METHOD</code> безопаснее.</p><p id="z61r5e_391"><code class="code" id="z61r5e_436">@DisplayName</code> Позволяет задать читаемое название теста. Отображается в IDE и CI, особенно полезно в параметризованных или BDD-ориентированных тестах. Работает и на методах, и на классах.</p><div class="code-block" data-lang="kotlin">
@DisplayName(&quot;Пользователь с ролью admin получает все доступы&quot;)
@Test
fun adminGetsAllPermissions() {
    ...
}
</div><p id="z61r5e_393"><code class="code" id="z61r5e_437">@Disabled</code> Пропускает тест. Используется для временного отключения (например, нестабильный код, баг в зависимости). В отчётах видно, что тест отключён.</p><div class="code-block" data-lang="kotlin">
@Disabled(&quot;Отключён до фикса external API&quot;)
@Test
fun flakyIntegrationTest() {
    ...
}
</div><p id="z61r5e_395"><code class="code" id="z61r5e_438">@Nested</code> Позволяет структурировать тесты в иерархии с вложенными контекстами. Применяется только к <code class="code" id="z61r5e_439">inner class</code>, иначе инстанс не создаётся. Удобен для Given/When/Then-структур.</p><div class="code-block" data-lang="kotlin">
@Nested
inner class WhenUserIsGuest {
    @Test
    fun `should not access admin panel`() {
        ...
    }
}
</div><p id="z61r5e_397"><code class="code" id="z61r5e_440">@ParameterizedTest</code> Запускает один и тот же метод несколько раз с разными параметрами. Требует указания источника данных через <code class="code" id="z61r5e_441">@ValueSource</code>, <code class="code" id="z61r5e_442">@CsvSource</code>, <code class="code" id="z61r5e_443">@EnumSource</code> и др. Метод должен принимать аргументы.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@ValueSource(strings = [&quot;admin&quot;, &quot;user&quot;, &quot;guest&quot;])
fun testRoles(role: String) {
    assertTrue(role.isNotBlank())
}
</div><p id="z61r5e_399"><code class="code" id="z61r5e_444">@ValueSource</code>, <code class="code" id="z61r5e_445">@CsvSource</code>, <code class="code" id="z61r5e_446">@EnumSource</code>, <code class="code" id="z61r5e_447">@MethodSource</code>, <code class="code" id="z61r5e_448">@ArgumentsSource</code> Аннотации для генерации данных в параметризованных тестах. <code class="code" id="z61r5e_449">@ValueSource</code> для простых значений. <code class="code" id="z61r5e_450">@CsvSource</code> для табличных данных. <code class="code" id="z61r5e_451">@MethodSource</code> ссылка на метод, возвращающий <code class="code" id="z61r5e_452">Stream&lt;Arguments&gt;</code>. <code class="code" id="z61r5e_453">@EnumSource</code> прокидывает значения enum. <code class="code" id="z61r5e_454">@ArgumentsSource</code> настраиваемый источник данных.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@CsvSource(&quot;admin, true&quot;, &quot;guest, false&quot;)
fun rolePermissionTest(role: String, allowed: Boolean) {
    assertEquals(allowed, checkAccess(role))
}
</div><p id="z61r5e_401"><code class="code" id="z61r5e_455">@RepeatedTest</code> Запускает один и тот же тест несколько раз. Удобен для проверки нестабильных сценариев: флаки, гонки, недетерминированные вычисления. Метод может принимать <code class="code" id="z61r5e_456">RepetitionInfo</code>.</p><div class="code-block" data-lang="kotlin">
@RepeatedTest(3)
fun unstableTest() {
    assertTrue(runComputation().isSuccessful)
}
</div><p id="z61r5e_403"><code class="code" id="z61r5e_457">@Timeout</code> Завершает тест с ошибкой, если он выполняется дольше заданного времени. Применяется на метод и на весь класс. Полезен для защиты от зависаний.</p><div class="code-block" data-lang="kotlin">
@Timeout(5)
@Test
fun longRunningProcessCompletes() {
    performHeavyOperation()
}
</div><p id="z61r5e_405"><code class="code" id="z61r5e_458">@Tag</code> Добавляет произвольные метки тестам. Используются в CI/CD для фильтрации: можно запускать только тесты с нужным тегом (<code class="code" id="z61r5e_459">@Tag(&quot;slow&quot;)</code>, <code class="code" id="z61r5e_460">@Tag(&quot;ci&quot;)</code>).</p><div class="code-block" data-lang="kotlin">
@Tag(&quot;integration&quot;)
@Test
fun savesToDatabase() {
    saveToDb()
}
</div><p id="z61r5e_407"><code class="code" id="z61r5e_461">@ExtendWith(...)</code> Подключает расширения (Mockito, Spring, Testcontainers, кастомные хуки). Extension-интерфейсы могут внедрять зависимости, слушать события, управлять окружением.</p><div class="code-block" data-lang="kotlin">
@ExtendWith(SpringExtension::class)
class UserServiceSpringTest { ... }
</div><p id="z61r5e_409"><code class="code" id="z61r5e_462">@TestFactory</code> Позволяет генерировать тесты динамически во время выполнения. Метод должен возвращать <code class="code" id="z61r5e_463">Collection&lt;DynamicTest&gt;</code> или <code class="code" id="z61r5e_464">Stream&lt;DynamicTest&gt;</code>. Применяется при неизвестном числе кейсов (например, из JSON-файла).</p><div class="code-block" data-lang="kotlin">
@TestFactory
fun dynamicTestsFromFile(): List&lt;DynamicTest&gt; {
    return File(&quot;cases.txt&quot;).readLines().map { line -&gt;
        dynamicTest(&quot;Case: $line&quot;) {
            check(line.isNotBlank())
        }
    }
}
</div><p id="z61r5e_411">В статье не будет практического примера по использованию аннотаций для этого существует официальная документация: <a href="https://docs.junit.org/current/user-guide/" id="z61r5e_465" data-external="true" rel="noopener noreferrer" target="_blank">Junit 5 Documentation</a>, которая очень подробно описывает возможности и использование JUnit 5.</p></section></section><section class="chapter"><h2 id="junit-5-test" data-toc="junit-5-test">Как JUnit 5 запускает ваш @Test: от команды до метода</h2><p id="z61r5e_466">Когда вы нажимаете &quot;Run&quot; в IDE или запускаете <code class="code" id="z61r5e_483">./gradlew test</code>, за этим простым действием скрывается сложная многоуровневая архитектура. Давайте проследим весь путь выполнения теста от команды в терминале до вызова вашего метода, помеченного <code class="code" id="z61r5e_484">@Test</code>.</p><section class="chapter"><h3 id="z61r5e_467" data-toc="z61r5e_467">Рабочий пример для демонстрации</h3><p id="z61r5e_485">Возьмем что-то практичное загрузчик изображений. Код простой, но вполне рабочий:</p><div class="code-block" data-lang="kotlin">
class ImageDownloader {
    fun downloadImage(url: String): ByteArray {
        val inputStream = URI(url).toURL().openStream()
        return inputStream.use { it.readAllBytes() }
    }
}
</div><p id="z61r5e_487">Далее тест для <code class="code" id="z61r5e_494">ImageDownloader</code> с использованием JUnit 5:</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_METHOD)
@DisplayName(&quot;Загрузка изображения и сохранение в файл&quot;)
class ImageDownloaderTest {

    private lateinit var tempFile: File
    private lateinit var outputStream: FileOutputStream

    private val imageUrl = &quot;https://i.postimg.cc/26h8JBpH/QYbec-Thl-Qy7mcx-ZBYp-C0m-BDp16no-Mt-R5vwe-St-Wmv-large.jpg&quot;

    @BeforeEach
    fun setUp() {
        tempFile = File(&quot;image-test.jpg&quot;)
        outputStream = FileOutputStream(tempFile, true)
    }

    @Test
    @DisplayName(&quot;Изображение должно быть скачано и записано в файл&quot;)
    fun `downloaded image is saved to file`() {
        val downloader = ImageDownloader()
        val bytes = downloader.downloadImage(imageUrl)

        requireNotNull(bytes) { &quot;Скачанные данные не должны быть null&quot; }

        outputStream.write(bytes)
        outputStream.flush()

        assertTrue(tempFile.length() &gt; 0, &quot;Файл после загрузки не должен быть пустым&quot;)
    }

    @AfterEach
    fun tearDown() {
        outputStream.close()
        tempFile.delete()
    }
}
</div><p id="z61r5e_489">Тест довольно straightforward: есть один метод <code class="code" id="z61r5e_495">downloaded image is saved to file</code>, который скачивает изображение и проверяет, что файл действительно создался и не пустой. В <code class="code" id="z61r5e_496">setUp</code> готовим временный файл и поток, в <code class="code" id="z61r5e_497">tearDown</code> всё убираем за собой. <code class="code" id="z61r5e_498">@DisplayName</code> нужен для читаемых названий в отчетах вместо технических имен методов увидим осмысленные описания. <figure id="z61r5e_499"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles1.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles1.png" title="testing_philosophy_kotlin_expect_actual_test_doubles1.png" width="2824" height="830"></figure><figure id="z61r5e_500"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles2.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles2.png" title="testing_philosophy_kotlin_expect_actual_test_doubles2.png" width="2824" height="818"></figure> Теперь запустим тест через Gradle:</p><div class="code-block" data-lang="bash">
./gradlew :test --tests &quot;test.ImageDownloaderTest&quot;
</div><p id="z61r5e_491">Эта команда сработает, если в <code class="code" id="z61r5e_501">build.gradle</code> настроена задача test:</p><div class="code-block" data-lang="kotlin">
tasks.test {
    useJUnitPlatform()
}
</div><p id="z61r5e_493">И вот здесь начинается интересное за кулисами запускается целая цепочка вызовов, которая проходит через несколько архитектурных слоев.</p></section><section class="chapter"><h3 id="1-gradle-junit-platform" data-toc="1-gradle-junit-platform">Этап 1: Gradle настраивает JUnit Platform</h3><p id="z61r5e_502">Вызов <code class="code" id="z61r5e_508">useJUnitPlatform()</code> в Gradle это конфигурационная строчка, за которой скрывается сложная логика. Под капотом происходит следующее:</p><div class="code-block" data-lang="java">
public void useJUnitPlatform() {
    useTestFramework(new JUnitPlatformTestFramework((DefaultTestFilter) getFilter(), true, getDryRun()));
}
</div><p id="z61r5e_504">Gradle создает экземпляр <code class="code" id="z61r5e_509">JUnitPlatformTestFramework</code>, который реализует интерфейс <code class="code" id="z61r5e_510">TestFramework</code>. Этот объект станет мостом между Gradle и JUnit Platform он знает, как найти тесты, как их запустить и как получить результаты.</p><p id="z61r5e_505">Интересный факт: несмотря на то, что Kotlin набирает популярность, и наш тест написан на нем, исходники JUnit по-прежнему остаются верными букве &quot;J&quot; в названии, то есть на Java. Аннотация <code class="code" id="z61r5e_511">@Test</code> выглядит так:</p><div class="code-block" data-lang="java">

@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@API(status = STABLE, since = &quot;5.0&quot;)
@Testable
public @interface Test {
}
</div><p id="z61r5e_507">Документация к аннотации гласит: &quot; <code class="code" id="z61r5e_512">@Test</code> используется для обозначения тестового метода. Методы с <code class="code" id="z61r5e_513">@Test</code> не должны быть <code class="code" id="z61r5e_514">private</code> или <code class="code" id="z61r5e_515">static</code> и не должны возвращать значение&quot;. Простые правила, но за ними стоит продуманная архитектура.</p></section><section class="chapter"><h3 id="2" data-toc="2">Этап 2: Создание фабрики процессоров тестов</h3><p id="z61r5e_516">Когда Gradle готов запускать тесты, он обращается к нашему <code class="code" id="z61r5e_521">JUnitPlatformTestFramework</code> за фабрикой процессоров:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestFramework implements TestFramework {
    @Override
    public WorkerTestClassProcessorFactory getProcessorFactory() {
        return new JUnitPlatformTestClassProcessorFactory(new JUnitPlatformSpec(...));
    }
}
</div><p id="z61r5e_518">Эта фабрика умеет создавать процессоры тестовых классов объекты, которые знают, как обрабатывать отдельные тестовые классы. Когда приходит время, фабрика создает <code class="code" id="z61r5e_522">JUnitPlatformTestClassProcessor</code>:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessorFactory implements WorkerTestClassProcessorFactory {
    @Override
    public WorkerTestClassProcessor create(...,JUnitPlatformSpec spec) {
        return new JUnitPlatformTestClassProcessor(spec, ...);
    }
}
</div><p id="z61r5e_520"><code class="code" id="z61r5e_523">JUnitPlatformTestClassProcessor</code> наследуется от <code class="code" id="z61r5e_524">AbstractJUnitTestClassProcessor</code> и реализует интерфейс <code class="code" id="z61r5e_525">TestClassProcessor</code>. Это ключевой компонент именно он будет координировать выполнение наших тестов.</p></section><section class="chapter"><h3 id="3-testworker" data-toc="3-testworker">Этап 3: TestWorker начинает обработку</h3><p id="z61r5e_526">Внутри Gradle работает <code class="code" id="z61r5e_532">TestWorker</code> компонент, который управляет жизненным циклом выполнения тестов.</p><div class="code-block" data-lang="java">
package org.gradle.api.internal.tasks.testing.worker;

public class TestWorker implements Action&lt;WorkerProcessContext&gt;, RemoteTestClassProcessor, Serializable, Stoppable {

    private TestClassProcessor processor;

    @Override
    public void processTestClass(final TestClassRunInfo testClass) {
        ...
        processor.processTestClass(testClass);
        ...
    }

    @Override
    public void startProcessing() {
        ...
        processor.startProcessing(resultProcessor);
    }
}

</div><p id="z61r5e_528">TestWorker вызывает два ключевых метода процессора:</p><div class="code-block" data-lang="java">
public abstract class AbstractJUnitTestClassProcessor implements TestClassProcessor {

    private Action&lt;String&gt; executor;

    @Override
    public void startProcessing(TestResultProcessor resultProcessor) {
        TestResultProcessor resultProcessorChain = createResultProcessorChain(resultProcessor);
        resultProcessorActor = actorFactory.createBlockingActor(resultProcessorChain);
        executor = createTestExecutor(resultProcessorActor);
    }

    @Override
    public void processTestClass(TestClassRunInfo testClass) {
        LOGGER.debug(&quot;Executing test class {}&quot;, testClass.getTestClassName());
        executor.execute(testClass.getTestClassName());
    }
}
</div><p id="z61r5e_530">На этапе <code class="code" id="z61r5e_533">startProcessing</code> создается цепочка обработчиков результатов и actor для потокобезопасной работы с ними. Actor это паттерн, который гарантирует, что все операции с результатами тестов будут выполняться последовательно, даже если тесты запускаются в нескольких потоках.</p><p id="z61r5e_531">Метод <code class="code" id="z61r5e_534">processTestClass</code> получает информацию о тестовом классе и передает его имя executor'у для выполнения. Но тут есть подвох тесты еще не запускаются!</p></section><section class="chapter"><h3 id="4" data-toc="4">Этап 4: Накопление классов перед запуском</h3><p id="z61r5e_535">В <code class="code" id="z61r5e_541">JUnitPlatformTestClassProcessor</code> используется интересная стратегия сначала собрать все тестовые классы, а потом запустить их разом:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessor extends AbstractJUnitTestClassProcessor {

    @Override
    protected Action&lt;String&gt; createTestExecutor(Actor resultProcessorActor) {
        TestResultProcessor threadSafeResultProcessor = resultProcessorActor.getProxy(TestResultProcessor.class);
        launcherSession = BackwardsCompatibleLauncherSession.open();
        junitClassLoader = Thread.currentThread().getContextClassLoader();
        testClassExecutor = new CollectAllTestClassesExecutor(threadSafeResultProcessor);
        return testClassExecutor;
    }

    @Override
    public void stop() {
        testClassExecutor.processAllTestClasses();
        launcherSession.close();
        super.stop();
    }
}
</div><p id="z61r5e_537"><code class="code" id="z61r5e_542">CollectAllTestClassesExecutor</code> это внутренний класс, который просто накапливает имена тестовых классов:</p><div class="code-block" data-lang="java">
private class CollectAllTestClassesExecutor implements Action&lt;String&gt; {
    private final List&lt;Class&lt;?&gt;&gt; testClasses = new ArrayList&lt;&gt;();

    @Override
    public void execute(@Nonnull String testClassName) {
        Class&lt;?&gt; klass = loadClass(testClassName);
        testClasses.add(klass);
    }

    void processAllTestClasses() {
        LauncherDiscoveryRequest discoveryRequest = createLauncherDiscoveryRequest(testClasses);
        TestExecutionListener executionListener = new JUnitPlatformTestExecutionListener(...);
        Launcher launcher = launcherSession.getLauncher();
        launcher.execute(discoveryRequest, executionListener);
    }
}
</div><p id="z61r5e_539">Такой подход позволяет JUnit Platform получить полную картину всех тестов перед началом выполнения. Это важно для планирования выполнения, распределения по потокам и создания правильной структуры отчетов.</p><p id="z61r5e_540">Реальный запуск происходит только когда Gradle вызывает <code class="code" id="z61r5e_543">stop()</code> на процессоре, что приводит к вызову <code class="code" id="z61r5e_544">processAllTestClasses()</code>.</p></section><section class="chapter"><h3 id="5-launcher" data-toc="5-launcher">Этап 5: Launcher берет управление на себя</h3><p id="z61r5e_545">Когда все классы собраны, создается <code class="code" id="z61r5e_550">LauncherDiscoveryRequest</code> объект, который описывает, какие тесты нужно найти и выполнить. Затем получается экземпляр <code class="code" id="z61r5e_551">Launcher</code> из сессии и запускается выполнение:</p><div class="code-block" data-lang="java">
Launcher launcher = launcherSession.getLauncher();
launcher.

execute(discoveryRequest, executionListener);
</div><p id="z61r5e_547"><code class="code" id="z61r5e_552">Launcher</code> это центральная точка входа в JUnit Platform. Его реализация <code class="code" id="z61r5e_553">DefaultLauncher</code> выглядит довольно просто:</p><div class="code-block" data-lang="java">
public class DefaultLauncher implements Launcher {

    private final EngineExecutionOrchestrator executionOrchestrator = new EngineExecutionOrchestrator(...);

    @Override
    public void execute(TestPlan testPlan, TestExecutionListener... listeners) {
        execute((InternalTestPlan) testPlan, listeners);
    }

    private void execute(InternalTestPlan internalTestPlan, TestExecutionListener[] listeners) {
        executionOrchestrator.execute(internalTestPlan, listeners);
    }
}
</div><p id="z61r5e_549">Основная работа делегируется в <code class="code" id="z61r5e_554">EngineExecutionOrchestrator</code> оркестратор выполнения движков тестов.</p></section><section class="chapter"><h3 id="6" data-toc="6">Этап 6: Оркестратор запускает движки тестов</h3><p id="z61r5e_555">JUnit Platform построена по модульному принципу разные типы тестов могут выполняться разными движками (engines). Для JUnit 5 это <code class="code" id="z61r5e_559">JupiterTestEngine</code>, для JUnit 4 <code class="code" id="z61r5e_560">VintageTestEngine</code>, есть движки для TestNG и других фреймворков.</p><div class="code-block" data-lang="java">
public class EngineExecutionOrchestrator {

    public void execute(LauncherDiscoveryResult discoveryResult, EngineExecutionListener engineExecutionListener) {
        for (TestEngine testEngine : discoveryResult.getTestEngines()) {
            TestDescriptor engineDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
            testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
        }
    }
}
</div><p id="z61r5e_557">Для каждого найденного движка создается <code class="code" id="z61r5e_561">ExecutionRequest</code> с описанием тестов, которые этот движок должен выполнить, и вызывается <code class="code" id="z61r5e_562">execute()</code>.</p><p id="z61r5e_558">В нашем случае будет использоваться <code class="code" id="z61r5e_563">JupiterTestEngine</code> движок для JUnit Jupiter (официальное название JUnit 5).</p></section><section class="chapter"><h3 id="7-jupitertestengine" data-toc="7-jupitertestengine">Этап 7: JupiterTestEngine организует иерархическое выполнение</h3><p id="z61r5e_564"><code class="code" id="z61r5e_568">JupiterTestEngine</code> наследуется от <code class="code" id="z61r5e_569">HierarchicalTestEngine</code> базового класса для движков, которые работают с иерархической структурой тестов:</p><div class="code-block" data-lang="java">
public final class JupiterTestEngine extends HierarchicalTestEngine&lt;JupiterEngineExecutionContext&gt; {

    @Override
    public void execute(ExecutionRequest request) {
        try (HierarchicalTestExecutorService executorService = createExecutorService(request)) {
            JupiterEngineExecutionContext executionContext = createExecutionContext(request);
            ThrowableCollector.Factory throwableCollectorFactory = createThrowableCollectorFactory(request);

            new HierarchicalTestExecutor&lt;&gt;(
                    request,
                    executionContext,
                    executorService,
                    throwableCollectorFactory
            ).execute().get();
        } catch (Exception exception) {
            throw new JUnitException(&quot;Error executing tests for engine &quot; + getId(), exception);
        }
    }
}
</div><p id="z61r5e_566">Здесь создается <code class="code" id="z61r5e_570">HierarchicalTestExecutor</code> исполнитель, который умеет работать с деревом <code class="code" id="z61r5e_571">TestDescriptor</code>'ов. Каждый <code class="code" id="z61r5e_572">TestDescriptor</code> представляет узел в иерархии тестов это может быть движок, пакет, класс, метод или отдельный тестовый случай.</p><p id="z61r5e_567"><code class="code" id="z61r5e_573">ExecutorService</code> определяет, как будут выполняться тесты последовательно в одном потоке или параллельно в нескольких. <code class="code" id="z61r5e_574">ThrowableCollector</code> нужен для корректной обработки исключений на разных уровнях иерархии.</p></section><section class="chapter"><h3 id="8-hierarchicaltestexecutor" data-toc="8-hierarchicaltestexecutor">Этап 8: HierarchicalTestExecutor запускает корневую задачу</h3><div class="code-block" data-lang="java">
class HierarchicalTestExecutor&lt;C extends EngineExecutionContext&gt; {

    Future&lt;Void&gt; execute() {
        NodeTestTask&lt;C&gt; rootTestTask = new NodeTestTask&lt;&gt;(taskContext, rootTestDescriptor);
        rootTestTask.setParentContext(this.rootContext);
        return this.executorService.submit(rootTestTask);
    }
}
</div><p id="z61r5e_576">Создается корневая задача <code class="code" id="z61r5e_579">NodeTestTask</code> для корневого <code class="code" id="z61r5e_580">TestDescriptor</code> и отправляется на выполнение в <code class="code" id="z61r5e_581">ExecutorService</code>. Часто используется <code class="code" id="z61r5e_582">SameThreadHierarchicalTestExecutorService</code>, который выполняет задачи синхронно:</p><div class="code-block" data-lang="java">
public class SameThreadHierarchicalTestExecutorService implements HierarchicalTestExecutorService {

    @Override
    public Future&lt;Void&gt; submit(TestTask testTask) {
        testTask.execute();
        return CompletableFuture.completedFuture(null);
    }
}
</div><p id="z61r5e_578">В нашем примере используется <code class="code" id="z61r5e_583">SameThreadHierarchicalTestExecutorService</code> исполнитель, который выполняет все <code class="code" id="z61r5e_584">NodeTestTask</code> последовательно в одном потоке. Это поведение можно наблюдать при запуске одиночного тестового класса, особенно из IDE или через <code class="code" id="z61r5e_585">--tests</code> в Gradle. Но важно понимать: выбор конкретной реализации <code class="code" id="z61r5e_586">HierarchicalTestExecutorService</code> делает сама JUnit Platform, опираясь на конфигурацию и масштаб тестового плана. Если платформа обнаруживает, что тестов много, или включена параллелизация (<code class="code" id="z61r5e_587">junit.jupiter.execution.parallel.enabled=true</code>), или запуск идёт в рамках всего проекта, она может подставить <code class="code" id="z61r5e_588">ForkJoinPoolHierarchicalTestExecutorService</code>. В этом случае <code class="code" id="z61r5e_589">NodeTestTask</code>'и распараллеливаются с помощью <code class="code" id="z61r5e_590">ForkJoinPool</code>, что ускоряет прогон, но требует особого внимания к потокобезопасности и корректному управлению состоянием в <code class="code" id="z61r5e_591">@BeforeEach</code>, <code class="code" id="z61r5e_592">@AfterEach</code> и других фазах жизненного цикла. Фактически мы не выбираем, в каком потоке будет выполняться тест это делает движок, ориентируясь на тестовый план и окружение. Поэтому нельзя полагаться на порядок или изоляцию, если вы не контролируете среду исполнения явно.</p></section><section class="chapter"><h3 id="9-nodetesttask" data-toc="9-nodetesttask">Этап 9: NodeTestTask выполняет рекурсивную обработку узлов</h3><p id="z61r5e_593"><code class="code" id="z61r5e_602">NodeTestTask</code> это обёртка над логикой выполнения одного <code class="code" id="z61r5e_603">TestDescriptor</code> в иерархии тестов. Каждый такой узел может представлять движок, контейнер, класс, метод или даже динамический тест. Выполнение узла организовано через метод <code class="code" id="z61r5e_604">executeRecursively()</code>:</p><div class="code-block" data-lang="java">
public class NodeTestTask&lt;C extends EngineExecutionContext&gt; implements TestTask {

    @Override
    public void execute() {
        executeRecursively();
    }

    private void executeRecursively() {
        throwableCollector.execute(() -&gt; {
            node.around(context, ctx -&gt; {
                context = node.before(context);
                context = node.execute(context, dynamicTestExecutor);
                taskContext.getExecutorService().invokeAll(children);
                dynamicTestExecutor.awaitFinished();
                node.after(context);
            });
        });
    }
}
</div><p id="z61r5e_595">Метод <code class="code" id="z61r5e_605">executeRecursively()</code> реализует канонический жизненный цикл выполнения теста:</p><ol class="list _decimal" id="z61r5e_596" type="1"><li class="list__item" id="z61r5e_606"><p id="z61r5e_611"><span class="control" id="z61r5e_612">before</span> - подготовка окружения, выполнение <code class="code" id="z61r5e_613">@BeforeAll</code> и <code class="code" id="z61r5e_614">@BeforeEach</code>, создание экземпляра тестового класса</p></li><li class="list__item" id="z61r5e_607"><p id="z61r5e_615"><span class="control" id="z61r5e_616">execute</span> - непосредственное выполнение логики узла (например, вызов метода с <code class="code" id="z61r5e_617">@Test</code>)</p></li><li class="list__item" id="z61r5e_608"><p id="z61r5e_618"><span class="control" id="z61r5e_619">children</span> - рекурсивное выполнение всех дочерних узлов</p></li><li class="list__item" id="z61r5e_609"><p id="z61r5e_620"><span class="control" id="z61r5e_621">dynamic</span> - ожидание завершения динамически зарегистрированных тестов (через <code class="code" id="z61r5e_622">@TestFactory</code>)</p></li><li class="list__item" id="z61r5e_610"><p id="z61r5e_623"><span class="control" id="z61r5e_624">after</span> - завершающие действия, выполнение <code class="code" id="z61r5e_625">@AfterEach</code> и <code class="code" id="z61r5e_626">@AfterAll</code></p></li></ol><p id="z61r5e_597">Ключевая строка здесь <code class="code" id="z61r5e_627">context = node.execute(context, dynamicTestExecutor)</code>. Вызов делегируется текущему <code class="code" id="z61r5e_628">TestDescriptor</code>, чья реализация определяет, что именно будет исполнено.</p><p id="z61r5e_598">В случае обычного тестового метода этот узел будет представлять собой экземпляр <code class="code" id="z61r5e_629">TestMethodTestDescriptor</code>, а значит, выполнение пойдёт в его метод <code class="code" id="z61r5e_630">execute()</code>:</p><div class="code-block" data-lang="java">

@Override
public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
                                             DynamicTestExecutor dynamicTestExecutor) {
    ThrowableCollector throwableCollector = context.getThrowableCollector();

    invokeBeforeEachCallbacks(context);
    if (throwableCollector.isEmpty()) {
        invokeBeforeEachMethods(context);
        if (throwableCollector.isEmpty()) {
            invokeBeforeTestExecutionCallbacks(context);
            if (throwableCollector.isEmpty()) {
                invokeTestMethod(context, dynamicTestExecutor);
            }
            invokeAfterTestExecutionCallbacks(context);
        }
        invokeAfterEachMethods(context);
    }
    invokeAfterEachCallbacks(context);

    return context;
}
</div><p id="z61r5e_600">Таким образом, вызов <code class="code" id="z61r5e_631">node.execute(...)</code> на самом деле инициирует выполнение целого сценария: от вызова <code class="code" id="z61r5e_632">@BeforeEach</code> и <code class="code" id="z61r5e_633">@BeforeTestExecution</code>, до реального <code class="code" id="z61r5e_634">@Test</code>-метода (внутри <code class="code" id="z61r5e_635">invokeTestMethod(...)</code>) и последующего завершения через <code class="code" id="z61r5e_636">@AfterEach</code>.</p><p id="z61r5e_601">Это значит, что <code class="code" id="z61r5e_637">TestMethodTestDescriptor</code> внутри себя тщательно оборачивает <code class="code" id="z61r5e_638">Method.invoke(...)</code> в точках расширения, где могут подключиться extension'ы, interception'ы и пользовательская логика. Именно поэтому <code class="code" id="z61r5e_639">@Test</code> - это управляемый, фазовый процесс с точками вмешательства на каждом этапе.</p></section><section class="chapter"><h3 id="10" data-toc="10">Этап 10: Выполнение конкретного тестового метода</h3><p id="z61r5e_640">Когда очередь доходит до узла типа <code class="code" id="z61r5e_648">MethodTestDescriptor</code> (это наш метод <code class="code" id="z61r5e_649">downloaded image is saved to file</code>), вызывается его метод <code class="code" id="z61r5e_650">execute()</code>:</p><div class="code-block" data-lang="java">

@Override
public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context, DynamicTestExecutor dynamicTestExecutor) {
    invoker.invoke(context.getExtensionRegistry(), context.getTestInstance(), executable);
    return context;
}
</div><p id="z61r5e_642">Здесь <code class="code" id="z61r5e_651">invoker</code> это экземпляр <code class="code" id="z61r5e_652">ExecutableInvoker</code>, а <code class="code" id="z61r5e_653">executable</code> объект типа <code class="code" id="z61r5e_654">Method</code>, который ссылается на наш тестовый метод.</p><p id="z61r5e_643"><code class="code" id="z61r5e_655">ExecutableInvoker</code> обрабатывает параметры метода (если они есть), применяет расширения и в конце концов вызывает:</p><div class="code-block" data-lang="java">
public class ExecutableInvoker {

    public Object invoke(ExtensionRegistry extensionRegistry, Object target, Executable executable, Object... arguments) throws Throwable {
        ...
        return ReflectionUtils.invokeMethod((Method) executable, target, arguments);
    }
}
</div><p id="z61r5e_645">А <code class="code" id="z61r5e_656">ReflectionUtils.invokeMethod()</code> делает то, что и следует из названия:</p><div class="code-block" data-lang="java">
public final class ReflectionUtils {

    public static Object invokeMethod(Method method, Object target, Object... arguments) throws Exception {
        method.setAccessible(true);
        return method.invoke(target, arguments);
    }
}
</div><p id="z61r5e_647">И вот здесь, наконец, происходит то, ради чего была запущена вся эта машинерия, выполняется <code class="code" id="z61r5e_657">Method.invoke()</code> на экземпляре нашего класса <code class="code" id="z61r5e_658">ImageDownloaderTest</code>, вызывая метод <code class="code" id="z61r5e_659">downloaded image is saved to file()</code>.</p></section><section class="chapter"><h3 id="11" data-toc="11">Этап 11: Обработка динамических тестов</h3><p id="z61r5e_660">JUnit 5 поддерживает динамические тесты тесты, которые создаются во время выполнения через <code class="code" id="z61r5e_665">@TestFactory</code>. Если в нашем классе был бы такой метод:</p><div class="code-block" data-lang="kotlin">
@TestFactory
fun dynamicTests(): Stream&lt;DynamicTest&gt; {
    return Stream.of(
        DynamicTest.dynamicTest(&quot;Test 1&quot;) { /* логика теста 1 */ },
        DynamicTest.dynamicTest(&quot;Test 2&quot;) { /* логика теста 2 */ }
    )
}
</div><p id="z61r5e_662">То эти тесты регистрировались бы через <code class="code" id="z61r5e_666">DynamicTestExecutor</code>:</p><div class="code-block" data-lang="java">
public interface DynamicTestExecutor {
    void execute(TestDescriptor dynamicTestDescriptor);

    void awaitFinished();
}
</div><p id="z61r5e_664">Во время выполнения фабричного метода динамические тесты регистрируются через <code class="code" id="z61r5e_667">execute()</code>, а их реальное выполнение происходит при вызове <code class="code" id="z61r5e_668">awaitFinished()</code> в <code class="code" id="z61r5e_669">NodeTestTask</code>. Это позволяет поддерживать правильный порядок выполнения и корректно обрабатывать результаты динамических тестов.</p></section><section class="chapter"><h3 id="junit" data-toc="junit">Как JUnit узнаёт, что перед ним тест?</h3><p id="z61r5e_670">В предыдущей главе мы остановились на моменте, когда <code class="code" id="z61r5e_684">@Test</code>-метод уже исполняется. Но как JUnit вообще узнаёт, что этот метод тест? И откуда он вообще берёт класс?</p><p id="z61r5e_671">На самом деле всё начинается сильно раньше, ещё в момент, когда Gradle запускает worker-процесс, где впоследствии и будет обнаружен наш тестовый класс.</p><p id="z61r5e_672">Разберёмся, как Gradle собирает окружение, и какие шаги ведут к запуску тестового <code class="code" id="z61r5e_685">Runnable</code> из пользовательского <code class="code" id="z61r5e_686">TestWorker</code>. Всё, что не критично, отправим в троеточие.</p><section class="chapter"><h4 id="gradleworkermain-worker-gradle" data-toc="gradleworkermain-worker-gradle"><code class="code" id="z61r5e_690">GradleWorkerMain</code> точка входа в дочерний worker-процесс Gradle</h4><div class="code-block" data-lang="java">
public class GradleWorkerMain {

    public void run() throws Exception {
        Class&lt;? extends Callable&lt;Void&gt;&gt; workerClass = (Class&lt;? extends Callable&lt;Void&gt;&gt;) implementationClassLoader.loadClass(&quot;org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker&quot;).asSubclass(Callable.class);
        Callable&lt;Void&gt; main = workerClass.getConstructor(DataInputStream.class).newInstance(instr);
        main.call();
    }

    public static void main(String[] args) {
        new GradleWorkerMain().run();
        System.exit(0);
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_689"><p id="z61r5e_691">Здесь формируется worker-класс, через который всё и запускается. Пока всё похоже на обычный Java bootstrap, но дальше начинается специфичная инициализация Gradle. <span class="control" id="z61r5e_692">Комментарий:</span> <code class="code" id="z61r5e_693">GradleWorkerMain</code> это <span class="emphasis" id="z61r5e_694">основная точка входа</span> для любого внешнего worker-процесса Gradle. Он изолирован от основного демона Gradle и запускается в отдельном процессе JVM. Его задача создать нужный <code class="code" id="z61r5e_695">Callable</code>, загрузив его через <code class="code" id="z61r5e_696">implementationClassLoader</code>, и запустить его. Это инфраструктурный механизм Gradle для выполнения изолированных задач (компиляции, тестов, аннотации и т. п.).</p></aside></section><section class="chapter"><h4 id="systemapplicationclassloaderworker-gradle-worker-api" data-toc="systemapplicationclassloaderworker-gradle-worker-api"><code class="code" id="z61r5e_700">SystemApplicationClassLoaderWorker</code> адаптер, запускающий рабочую логику в контексте Gradle Worker API</h4><div class="code-block" data-lang="java">
public class SystemApplicationClassLoaderWorker implements Callable&lt;Void&gt; {

    @Override
    public Void call() throws Exception {
        ...
        ActionExecutionWorker worker = new ActionExecutionWorker(config.getWorkerAction());
        worker.execute(new ContextImpl(...));
        ...
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_699"><p id="z61r5e_701">Здесь мы впервые встречаем <code class="code" id="z61r5e_702">config.getWorkerAction()</code>, именно он содержит <code class="code" id="z61r5e_703">TestWorker</code>, который отвечает за запуск тестов. Но пока он обёрнут в универсальный <code class="code" id="z61r5e_704">ActionExecutionWorker</code>. <span class="control" id="z61r5e_705">Комментарий:</span> <code class="code" id="z61r5e_706">SystemApplicationClassLoaderWorker</code> это <span class="emphasis" id="z61r5e_707">внутренний запускной адаптер Gradle</span>, который оборачивает и исполняет реальную рабочую нагрузку. Он используется для переключения контекста ClassLoader-а (SystemApplicationClassLoader) и передачи управления <code class="code" id="z61r5e_708">ActionExecutionWorker</code>. Именно в этом классе происходит развертывание конфигурации worker-а (<code class="code" id="z61r5e_709">config</code>) и передача управления реальной задаче.</p></aside></section><section class="chapter"><h4 id="actionexecutionworker-testworker" data-toc="actionexecutionworker-testworker"><code class="code" id="z61r5e_713">ActionExecutionWorker</code> вызов настоящего <code class="code" id="z61r5e_714">TestWorker</code></h4><div class="code-block" data-lang="java">
public class ActionExecutionWorker implements Action&lt;WorkerProcessContext&gt; {
    private final Action&lt;? super WorkerProcessContext&gt; action;

    public ActionExecutionWorker(Action&lt;? super WorkerProcessContext&gt; action) {
        this.action = action;
    }

    @Override
    public void execute(final WorkerProcessContext workerContext) {
        ObjectConnection clientConnection = workerContext.getServerConnection();
        clientConnection.addUnrecoverableErrorHandler(new Action&lt;Throwable&gt;() {
            @Override
            public void execute(Throwable throwable) {
                if (action instanceof Stoppable) {
                    ((Stoppable) action).stop();
                }
            }
        });

        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(action.getClass().getClassLoader());
        try {
            action.execute(workerContext); // &lt;-- ключевой момент: вызывает TestWorker
        } finally {
            ...
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_712"><p id="z61r5e_715">Здесь action это и есть TestWorker, просто замаскированный под Action. Этот вызов приводит к запуску кода, который действительно управляет жизненным циклом тестов. <span class="control" id="z61r5e_716">Комментарий:</span> <code class="code" id="z61r5e_717">ActionExecutionWorker</code> универсальный обёртчик, запускающий пользовательский <code class="code" id="z61r5e_718">Action</code> (в нашем случае <code class="code" id="z61r5e_719">TestWorker</code>). Он также добавляет обработчик критических ошибок (<code class="code" id="z61r5e_720">addUnrecoverableErrorHandler</code>), который при сбое выполнит <code class="code" id="z61r5e_721">stop()</code> у <code class="code" id="z61r5e_722">TestWorker</code>. Это инфраструктурный компонент Gradle Worker API, обеспечивающий безопасное выполнение задач.</p></aside></section><section class="chapter"><h4 id="testworker" data-toc="testworker"><code class="code" id="z61r5e_729">TestWorker</code> управление жизненным циклом и запуск тестов</h4><div class="code-block" data-lang="java">
public class TestWorker implements Action&lt;WorkerProcessContext&gt;, RemoteTestClassProcessor, Serializable, Stoppable {

    @Override
    public void execute(final WorkerProcessContext workerProcessContext) {
        ...
        CloseableServiceRegistry testServices = TestFrameworkServiceRegistry.create(workerProcessContext);
        startReceivingTests(workerProcessContext, testServices);

        try {
            while (state != State.STOPPED) {
                executeAndMaintainThreadName(runQueue.take());
            }
        } finally {
            ...
            testServices.close();
        }
    }

    private static void executeAndMaintainThreadName(Runnable action) {
        try {
            action.run();
        } finally {
            Thread.currentThread().setName(WORK_THREAD_NAME);
        }
    }

    @Override
    public void stop() {
        submitToRun(new Runnable() {
            @Override
            public void run() {
                try {
                    processor.stop();
                } finally {
                    state = State.STOPPED;
                    // Clean the interrupted status
                    // because some test class processors do work here, e.g. JUnitPlatform
                    Thread.interrupted();
                }
            }
        });
    }

}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_725"><p id="z61r5e_730">Здесь начинается реальная жизнь тестов. Метод <code class="code" id="z61r5e_731">startReceivingTests()</code> инициирует приём тестов от Master-процесса, а <code class="code" id="z61r5e_732">runQueue.take()</code> вытаскивает очередной <code class="code" id="z61r5e_733">Runnable</code> - в том числе и JUnit-подобные вызовы. Но кто решает, какие классы положить в эту очередь? executeAndMaintainThreadName, вызывая action.run(), на самом деле вызовет stop у TestWorker. <span class="control" id="z61r5e_734">Комментарий:</span> <code class="code" id="z61r5e_735">TestWorker</code> это главная точка управления тестами на стороне worker-процесса. Он слушает очередь задач (<code class="code" id="z61r5e_736">runQueue</code>) и исполняет их. Именно сюда Master отправляет команды через <code class="code" id="z61r5e_737">RemoteTestClassProcessor &rarr; Dispatch &rarr; MethodInvocation</code>. Также реализует <code class="code" id="z61r5e_738">Stoppable</code>, чтобы корректно завершить тестовый процесс по команде снаружи (в том числе при отмене сборки).</p></aside><p id="z61r5e_726">Отлично, теперь мы перешли к следующему важному слою, механизму доставки и вызова тестов. На этом этапе <code class="code" id="z61r5e_739">TestWorker</code> уже готов принимать команды, но кто же инициирует вызовы тестов и как классы с <code class="code" id="z61r5e_740">@Test</code> действительно попадают в исполнение?</p><p id="z61r5e_727">Разбираем цепочку, в которой <code class="code" id="z61r5e_741">Dispatch</code>, <code class="code" id="z61r5e_742">MethodInvocation</code> и <code class="code" id="z61r5e_743">TestClassProcessor</code> играют ключевую роль в том, как тестовый класс сначала * *обнаруживается**, а затем **передаётся** для обработки.</p><p id="z61r5e_728">В этом этапе мы находимся чуть выше JUnit Platform, на уровне Gradle Test Framework. Здесь через прокси и диспатчер происходит вызов методов, которые в итоге передают управление JUnit Engine'у.</p></section><section class="chapter"><h4 id="proxydispatchadapter-dispatch" data-toc="proxydispatchadapter-dispatch"><code class="code" id="z61r5e_747">ProxyDispatchAdapter</code> создание прокси, который делегирует вызовы через <code class="code" id="z61r5e_748">Dispatch</code></h4><div class="code-block" data-lang="java">
public class ProxyDispatchAdapter&lt;T&gt; {
    private final Class&lt;T&gt; type;
    private final T source;

    public ProxyDispatchAdapter(Dispatch&lt;? super MethodInvocation&gt; dispatch, Class&lt;T&gt; type, Class&lt;?&gt;... extraTypes) {
        this.type = type;
        List&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;Class&lt;?&gt;&gt;();
        ClassLoader classLoader = type.getClassLoader();
        types.add(type);
        for (Class&lt;?&gt; extraType : extraTypes) {
            ...
            types.add(extraType);
        }
        source = type.cast(Proxy.newProxyInstance(
                classLoader,
                types.toArray(new Class&lt;?&gt;[0]),
                new DispatchingInvocationHandler(type, dispatch)));
    }

    public T getSource() {
        return source;
    }

    private static class DispatchingInvocationHandler implements InvocationHandler {
        private final Class&lt;?&gt; type;
        private final Dispatch&lt;? super MethodInvocation&gt; dispatch;

        @Override
        public Object invoke(Object target, Method method, Object[] parameters) throws Throwable {
            dispatch.dispatch(new MethodInvocation(method, parameters));
            return null;
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_746"><p id="z61r5e_749">Здесь создаётся <span class="control" id="z61r5e_750">динамический прокси</span> (через <code class="code" id="z61r5e_751">java.lang.reflect.Proxy</code>), который вместо непосредственного вызова метода прокидывает его как <code class="code" id="z61r5e_752">MethodInvocation</code> в <code class="code" id="z61r5e_753">Dispatch</code>. Это ключевая прослойка для удалённого и deferred-вызова <code class="code" id="z61r5e_754">processTestClass(...)</code>. <span class="control" id="z61r5e_755">Комментарий:</span> используется в master-процессе. Возвращает реализацию интерфейса <code class="code" id="z61r5e_756">TestClassProcessor</code>, но на деле метод будет превращён в <code class="code" id="z61r5e_757">MethodInvocation</code> и передан в <code class="code" id="z61r5e_758">Dispatch</code>, который отправит его в дочерний процесс.</p></aside></section><section class="chapter"><h4 id="contextclassloaderdispatch-classloader" data-toc="contextclassloaderdispatch-classloader"><code class="code" id="z61r5e_762">ContextClassLoaderDispatch</code> временно меняет classloader на тестовый</h4><div class="code-block" data-lang="java">
public class ContextClassLoaderDispatch&lt;T&gt; implements Dispatch&lt;T&gt; {
    private final Dispatch&lt;? super T&gt; dispatch;
    private final ClassLoader contextClassLoader;

    @Override
    public void dispatch(T message) {
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(contextClassLoader);
        try {
            dispatch.dispatch(message);
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_761"><p id="z61r5e_763">Оборачивает <code class="code" id="z61r5e_764">Dispatch</code>, чтобы каждый вызов происходил в нужном <span class="control" id="z61r5e_765">contextClassLoader'е</span>, том, в котором доступны юзерские тесты, аннотации <code class="code" id="z61r5e_766">@Test</code> и прочие артефакты сборки. В противном случае рефлексия просто не увидит нужные классы. <span class="control" id="z61r5e_767">Комментарий:</span> используется на стороне worker-а для того, чтобы внутри JUnit-кода применялся корректный <code class="code" id="z61r5e_768">ClassLoader</code>, видящий классы тестов, их зависимости и runtime-окружение.</p></aside></section><section class="chapter"><h4 id="reflectiondispatch" data-toc="reflectiondispatch"><code class="code" id="z61r5e_772">ReflectionDispatch</code> финальный обработчик, вызывающий метод</h4><div class="code-block" data-lang="java">
public class ReflectionDispatch implements Dispatch&lt;MethodInvocation&gt; {
    private final Object target;

    @Override
    public void dispatch(MethodInvocation message) {
        try {
            Method method = message.getMethod();
            method.setAccessible(true);
            method.invoke(target, message.getArguments());
        } catch (InvocationTargetException e) {
            throw UncheckedException.throwAsUncheckedException(e.getCause());
        } catch (Throwable throwable) {
            throw UncheckedException.throwAsUncheckedException(throwable);
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_771"><p id="z61r5e_773">Это последний шаг цепочки вызова: приходит <code class="code" id="z61r5e_774">MethodInvocation</code>, и метод вызывается на <code class="code" id="z61r5e_775">target</code>-объекте. Обычно это и есть <code class="code" id="z61r5e_776">JUnitTestClassProcessor</code>, у которого вызывается <code class="code" id="z61r5e_777">processTestClass(...)</code>. <span class="control" id="z61r5e_778">Комментарий:</span> работает внутри <code class="code" id="z61r5e_779">TestWorker</code> - принимает вызов из master-процесса, извлекает метод и аргументы, и вызывает нужный метод на <code class="code" id="z61r5e_780">TestClassProcessor</code>, фактически начиная выполнение теста.</p></aside></section><section class="chapter"><h4 id="suitetestclassprocessor" data-toc="suitetestclassprocessor"><code class="code" id="z61r5e_784">SuiteTestClassProcessor</code> - обёртка над настоящей обработкой класса</h4><div class="code-block" data-lang="java">
public class SuiteTestClassProcessor implements TestClassProcessor {
    private final TestClassProcessor processor;

    @Override
    public void processTestClass(TestClassRunInfo testClass) {
        ...
        processor.processTestClass(testClass);
        ...
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_783"><p id="z61r5e_785">Именно здесь вызывается <code class="code" id="z61r5e_786">processTestClass(...)</code> на реальном обработчике, чаще всего это <code class="code" id="z61r5e_787">JUnitTestClassProcessor</code>, и уже он инициализирует JUnit Engine, Discovery, и начинает сканировать аннотации <code class="code" id="z61r5e_788">@Test</code>. <span class="control" id="z61r5e_789">Комментарий:</span> <code class="code" id="z61r5e_790">SuiteTestClassProcessor</code> добавляет fault-tolerance-обёртку над реальным <code class="code" id="z61r5e_791">TestClassProcessor</code>. Он отлавливает исключения выполнения и репортит их через <code class="code" id="z61r5e_792">resultProcessor</code>, чтобы обеспечить корректную отчётность, даже если тесты упали на фазе запуска.</p></aside></section><section class="chapter"><h4 id="abstractjunittestclassprocessor-junit" data-toc="abstractjunittestclassprocessor-junit"><code class="code" id="z61r5e_796">AbstractJUnitTestClassProcessor</code> общая логика для JUnit-обработчиков</h4><div class="code-block" data-lang="java">
public abstract class AbstractJUnitTestClassProcessor implements TestClassProcessor {

    private Action&lt;String&gt; executor;

    @Override
    public void startProcessing(TestResultProcessor resultProcessor) {
        executor = createTestExecutor(resultProcessorActor);
    }

     @Override
     public void processTestClass(TestClassRunInfo testClass) {
         executor.execute(testClass.getTestClassName());
     }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_795"><p id="z61r5e_797">Далее переменной <code class="code" id="z61r5e_798">executor</code> присваивается результат функции <code class="code" id="z61r5e_799">createTestExecutor(...)</code>, а в методе <code class="code" id="z61r5e_800">processTestClass(...)</code> идёт обращение к этому <code class="code" id="z61r5e_801">executor</code>. <span class="control" id="z61r5e_802">Комментарий:</span> <code class="code" id="z61r5e_803">AbstractJUnitTestClassProcessor</code> содержит шаблонную реализацию <code class="code" id="z61r5e_804">processTestClass(...)</code>, делегируя выполнение <code class="code" id="z61r5e_805">Action&lt;String&gt;</code>, это и есть фактический механизм исполнения теста. Конкретные реализации определяют, как именно запускать класс.</p></aside></section><section class="chapter"><h4 id="junitplatformtestclassprocessor-junit-5" data-toc="junitplatformtestclassprocessor-junit-5"><code class="code" id="z61r5e_809">JUnitPlatformTestClassProcessor</code> реализация под JUnit 5</h4><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessor extends AbstractJUnitTestClassProcessor {

    @Override
    protected Action&lt;String&gt; createTestExecutor(Actor resultProcessorActor) {
        ...
        testClassExecutor = new CollectAllTestClassesExecutor(threadSafeResultProcessor);
        return testClassExecutor;
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_808"><p id="z61r5e_810"><code class="code" id="z61r5e_811">JUnitPlatformTestClassProcessor</code> наследуется от <code class="code" id="z61r5e_812">AbstractJUnitTestClassProcessor</code> и предоставляет реализацию метода <code class="code" id="z61r5e_813">createTestExecutor(...)</code>. <span class="control" id="z61r5e_814">Комментарий:</span> на фазе запуска (в <code class="code" id="z61r5e_815">startProcessing</code>) создаётся <code class="code" id="z61r5e_816">CollectAllTestClassesExecutor</code>, который временно накапливает все классы, помеченные к исполнению. Позже Gradle вызовет <code class="code" id="z61r5e_817">stopProcessing()</code>, и тогда накопленные классы передадутся в <code class="code" id="z61r5e_818">JUnitPlatform</code> через <code class="code" id="z61r5e_819">Launcher.execute(...)</code>.</p></aside></section><section class="chapter"><h4 id="collectalltestclassesexecutor" data-toc="collectalltestclassesexecutor"><code class="code" id="z61r5e_823">CollectAllTestClassesExecutor</code> накопление тестовых классов до момента исполнения</h4><div class="code-block" data-lang="java">
private class CollectAllTestClassesExecutor implements Action&lt;String&gt; {
    private final List&lt;Class&lt;?&gt;&gt; testClasses = new ArrayList&lt;&gt;();

    @Override
    public void execute(@Nonnull String testClassName) {
        Class&lt;?&gt; klass = loadClass(testClassName);
        testClasses.add(klass);
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z61r5e_822"><p id="z61r5e_824">Тут <code class="code" id="z61r5e_825">klass</code> добавляется в список <code class="code" id="z61r5e_826">testClasses</code>. <span class="control" id="z61r5e_827">Комментарий:</span> <code class="code" id="z61r5e_828">CollectAllTestClassesExecutor</code> не запускает тесты немедленно. Он просто накапливает их для дальнейшего пакетного исполнения. Позднее, в методе <code class="code" id="z61r5e_829">stopProcessing()</code>, список будет передан <code class="code" id="z61r5e_830">JUnit Launcher</code>, чтобы протестировать все классы единым <code class="code" id="z61r5e_831">TestPlan</code>.</p></aside></section></section><section class="chapter"><h3 id="z61r5e_480" data-toc="z61r5e_480">Почему мы всё это рассмотрели?</h3><p id="z61r5e_832">Если вы дочитали до этого момента, то наверняка хотя бы раз задали себе вопрос: зачем вообще вникать в архитектуру JUnit 5? Зачем знать, что делает <code class="code" id="z61r5e_839">TestWorker</code>, чем <code class="code" id="z61r5e_840">TestEngine</code> отличается от API, и как <code class="code" id="z61r5e_841">Gradle</code> взаимодействует с <code class="code" id="z61r5e_842">JUnit Platform</code>?</p><p id="z61r5e_833">Ответ в самом характере JUnit. Это инфраструктура, на которой десятилетиями держалась JVM-разработка. JUnit это канонический пример того, как строятся фреймворки с глубокой интеграцией: в Gradle, в IDE, в CI. Поняв как работает JUnit, вы поймёте, как устроены почти все тестовые инструменты в JVM-мире, от Spock до Kotest, от TestNG до Spek.</p><p id="z61r5e_834">Тесты на основе аннотаций всегда работают через рефлексию. Всегда есть рантайм, который анализирует классы, определяет методы, оборачивает их в структуру исполнения. Всегда есть <code class="code" id="z61r5e_843">TestEngine</code>, который решает, как именно вызвать <code class="code" id="z61r5e_844">@BeforeEach</code>, что считать failed-стейтом, и как прервать иерархию при падении родителя. Именно <code class="code" id="z61r5e_845">Engine</code>, а не <code class="code" id="z61r5e_846">@Test</code> и не <code class="code" id="z61r5e_847">Assertions</code>, определяет поведение.</p><p id="z61r5e_835">JUnit Platform отделила Engine от API. Это был стратегический шаг. Теперь JUnit это инфраструктурный протокол, к которому могут подключаться любые движки. Jupiter один из них. Kotest другой. Даже ваш собственный.</p><p id="z61r5e_836">Мы прошли весь путь: от команды <code class="code" id="z61r5e_848">./gradlew test</code> до самого вызова вашего метода. По дороге были:</p><ul class="list _bullet" id="z61r5e_837"><li class="list__item" id="z61r5e_849"><p id="z61r5e_856">Gradle, который координирует процесс;</p></li><li class="list__item" id="z61r5e_850"><p id="z61r5e_857">Forked Worker, запускающий процесс с изоляцией;</p></li><li class="list__item" id="z61r5e_851"><p id="z61r5e_858">TestClassProcessor, создающий структуру исполнения;</p></li><li class="list__item" id="z61r5e_852"><p id="z61r5e_859">JUnit Platform, связывающая мир движков и инфраструктуры;</p></li><li class="list__item" id="z61r5e_853"><p id="z61r5e_860">JUnit Jupiter, реализующий правила JUnit 5;</p></li><li class="list__item" id="z61r5e_854"><p id="z61r5e_861">Hierarchical Test Executor, обрабатывающий before/execute/after как дерево;</p></li><li class="list__item" id="z61r5e_855"><p id="z61r5e_862">и, наконец, конкретный метод, вызываемый через рефлексию.</p></li></ul><p id="z61r5e_838">Это выглядит сложнее, чем <code class="code" id="z61r5e_863">assertEquals(4, 2 + 2)</code>, но эта сложность осмысленная. Она обеспечивает модульность, расширяемость, гибкость и параллелизм. Она позволяет использовать свои движки, свои жизненные циклы, свои правила. И именно это знание отличает пользователя фреймворка от инженера.</p></section><section class="chapter"><h3 id="visiblefortesting" data-toc="visiblefortesting"><code class="code" id="z61r5e_871">@VisibleForTesting</code>: доступ, расширенный исключительно для тестов</h3><p id="z61r5e_865">Стоит упомянуть про аннотацию <code class="code" id="z61r5e_872">@VisibleForTesting</code> нечастого, но важного участника тестового ландшафта. Она не делает метод тестом, не участвует в рантайме и никак не влияет на выполнение. Но если вы видите её в коде значит, где-то произошла честная сделка между инкапсуляцией и тестируемостью. Компромисс. Внятно обозначенный.</p><p id="z61r5e_866">Аннотация сигнализирует: этот метод, это поле или конструктор открыты шире, чем должны быть, потому что тест этого требует. Приватную логику не протестируешь напрямую, а выносить её наружу в API не хочется. Тогда разработчик идёт на аккуратное нарушение границы и оставляет пометку <code class="code" id="z61r5e_873">@VisibleForTesting</code>. Это как ручка от сейфа, которую поставили снаружи исключительно для инженеров техподдержки.</p><p id="z61r5e_867">Такой подход особенно распространён в Android и Kotlin-проектах, где модификатор <code class="code" id="z61r5e_874">internal</code> или <code class="code" id="z61r5e_875">protected</code> часто становится компромиссной зоной. Метод мог бы быть <code class="code" id="z61r5e_876">private</code>, но тогда тесты не смогут его вызвать. Расширяем видимость, но делаем это явно и документированно:</p><div class="code-block" data-lang="kotlin">
@VisibleForTesting
internal fun recalculateChecksum() {
    // метод открыт для тестов, чтобы тест мог вызвать напрямую
}
</div><p id="z61r5e_869">У аннотации нет единого источника. Первая её версия появилась в Guava: <code class="code" id="z61r5e_877">com.google.common.annotations.VisibleForTesting</code>. Затем аналогичные появились в <code class="code" id="z61r5e_878">androidx.annotation</code> и <code class="code" id="z61r5e_879">org.jetbrains.annotations</code> с тем же смыслом, но немного разной реализацией. Например, Android-версия допускает уточнение, какую видимость следует использовать в продакшене (<code class="code" id="z61r5e_880">otherwise = PRIVATE</code>), если вы вдруг забудете вернуть модификатор обратно.</p><p id="z61r5e_870">Важно понимать: компилятору всё равно. JUnit тем более. Это честная метка. Обещание, данное себе и команде: &quot;я знаю, что это дырка в инкапсуляции и сделал её не по глупости&quot;. Именно такие детали отличают инженерное решение от хаотичного &laquo;лишь бы работало&raquo;.</p></section><section class="chapter"><h3 id="junit-5" data-toc="junit-5">Почему JUnit 5 это уже не только про юниты</h3><p id="z61r5e_881">Когда говорят &laquo;JUnit 5&raquo;, чаще всего имеют в виду просто современную библиотеку для написания юнит-тестов. И это правда JUnit 5 вполне можно использовать как обычный инструмент: подключить, написать тесты, запускать из IDE или Gradle.</p><p id="z61r5e_882">Но это поверхностный взгляд. Потому что <code class="code" id="z61r5e_890">JUnit 5</code> это фреймворк, из которого можно собирать другие фреймворки. Внутри него JUnit Platform, модуль, который работает как рантайм-движок: он не диктует, как должны выглядеть тесты, он умеет обнаруживать, исполнять и агрегировать любые тестовые единицы, если они реализованы в рамках платформенного контракта.</p><p id="z61r5e_883">На этом контракте уже сегодня построено множество других библиотек. Они не используют JUnit &laquo;как есть&raquo;, они строят свои абстракции, свои DSL&rsquo;ы, но под капотом всё это всё равно исполняется через JUnit Platform. Ниже несколько ярких примеров:</p><p id="z61r5e_884"><code class="code" id="z61r5e_891">Kotest</code> Фреймворк, который кардинально переосмысливает, как должен выглядеть тест в языке Kotlin. Вместо привычной структуры &ldquo;класс + методы&rdquo;, здесь декларативный DSL, приближённый к структуре документации: &quot;should do something&quot; внутри &quot;describe this behavior&quot;. Kotest также встроенно поддерживает property-based testing, матчер-DSL, тестовые генераторы и детерминированные стратегии повторения. Но что важно всё это работает через JUnit Platform, а значит, совместимо с IDE, Gradle и CI из коробки.</p><p id="z61r5e_885"><code class="code" id="z61r5e_892">Spek</code> Минималистичный фреймворк, ориентированный на спецификацию поведения. Тесты в Spek пишутся как цепочки вложенных блоков given / on / it, приближаясь к форме технического задания. В отличие от Kotest, Spek делает акцент на чистоте и лаконичности, особенно в микросервисных сценариях. И снова под всей этой структурой лежит JUnit Platform.</p><p id="z61r5e_886"><code class="code" id="z61r5e_893">Cucumber</code> BDD-фреймворк, который строится вокруг Gherkin-сценариев. Вы описываете поведение системы в .feature-файле на естественном языке, а реализацию шагов связываете с кодом. Для запуска этих сценариев, Cucumber использует свой адаптер, который регистрирует себя как TestEngine JUnit Platform. Это позволяет запускать BDD-тесты в той же среде, что и обычные unit или integration тесты, не ломая пайплайн.</p><p id="z61r5e_887"><code class="code" id="z61r5e_894">JQwik</code> Property-based testing на Java и Kotlin, вдохновлённый QuickCheck. Вместо написания конкретных примеров, вы описываете свойства, которые система должна удовлетворять для произвольных входов. Генерация данных, shrink&rsquo;инг, случайность всё встроено. И опять же: он не делает свою экосистему он интегрируется через JUnit Platform.</p><p id="z61r5e_888"><code class="code" id="z61r5e_895">JUnit 5</code> это почва, на которой растут разные формы тестирования: декларативные, спецификационные, BDD, property-based. Возможность строить поверх него это основа архитектурного замысла.</p><p id="z61r5e_889">Это платформа, к которой можно подключить своё видение того, что такое тест вообще.</p></section></section><section class="chapter"><h2 id="7-kotlin-test-kotest" data-toc="7-kotlin-test-kotest">7. Kotlin Test: Строгая минималистика или Kotest</h2><p id="z61r5e_896">Когда разработчик впервые сталкивается с тестами в Kotlin, особенно на JVM, он почти автоматически тянется к тому, что уже знакомо, JUnit. Возможно, даже не подозревая, что в стандартной библиотеке Kotlin есть свой собственный тестовый модуль <code class="code" id="z61r5e_906">kotlin.test</code>. Не библиотека на GitHub, не очередной фреймворк от энтузиастов, а часть самого языка. Устанавливать его не нужно, он поставляется вместе со стандартной библиотекой, и уже доступен в любом Kotlin-проекте.</p><figure id="z61r5e_897"><img alt="junit-kotlin-tet.jpeg" src="images/testing_philosophy_kotlin_expect_actual_test_doubles3.jpeg" title="junit-kotlin-tet.jpeg" width="2896" height="766"></figure><p id="z61r5e_898">Если открыть любую multiplatform-библиотеку JetBrains, например, kotlinx.coroutines или kotlinx.datetime, можно увидеть, что все тесты написаны на <code class="code" id="z61r5e_907">kotlin.test</code>: <code class="code" id="z61r5e_908">@Test</code>, <code class="code" id="z61r5e_909">assertEquals</code>, <code class="code" id="z61r5e_910">assertFailsWith</code>. И всё это без упоминания JUnit. Это не случайность. <code class="code" id="z61r5e_911">kotlin.test</code> был задуман как <span class="control" id="z61r5e_912">единый абстрактный слой для тестирования во всех таргетах: JVM, JS, Native</span>. Он не привязан к JUnit, Mocha или XCTest, но умеет работать с каждым из них, если ты подключаешь соответствующий адаптер. На JVM это может быть <code class="code" id="z61r5e_913">kotlin-test-junit</code>, <code class="code" id="z61r5e_914">kotlin-test-junit5</code>, <code class="code" id="z61r5e_915">kotlin-test-testng</code>. На JavaScript интеграция с Mocha. На Native своя реализация, написанная на C interop. API при этом остаётся единым.</p><p id="z61r5e_899">Под капотом, конечно, никакого волшебства нет: <code class="code" id="z61r5e_916">assertEquals</code> делегирует на <code class="code" id="z61r5e_917">org.junit.jupiter.api.Assertions.assertEquals</code> только если ты сам подключил <code class="code" id="z61r5e_918">kotlin-test-junit5</code>. Нет JUnit будет <code class="code" id="z61r5e_919">NoClassDefFoundError</code>. Никаких запасных планов. <code class="code" id="z61r5e_920">kotlin.test</code> это не runtime-инфраструктура, а чисто <span class="control" id="z61r5e_921">API-слой</span>, такой же как <code class="code" id="z61r5e_922">kotlin.collections</code>. Kotlin предоставляет общее имя, реализация зависит от того, на какой платформе ты находишься и что положил в classpath.</p><p id="z61r5e_900">Именно поэтому <code class="code" id="z61r5e_923">kotlin.test</code> часто недооценивают: на JVM он не кажется самостоятельным, выглядит как прокладка, иногда как костыль. Но за этим решением стоит другая философия, уйти от JUnit. Сделать API тестирования таким же, как стандартные функции в Kotlin: лаконичным, предсказуемым, платформонейтральным. У Kotlin нет своего <code class="code" id="z61r5e_924">@Synchronized</code>, своего <code class="code" id="z61r5e_925">List</code> или <code class="code" id="z61r5e_926">File</code>, потому что есть JVM-шные аналоги. Но у него есть <code class="code" id="z61r5e_927">kotlin.test.assertEquals</code>.</p><p id="z61r5e_901">Пример минимального теста в духе этой философии:</p><div class="code-block" data-lang="kotlin">
@Test
fun testSum() {
    assertEquals(4, 2 + 2)
}
</div><p id="z61r5e_903">Без <code class="code" id="z61r5e_928">@RunWith</code>, без <code class="code" id="z61r5e_929">@DisplayName</code>, без <code class="code" id="z61r5e_930">assertThat(...).isEqualTo(...)</code>. Просто функция, просто проверка. Как будто ты пишешь обычный код, и это ключевой замысел. Встраивать тестирование в обычную практику разработки, сделать его естественным, как <code class="code" id="z61r5e_931">println()</code>.</p><p id="z61r5e_904">Но у этой строгости есть и предел. В какой-то момент тебе хочется группировать тесты по контексту, писать <code class="code" id="z61r5e_932">beforeEach</code>, использовать <code class="code" id="z61r5e_933">property-based testing</code>, делать ассерт целой структуры. И вот здесь начинается другая история, история Kotest.</p><section class="chapter"><h3 id="kotest-kotlin-first" data-toc="kotest-kotlin-first">Kotest лучшая Kotlin First тестовая библиотека?</h3><p id="z61r5e_934">Kotest это попытка переосмыслить саму структуру тестов, убрав их из мира фреймворков и вернуть в язык. Написать тесты как код, а не как декларации.</p><p id="z61r5e_935">В Kotest нет <code class="code" id="z61r5e_949">@Test</code>. Вместо этого структуры и декларативные конструкции. Спецификации (<code class="code" id="z61r5e_950">FunSpec</code>, <code class="code" id="z61r5e_951">DescribeSpec</code>, <code class="code" id="z61r5e_952">BehaviorSpec</code> и другие) задают форму теста: ты не навешиваешь аннотацию на метод, ты описываешь, как ведёт себя система в определённом контексте. DSL делает это без ceremony.</p><div class="code-block" data-lang="kotlin">
class MathSpec : FunSpec({
    test(&quot;2 + 2 should be 4&quot;) {
        2 + 2 shouldBe 4
    }
})
</div><p id="z61r5e_937">Это читается как спецификация. Kotest позволяет писать тесты в форме, близкой к документации, но без потери точности или контроля над структурой. Ты явно задаёшь контекст, ожидаемое поведение, границы. Это дерево, а не набор методов.</p><p id="z61r5e_938">У каждого стиля (Spec) своя семантика. <code class="code" id="z61r5e_953">FunSpec</code> минимализм, <code class="code" id="z61r5e_954">DescribeSpec</code> BDD, <code class="code" id="z61r5e_955">ShouldSpec</code> поведенческое описание, <code class="code" id="z61r5e_956">WordSpec</code> текстовая вложенность, <code class="code" id="z61r5e_957">FreeSpec</code> произвольная свобода, <code class="code" id="z61r5e_958">ExpectSpec</code> JUnit-стиль. Это разные способы мыслить о тестах.</p><p id="z61r5e_939">Kotest работает через <code class="code" id="z61r5e_959">TestEngine</code>, который интегрируется с JUnit Platform. Без JUnit Platform он не запускается, и это принципиальный момент: Kotest <span class="control" id="z61r5e_960">не отвергает JUnit</span>, он использует его как точку входа, но полностью заменяет внутреннюю механику. Это самостоятельный фреймворк, который использует JUnit только как bootstrap и канал для IDE и Gradle.</p><p id="z61r5e_940">Каждый тест может быть <code class="code" id="z61r5e_961">suspend</code>. Корутинные тесты не требуют никаких обёрток или расширений. <code class="code" id="z61r5e_962">delay</code>, <code class="code" id="z61r5e_963">Flow</code>, <code class="code" id="z61r5e_964">runBlockingTest</code>, всё работает из коробки. Это особенно важно, если ты тестируешь то, что и так построено на suspend-функциях. В <code class="code" id="z61r5e_965">kotlin.test</code> это возможно, но не на всех уровнях одинаково гладко.</p><p id="z61r5e_941">Matchers в Kotest отдельная тема. Ты не делаешь <code class="code" id="z61r5e_966">assertEquals</code>, ты пишешь <code class="code" id="z61r5e_967">value shouldBe expected</code>. Или <code class="code" id="z61r5e_968">list shouldContainExactly listOf(...)</code>. Или <code class="code" id="z61r5e_969">exception shouldHaveMessage &quot;Invalid state&quot;</code>. Это способ избавиться от лишнего уровня абстракции: не писать &quot;assert X о Y&quot;, а описывать свойства Y как есть.</p><p id="z61r5e_942">Существует <code class="code" id="z61r5e_970">assertSoftly</code>, которое позволяет в одном тесте проверять сразу несколько свойств и видеть все ошибки сразу, а не только первую. Это удобно, когда ты тестируешь сложный объект и не хочешь писать пять отдельных тестов на каждое поле.</p><p id="z61r5e_943">Kotest также поддерживает property-based testing через <code class="code" id="z61r5e_971">forAll</code>, <code class="code" id="z61r5e_972">checkAll</code>, <code class="code" id="z61r5e_973">Gen</code>. Это ближе к QuickCheck, чем к JUnit. Тесты становятся генератором гипотез, а не списком кейсов. В мире строго типизированного языка с мощным компилятором это логичное продолжение.</p><div class="code-block" data-lang="kotlin">
class EmailValidatorTest : StringSpec({
    &quot;should only accept valid emails&quot; {
        forAll(Gen.email()) { email -&gt;
            isValidEmail(email)
        }
    }
})
</div><p id="z61r5e_945">Kotest можно использовать на JS и Native, но не с той же глубиной. Его настоящая сила в JVM. Именно там ты получаешь весь спектр: DSL, корутины, матчеры, генераторы, спецификации, soft-asserts, глобальные конфигурации, hooks и extensions. Это целая тестовая среда.</p><p id="z61r5e_946">Но есть и границы. Kotest сложнее стартовать. Он не такой лёгкий, как <code class="code" id="z61r5e_974">kotlin.test</code>. Его интеграция с IDE не всегда бесшовна. Иногда нужно понимать, как устроен lifecycle, особенно если ты пишешь расширения или работаешь с Before/After-hooks. Документация покрывает многое, но не всё. Если ты новичок в Kotlin или хочешь просто проверить, что функция возвращает true тебе, возможно, не нужен весь этот DSL.</p><p id="z61r5e_947">И вот здесь и возникает выбор. Если тебе нужно писать простые тесты быстро и платформонейтрально <code class="code" id="z61r5e_975">kotlin.test</code> даст всё, что нужно. Он строг, предсказуем и не требует инфраструктуры. Но если ты хочешь описывать поведение системы в терминах, близких к языку, если тебе важна выразительность, вложенность, property-based тестирование, гибкая конфигурация и DSL, написанный именно для Kotlin Kotest берёт это всё на себя. Не по лицензии. По замыслу.</p><p id="z61r5e_948">И делает это лучше всех на JVM.</p></section></section><section class="chapter"><h2 id="8" data-toc="8">8. Заключение: Тесты как мышление, а не как процедура</h2><p id="z61r5e_976">Мы прошли путь от <code class="code" id="z61r5e_983">assertEquals(expected, actual)</code> до архитектуры JUnit Platform. От простого сравнения двух значений до понимания того, как работает вся инфраструктура тестирования на JVM. Это не случайность. Тестирование начинается с философии, а заканчивается инженерией.</p><p id="z61r5e_977">Если вы запомните из этой статьи только одну мысль, пусть это будет следующая: <span class="control" id="z61r5e_984">тест это модель поведения</span>. Когда вы пишете <code class="code" id="z61r5e_985">assertTrue(user.isActive())</code>, вы не проверяете, активен ли пользователь в реальности. Вы фиксируете соглашение о том, что в заданных условиях свойство <code class="code" id="z61r5e_986">isActive</code> должно возвращать <code class="code" id="z61r5e_987">true</code>. Это контракт между вами и системой. И когда тест падает, нарушается именно этот контракт.</p><p id="z61r5e_978">Test Doubles, stub, mock, fake, spy, это способы построения контролируемых миров, где можно изолированно проверить отдельные аспекты поведения. Выбор между ними отражает ваш подход к архитектуре: что важно контролировать, что можно упростить, а что необходимо сохранить в первозданном виде.</p><p id="z61r5e_979">JUnit прошёл эволюцию от процедурного фреймворка к платформе. Сегодня JUnit 5 это инфраструктура, на которой строятся другие подходы к тестированию: от Kotest с его выразительным DSL до Cucumber с BDD-сценариями. Понимание этой архитектуры даёт возможность не только использовать готовые решения, но и создавать свои.</p><p id="z61r5e_980">Kotlin привносит в тестирование ту же философию, что и в основной код: лаконичность без потери выразительности, строгость без излишней ceremony. <code class="code" id="z61r5e_988">kotlin.test</code> даёт платформонейтральный минимум. Kotest богатую экосистему для тех, кто хочет описывать поведение системы как спецификацию, а не как набор процедур.</p><p id="z61r5e_981">Но главное не в выборе инструментов. Главное в понимании того, что вы тестируете и зачем. Каждый <code class="code" id="z61r5e_989">@Test</code> это гипотеза о поведении системы. Каждый assert это граница между допустимым и недопустимым. И чем яснее эти границы, тем надёжнее система и тем проще её развивать.</p><p id="z61r5e_982">В следующих частях серии мы углубимся в практические аспекты: как работают популярные фреймворки для тестирования, как работает тестовая инфраструктура под капотом, как избежать иллюзий стабильности и построить пирамиду тестов, которая действительно работает. Но основа уже заложена. Тесты это способ формализовать то, как код должен работать. И если вы это понимаете, вы уже на правильном пути.</p></section><div class="last-modified">03 January 2026</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="decompose-save-state-internal.html" class="navigation-links__prev">Decompose и Essenty: под капотом сохранения состояния без ViewModel</a><a href="serialzation.html" class="navigation-links__next">Введение</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>