<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-link-color="#57B747" data-content-max-width="1600" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-30T23:19:07.006743"><title>&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | suleimanov</title><script type="application/json" id="virtual-toc-data">[{"id":"1","level":0,"title":"1. Введение: Почему тесты - это не проверка, а модель","anchor":"#1"},{"id":"2","level":0,"title":"2. Базис: Лексикон тестирования","anchor":"#2"},{"id":"3","level":0,"title":"3. Концепция: Что вообще мы тестируем?","anchor":"#3"},{"id":"4-expect-actual","level":0,"title":"4. Expect / Actual: Слова, которые всё говорят","anchor":"#4-expect-actual"},{"id":"5-test-doubles-mocks-stubs-fakes-spies-dummy","level":0,"title":"5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies, Dummy","anchor":"#5-test-doubles-mocks-stubs-fakes-spies-dummy"},{"id":"6-unit-vs-junit","level":0,"title":"6. Unit vs JUnit: Что действительно стоит за словами","anchor":"#6-unit-vs-junit"},{"id":"junit-5-test","level":0,"title":"Как JUnit 5 запускает ваш @Test: от команды до метода","anchor":"#junit-5-test"},{"id":"junit-platform-gradle-test-framework-junit-engine","level":0,"title":"В этом этапе мы находимся чуть выше JUnit Platform, на уровне Gradle Test Framework. Здесь через прокси и диспатчер происходит вызов методов, которые в итоге передают управление JUnit Engine\u0027у.","anchor":"#junit-platform-gradle-test-framework-junit-engine"},{"id":"7-kotlin-test-kotest","level":0,"title":"7. Kotlin Test: Строгая минималистика или Kotest","anchor":"#7-kotlin-test-kotest"},{"id":"8","level":0,"title":"8. Заключение: Тесты как мышление, а не как процедура","anchor":"#8"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/style.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://iili.io/3eop8YX.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | suleimanov"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="suleimanov Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | suleimanov"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html#webpage",
    "url": "writerside-documentation//1.0/testing-philosophy-kotlin-expect-actual-test-doubles.html",
    "name": "&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles | suleimanov",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "suleimanov Help"
}</script><!-- End Schema.org --></head><body data-id="testing_philosophy_kotlin_expect_actual_test_doubles" data-main-title="&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Kotlin///Test"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>suleimanov 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="testing_philosophy_kotlin_expect_actual_test_doubles" id="testing_philosophy_kotlin_expect_actual_test_doubles.md">&quot;Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles</h1><section class="chapter"><h2 id="1" data-toc="1">1. Введение: Почему тесты - это не проверка, а модель</h2><p id="z9669ya_12">Эта статья открывает серию &laquo;Android под капотом: Тестирование без иллюзий&raquo;. Семь частей - семь углублений, от фундамента до системной архитектуры, от синтаксиса до этики. Перед вами первая: философская база. Она нужна, чтобы все остальные статьи не висели в воздухе.</p><p id="z9669ya_13">Если вы давно тестируете - это напоминание о том, <span class="emphasis" id="z9669ya_20">зачем</span> вы это делаете. Если вы только начинаете - это фундамент, без которого всё остальное превращается в механическое повторение шаблонов по tutorial-ам и &quot;Best Practice&quot;.</p><p id="z9669ya_14">Тесты часто представляют как механизм проверки: мол, есть код, и нужно проверить, правильно ли он работает. Но программное обеспечение - не прибор. У нас нет датчиков, которыми можно измерить корректность. У нас есть только модели поведения. И тесты - это не проверка, а реализация этих моделей в виде исполняемого кода.</p><p id="z9669ya_15">Когда мы пишем тест, мы создаём вторую вселенную, то есть виртуального пользователя. Она похожа на настоящую, но лучше контролируема. В ней время стоит на месте, зависимости делают только то, что мы им разрешаем, а сама система ведёт себя предсказуемо. Это не копия продакшена - это его реконструкция. Более того:это реконструкция, основанная не на фактах, а на <span class="control" id="z9669ya_21">намерениях</span>. Мы тестируем не то, как система работает - а то, как мы <span class="emphasis" id="z9669ya_22">хотим</span>, чтобы она работала.</p><p id="z9669ya_16">Вот почему тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется - тест падает, частая практика не так ли?). Не потому, что код стал хуже. А потому, что зеркало, в которое мы смотрели, больше не совпадает с формой оригинала.</p><p id="z9669ya_17">Тест - это артефакт доверия. Он фиксирует границы допустимого, которые мы согласились считать истиной. Каждый<code class="code" id="z9669ya_23">assertEquals(expected, actual)</code> - это не факт, это акт утверждения. Он говорит: <span class="emphasis" id="z9669ya_24">мы согласны, что если <code class="code" id="z9669ya_25">actual == expected</code>, то всё хорошо</span>. Это соглашение. Это договор.</p><p id="z9669ya_18">Kotlin хорошо подходит для тестирования, потому что даёт те же инструменты, что и для основного кода: лямбды, DSL, расширения, корутины, строгую типизацию. Тесты на Kotlin не ощущаются как отдельный язык - они пишутся теми же средствами, в той же парадигме. Нет ощущения &laquo;тест - это вторая лига&raquo;. Благодаря компактному синтаксису, читаемости и отсутствию лишнего шаблонного кода, тест выглядит как часть архитектуры, а не как надстройка над ней.</p><p id="z9669ya_19">Во всей серии примеры будут на Kotlin - не потому что &laquo;так модно&raquo;, а потому что это стандарт Android-разработки и полноценный язык для продакшена, независимо от платформы. Kotlin уже используется в Spring, Ktor, Compose, KMP - и везде он одинаково хорош для тестов.</p></section><section class="chapter"><h2 id="2" data-toc="2">2. Базис: Лексикон тестирования</h2><p id="z9669ya_26">Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Без него любые рассуждения - словно попытка строить архитектуру без понятий &quot;стена&quot;, &quot;связь&quot; и &quot;опора&quot;. Ниже - не полный глоссарий, а именно тот минимум, на который будет опираться вся серия.</p><section class="chapter"><h3 id="assertion" data-toc="assertion">Assertion</h3><p id="z9669ya_34">Assertion - это программное утверждение, выражающее ожидание. Если оно не выполняется - тест считается неуспешным. В большинстве фреймворков assertion реализован как функция, выбрасывающая исключение при расхождении:</p><div class="code-block" data-lang="kotlin">
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
</div><p id="z9669ya_36">Важно понимать: assertion не описывает поведение - он фиксирует его. Это финальная точка сценария, где тест явно заявляет: <span class="emphasis" id="z9669ya_37">вот то, что я считаю допустимым</span>. Всё остальное - лишь подготовка к этому моменту.</p></section><section class="chapter"><h3 id="test-case" data-toc="test-case">Test Case</h3><p id="z9669ya_38">Test Case - это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и проверка результата (assert). В Kotlin это обычно функция с аннотацией <code class="code" id="z9669ya_41">@Test</code>.</p><div class="code-block" data-lang="kotlin">
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login(&quot;admin&quot;, &quot;wrong&quot;)
    assertFalse(result.success)
}
</div><p id="z9669ya_40">Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения - он быстро теряет свою надёжность.</p></section><section class="chapter"><h3 id="test-suite" data-toc="test-suite">Test Suite</h3><p id="z9669ya_42">Test Suite - это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно это класс, файл или структура DSL. Назначение suite-а - собрать родственные кейсы и запускать их совместно, например, при CI-сборке или нагрузочном прогоне.</p><p id="z9669ya_43">Хорошо организованный suite - это не просто папка с тестами. Это карта покрытия. Он показывает, где есть тесты, а где - только надежда на интуицию разработчиков.</p></section><section class="chapter"><h3 id="test-runner" data-toc="test-runner">Test Runner</h3><p id="z9669ya_44">Test Runner - это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение, репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через Gradle (или build system IDE), где runner интегрирован в пайплайн.</p><p id="z9669ya_45">Хороший runner не замечается. Плохой - ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.</p></section><section class="chapter"><h3 id="test-double" data-toc="test-double">Test Double</h3><p id="z9669ya_46">Test Double - это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.</p><p id="z9669ya_47">Существует несколько типов Test Double-ов - и каждый из них решает свою задачу.</p><p id="z9669ya_48"><span class="control" id="z9669ya_54">Stub</span> используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем. Его задача - быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.</p><p id="z9669ya_49"><span class="control" id="z9669ya_55">Mock</span> применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.</p><p id="z9669ya_50"><span class="control" id="z9669ya_56">Fake</span> - это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В отличие от stub-ов и mock-ов, фейк умеет &laquo;жить&raquo; - накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.</p><p id="z9669ya_51"><span class="control" id="z9669ya_57">Spy</span> похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.</p><p id="z9669ya_52"><span class="control" id="z9669ya_58">Dummy</span> &mdash; самый простой и самый бесполезный на первый взгляд Test Double. Он ничего не делает, ничего не возвращает и никак не влияет на поведение теста. Его задача &mdash; просто быть. Dummy нужен в тех случаях, когда метод требует обязательного параметра, но в тесте этот параметр не играет никакой роли. Например, когда нужно передать объект логгера или callback, но сам лог не важен. Это форма синтаксического шума, которую мы осознанно заглушаем.</p><p id="z9669ya_53">Test Double - это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения. И если код не поддаётся тестированию с такими объектами - проблема обычно не в тестах, а в архитектуре.</p></section><section class="chapter"><h3 id="unit-vs-integration" data-toc="unit-vs-integration">Unit vs Integration</h3><p id="z9669ya_59">Unit-тест - это тест, который полностью контролирует окружение. Все внешние зависимости заменяются на подставные объекты (Test Doubles), состояние стабильно, внешних эффектов нет. Такой тест проверяет поведение конкретной единицы кода: функции, метода, класса - в изоляции.</p><p id="z9669ya_60">Integration-тест допускает реальные зависимости: базу данных, файловую систему, сеть. Его цель - проверить, как компоненты взаимодействуют друг с другом в условиях, приближенных к боевым.</p><p id="z9669ya_61">Разделение между ними не бинарное. Это шкала. Есть тесты, которые используют, например, настоящий генератор UUID или текущее время - формально это уже не &quot;чистый&quot; Unit. Но такие компромиссы допустимы, если они осознаны. Главное - понимать, что вы контролируете, а что - нет.</p><p id="z9669ya_62">Критерий здесь не в размере функции или скорости выполнения, а в уровне изоляции. Чем больше вы контролируете, тем ближе тест к Unit. Чем больше полагаетесь на реальные зависимости - тем ближе он к Integration. Это не про формат, это про доверие.</p></section><section class="chapter"><h3 id="z9669ya_33" data-toc="z9669ya_33">Тест как артефакт</h3><p id="z9669ya_63">Тест - это не костыль и не подстраховка. Это полноценный исполняемый артефакт, живущий в том же репозитории, что и основной код. Он проходит через компиляцию, участвует в CI/CD пайплайне, ломается при неудачном рефакторинге и требует сопровождения. Если продакшен-код описывает <span class="emphasis" id="z9669ya_65">как</span> работает система, то тест - <span class="emphasis" id="z9669ya_66">что считается допустимым</span> в её поведении.</p><p id="z9669ya_64">Хороший тест не объясняет. Он формализует. И в этом его ценность: он позволяет автоматизировать договор между человеком и системой.</p></section></section><section class="chapter"><h2 id="3" data-toc="3">3. Концепция: Что вообще мы тестируем?</h2><p id="z9669ya_67">Если упростить до предела, то тест - это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно. Он подтверждает, что <span class="control" id="z9669ya_72">в заданных условиях</span> она ведёт себя <span class="control" id="z9669ya_73">определённым образом</span>. Мы не тестируем &quot;истину&quot;. Мы тестируем поведение в симулированной среде.</p><section class="chapter"><h3 id="z9669ya_68" data-toc="z9669ya_68">Симуляция, а не доказательство</h3><p id="z9669ya_74">Распространённая ошибка - считать, что наличие тестов означает корректность системы. Это не так. Тест - это не формальное доказательство, а ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.</p><p id="z9669ya_75">Если поведение системы изменилось, но тесты всё ещё проходят - это не значит, что поведение правильное. Это значит, что тест об этом не знает.</p><p id="z9669ya_76">Например: раньше <code class="code" id="z9669ya_78">isPremiumUser</code> возвращал <code class="code" id="z9669ya_79">true</code>, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь <code class="code" id="z9669ya_80">true</code> возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними - и продолжают проходить. Только теперь они подтверждают совсем не то, что раньше. Просто не знают, что смысл <code class="code" id="z9669ya_81">true</code> изменился.</p><p id="z9669ya_77">Тест проверяет не всю систему, а <span class="control" id="z9669ya_82">конкретный срез</span>: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось &laquo;допустимым&raquo;. Если позже меняется бизнес-логика, интерфейс или требования - тест становится устаревшим. Это не баг, это свойство теста как инструмента.</p></section><section class="chapter"><h3 id="z9669ya_69" data-toc="z9669ya_69">Контролируемое окружение</h3><p id="z9669ya_83">Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время, потоки, гонки, кеши. Тест же создаёт <span class="control" id="z9669ya_85">контролируемое окружение</span>, где всё поведение заранее известно и управляется вручную: от стабов и фейков до фиктивного времени и UUID.</p><p id="z9669ya_84">Разница принципиальна. В production ошибки могут быть случайными. В тестах они - либо детерминированы, либо не обнаруживаются вовсе. Поэтому тест никогда не может гарантировать &quot;всё работает&quot;. Он может только сказать: <span class="emphasis" id="z9669ya_86">в этих условиях - да</span>.</p></section><section class="chapter"><h3 id="z9669ya_70" data-toc="z9669ya_70">Уровень доверия</h3><p id="z9669ya_87">Каждый тест даёт разработчику определённый уровень уверенности. Но важно понимать, откуда именно эта уверенность берётся. Unit-тесты дают быструю обратную связь: запускаются мгновенно, падения легко локализуются, работают стабильно. Но они покрывают только локальную логику - изолированную от остальной системы. Их надёжность держится на том, что окружение подменено, а поведение - строго контролируется.</p><p id="z9669ya_88">Интеграционные тесты покрывают больше связей. Они проверяют, как компоненты работают вместе: контроллер, сервис, база, кэш, очередь. Они ближе к реальности, но требуют больше инфраструктуры, сложнее в запуске, и их падения труднее отлаживать. Тем не менее, именно они ловят те ошибки, которые unit-прогон никогда не заметит.</p><p id="z9669ya_89">Это всегда компромисс. Между скоростью и полнотой. Между удобством и точностью. Между временем отклика и глубиной сигнала. И пока эти компромиссы не осознаны - ни одно число покрытия не имеет смысла. &laquo;100% покрытие&raquo; может означать как надёжную защиту, так и пустой ритуал - всё зависит от того, <span class="emphasis" id="z9669ya_90">что именно</span> вы покрыли, и <span class="emphasis" id="z9669ya_91">зачем</span>.</p></section><section class="chapter"><h3 id="z9669ya_71" data-toc="z9669ya_71">Что мы действительно тестируем</h3><p id="z9669ya_92">На практике, когда мы пишем тест, мы не &laquo;проверяем весь модуль&raquo; - мы проверяем конкретное поведение в конкретной ситуации. Например: что при определённых входных данных метод вызывает другой компонент с нужным параметром. Или что система возвращает ожидаемый результат. Или что в случае ошибки происходит fallback, а не крэш. Или что состояние сохраняется при переходе экрана.</p><p id="z9669ya_93">Это не &laquo;абсолютная проверка системы&raquo;. Это фрагмент поведения, проверенный в специально собранном окружении - со стабами, фейками и полной симуляцией контекста. Мы руками собираем эту модель и утверждаем: <span class="emphasis" id="z9669ya_96">вот в таких условиях система должна вести себя так-то</span>.</p><p id="z9669ya_94">Чем ближе этот контекст к продакшену - тем ценнее тест. Чем дальше - тем он быстрее, дешевле и проще, но локальнее по смыслу. И в этом нет ничего плохого. Главное - понимать, что именно мы тестируем, и почему.</p><p id="z9669ya_95">Тест - это не способ доказать, что всё работает. Это способ убедиться, что <span class="control" id="z9669ya_97">в заданных условиях</span> ничего не сломано. И если условия выбраны правильно - этого уже достаточно, чтобы тест выполнял свою работу честно.</p></section></section><section class="chapter"><h2 id="4-expect-actual" data-toc="4-expect-actual">4. Expect / Actual: Слова, которые всё говорят</h2><p id="z9669ya_98">Почти в каждом тесте есть одна и та же сцена: мы сравниваем то, что получилось, с тем, что мы ожидали. Чаще всего - через <code class="code" id="z9669ya_103">assertEquals(expected, actual)</code>, <code class="code" id="z9669ya_104">assertTrue(condition)</code>, <code class="code" id="z9669ya_105">assertFailsWith&lt;SomeException&gt;()</code> или их аналоги. И вроде бы всё очевидно: проверяем, что результат совпадает с ожиданием. Но даже в этих простых вызовах есть неочевидный момент.</p><section class="chapter"><h3 id="z9669ya_99" data-toc="z9669ya_99">Не просто сравнение, а утверждение</h3><p id="z9669ya_106">Когда мы вызываем <code class="code" id="z9669ya_108">assertEquals(expected, actual)</code>, мы не просто сверяем два значения. Мы делаем утверждение. Мы говорим: <span class="emphasis" id="z9669ya_109">если actual не совпадает с expected - значит, нарушен контракт</span>. Это не операция сравнения, это <span class="control" id="z9669ya_110">тест на согласие с нашей моделью</span>.</p><p id="z9669ya_107">Важно понимать: <code class="code" id="z9669ya_111">assert*</code> - это не отладка. Не исследование. Это декларация. Тест либо пройден, либо нет. Нет &laquo;почти&raquo;, нет &laquo;предупреждения&raquo;. И если условие не выполняется - не система сломалась, а <span class="control" id="z9669ya_112">наши ожидания не совпали с реальностью</span>.</p></section><section class="chapter"><h3 id="expected-actual" data-toc="expected-actual">Expected/Actual - порядок, который важен</h3><p id="z9669ya_113">Почти все assert-функции следуют одному и тому же порядку: сначала <code class="code" id="z9669ya_115">expected</code>, потом <code class="code" id="z9669ya_116">actual</code>. И это не случайность. Это отражение позиции: &laquo;мы считаем, что вот это - правильно, а теперь проверим, совпадает ли с тем, что вышло&raquo;. В этом смысле <code class="code" id="z9669ya_117">actual</code> - первичен. Он результат. Он - реальность. А <code class="code" id="z9669ya_118">expected</code> - это наша гипотеза.</p><p id="z9669ya_114">Если местами их перепутать, тест всё равно будет работать. Но смысл высказывания становится неявным. Падает читаемость. И, главное, исчезает ощущение, <span class="control" id="z9669ya_119">что именно</span> пошло не так: то ли мы ошиблись в модели, то ли код нарушил контракт.</p></section><section class="chapter"><h3 id="asserttrue-assertfalse" data-toc="asserttrue-assertfalse">assertTrue / assertFalse - примитив, но с той же логикой</h3><p id="z9669ya_120">Функции <code class="code" id="z9669ya_122">assertTrue</code> и <code class="code" id="z9669ya_123">assertFalse</code> не используют expected/actual явно, но логика та же: вы передаёте условие, которое считаете * <span class="emphasis" id="z9669ya_124">допустимым</span>*. Если оно ложно - тест не пройден. Значит, что-то пошло не так в коде, в контракте или в наших представлениях о корректности.</p><p id="z9669ya_121">По сути, каждая <code class="code" id="z9669ya_125">assert*</code> - это бинарный фильтр: либо да, либо нет. Это инструмент для фиксации допусков, а не для поиска ошибок. И чем яснее мы это осознаём - тем точнее пишем тесты.</p></section><section class="chapter"><h3 id="kotlin-native" data-toc="kotlin-native">Ключевые слова Kotlin Native? Не об этом речь</h3><p id="z9669ya_126">Да, в Kotlin Native действительно есть ключевые слова <code class="code" id="z9669ya_129">expect</code> и <code class="code" id="z9669ya_130">actual</code>. Они используются в механизме мультиплатформенности: <code class="code" id="z9669ya_131">expect</code> задаёт интерфейс, <code class="code" id="z9669ya_132">actual</code> - реализацию для конкретной платформы. Это может сбить с толку - особенно начинающих. Но в контексте тестирования мы говорим совсем о другом. Здесь <code class="code" id="z9669ya_133">expected</code> и <code class="code" id="z9669ya_134">actual</code> - это <span class="control" id="z9669ya_135">соглашение на уровне мышления</span>, а не синтаксиса. Это структура суждения: &quot;я ожидаю X, и вижу Y - совпали ли они?&quot;</p><p id="z9669ya_127">Если воспринимать тест как акт сверки - <code class="code" id="z9669ya_136">expected</code> и <code class="code" id="z9669ya_137">actual</code> не более чем параметры. Но если понимать, что тест - это <span class="control" id="z9669ya_138">артефакт соглашения</span>, то <code class="code" id="z9669ya_139">expected</code> - это наш манифест. А <code class="code" id="z9669ya_140">actual</code> - это отражение реальности. И когда они не совпадают, вопрос не в ошибке, а в расхождении между тем, что система делает, и тем, что мы от неё хотели.</p><p id="z9669ya_128">Писать тест - значит формализовать ожидания. А <code class="code" id="z9669ya_141">assertEquals(expected, actual)</code> - это не просто вызов функции. Это фраза. Она что-то утверждает. И если её читать именно как утверждение - структура начинает играть значение.</p></section></section><section class="chapter"><h2 id="5-test-doubles-mocks-stubs-fakes-spies-dummy" data-toc="5-test-doubles-mocks-stubs-fakes-spies-dummy">5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies, Dummy</h2><figure id="z9669ya_142"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles5.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles5.png" title="testing_philosophy_kotlin_expect_actual_test_doubles5.png" width="3000" height="800"></figure><p id="z9669ya_143">Когда мы говорим о Test Double, мы имеем в виду объекты, которые заменяют настоящие зависимости в тесте. Они позволяют запускать код в изоляции, без доступа к базе, сети, времени или другим внешним эффектам. Это делает тесты контролируемыми. Но важно понимать, что Double - это не просто &laquo;заглушка&raquo;. Это модель. И выбор модели влияет на то, <span class="emphasis" id="z9669ya_167">что именно</span> мы тестируем.</p><p id="z9669ya_144">Есть четыре основных типа Test Double, и у каждого - своя цель.</p><p id="z9669ya_145"><span class="control" id="z9669ya_168">Stub</span> - самый простой тестовый двойник. Он всегда возвращает заранее заданные значения и никак не реагирует на входные данные. Stub не проверяет, что ему передали, не логирует вызовы и не участвует в бизнес-логике - он просто стабилизирует поведение зависимости. Используется, когда зависимость нужна &laquo;для галочки&raquo;: достаточно вернуть нужное значение, чтобы тест мог продолжиться. Stub - это фон, а не часть сцены. Например, в тесте сервиса пользователей можно создать заглушку репозитория, которая всегда возвращает одного и того же пользователя, игнорируя запрошенный ID:</p><div class="code-block" data-lang="kotlin">
interface UserRepository {
    fun findById(id: String): User
}

class UserRepositoryStub : UserRepository {
    override fun findById(id: String): User {
        // Намеренно игнорируем id - Stub всегда возвращает одно и то же
        return User(id = &quot;stub-id&quot;, name = &quot;John Doe&quot;)
    }
}

// Использование в тесте
val stubRepo = UserRepositoryStub()
val service = UserService(stubRepo)
val user = service.getUser(&quot;123&quot;)
check(user.name == &quot;John Doe&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_147"><p id="z9669ya_169"><span class="control" id="z9669ya_170">В примере выше поведение Stub проявляется в том, что <code class="code" id="z9669ya_171">UserRepositoryStub</code> всегда возвращает один и тот же результат (<code class="code" id="z9669ya_172">John Doe</code>), независимо от входного параметра <code class="code" id="z9669ya_173">id</code>. Он не анализирует, что ему передали, и служит лишь для стабилизации окружения.</span></p></aside><p id="z9669ya_148"><span class="control" id="z9669ya_174">Mock</span> - объект, который фиксирует, как с ним взаимодействовали. Он запоминает, какие методы вызвали, с какими параметрами и сколько раз. Задача mock-объекта - не возвращать данные, а подтвердить, что код выполнил определённые действия. Mock используют там, где важно проверить, <span class="emphasis" id="z9669ya_175">как</span> происходило взаимодействие: был ли вызван логгер, ушло ли письмо, вызвался ли callback. Это объект-наблюдатель, с помощью которого тест проверяет поведение. Например, можно создать фальшивый логгер, который будет сохранять записанные сообщения вместо реального вывода, а затем убедиться в тесте, что нужный метод вызывался с ожидаемыми параметрами:</p><div class="code-block" data-lang="kotlin">
interface Logger {
    fun log(message: String)
}

class LoggerMock : Logger {
    val receivedMessages = mutableListOf&lt;String&gt;()

    override fun log(message: String) {
        receivedMessages.add(message)
    }
}

// Использование
val logger = LoggerMock()
val service = UserService(logger = logger)
service.createUser(&quot;Alice&quot;)
check(logger.receivedMessages.size == 1)
check(logger.receivedMessages.first() == &quot;User created&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_150"><p id="z9669ya_176"><span class="control" id="z9669ya_177">В примере выше поведение Mock проявляется в том, что <code class="code" id="z9669ya_178">LoggerMock</code> запоминает все вызовы метода <code class="code" id="z9669ya_179">log</code>. В тесте мы проверяем, что сообщение действительно было зафиксировано. Это и есть суть mock - не поведение, а проверка взаимодействия.</span></p></aside><p id="z9669ya_151"><span class="emphasis" id="z9669ya_180">Mock часто реализуют с помощью библиотек вроде Mockito или MockK, но здесь он показан вручную, чтобы разобрать суть концепции.</span></p><p id="z9669ya_152"><span class="control" id="z9669ya_181">Fake</span> - рабочая подделка. Это не имитация отдельных вызовов, а полноценная, но упрощённая реализация зависимости. Например, in-memory база данных или фейковый API, который хранит данные в памяти. Fake не просто &laquo;притворяется&raquo; - он действительно ведёт себя как настоящая система, только без использования реальных ресурсов. Его используют, когда нужна реальная логика взаимодействия, но не нужна тяжелая инфраструктура. Например, вместо обращения к настоящей базе данных можно использовать фейковый репозиторий, который хранит пользователей в памяти:</p><div class="code-block" data-lang="kotlin">
interface UserRepository {
    fun save(user: User)
    fun findById(id: String): User?
}

class FakeUserRepository : UserRepository {
    private val users = mutableMapOf&lt;String, User&gt;()

    override fun save(user: User) {
        users[user.id] = user
    }

    override fun findById(id: String): User? {
        return users[id]
    }
}

// Использование
val repo = FakeUserRepository()
repo.save(User(&quot;1&quot;, &quot;Alice&quot;))
val result = repo.findById(&quot;1&quot;)
check(result?.name == &quot;Alice&quot;)
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_154"><p id="z9669ya_182"><span class="control" id="z9669ya_183">В примере выше поведение Fake проявляется в том, что <code class="code" id="z9669ya_184">FakeUserRepository</code> действительно сохраняет и возвращает данные, как настоящий репозиторий, но без настоящей базы данных. Это полноценная логика - только in-memory.</span></p></aside><p id="z9669ya_155"><span class="control" id="z9669ya_185">Spy</span> - &laquo;двойной агент&raquo;. Он оборачивает реальный объект, но отслеживает, что с ним происходило. Spy не подменяет поведение (как mock) и не заменяет всю реализацию (как fake). Вместо этого он делегирует вызовы настоящему объекту и параллельно фиксирует обращения (например, считает вызовы или сохраняет параметры). Это компромисс между прозрачным поведением и возможностью анализировать взаимодействие. Например, можно обернуть реальный (или фейковый) репозиторий в класс-Spy, который будет делегировать вызовы базовому объекту и считать, сколько раз вызывался метод поиска пользователя:</p><div class="code-block" data-lang="kotlin">
class UserRepositorySpy(private val realRepo: UserRepository) : UserRepository {
    var findByIdCallCount = 0
    val capturedIds = mutableListOf&lt;String&gt;()

    override fun save(user: User) {
        realRepo.save(user)
    }

    override fun findById(id: String): User? {
        findByIdCallCount++
        capturedIds.add(id)
        return realRepo.findById(id)
    }
}

// Использование
val realRepo = FakeUserRepository()
realRepo.save(User(&quot;1&quot;, &quot;Bob&quot;))
val spy = UserRepositorySpy(realRepo)
val user = spy.findById(&quot;1&quot;)
check(user?.name == &quot;Bob&quot;)
check(spy.findByIdCallCount == 1)
check(spy.capturedIds.contains(&quot;1&quot;))
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_157"><p id="z9669ya_186"><span class="control" id="z9669ya_187">В примере выше поведение Spy проявляется в том, что <code class="code" id="z9669ya_188">UserRepositorySpy</code> делегирует вызовы <code class="code" id="z9669ya_189">realRepo</code>, но при этом фиксирует: сколько раз вызывался метод <code class="code" id="z9669ya_190">findById</code>, какие значения передавались.</span></p></aside><p id="z9669ya_158"><span class="emphasis" id="z9669ya_191">Spy полезен там, где поведение важно сохранить, но при этом нужно наблюдать за взаимодействиями. Мы видим как &quot;что вызвали&quot;, так и &quot;что реально произошло&quot;.</span></p><p id="z9669ya_159"><span class="control" id="z9669ya_192">Dummy</span> - &laquo;молчаливый статист&raquo;. Он существует только потому, что <span class="control" id="z9669ya_193">метод требует аргумента</span>, но сам по себе <span class="control" id="z9669ya_194">в тесте не используется</span>. Dummy не выполняет действий, не хранит состояния и не участвует в логике &mdash; его задача одна: <span class="emphasis" id="z9669ya_195">быть на месте, где требуется объект</span>. Это самый простой и безопасный тип Test Double, позволяющий явно показать: &laquo;этот параметр здесь не важен&raquo;.</p><p id="z9669ya_160">Например, если метод требует <code class="code" id="z9669ya_196">Logger</code>, но логирование в тесте не играет роли, можно передать dummy-реализацию:</p><div class="code-block" data-lang="kotlin">
class DummyLogger : Logger {
    override fun info(message: String) = Unit
    override fun error(message: String, throwable: Throwable?) = Unit
}

// Использование
val logger = DummyLogger()
val service = UserService(logger) // здесь логер не используется
val result = service.doSomething()
check(result == ExpectedResult)
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_162"><p id="z9669ya_197"><span class="control" id="z9669ya_198">В примере выше <code class="code" id="z9669ya_201">DummyLogger</code> никак не влияет на результат <code class="code" id="z9669ya_202">doSomething()</code>.</span> Он передаётся только потому, что <code class="code" id="z9669ya_199">UserService</code> требует <code class="code" id="z9669ya_200">Logger</code> в конструкторе.</p></aside><p id="z9669ya_163"><span class="emphasis" id="z9669ya_203">Dummy полезен там, где важна только сигнатура, а не смысл. Он делает зависимости явными, но без побочных эффектов или логики. Это форма честной заглушки, мы прямо говорим: &laquo;этот объект не играет роли, просто позвольте тесту выполниться&raquo;.</span></p><p id="z9669ya_164">Иногда выбор типа Double кажется техническим: что проще заиспользовать, что быстрее написать. Но на самом деле он отражает <span class="control" id="z9669ya_204">подход к архитектуре</span>. Если мы используем stub - мы говорим: эта зависимость не важна. Если fake - мы признаём, что логика важна, но инфраструктура - нет. Если mock - мы хотим проконтролировать, как именно система взаимодействует. Spy - мы хотим знать детали, но не мешать процессу.</p><p id="z9669ya_165">Это выбор: <span class="control" id="z9669ya_205">моделировать поведение или структуру</span>. Проверять результат или отслеживать путь. Упростить окружение или сохранить его поведение. И когда Double выбран неправильно - тест может быть зелёным, но бессмысленным.</p><p id="z9669ya_166">Поэтому вопрос не в том, <span class="emphasis" id="z9669ya_206">какой</span> Double использовать, а в том, <span class="emphasis" id="z9669ya_207">что именно мы хотим зафиксировать в этом тесте</span>.</p></section><section class="chapter"><h2 id="6-unit-vs-junit" data-toc="6-unit-vs-junit">6. Unit vs JUnit: Что действительно стоит за словами</h2><p id="z9669ya_208">Слово <span class="control" id="z9669ya_216">unit</span> в программировании означает <span class="emphasis" id="z9669ya_217">единицу поведения</span> минимальный фрагмент системы, который можно протестировать изолированно. Это может быть функция, метод, модуль или класс. Главное он должен быть <span class="control" id="z9669ya_218">самодостаточным</span>: то есть его поведение можно проверить без запуска всей системы.</p><p id="z9669ya_209">Тест такого фрагмента называют <span class="control" id="z9669ya_219">unit-тестом</span> он фокусируется не на всей программе, а на её <span class="control" id="z9669ya_220">наименьшей значимой части</span>, изолируя внешние зависимости (через stub, mock, fake и т. д.).</p><aside class="prompt" data-type="tip" data-title="" id="z9669ya_210"><p id="z9669ya_221">Unit = Единица (поведения) , Unit Test = Проверка этой единицы , JUnit = Java Unit Testing Framework</p></aside><p id="z9669ya_211"><span class="control" id="z9669ya_222">JUnit</span> это инструмент, изначально созданный для того, чтобы <span class="control" id="z9669ya_223">писать и запускать unit-тесты на Java</span>. Название это сокращение от <span class="emphasis" id="z9669ya_224">Java + Unit</span>. Но за 20 лет JUnit стал не просто библиотекой, а полноценной <span class="control" id="z9669ya_225">тестовой платформой</span>, которую можно использовать для чего угодно: от простейших проверок до интеграционных и property-based тестов.</p><p id="z9669ya_212">Чтобы понимать, как писать хорошие тесты, важно разобраться не только в коде, но и в истории: как JUnit развивался, и какие идеи он принёс.</p><section class="chapter"><h3 id="junit-dsl" data-toc="junit-dsl">История JUnit: от процедур до DSL</h3><p id="z9669ya_226"><span class="control" id="z9669ya_238">JUnit 3</span> появился в начале 2000-х. Это был процедурный фреймворк, построенный на соглашениях, а не на аннотациях или конфигурациях. Чтобы метод считался тестом, он должен был начинаться с <code class="code" id="z9669ya_239">test</code>, а класс расширять <code class="code" id="z9669ya_240">TestCase</code>. Всё наследовалось напрямую, никакой инверсии, никакой метаинформации.</p><div class="code-block" data-lang="java">
public class UserServiceTest extends TestCase {
    public void testUserIsCreated() {
        UserService service = new UserService();
        User user = service.create(&quot;Alice&quot;);
        assertEquals(&quot;Alice&quot;, user.getName());
    }
}
</div><p id="z9669ya_228">Никакой магии. JUnit по имени искал методы, начинал их выполнять и сигнализировал о падениях через <code class="code" id="z9669ya_241">AssertionFailedError</code> или исключения. Всё держалось на соглашениях и строгом порядке.</p><p id="z9669ya_229"><span class="control" id="z9669ya_242">JUnit 4</span> стал поворотной точкой. Он избавился от необходимости наследования <code class="code" id="z9669ya_243">TestCase</code> и перешёл к декларативному стилю на базе аннотаций. Метод помечался <code class="code" id="z9669ya_244">@Test</code>, и это было достаточно, чтобы фреймворк понял перед ним тест.</p><div class="code-block" data-lang="kotlin">
class UserServiceTest {

    @Test
    fun userIsCreated() {
        val service = UserService()
        val user = service.create(&quot;Alice&quot;)
        assertEquals(&quot;Alice&quot;, user.name)
    }
}
</div><p id="z9669ya_231">Появились <code class="code" id="z9669ya_245">@Before</code>, <code class="code" id="z9669ya_246">@After</code>, <code class="code" id="z9669ya_247">@Ignore</code>, а также возможность писать кастомные раннеры. Но при всём этом JUnit 4 оставался процедурным. Каждый тест по сути обычная функция, просто обёрнутая инфраструктурой.</p><p id="z9669ya_232"><span class="control" id="z9669ya_248">JUnit 5</span> уже не фреймворк, а <span class="control" id="z9669ya_249">платформа</span>. Он разделён на три части: <code class="code" id="z9669ya_250">Platform</code>, <code class="code" id="z9669ya_251">Jupiter</code> и <code class="code" id="z9669ya_252">Vintage</code>.</p><p id="z9669ya_233"><code class="code" id="z9669ya_253">JUnit Platform</code> это базовый механизм обнаружения и запуска тестов. Он взаимодействует с Gradle, Maven, IDE и CI-системами. Через него тесты регистрируются, исполняются и репортуются. Это слой интеграции, а не логики. <code class="code" id="z9669ya_254">JUnit Jupiter</code> это современный API и тестовый движок. Он поддерживает всё, что появилось в JUnit 5: вложенные тестовые классы (<code class="code" id="z9669ya_255">@Nested</code>), настраиваемые названия (<code class="code" id="z9669ya_256">@DisplayName</code>), параметризованные и динамические тесты (<code class="code" id="z9669ya_257">@ParameterizedTest</code>, <code class="code" id="z9669ya_258">@TestFactory</code>). Jupiter делает тесты декларативными и выразительными, приближая их к DSL. <code class="code" id="z9669ya_259">JUnit Vintage</code> это адаптер. Он позволяет запускать старые тесты, написанные на JUnit 3 и 4, внутри новой платформы. Благодаря Vintage проекты могут мигрировать постепенно, без полного переписывания.</p><p id="z9669ya_234">Синтаксис стал выразительным. Теперь тесты можно строить как декларации поведения, использовать параметры, вводить структуры.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@ValueSource(strings = [&quot;admin&quot;, &quot;user&quot;, &quot;guest&quot;])
fun `roles should not be empty`(role: String) {
    val system = RoleService()
    val permissions = system.getPermissions(role)
    assertTrue(permissions.isNotEmpty())
}
</div><p id="z9669ya_236">JUnit 5 перестал быть &quot;юнит&quot;-фреймворком в узком смысле. Он стал каркасом для любых тестов: юнитов, интеграций, property-based подхода, контрактных проверок. Всё, что можно выразить в виде исполняемого DSL с проверками теперь помещается внутрь.</p><p id="z9669ya_237">JUnit не только принял декларативность, но и сам стал частью архитектурного мышления. И теперь, говоря <code class="code" id="z9669ya_260">@Test</code>, мы запускаем не просто метод мы инициируем часть тестового пайплайна, где поведение фиксируется как артефакт.</p></section><section class="chapter"><h3 id="ci" data-toc="ci">Почему это важно в CI</h3><p id="z9669ya_261">JUnit-интеграции в IDE, Gradle, Maven, Bazel и CI-системы (например, GitHub Actions) ожидают строго определённую структуру: <code class="code" id="z9669ya_262">@Test</code>-методы автоматически индексируются, изолируются и репортятся. Без этой аннотации метод просто функция, недоступная для раннера.</p></section><section class="chapter"><h3 id="junit-5" data-toc="junit-5">Знакомство с основами JUnit 5</h3><figure id="z9669ya_263"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles4.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles4.png" title="testing_philosophy_kotlin_expect_actual_test_doubles4.png" width="982" height="300"></figure><p id="z9669ya_264">Если в JUnit 4 аннотации были просто флажками, то в JUnit 5 они стали формализованными элементами контракта. Через них описывается жизненный цикл, поведение, параметры и точки интеграции тестов. Ниже минимально необходимый набор аннотаций, чтобы уверенно ориентироваться в Jupiter.</p><p id="z9669ya_265"><code class="code" id="z9669ya_299">@Test</code> Это главная точка входа. Без неё метод просто функция. С ней полноценный тест, который JUnit включит в жизненный цикл: вызовет <code class="code" id="z9669ya_300">@BeforeEach</code>, сам тест, <code class="code" id="z9669ya_301">@AfterEach</code>, соберёт результат и отобразит в отчёте.</p><p id="z9669ya_266">Метод с <code class="code" id="z9669ya_302">@Test</code> должен быть открытым (<code class="code" id="z9669ya_303">public</code>), без параметров, без возвращаемого значения (<code class="code" id="z9669ya_304">Unit</code>) и не <code class="code" id="z9669ya_305">static</code> (в Java) или <code class="code" id="z9669ya_306">companion</code> (в Kotlin). Если тест бросает исключение он считается проваленным. Если нет прошёл успешно.</p><div class="code-block" data-lang="kotlin">
@Test
fun `user is created`() {
    val service = UserService()
    val user = service.create(&quot;Alice&quot;)
    assertEquals(&quot;Alice&quot;, user.name)
}
</div><p id="z9669ya_268">JUnit вызывает этот метод как автономную единицу отдельно от других, в новом инстансе класса (если не указано иначе). Это часть контракта: тест не должен зависеть от других тестов и делиться с ними состоянием.</p><p id="z9669ya_269"><code class="code" id="z9669ya_307">@BeforeEach</code>/<code class="code" id="z9669ya_308">@AfterEach</code> Вызываются перед и после каждого <code class="code" id="z9669ya_309">@Test</code>. Используются для настройки окружения и его очистки: создание файлов, сброс состояний, закрытие ресурсов. Каждый тест запускается на новом экземпляре класса, так что состояния между методами не сохраняются.</p><div class="code-block" data-lang="kotlin">
@BeforeEach
fun setUp() {
    initDatabase()
}

@AfterEach
fun tearDown() {
    cleanupTempFiles()
}
</div><p id="z9669ya_271"><code class="code" id="z9669ya_310">@BeforeAll</code>/<code class="code" id="z9669ya_311">@AfterAll</code> Запускаются один раз до и после всех тестов в классе. Используются для тяжёлой инициализации (например, поднятие embedded Redis, Kafka, Docker-контейнеров). В Kotlin требуют <code class="code" id="z9669ya_312">@TestInstance(PER_CLASS)</code>.</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@BeforeAll
fun initSuite() {
    EmbeddedRedis.start()
}
</div><p id="z9669ya_273"><code class="code" id="z9669ya_313">@TestInstance(...)</code> Определяет, как JUnit создаёт экземпляры тестового класса.</p><p id="z9669ya_274">По умолчанию используется <code class="code" id="z9669ya_314">PER_METHOD</code>, при котором <span class="control" id="z9669ya_315">для каждого метода с <code class="code" id="z9669ya_316">@Test</code> создаётся отдельный объект</span>. Это обеспечивает изоляцию между тестами, но не позволяет сохранять общее состояние между ними.</p><p id="z9669ya_275">Если указать <code class="code" id="z9669ya_317">PER_CLASS</code>, то <span class="control" id="z9669ya_318">один объект создаётся на весь класс</span>. Это позволяет использовать <code class="code" id="z9669ya_319">@BeforeAll</code> и <code class="code" id="z9669ya_320">@AfterAll</code> как обычные методы (не в <code class="code" id="z9669ya_321">companion object</code>), а также делиться состоянием между тестами.</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ConfiguredTestLifecycle {

    private var counter = 0

    @BeforeAll
    fun initOnce() {
        counter = 10
    }

    @Test
    fun testA() {
        assert(counter &gt;= 10)
    }

    @Test
    fun testB() {
        counter++ // состояние сохраняется между тестами
    }
}
</div><p id="z9669ya_277">Такой подход используют, когда инициализация тяжёлая или состояние нужно сохранить между тестами. Но в большинстве случаев <code class="code" id="z9669ya_322">PER_METHOD</code> безопаснее.</p><p id="z9669ya_278"><code class="code" id="z9669ya_323">@DisplayName</code> Позволяет задать читаемое название теста. Отображается в IDE и CI, особенно полезно в параметризованных или BDD-ориентированных тестах. Работает и на методах, и на классах.</p><div class="code-block" data-lang="kotlin">
@DisplayName(&quot;Пользователь с ролью admin получает все доступы&quot;)
@Test
fun adminGetsAllPermissions() {
    ...
}
</div><p id="z9669ya_280"><code class="code" id="z9669ya_324">@Disabled</code> Пропускает тест. Используется для временного отключения (например, нестабильный код, баг в зависимости). В отчётах видно, что тест отключён.</p><div class="code-block" data-lang="kotlin">
@Disabled(&quot;Отключён до фикса external API&quot;)
@Test
fun flakyIntegrationTest() {
    ...
}
</div><p id="z9669ya_282"><code class="code" id="z9669ya_325">@Nested</code> Позволяет структурировать тесты в иерархии с вложенными контекстами. Применяется только к <code class="code" id="z9669ya_326">inner class</code>, иначе инстанс не создаётся. Удобен для Given/When/Then-структур.</p><div class="code-block" data-lang="kotlin">
@Nested
inner class WhenUserIsGuest {
    @Test
    fun `should not access admin panel`() {
        ...
    }
}
</div><p id="z9669ya_284"><code class="code" id="z9669ya_327">@ParameterizedTest</code> Запускает один и тот же метод несколько раз с разными параметрами. Требует указания источника данных через <code class="code" id="z9669ya_328">@ValueSource</code>, <code class="code" id="z9669ya_329">@CsvSource</code>, <code class="code" id="z9669ya_330">@EnumSource</code> и др. Метод должен принимать аргументы.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@ValueSource(strings = [&quot;admin&quot;, &quot;user&quot;, &quot;guest&quot;])
fun testRoles(role: String) {
    assertTrue(role.isNotBlank())
}
</div><p id="z9669ya_286"><code class="code" id="z9669ya_331">@ValueSource</code>, <code class="code" id="z9669ya_332">@CsvSource</code>, <code class="code" id="z9669ya_333">@EnumSource</code>, <code class="code" id="z9669ya_334">@MethodSource</code>, <code class="code" id="z9669ya_335">@ArgumentsSource</code> Аннотации для генерации данных в параметризованных тестах. <code class="code" id="z9669ya_336">@ValueSource</code> для простых значений. <code class="code" id="z9669ya_337">@CsvSource</code> для табличных данных. <code class="code" id="z9669ya_338">@MethodSource</code> ссылка на метод, возвращающий <code class="code" id="z9669ya_339">Stream&lt;Arguments&gt;</code>. <code class="code" id="z9669ya_340">@EnumSource</code> прокидывает значения enum. <code class="code" id="z9669ya_341">@ArgumentsSource</code> настраиваемый источник данных.</p><div class="code-block" data-lang="kotlin">
@ParameterizedTest
@CsvSource(&quot;admin, true&quot;, &quot;guest, false&quot;)
fun rolePermissionTest(role: String, allowed: Boolean) {
    assertEquals(allowed, checkAccess(role))
}
</div><p id="z9669ya_288"><code class="code" id="z9669ya_342">@RepeatedTest</code> Запускает один и тот же тест несколько раз. Удобен для проверки нестабильных сценариев: флаки, гонки, недетерминированные вычисления. Метод может принимать <code class="code" id="z9669ya_343">RepetitionInfo</code>.</p><div class="code-block" data-lang="kotlin">
@RepeatedTest(3)
fun unstableTest() {
    assertTrue(runComputation().isSuccessful)
}
</div><p id="z9669ya_290"><code class="code" id="z9669ya_344">@Timeout</code> Завершает тест с ошибкой, если он выполняется дольше заданного времени. Применяется на метод и на весь класс. Полезен для защиты от зависаний.</p><div class="code-block" data-lang="kotlin">
@Timeout(5)
@Test
fun longRunningProcessCompletes() {
    performHeavyOperation()
}
</div><p id="z9669ya_292"><code class="code" id="z9669ya_345">@Tag</code> Добавляет произвольные метки тестам. Используются в CI/CD для фильтрации: можно запускать только тесты с нужным тегом (<code class="code" id="z9669ya_346">@Tag(&quot;slow&quot;)</code>, <code class="code" id="z9669ya_347">@Tag(&quot;ci&quot;)</code>).</p><div class="code-block" data-lang="kotlin">
@Tag(&quot;integration&quot;)
@Test
fun savesToDatabase() {
    saveToDb()
}
</div><p id="z9669ya_294"><code class="code" id="z9669ya_348">@ExtendWith(...)</code> Подключает расширения (Mockito, Spring, Testcontainers, кастомные хуки). Extension-интерфейсы могут внедрять зависимости, слушать события, управлять окружением.</p><div class="code-block" data-lang="kotlin">
@ExtendWith(SpringExtension::class)
class UserServiceSpringTest { ... }
</div><p id="z9669ya_296"><code class="code" id="z9669ya_349">@TestFactory</code> Позволяет генерировать тесты динамически во время выполнения. Метод должен возвращать <code class="code" id="z9669ya_350">Collection&lt;DynamicTest&gt;</code> или <code class="code" id="z9669ya_351">Stream&lt;DynamicTest&gt;</code>. Применяется при неизвестном числе кейсов (например, из JSON-файла).</p><div class="code-block" data-lang="kotlin">
@TestFactory
fun dynamicTestsFromFile(): List&lt;DynamicTest&gt; {
    return File(&quot;cases.txt&quot;).readLines().map { line -&gt;
        dynamicTest(&quot;Case: $line&quot;) {
            check(line.isNotBlank())
        }
    }
}
</div><p id="z9669ya_298">В статье не будет практического примера по использованию аннотаций для этого существует официальная документация: <a href="https://docs.junit.org/current/user-guide/" id="z9669ya_352" data-external="true" rel="noopener noreferrer" target="_blank">Junit 5 Documentation</a>, которая очень подробно описывает возможности и использование JUnit 5.</p></section></section><section class="chapter"><h2 id="junit-5-test" data-toc="junit-5-test">Как JUnit 5 запускает ваш @Test: от команды до метода</h2><p id="z9669ya_353">Когда вы нажимаете &quot;Run&quot; в IDE или запускаете <code class="code" id="z9669ya_367">./gradlew test</code>, за этим простым действием скрывается сложная многоуровневая архитектура. Давайте проследим весь путь выполнения теста от команды в терминале до вызова вашего метода, помеченного <code class="code" id="z9669ya_368">@Test</code>.</p><section class="chapter"><h3 id="z9669ya_354" data-toc="z9669ya_354">Рабочий пример для демонстрации</h3><p id="z9669ya_369">Возьмем что-то практичное загрузчик изображений. Код простой, но вполне рабочий:</p><div class="code-block" data-lang="kotlin">
class ImageDownloader {
    fun downloadImage(url: String): ByteArray {
        val inputStream = URI(url).toURL().openStream()
        return inputStream.use { it.readAllBytes() }
    }
}
</div><p id="z9669ya_371">Далее тест для <code class="code" id="z9669ya_378">ImageDownloader</code> с использованием JUnit 5:</p><div class="code-block" data-lang="kotlin">
@TestInstance(TestInstance.Lifecycle.PER_METHOD)
@DisplayName(&quot;Загрузка изображения и сохранение в файл&quot;)
class ImageDownloaderTest {

    private lateinit var tempFile: File
    private lateinit var outputStream: FileOutputStream

    private val imageUrl = &quot;https://i.postimg.cc/26h8JBpH/QYbec-Thl-Qy7mcx-ZBYp-C0m-BDp16no-Mt-R5vwe-St-Wmv-large.jpg&quot;

    @BeforeEach
    fun setUp() {
        tempFile = File(&quot;image-test.jpg&quot;)
        outputStream = FileOutputStream(tempFile, true)
    }

    @Test
    @DisplayName(&quot;Изображение должно быть скачано и записано в файл&quot;)
    fun `downloaded image is saved to file`() {
        val downloader = ImageDownloader()
        val bytes = downloader.downloadImage(imageUrl)

        requireNotNull(bytes) { &quot;Скачанные данные не должны быть null&quot; }

        outputStream.write(bytes)
        outputStream.flush()

        assertTrue(tempFile.length() &gt; 0, &quot;Файл после загрузки не должен быть пустым&quot;)
    }

    @AfterEach
    fun tearDown() {
        outputStream.close()
        tempFile.delete()
    }
}
</div><p id="z9669ya_373">Тест довольно straightforward: есть один метод <code class="code" id="z9669ya_379">downloaded image is saved to file</code>, который скачивает изображение и проверяет, что файл действительно создался и не пустой. В <code class="code" id="z9669ya_380">setUp</code> готовим временный файл и поток, в <code class="code" id="z9669ya_381">tearDown</code> всё убираем за собой. <code class="code" id="z9669ya_382">@DisplayName</code> нужен для читаемых названий в отчетах вместо технических имен методов увидим осмысленные описания. <figure id="z9669ya_383"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles1.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles1.png" title="testing_philosophy_kotlin_expect_actual_test_doubles1.png" width="2824" height="830"></figure><figure id="z9669ya_384"><img alt="testing_philosophy_kotlin_expect_actual_test_doubles2.png" src="images/testing_philosophy_kotlin_expect_actual_test_doubles2.png" title="testing_philosophy_kotlin_expect_actual_test_doubles2.png" width="2824" height="818"></figure> Теперь запустим тест через Gradle:</p><div class="code-block" data-lang="bash">
./gradlew :test --tests &quot;test.ImageDownloaderTest&quot;
</div><p id="z9669ya_375">Эта команда сработает, если в <code class="code" id="z9669ya_385">build.gradle</code> настроена задача test:</p><div class="code-block" data-lang="kotlin">
tasks.test {
    useJUnitPlatform()
}
</div><p id="z9669ya_377">И вот здесь начинается интересное за кулисами запускается целая цепочка вызовов, которая проходит через несколько архитектурных слоев.</p></section><section class="chapter"><h3 id="1-gradle-junit-platform" data-toc="1-gradle-junit-platform">Этап 1: Gradle настраивает JUnit Platform</h3><p id="z9669ya_386">Вызов <code class="code" id="z9669ya_392">useJUnitPlatform()</code> в Gradle это не просто конфигурационная строчка. Под капотом происходит следующее:</p><div class="code-block" data-lang="java">
public void useJUnitPlatform() {
    useTestFramework(new JUnitPlatformTestFramework((DefaultTestFilter) getFilter(), true, getDryRun()));
}
</div><p id="z9669ya_388">Gradle создает экземпляр <code class="code" id="z9669ya_393">JUnitPlatformTestFramework</code>, который реализует интерфейс <code class="code" id="z9669ya_394">TestFramework</code>. Этот объект станет мостом между Gradle и JUnit Platform он знает, как найти тесты, как их запустить и как получить результаты.</p><p id="z9669ya_389">Интересный факт: несмотря на то, что Kotlin набирает популярность, и наш тест написан на нем, исходники JUnit по-прежнему остаются верными букве &quot;J&quot; в названии, то есть на Java. Аннотация <code class="code" id="z9669ya_395">@Test</code> выглядит так:</p><div class="code-block" data-lang="java">

@Target({ElementType.ANNOTATION_TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@API(status = STABLE, since = &quot;5.0&quot;)
@Testable
public @interface Test {
}
</div><p id="z9669ya_391">Документация к аннотации гласит: &quot; <code class="code" id="z9669ya_396">@Test</code> используется для обозначения тестового метода. Методы с <code class="code" id="z9669ya_397">@Test</code> не должны быть <code class="code" id="z9669ya_398">private</code> или<code class="code" id="z9669ya_399">static</code> и не должны возвращать значение&quot;. Простые правила, но за ними стоит продуманная архитектура.</p></section><section class="chapter"><h3 id="2" data-toc="2">Этап 2: Создание фабрики процессоров тестов</h3><p id="z9669ya_400">Когда Gradle готов запускать тесты, он обращается к нашему <code class="code" id="z9669ya_405">JUnitPlatformTestFramework</code> за фабрикой процессоров:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestFramework implements TestFramework {
    @Override
    public WorkerTestClassProcessorFactory getProcessorFactory() {
        return new JUnitPlatformTestClassProcessorFactory(new JUnitPlatformSpec(...));
    }
}
</div><p id="z9669ya_402">Эта фабрика умеет создавать процессоры тестовых классов объекты, которые знают, как обрабатывать отдельные тестовые классы. Когда приходит время, фабрика создает <code class="code" id="z9669ya_406">JUnitPlatformTestClassProcessor</code>:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessorFactory implements WorkerTestClassProcessorFactory {
    @Override
    public WorkerTestClassProcessor create(...,JUnitPlatformSpec spec) {
        return new JUnitPlatformTestClassProcessor(spec, ...);
    }
}
</div><p id="z9669ya_404"><code class="code" id="z9669ya_407">JUnitPlatformTestClassProcessor</code> наследуется от <code class="code" id="z9669ya_408">AbstractJUnitTestClassProcessor</code> и реализует интерфейс <code class="code" id="z9669ya_409">TestClassProcessor</code>. Это ключевой компонент именно он будет координировать выполнение наших тестов.</p></section><section class="chapter"><h3 id="3-testworker" data-toc="3-testworker">Этап 3: TestWorker начинает обработку</h3><p id="z9669ya_410">Внутри Gradle работает <code class="code" id="z9669ya_416">TestWorker</code> компонент, который управляет жизненным циклом выполнения тестов.</p><div class="code-block" data-lang="java">
package org.gradle.api.internal.tasks.testing.worker;

public class TestWorker implements Action&lt;WorkerProcessContext&gt;, RemoteTestClassProcessor, Serializable, Stoppable {

    private TestClassProcessor processor;

    @Override
    public void processTestClass(final TestClassRunInfo testClass) {
        ...
        processor.processTestClass(testClass);
        ...
    }

    @Override
    public void startProcessing() {         
        ...
        processor.startProcessing(resultProcessor);
    }
}

</div><p id="z9669ya_412">TestWorker вызывает два ключевых метода процессора:</p><div class="code-block" data-lang="java">
public abstract class AbstractJUnitTestClassProcessor implements TestClassProcessor {

    private Action&lt;String&gt; executor;

    @Override
    public void startProcessing(TestResultProcessor resultProcessor) {
        TestResultProcessor resultProcessorChain = createResultProcessorChain(resultProcessor);
        resultProcessorActor = actorFactory.createBlockingActor(resultProcessorChain);
        executor = createTestExecutor(resultProcessorActor);
    }

    @Override
    public void processTestClass(TestClassRunInfo testClass) {
        LOGGER.debug(&quot;Executing test class {}&quot;, testClass.getTestClassName());
        executor.execute(testClass.getTestClassName());
    }
}
</div><p id="z9669ya_414">На этапе <code class="code" id="z9669ya_417">startProcessing</code> создается цепочка обработчиков результатов и actor для потокобезопасной работы с ними. Actor это паттерн, который гарантирует, что все операции с результатами тестов будут выполняться последовательно, даже если тесты запускаются в нескольких потоках.</p><p id="z9669ya_415">Метод <code class="code" id="z9669ya_418">processTestClass</code> получает информацию о тестовом классе и передает его имя executor'у для выполнения. Но тут есть подвох тесты еще не запускаются!</p></section><section class="chapter"><h3 id="4" data-toc="4">Этап 4: Накопление классов перед запуском</h3><p id="z9669ya_419">В <code class="code" id="z9669ya_425">JUnitPlatformTestClassProcessor</code> используется интересная стратегия сначала собрать все тестовые классы, а потом запустить их разом:</p><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessor extends AbstractJUnitTestClassProcessor {

    @Override
    protected Action&lt;String&gt; createTestExecutor(Actor resultProcessorActor) {
        TestResultProcessor threadSafeResultProcessor = resultProcessorActor.getProxy(TestResultProcessor.class);
        launcherSession = BackwardsCompatibleLauncherSession.open();
        junitClassLoader = Thread.currentThread().getContextClassLoader();
        testClassExecutor = new CollectAllTestClassesExecutor(threadSafeResultProcessor);
        return testClassExecutor;
    }

    @Override
    public void stop() {
        testClassExecutor.processAllTestClasses();
        launcherSession.close();
        super.stop();
    }
}
</div><p id="z9669ya_421"><code class="code" id="z9669ya_426">CollectAllTestClassesExecutor</code> это внутренний класс, который просто накапливает имена тестовых классов:</p><div class="code-block" data-lang="java">
private class CollectAllTestClassesExecutor implements Action&lt;String&gt; {
    private final List&lt;Class&lt;?&gt;&gt; testClasses = new ArrayList&lt;&gt;();

    @Override
    public void execute(@Nonnull String testClassName) {
        Class&lt;?&gt; klass = loadClass(testClassName);
        testClasses.add(klass);
    }

    void processAllTestClasses() {
        LauncherDiscoveryRequest discoveryRequest = createLauncherDiscoveryRequest(testClasses);
        TestExecutionListener executionListener = new JUnitPlatformTestExecutionListener(...);
        Launcher launcher = launcherSession.getLauncher();
        launcher.execute(discoveryRequest, executionListener);
    }
}
</div><p id="z9669ya_423">Такой подход позволяет JUnit Platform получить полную картину всех тестов перед началом выполнения. Это важно для планирования выполнения, распределения по потокам и создания правильной структуры отчетов.</p><p id="z9669ya_424">Реальный запуск происходит только когда Gradle вызывает <code class="code" id="z9669ya_427">stop()</code> на процессоре, что приводит к вызову <code class="code" id="z9669ya_428">processAllTestClasses()</code>.</p></section><section class="chapter"><h3 id="5-launcher" data-toc="5-launcher">Этап 5: Launcher берет управление на себя</h3><p id="z9669ya_429">Когда все классы собраны, создается <code class="code" id="z9669ya_434">LauncherDiscoveryRequest</code> объект, который описывает, какие тесты нужно найти и выполнить. Затем получается экземпляр <code class="code" id="z9669ya_435">Launcher</code> из сессии и запускается выполнение:</p><div class="code-block" data-lang="java">
Launcher launcher = launcherSession.getLauncher();
launcher.

execute(discoveryRequest, executionListener);
</div><p id="z9669ya_431"><code class="code" id="z9669ya_436">Launcher</code> это центральная точка входа в JUnit Platform. Его реализация <code class="code" id="z9669ya_437">DefaultLauncher</code> выглядит довольно просто:</p><div class="code-block" data-lang="java">
public class DefaultLauncher implements Launcher {

    private final EngineExecutionOrchestrator executionOrchestrator = new EngineExecutionOrchestrator(...);

    @Override
    public void execute(TestPlan testPlan, TestExecutionListener... listeners) {
        execute((InternalTestPlan) testPlan, listeners);
    }

    private void execute(InternalTestPlan internalTestPlan, TestExecutionListener[] listeners) {
        executionOrchestrator.execute(internalTestPlan, listeners);
    }
}
</div><p id="z9669ya_433">Основная работа делегируется в <code class="code" id="z9669ya_438">EngineExecutionOrchestrator</code> оркестратор выполнения движков тестов.</p></section><section class="chapter"><h3 id="6" data-toc="6">Этап 6: Оркестратор запускает движки тестов</h3><p id="z9669ya_439">JUnit Platform построена по модульному принципу разные типы тестов могут выполняться разными движками (engines). Для JUnit 5 это <code class="code" id="z9669ya_443">JupiterTestEngine</code>, для JUnit 4 <code class="code" id="z9669ya_444">VintageTestEngine</code>, есть движки для TestNG и других фреймворков.</p><div class="code-block" data-lang="java">
public class EngineExecutionOrchestrator {

    public void execute(LauncherDiscoveryResult discoveryResult, EngineExecutionListener engineExecutionListener) {
        for (TestEngine testEngine : discoveryResult.getTestEngines()) {
            TestDescriptor engineDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
            testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
        }
    }
}
</div><p id="z9669ya_441">Для каждого найденного движка создается <code class="code" id="z9669ya_445">ExecutionRequest</code> с описанием тестов, которые этот движок должен выполнить, и вызывается <code class="code" id="z9669ya_446">execute()</code>.</p><p id="z9669ya_442">В нашем случае будет использоваться <code class="code" id="z9669ya_447">JupiterTestEngine</code> движок для JUnit Jupiter (официальное название JUnit 5).</p></section><section class="chapter"><h3 id="7-jupitertestengine" data-toc="7-jupitertestengine">Этап 7: JupiterTestEngine организует иерархическое выполнение</h3><p id="z9669ya_448"><code class="code" id="z9669ya_452">JupiterTestEngine</code> наследуется от <code class="code" id="z9669ya_453">HierarchicalTestEngine</code> базового класса для движков, которые работают с иерархической структурой тестов:</p><div class="code-block" data-lang="java">
public final class JupiterTestEngine extends HierarchicalTestEngine&lt;JupiterEngineExecutionContext&gt; {

    @Override
    public void execute(ExecutionRequest request) {
        try (HierarchicalTestExecutorService executorService = createExecutorService(request)) {
            JupiterEngineExecutionContext executionContext = createExecutionContext(request);
            ThrowableCollector.Factory throwableCollectorFactory = createThrowableCollectorFactory(request);

            new HierarchicalTestExecutor&lt;&gt;(
                    request,
                    executionContext,
                    executorService,
                    throwableCollectorFactory
            ).execute().get();
        } catch (Exception exception) {
            throw new JUnitException(&quot;Error executing tests for engine &quot; + getId(), exception);
        }
    }
}
</div><p id="z9669ya_450">Здесь создается <code class="code" id="z9669ya_454">HierarchicalTestExecutor</code> исполнитель, который умеет работать с деревом <code class="code" id="z9669ya_455">TestDescriptor</code>'ов. Каждый <code class="code" id="z9669ya_456">TestDescriptor</code> представляет узел в иерархии тестов это может быть движок, пакет, класс, метод или отдельный тестовый случай.</p><p id="z9669ya_451"><code class="code" id="z9669ya_457">ExecutorService</code> определяет, как будут выполняться тесты последовательно в одном потоке или параллельно в нескольких. <code class="code" id="z9669ya_458">ThrowableCollector</code> нужен для корректной обработки исключений на разных уровнях иерархии.</p></section><section class="chapter"><h3 id="8-hierarchicaltestexecutor" data-toc="8-hierarchicaltestexecutor">Этап 8: HierarchicalTestExecutor запускает корневую задачу</h3><div class="code-block" data-lang="java">
class HierarchicalTestExecutor&lt;C extends EngineExecutionContext&gt; {

    Future&lt;Void&gt; execute() {
        NodeTestTask&lt;C&gt; rootTestTask = new NodeTestTask&lt;&gt;(taskContext, rootTestDescriptor);
        rootTestTask.setParentContext(this.rootContext);
        return this.executorService.submit(rootTestTask);
    }
}
</div><p id="z9669ya_460">Создается корневая задача <code class="code" id="z9669ya_463">NodeTestTask</code> для корневого <code class="code" id="z9669ya_464">TestDescriptor</code> и отправляется на выполнение в <code class="code" id="z9669ya_465">ExecutorService</code>. Часто используется <code class="code" id="z9669ya_466">SameThreadHierarchicalTestExecutorService</code>, который выполняет задачи синхронно:</p><div class="code-block" data-lang="java">
public class SameThreadHierarchicalTestExecutorService implements HierarchicalTestExecutorService {

    @Override
    public Future&lt;Void&gt; submit(TestTask testTask) {
        testTask.execute();
        return CompletableFuture.completedFuture(null);
    }
}
</div><p id="z9669ya_462">В нашем примере используется <code class="code" id="z9669ya_467">SameThreadHierarchicalTestExecutorService</code> исполнитель, который выполняет все <code class="code" id="z9669ya_468">NodeTestTask</code> последовательно в одном потоке. Это поведение можно наблюдать при запуске одиночного тестового класса, особенно из IDE или через <code class="code" id="z9669ya_469">--tests</code> в Gradle. Но важно понимать: выбор конкретной реализации <code class="code" id="z9669ya_470">HierarchicalTestExecutorService</code> делает не разработчик, а сама JUnit Platform, опираясь на конфигурацию и масштаб тестового плана. Если платформа обнаруживает, что тестов много, или включена параллелизация (<code class="code" id="z9669ya_471">junit.jupiter.execution.parallel.enabled=true</code>), или запуск идёт в рамках всего проекта, она может подставить <code class="code" id="z9669ya_472">ForkJoinPoolHierarchicalTestExecutorService</code>. В этом случае <code class="code" id="z9669ya_473">NodeTestTask</code>'и распараллеливаются с помощью <code class="code" id="z9669ya_474">ForkJoinPool</code>, что ускоряет прогон, но требует особого внимания к потокобезопасности и корректному управлению состоянием в <code class="code" id="z9669ya_475">@BeforeEach</code>, <code class="code" id="z9669ya_476">@AfterEach</code> и других фазах жизненного цикла. Фактически мы не выбираем, в каком потоке будет выполняться тест это делает движок, ориентируясь на тестовый план и окружение. Поэтому нельзя полагаться на порядок или изоляцию, если вы не контролируете среду исполнения явно.</p></section><section class="chapter"><h3 id="9-nodetesttask" data-toc="9-nodetesttask">Этап 9: NodeTestTask выполняет рекурсивную обработку узлов</h3><p id="z9669ya_477"><code class="code" id="z9669ya_486">NodeTestTask</code> это обёртка над логикой выполнения одного <code class="code" id="z9669ya_487">TestDescriptor</code> в иерархии тестов. Каждый такой узел может представлять движок, контейнер, класс, метод или даже динамический тест. Выполнение узла организовано через метод <code class="code" id="z9669ya_488">executeRecursively()</code>:</p><div class="code-block" data-lang="java">
public class NodeTestTask&lt;C extends EngineExecutionContext&gt; implements TestTask {

    @Override
    public void execute() {
        executeRecursively();
    }

    private void executeRecursively() {
        throwableCollector.execute(() -&gt; {
            node.around(context, ctx -&gt; {
                context = node.before(context);
                context = node.execute(context, dynamicTestExecutor);
                taskContext.getExecutorService().invokeAll(children);
                dynamicTestExecutor.awaitFinished();
                node.after(context);
            });
        });
    }
}
</div><p id="z9669ya_479">Метод <code class="code" id="z9669ya_489">executeRecursively()</code> реализует канонический жизненный цикл выполнения теста:</p><ol class="list _decimal" id="z9669ya_480" type="1"><li class="list__item" id="z9669ya_490"><p id="z9669ya_495"><span class="control" id="z9669ya_496">before</span> - подготовка окружения, выполнение <code class="code" id="z9669ya_497">@BeforeAll</code> и <code class="code" id="z9669ya_498">@BeforeEach</code>, создание экземпляра тестового класса</p></li><li class="list__item" id="z9669ya_491"><p id="z9669ya_499"><span class="control" id="z9669ya_500">execute</span> - непосредственное выполнение логики узла (например, вызов метода с <code class="code" id="z9669ya_501">@Test</code>)</p></li><li class="list__item" id="z9669ya_492"><p id="z9669ya_502"><span class="control" id="z9669ya_503">children</span> - рекурсивное выполнение всех дочерних узлов</p></li><li class="list__item" id="z9669ya_493"><p id="z9669ya_504"><span class="control" id="z9669ya_505">dynamic</span> - ожидание завершения динамически зарегистрированных тестов (через <code class="code" id="z9669ya_506">@TestFactory</code>)</p></li><li class="list__item" id="z9669ya_494"><p id="z9669ya_507"><span class="control" id="z9669ya_508">after</span> - завершающие действия, выполнение <code class="code" id="z9669ya_509">@AfterEach</code> и <code class="code" id="z9669ya_510">@AfterAll</code></p></li></ol><p id="z9669ya_481">Ключевая строка здесь <code class="code" id="z9669ya_511">context = node.execute(context, dynamicTestExecutor)</code>. Вызов делегируется текущему <code class="code" id="z9669ya_512">TestDescriptor</code>, чья реализация определяет, что именно будет исполнено.</p><p id="z9669ya_482">В случае обычного тестового метода этот узел будет представлять собой экземпляр <code class="code" id="z9669ya_513">TestMethodTestDescriptor</code>, а значит, выполнение пойдёт в его метод <code class="code" id="z9669ya_514">execute()</code>:</p><div class="code-block" data-lang="java">

@Override
public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
                                             DynamicTestExecutor dynamicTestExecutor) {
    ThrowableCollector throwableCollector = context.getThrowableCollector();

    invokeBeforeEachCallbacks(context);
    if (throwableCollector.isEmpty()) {
        invokeBeforeEachMethods(context);
        if (throwableCollector.isEmpty()) {
            invokeBeforeTestExecutionCallbacks(context);
            if (throwableCollector.isEmpty()) {
                invokeTestMethod(context, dynamicTestExecutor);
            }
            invokeAfterTestExecutionCallbacks(context);
        }
        invokeAfterEachMethods(context);
    }
    invokeAfterEachCallbacks(context);

    return context;
}
</div><p id="z9669ya_484">Таким образом, вызов <code class="code" id="z9669ya_515">node.execute(...)</code> на самом деле инициирует выполнение целого сценария: от вызова <code class="code" id="z9669ya_516">@BeforeEach</code> и <code class="code" id="z9669ya_517">@BeforeTestExecution</code>, до реального <code class="code" id="z9669ya_518">@Test</code>-метода (внутри <code class="code" id="z9669ya_519">invokeTestMethod(...)</code>) и последующего завершения через <code class="code" id="z9669ya_520">@AfterEach</code>.</p><p id="z9669ya_485">Это значит, что <code class="code" id="z9669ya_521">TestMethodTestDescriptor</code> внутри себя не просто вызывает <code class="code" id="z9669ya_522">Method.invoke(...)</code>, а тщательно оборачивает его в точках расширения, где могут подключиться extension'ы, interception'ы и пользовательская логика. Именно поэтому <code class="code" id="z9669ya_523">@Test</code> не просто вызов метода, а управляемый, фазовый процесс с точками вмешательства на каждом этапе.</p></section><section class="chapter"><h3 id="10" data-toc="10">Этап 10: Выполнение конкретного тестового метода</h3><p id="z9669ya_524">Когда очередь доходит до узла типа <code class="code" id="z9669ya_532">MethodTestDescriptor</code> (это наш метод <code class="code" id="z9669ya_533">downloaded image is saved to file</code>), вызывается его метод <code class="code" id="z9669ya_534">execute()</code>:</p><div class="code-block" data-lang="java">

@Override
public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context, DynamicTestExecutor dynamicTestExecutor) {
    invoker.invoke(context.getExtensionRegistry(), context.getTestInstance(), executable);
    return context;
}
</div><p id="z9669ya_526">Здесь <code class="code" id="z9669ya_535">invoker</code> это экземпляр <code class="code" id="z9669ya_536">ExecutableInvoker</code>, а <code class="code" id="z9669ya_537">executable</code> объект типа <code class="code" id="z9669ya_538">Method</code>, который ссылается на наш тестовый метод.</p><p id="z9669ya_527"><code class="code" id="z9669ya_539">ExecutableInvoker</code> обрабатывает параметры метода (если они есть), применяет расширения и в конце концов вызывает:</p><div class="code-block" data-lang="java">
public class ExecutableInvoker {

    public Object invoke(ExtensionRegistry extensionRegistry, Object target, Executable executable, Object... arguments) throws Throwable {
        ...
        return ReflectionUtils.invokeMethod((Method) executable, target, arguments);
    }
}
</div><p id="z9669ya_529">А <code class="code" id="z9669ya_540">ReflectionUtils.invokeMethod()</code> делает то, что и следует из названия:</p><div class="code-block" data-lang="java">
public final class ReflectionUtils {

    public static Object invokeMethod(Method method, Object target, Object... arguments) throws Exception {
        method.setAccessible(true);
        return method.invoke(target, arguments);
    }
}
</div><p id="z9669ya_531">И вот здесь, наконец, происходит то, ради чего была запущена вся эта машинерия, выполняется <code class="code" id="z9669ya_541">Method.invoke()</code> на экземпляре нашего класса <code class="code" id="z9669ya_542">ImageDownloaderTest</code>, вызывая метод <code class="code" id="z9669ya_543">downloaded image is saved to file()</code>.</p></section><section class="chapter"><h3 id="11" data-toc="11">Этап 11: Обработка динамических тестов</h3><p id="z9669ya_544">JUnit 5 поддерживает динамические тесты тесты, которые создаются во время выполнения через <code class="code" id="z9669ya_549">@TestFactory</code>. Если в нашем классе был бы такой метод:</p><div class="code-block" data-lang="kotlin">
@TestFactory
fun dynamicTests(): Stream&lt;DynamicTest&gt; {
    return Stream.of(
        DynamicTest.dynamicTest(&quot;Test 1&quot;) { /* логика теста 1 */ },
        DynamicTest.dynamicTest(&quot;Test 2&quot;) { /* логика теста 2 */ }
    )
}
</div><p id="z9669ya_546">То эти тесты регистрировались бы через <code class="code" id="z9669ya_550">DynamicTestExecutor</code>:</p><div class="code-block" data-lang="java">
public interface DynamicTestExecutor {
    void execute(TestDescriptor dynamicTestDescriptor);

    void awaitFinished();
}
</div><p id="z9669ya_548">Во время выполнения фабричного метода динамические тесты регистрируются через <code class="code" id="z9669ya_551">execute()</code>, а их реальное выполнение происходит при вызове <code class="code" id="z9669ya_552">awaitFinished()</code> в <code class="code" id="z9669ya_553">NodeTestTask</code>. Это позволяет поддерживать правильный порядок выполнения и корректно обрабатывать результаты динамических тестов.</p></section><section class="chapter"><h3 id="junit" data-toc="junit">Как JUnit узнаёт, что перед ним тест?</h3><p id="z9669ya_554">В предыдущей главе мы остановились на моменте, когда <code class="code" id="z9669ya_561">@Test</code>-метод уже исполняется. Но как JUnit вообще узнаёт, что этот метод - тест? И откуда он вообще берёт класс?</p><p id="z9669ya_555">На самом деле всё начинается сильно раньше - ещё в момент, когда Gradle запускает worker-процесс, где впоследствии и будет обнаружен наш тестовый класс.</p><p id="z9669ya_556">Разберёмся, как Gradle собирает окружение, и какие шаги ведут к запуску тестового <code class="code" id="z9669ya_562">Runnable</code> из пользовательского <code class="code" id="z9669ya_563">TestWorker</code>. Всё, что не критично - отправим в троеточие.</p><section class="chapter"><h4 id="gradleworkermain-worker-gradle" data-toc="gradleworkermain-worker-gradle"><code class="code" id="z9669ya_567">GradleWorkerMain</code> - точка входа в дочерний worker-процесс Gradle</h4><div class="code-block" data-lang="java">
public class GradleWorkerMain {

    public void run() throws Exception {
        Class&lt;? extends Callable&lt;Void&gt;&gt; workerClass = (Class&lt;? extends Callable&lt;Void&gt;&gt;) implementationClassLoader.loadClass(&quot;org.gradle.process.internal.worker.child.SystemApplicationClassLoaderWorker&quot;).asSubclass(Callable.class);
        Callable&lt;Void&gt; main = workerClass.getConstructor(DataInputStream.class).newInstance(instr);
        main.call();
    }

    public static void main(String[] args) {
        new GradleWorkerMain().run();
        System.exit(0);
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_566"><p id="z9669ya_568">Здесь формируется worker-класс, через который всё и запускается. Пока всё похоже на обычный Java bootstrap - но дальше начинается специфичная инициализация Gradle. <span class="control" id="z9669ya_569">Комментарий:</span> <code class="code" id="z9669ya_570">GradleWorkerMain</code> - это <span class="emphasis" id="z9669ya_571">основная точка входа</span> для любого внешнего worker-процесса Gradle. Он изолирован от основного демона Gradle и запускается в отдельном процессе JVM. Его задача - создать нужный <code class="code" id="z9669ya_572">Callable</code>, загрузив его через<code class="code" id="z9669ya_573">implementationClassLoader</code>, и запустить его. Это инфраструктурный механизм Gradle для выполнения изолированных задач (компиляции, тестов, аннотации и т. п.).</p></aside></section><section class="chapter"><h4 id="systemapplicationclassloaderworker-gradle-worker-api" data-toc="systemapplicationclassloaderworker-gradle-worker-api"><code class="code" id="z9669ya_577">SystemApplicationClassLoaderWorker</code> - адаптер, запускающий рабочую логику в контексте Gradle Worker API</h4><div class="code-block" data-lang="java">
public class SystemApplicationClassLoaderWorker implements Callable&lt;Void&gt; {

    @Override
    public Void call() throws Exception {
        ...
        ActionExecutionWorker worker = new ActionExecutionWorker(config.getWorkerAction());
        worker.execute(new ContextImpl(...));
        ...
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_576"><p id="z9669ya_578">Здесь мы впервые встречаем <code class="code" id="z9669ya_579">config.getWorkerAction()</code> - именно он содержит <code class="code" id="z9669ya_580">TestWorker</code>, который отвечает за запуск тестов. Но пока он обёрнут в универсальный <code class="code" id="z9669ya_581">ActionExecutionWorker</code>. <span class="control" id="z9669ya_582">Комментарий:</span> <code class="code" id="z9669ya_583">SystemApplicationClassLoaderWorker</code> - это <span class="emphasis" id="z9669ya_584">внутренний запускной адаптер Gradle</span>, который оборачивает и исполняет реальную рабочую нагрузку. Он используется для переключения контекста ClassLoader-а (SystemApplicationClassLoader) и передачи управления <code class="code" id="z9669ya_585">ActionExecutionWorker</code>. Именно в этом классе происходит развертывание конфигурации worker-а (<code class="code" id="z9669ya_586">config</code>) и передача управления реальной задаче.</p></aside></section><section class="chapter"><h4 id="actionexecutionworker-testworker" data-toc="actionexecutionworker-testworker"><code class="code" id="z9669ya_590">ActionExecutionWorker</code> - вызов настоящего <code class="code" id="z9669ya_591">TestWorker</code></h4><div class="code-block" data-lang="java">
public class ActionExecutionWorker implements Action&lt;WorkerProcessContext&gt; {
    private final Action&lt;? super WorkerProcessContext&gt; action;

    public ActionExecutionWorker(Action&lt;? super WorkerProcessContext&gt; action) {
        this.action = action;
    }

    @Override
    public void execute(final WorkerProcessContext workerContext) {
        ObjectConnection clientConnection = workerContext.getServerConnection();
        clientConnection.addUnrecoverableErrorHandler(new Action&lt;Throwable&gt;() {
            @Override
            public void execute(Throwable throwable) {
                if (action instanceof Stoppable) {
                    ((Stoppable) action).stop();
                }
            }
        });

        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(action.getClass().getClassLoader());
        try {
            action.execute(workerContext); // &lt;-- ключевой момент: вызывает TestWorker
        } finally {
            ...
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_589"><p id="z9669ya_592">Здесь action - это и есть TestWorker, просто замаскированный под Action. Этот вызов приводит к запуску кода, который действительно управляет жизненным циклом тестов. <span class="control" id="z9669ya_593">Комментарий:</span> <code class="code" id="z9669ya_594">ActionExecutionWorker</code> - универсальный обёртчик, запускающий пользовательский <code class="code" id="z9669ya_595">Action</code> (в нашем случае - <code class="code" id="z9669ya_596">TestWorker</code>). Он также добавляет обработчик критических ошибок (<code class="code" id="z9669ya_597">addUnrecoverableErrorHandler</code>), который при сбое выполнит <code class="code" id="z9669ya_598">stop()</code> у <code class="code" id="z9669ya_599">TestWorker</code>. Это инфраструктурный компонент Gradle Worker API, обеспечивающий безопасное выполнение задач.</p></aside></section><section class="chapter"><h4 id="testworker" data-toc="testworker"><code class="code" id="z9669ya_605">TestWorker</code> - управление жизненным циклом и запуск тестов</h4><div class="code-block" data-lang="java">
public class TestWorker implements Action&lt;WorkerProcessContext&gt;, RemoteTestClassProcessor, Serializable, Stoppable {

    @Override
    public void execute(final WorkerProcessContext workerProcessContext) {
        ...
        CloseableServiceRegistry testServices = TestFrameworkServiceRegistry.create(workerProcessContext);
        startReceivingTests(workerProcessContext, testServices);

        try {
            while (state != State.STOPPED) {
                executeAndMaintainThreadName(runQueue.take());
            }
        } finally {
            ...
            testServices.close();
        }
    }

    private static void executeAndMaintainThreadName(Runnable action) {
        try {
            action.run();
        } finally {
            Thread.currentThread().setName(WORK_THREAD_NAME);
        }
    }

    @Override
    public void stop() {
        submitToRun(new Runnable() {
            @Override
            public void run() {
                try {
                    processor.stop();
                } finally {
                    state = State.STOPPED;
                    // Clean the interrupted status
                    // because some test class processors do work here, e.g. JUnitPlatform
                    Thread.interrupted();
                }
            }
        });
    }

}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_602"><p id="z9669ya_606">Здесь начинается реальная жизнь тестов. Метод <code class="code" id="z9669ya_607">startReceivingTests()</code> инициирует приём тестов от Master-процесса, а <code class="code" id="z9669ya_608">runQueue.take()</code> вытаскивает очередной <code class="code" id="z9669ya_609">Runnable</code> - в том числе и JUnit-подобные вызовы. Но кто решает, какие классы положить в эту очередь? executeAndMaintainThreadName, вызывая action.run(), на самом деле вызовет stop у TestWorker. <span class="control" id="z9669ya_610">Комментарий:</span> <code class="code" id="z9669ya_611">TestWorker</code> - это главная точка управления тестами на стороне worker-процесса. Он слушает очередь задач (<code class="code" id="z9669ya_612">runQueue</code>) и исполняет их. Именно сюда Master отправляет команды через <code class="code" id="z9669ya_613">RemoteTestClassProcessor &rarr; Dispatch &rarr; MethodInvocation</code>. Также реализует <code class="code" id="z9669ya_614">Stoppable</code> - чтобы корректно завершить тестовый процесс по команде снаружи (в том числе при отмене сборки).</p></aside><p id="z9669ya_603">Отлично, теперь мы перешли к следующему важному слою - механизму доставки и вызова тестов. На этом этапе <code class="code" id="z9669ya_615">TestWorker</code> уже готов принимать команды, но кто же инициирует вызовы тестов и как классы с <code class="code" id="z9669ya_616">@Test</code> действительно попадают в исполнение?</p><p id="z9669ya_604">Разбираем цепочку, в которой <code class="code" id="z9669ya_617">Dispatch</code>, <code class="code" id="z9669ya_618">MethodInvocation</code> и <code class="code" id="z9669ya_619">TestClassProcessor</code> играют ключевую роль в том, как тестовый класс сначала * <span class="emphasis" id="z9669ya_620">обнаруживается</span>*, а затем <span class="control" id="z9669ya_621">передаётся</span> для обработки.</p></section></section></section><section class="chapter"><h2 id="junit-platform-gradle-test-framework-junit-engine" data-toc="junit-platform-gradle-test-framework-junit-engine">В этом этапе мы находимся чуть выше JUnit Platform, на уровне Gradle Test Framework. Здесь через прокси и диспатчер происходит вызов методов, которые в итоге передают управление JUnit Engine'у.</h2><section class="chapter"><h3 id="proxydispatchadapter-dispatch" data-toc="proxydispatchadapter-dispatch"><code class="code" id="z9669ya_636">ProxyDispatchAdapter</code> - создание прокси, который делегирует вызовы через <code class="code" id="z9669ya_637">Dispatch</code></h3><div class="code-block" data-lang="java">
public class ProxyDispatchAdapter&lt;T&gt; {
    private final Class&lt;T&gt; type;
    private final T source;

    public ProxyDispatchAdapter(Dispatch&lt;? super MethodInvocation&gt; dispatch, Class&lt;T&gt; type, Class&lt;?&gt;... extraTypes) {
        this.type = type;
        List&lt;Class&lt;?&gt;&gt; types = new ArrayList&lt;Class&lt;?&gt;&gt;();
        ClassLoader classLoader = type.getClassLoader();
        types.add(type);
        for (Class&lt;?&gt; extraType : extraTypes) {
            ...
            types.add(extraType);
        }
        source = type.cast(Proxy.newProxyInstance(
                classLoader,
                types.toArray(new Class&lt;?&gt;[0]),
                new DispatchingInvocationHandler(type, dispatch)));
    }

    public T getSource() {
        return source;
    }

    private static class DispatchingInvocationHandler implements InvocationHandler {
        private final Class&lt;?&gt; type;
        private final Dispatch&lt;? super MethodInvocation&gt; dispatch;

        @Override
        public Object invoke(Object target, Method method, Object[] parameters) throws Throwable {
            dispatch.dispatch(new MethodInvocation(method, parameters));
            return null;
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_635"><p id="z9669ya_638">Здесь создаётся <span class="control" id="z9669ya_639">динамический прокси</span> (через <code class="code" id="z9669ya_640">java.lang.reflect.Proxy</code>), который вместо непосредственного вызова метода прокидывает его как <code class="code" id="z9669ya_641">MethodInvocation</code> в <code class="code" id="z9669ya_642">Dispatch</code>. Это ключевая прослойка для удалённого и deferred-вызова <code class="code" id="z9669ya_643">processTestClass(...)</code>. <span class="control" id="z9669ya_644">Комментарий:</span> используется в master-процессе. Возвращает реализацию интерфейса <code class="code" id="z9669ya_645">TestClassProcessor</code>, но на деле метод будет превращён в <code class="code" id="z9669ya_646">MethodInvocation</code> и передан в <code class="code" id="z9669ya_647">Dispatch</code>, который отправит его в дочерний процесс.</p></aside></section><section class="chapter"><h3 id="contextclassloaderdispatch-classloader" data-toc="contextclassloaderdispatch-classloader"><code class="code" id="z9669ya_651">ContextClassLoaderDispatch</code> - временно меняет classloader на тестовый</h3><div class="code-block" data-lang="java">
public class ContextClassLoaderDispatch&lt;T&gt; implements Dispatch&lt;T&gt; {
    private final Dispatch&lt;? super T&gt; dispatch;
    private final ClassLoader contextClassLoader;

    @Override
    public void dispatch(T message) {
        ClassLoader original = Thread.currentThread().getContextClassLoader();
        Thread.currentThread().setContextClassLoader(contextClassLoader);
        try {
            dispatch.dispatch(message);
        } finally {
            Thread.currentThread().setContextClassLoader(original);
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_650"><p id="z9669ya_652">Оборачивает <code class="code" id="z9669ya_653">Dispatch</code>, чтобы каждый вызов происходил в нужном <span class="control" id="z9669ya_654">contextClassLoader&rsquo;е</span> - тот, в котором доступны юзерские тесты, аннотации <code class="code" id="z9669ya_655">@Test</code> и прочие артефакты сборки. В противном случае рефлексия просто не увидит нужные классы. <span class="control" id="z9669ya_656">Комментарий:</span> используется на стороне worker-а для того, чтобы внутри JUnit-кода применялся корректный <code class="code" id="z9669ya_657">ClassLoader</code>, видящий классы тестов, их зависимости и runtime-окружение.</p></aside></section><section class="chapter"><h3 id="reflectiondispatch" data-toc="reflectiondispatch"><code class="code" id="z9669ya_661">ReflectionDispatch</code> - финальный обработчик, вызывающий метод</h3><div class="code-block" data-lang="java">
public class ReflectionDispatch implements Dispatch&lt;MethodInvocation&gt; {
    private final Object target;

    @Override
    public void dispatch(MethodInvocation message) {
        try {
            Method method = message.getMethod();
            method.setAccessible(true);
            method.invoke(target, message.getArguments());
        } catch (InvocationTargetException e) {
            throw UncheckedException.throwAsUncheckedException(e.getCause());
        } catch (Throwable throwable) {
            throw UncheckedException.throwAsUncheckedException(throwable);
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_660"><p id="z9669ya_662">Это последний шаг цепочки вызова: приходит <code class="code" id="z9669ya_663">MethodInvocation</code>, и метод вызывается на <code class="code" id="z9669ya_664">target</code>-объекте. Обычно это и есть <code class="code" id="z9669ya_665">JUnitTestClassProcessor</code>, у которого вызывается <code class="code" id="z9669ya_666">processTestClass(...)</code>. <span class="control" id="z9669ya_667">Комментарий:</span> работает внутри <code class="code" id="z9669ya_668">TestWorker</code> - принимает вызов из master-процесса, извлекает метод и аргументы, и вызывает нужный метод на <code class="code" id="z9669ya_669">TestClassProcessor</code>, фактически начиная выполнение теста.</p></aside></section><section class="chapter"><h3 id="suitetestclassprocessor" data-toc="suitetestclassprocessor"><code class="code" id="z9669ya_673">SuiteTestClassProcessor</code> - обёртка над настоящей обработкой класса</h3><div class="code-block" data-lang="java">
public class SuiteTestClassProcessor implements TestClassProcessor {
    private final TestClassProcessor processor;

    @Override
    public void processTestClass(TestClassRunInfo testClass) {
        ...
        processor.processTestClass(testClass);
        ...
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_672"><p id="z9669ya_674">Именно здесь вызывается <code class="code" id="z9669ya_675">processTestClass(...)</code> на реальном обработчике - чаще всего это <code class="code" id="z9669ya_676">JUnitTestClassProcessor</code>, и уже он инициализирует JUnit Engine, Discovery, и начинает сканировать аннотации <code class="code" id="z9669ya_677">@Test</code>. <span class="control" id="z9669ya_678">Комментарий:</span> <code class="code" id="z9669ya_679">SuiteTestClassProcessor</code> добавляет fault-tolerance-обёртку над реальным <code class="code" id="z9669ya_680">TestClassProcessor</code>. Он отлавливает исключения выполнения и репортит их через <code class="code" id="z9669ya_681">resultProcessor</code>, чтобы обеспечить корректную отчётность, даже если тесты упали на фазе запуска.</p></aside></section><section class="chapter"><h3 id="abstractjunittestclassprocessor-junit" data-toc="abstractjunittestclassprocessor-junit"><code class="code" id="z9669ya_685">AbstractJUnitTestClassProcessor</code> - общая логика для JUnit-обработчиков</h3><div class="code-block" data-lang="java">
public abstract class AbstractJUnitTestClassProcessor implements TestClassProcessor {

    private Action&lt;String&gt; executor;

    @Override
    public void startProcessing(TestResultProcessor resultProcessor) {
        executor = createTestExecutor(resultProcessorActor);
    }

    @Override
    public void processTestClass(TestClassRunInfo testClass) {
        LOGGER.debug(&quot;Executing test class {}&quot;, testClass.getTestClassName());
        executor.execute(testClass.getTestClassName());
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_684"><p id="z9669ya_686">Далее переменной <code class="code" id="z9669ya_687">executor</code> присваивается результат функции <code class="code" id="z9669ya_688">createTestExecutor(...)</code>, а в методе <code class="code" id="z9669ya_689">processTestClass(...)</code> идёт обращение к этому <code class="code" id="z9669ya_690">executor</code>. <span class="control" id="z9669ya_691">Комментарий:</span> <code class="code" id="z9669ya_692">AbstractJUnitTestClassProcessor</code> содержит шаблонную реализацию <code class="code" id="z9669ya_693">processTestClass(...)</code>, делегируя выполнение <code class="code" id="z9669ya_694">Action&lt;String&gt;</code> - это и есть фактический механизм исполнения теста. Конкретные реализации определяют, как именно запускать класс.</p></aside></section><section class="chapter"><h3 id="junitplatformtestclassprocessor-junit-5" data-toc="junitplatformtestclassprocessor-junit-5"><code class="code" id="z9669ya_698">JUnitPlatformTestClassProcessor</code> - реализация под JUnit 5</h3><div class="code-block" data-lang="java">
public class JUnitPlatformTestClassProcessor extends AbstractJUnitTestClassProcessor {

    @Override
    protected Action&lt;String&gt; createTestExecutor(Actor resultProcessorActor) {
        ...
        testClassExecutor = new CollectAllTestClassesExecutor(threadSafeResultProcessor);
        return testClassExecutor;
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_697"><p id="z9669ya_699"><code class="code" id="z9669ya_700">JUnitPlatformTestClassProcessor</code> наследуется от <code class="code" id="z9669ya_701">AbstractJUnitTestClassProcessor</code> и предоставляет реализацию метода <code class="code" id="z9669ya_702">createTestExecutor(...)</code>. <span class="control" id="z9669ya_703">Комментарий:</span> на фазе запуска (в <code class="code" id="z9669ya_704">startProcessing</code>) создаётся <code class="code" id="z9669ya_705">CollectAllTestClassesExecutor</code>, который временно накапливает все классы, помеченные к исполнению. Позже Gradle вызовет <code class="code" id="z9669ya_706">stopProcessing()</code>, и тогда накопленные классы передадутся в <code class="code" id="z9669ya_707">JUnitPlatform</code> через <code class="code" id="z9669ya_708">Launcher.execute(...)</code>.</p></aside></section><section class="chapter"><h3 id="collectalltestclassesexecutor" data-toc="collectalltestclassesexecutor"><code class="code" id="z9669ya_712">CollectAllTestClassesExecutor</code> - накопление тестовых классов до момента исполнения</h3><div class="code-block" data-lang="java">
private class CollectAllTestClassesExecutor implements Action&lt;String&gt; {
    private final List&lt;Class&lt;?&gt;&gt; testClasses = new ArrayList&lt;&gt;();

    @Override
    public void execute(@Nonnull String testClassName) {
        Class&lt;?&gt; klass = loadClass(testClassName);
        testClasses.add(klass);
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z9669ya_711"><p id="z9669ya_713">Тут <code class="code" id="z9669ya_714">klass</code> добавляется в список <code class="code" id="z9669ya_715">testClasses</code>. <span class="control" id="z9669ya_716">Комментарий:</span> <code class="code" id="z9669ya_717">CollectAllTestClassesExecutor</code> не запускает тесты немедленно. Он просто накапливает их для дальнейшего пакетного исполнения. Позднее, в методе <code class="code" id="z9669ya_718">stopProcessing()</code>, список будет передан <code class="code" id="z9669ya_719">JUnit Launcher</code>, чтобы протестировать все классы единым <code class="code" id="z9669ya_720">TestPlan</code>.</p></aside></section><section class="chapter"><h3 id="z9669ya_630" data-toc="z9669ya_630">Почему мы всё это рассмотрели?</h3><p id="z9669ya_721">Если вы дочитали до этого момента, то наверняка хотя бы раз задали себе вопрос: зачем вообще вникать в архитектуру JUnit 5? Зачем знать, что делает <code class="code" id="z9669ya_728">TestWorker</code>, чем <code class="code" id="z9669ya_729">TestEngine</code> отличается от API, и как <code class="code" id="z9669ya_730">Gradle</code> взаимодействует с <code class="code" id="z9669ya_731">JUnit Platform</code>?</p><p id="z9669ya_722">Ответ - в самом характере JUnit. Это не просто один из тестовых фреймворков. Это инфраструктура, на которой десятилетиями держалась JVM-разработка. JUnit - не просто библиотека. Это канонический пример того, как строятся фреймворки с глубокой интеграцией: в Gradle, в IDE, в CI. Поняв как работает JUnit, вы поймёте, как устроены почти все тестовые инструменты в JVM-мире - от Spock до Kotest, от TestNG до Spek.</p><p id="z9669ya_723">Тесты на основе аннотаций всегда работают через рефлексию. Всегда есть рантайм, который анализирует классы, определяет методы, оборачивает их в структуру исполнения. Всегда есть <code class="code" id="z9669ya_732">TestEngine</code>, который решает, как именно вызвать <code class="code" id="z9669ya_733">@BeforeEach</code>, что считать failed-стейтом, и как прервать иерархию при падении родителя. Именно <code class="code" id="z9669ya_734">Engine</code> - а не <code class="code" id="z9669ya_735">@Test</code> и не <code class="code" id="z9669ya_736">Assertions</code> - определяет поведение.</p><p id="z9669ya_724">JUnit Platform отделила Engine от API. Это был стратегический шаг. Теперь JUnit - это не библиотека с аннотациями. Это инфраструктурный протокол, к которому могут подключаться любые движки. Jupiter - один из них. Kotest - другой. Даже ваш собственный.</p><p id="z9669ya_725">Мы прошли весь путь: от команды <code class="code" id="z9669ya_737">./gradlew test</code> до самого вызова вашего метода. По дороге были:</p><ul class="list _bullet" id="z9669ya_726"><li class="list__item" id="z9669ya_738"><p id="z9669ya_745">Gradle, который координирует процесс;</p></li><li class="list__item" id="z9669ya_739"><p id="z9669ya_746">Forked Worker, запускающий процесс с изоляцией;</p></li><li class="list__item" id="z9669ya_740"><p id="z9669ya_747">TestClassProcessor, создающий структуру исполнения;</p></li><li class="list__item" id="z9669ya_741"><p id="z9669ya_748">JUnit Platform, связывающая мир движков и инфраструктуры;</p></li><li class="list__item" id="z9669ya_742"><p id="z9669ya_749">JUnit Jupiter, реализующий правила JUnit 5;</p></li><li class="list__item" id="z9669ya_743"><p id="z9669ya_750">Hierarchical Test Executor, обрабатывающий before/execute/after как дерево;</p></li><li class="list__item" id="z9669ya_744"><p id="z9669ya_751">и, наконец, конкретный метод, вызываемый через рефлексию.</p></li></ul><p id="z9669ya_727">Это выглядит сложнее, чем <code class="code" id="z9669ya_752">assertEquals(4, 2 + 2)</code>, но эта сложность - осмысленная. Она обеспечивает модульность, расширяемость, гибкость и параллелизм. Она позволяет использовать свои движки, свои жизненные циклы, свои правила. И именно это знание отличает пользователя фреймворка от инженера.</p></section><section class="chapter"><h3 id="visiblefortesting" data-toc="visiblefortesting"><code class="code" id="z9669ya_760">@VisibleForTesting</code>: доступ, расширенный исключительно для тестов</h3><p id="z9669ya_754">Стоит упомянуть про аннотацию <code class="code" id="z9669ya_761">@VisibleForTesting</code> нечастого, но важного участника тестового ландшафта. Она не делает метод тестом, не участвует в рантайме и никак не влияет на выполнение. Но если вы видите её в коде значит, где-то произошла честная сделка между инкапсуляцией и тестируемостью. Компромисс. Внятно обозначенный.</p><p id="z9669ya_755">Аннотация сигнализирует: этот метод, это поле или конструктор открыты шире, чем должны быть но не потому, что &laquo;так проще&raquo;, а потому, что тест этого требует. Приватную логику не протестируешь напрямую, а выносить её наружу в API не хочется. Тогда разработчик идёт на аккуратное нарушение границы и оставляет пометку <code class="code" id="z9669ya_762">@VisibleForTesting</code>. Это как ручка от сейфа, которую поставили снаружи исключительно для инженеров техподдержки.</p><p id="z9669ya_756">Такой подход особенно распространён в Android и Kotlin-проектах, где модификатор <code class="code" id="z9669ya_763">internal</code> или <code class="code" id="z9669ya_764">protected</code> часто становится компромиссной зоной. Метод мог бы быть <code class="code" id="z9669ya_765">private</code>, но тогда тесты не смогут его вызвать. Расширяем видимость, но делаем это явно и документированно:</p><div class="code-block" data-lang="kotlin">
@VisibleForTesting
internal fun recalculateChecksum() {
    // метод открыт не для продакшена, а чтобы тест мог вызвать напрямую
}
</div><p id="z9669ya_758">У аннотации нет единого источника. Первая её версия появилась в Guava: <code class="code" id="z9669ya_766">com.google.common.annotations.VisibleForTesting</code>. Затем аналогичные появились в <code class="code" id="z9669ya_767">androidx.annotation</code> и <code class="code" id="z9669ya_768">org.jetbrains.annotations</code> с тем же смыслом, но немного разной реализацией. Например, Android-версия допускает уточнение, какую видимость следует использовать в продакшене (<code class="code" id="z9669ya_769">otherwise = PRIVATE</code>), если вы вдруг забудете вернуть модификатор обратно.</p><p id="z9669ya_759">Важно понимать: компилятору всё равно. JUnit тем более. Это не инструкция, а честная метка. Обещание, данное себе и команде: &quot;я знаю, что это дырка в инкапсуляции и сделал её не по глупости&quot;. Именно такие детали отличают инженерное решение от хаотичного &laquo;лишь бы работало&raquo;.</p></section><section class="chapter"><h3 id="junit-5" data-toc="junit-5">Почему JUnit 5 это уже не просто про юниты</h3><p id="z9669ya_770">Когда говорят &laquo;JUnit 5&raquo;, чаще всего имеют в виду просто современную библиотеку для написания юнит-тестов. И это правда JUnit 5 вполне можно использовать как обычный инструмент: подключить, написать тесты, запускать из IDE или Gradle.</p><p id="z9669ya_771">Но это поверхностный взгляд. Потому что <code class="code" id="z9669ya_779">JUnit 5</code> это не просто библиотека. Это фреймворк, из которого можно собирать другие фреймворки. Внутри него JUnit Platform, модуль, который работает как рантайм-движок: он не диктует, как должны выглядеть тесты, он умеет обнаруживать, исполнять и агрегировать любые тестовые единицы, если они реализованы в рамках платформенного контракта.</p><p id="z9669ya_772">На этом контракте уже сегодня построено множество других библиотек. Они не используют JUnit &laquo;как есть&raquo;, они строят свои абстракции, свои DSL&rsquo;ы, но под капотом всё это всё равно исполняется через JUnit Platform. Ниже несколько ярких примеров:</p><p id="z9669ya_773"><code class="code" id="z9669ya_780">Kotest</code> Фреймворк, который кардинально переосмысливает, как должен выглядеть тест в языке Kotlin. Вместо привычной структуры &ldquo;класс + методы&rdquo;, здесь декларативный DSL, приближённый к структуре документации: &quot;should do something&quot; внутри &quot;describe this behavior&quot;. Kotest также встроенно поддерживает property-based testing, матчер-DSL, тестовые генераторы и детерминированные стратегии повторения. Но что важно всё это работает через JUnit Platform, а значит, совместимо с IDE, Gradle и CI из коробки.</p><p id="z9669ya_774"><code class="code" id="z9669ya_781">Spek</code> Минималистичный фреймворк, ориентированный на спецификацию поведения, а не реализацию. Тесты в Spek пишутся как цепочки вложенных блоков given / on / it, приближаясь к форме технического задания. В отличие от Kotest, Spek делает акцент на чистоте и лаконичности, особенно в микросервисных сценариях. И снова под всей этой структурой лежит не собственный раннер, а именно JUnit Platform.</p><p id="z9669ya_775"><code class="code" id="z9669ya_782">Cucumber</code> BDD-фреймворк, который строится вокруг Gherkin-сценариев. Вы описываете поведение системы в .feature-файле на естественном языке, а реализацию шагов связываете с кодом. Для запуска этих сценариев, Cucumber использует свой адаптер, который регистрирует себя как TestEngine JUnit Platform. Это позволяет запускать BDD-тесты в той же среде, что и обычные unit или integration тесты, не ломая пайплайн.</p><p id="z9669ya_776"><code class="code" id="z9669ya_783">JQwik</code> Property-based testing на Java и Kotlin, вдохновлённый QuickCheck. Вместо написания конкретных примеров, вы описываете свойства, которые система должна удовлетворять для произвольных входов. Генерация данных, shrink&rsquo;инг, случайность всё встроено. И опять же: он не делает свою экосистему он интегрируется через JUnit Platform.</p><p id="z9669ya_777"><code class="code" id="z9669ya_784">JUnit 5</code> это не вершина тестирования. Это скорее почва, на которой растут разные формы тестирования: декларативные, спецификационные, BDD, property-based. И возможность строить поверх него это не побочный эффект, это основа архитектурного замысла.</p><p id="z9669ya_778">Это не библиотека для &ldquo;написать тест и забыть&rdquo;, это платформа, к которой можно подключить своё видение того, что такое тест вообще.</p></section></section><section class="chapter"><h2 id="7-kotlin-test-kotest" data-toc="7-kotlin-test-kotest">7. Kotlin Test: Строгая минималистика или Kotest</h2><p id="z9669ya_785">Когда разработчик впервые сталкивается с тестами в Kotlin, особенно на JVM, он почти автоматически тянется к тому, что уже знакомо - JUnit. Возможно, даже не подозревая, что в стандартной библиотеке Kotlin есть свой собственный тестовый модуль - <code class="code" id="z9669ya_795">kotlin.test</code>. Не библиотека на GitHub, не очередной фреймворк от энтузиастов, а часть самого языка. Устанавливать его не нужно, он поставляется вместе со стандартной библиотекой, и уже доступен в любом Kotlin-проекте.</p><figure id="z9669ya_786"><img alt="junit-kotlin-tet.jpeg" src="images/testing_philosophy_kotlin_expect_actual_test_doubles3.jpeg" title="junit-kotlin-tet.jpeg" width="2896" height="766"></figure><p id="z9669ya_787">Если открыть любую multiplatform-библиотеку JetBrains - например, kotlinx.coroutines или kotlinx.datetime - можно увидеть, что все тесты написаны на <code class="code" id="z9669ya_796">kotlin.test</code>: <code class="code" id="z9669ya_797">@Test</code>, <code class="code" id="z9669ya_798">assertEquals</code>, <code class="code" id="z9669ya_799">assertFailsWith</code>. И всё это без упоминания JUnit. Это не случайность. <code class="code" id="z9669ya_800">kotlin.test</code> был задуман как <span class="control" id="z9669ya_801">единый абстрактный слой для тестирования во всех таргетах: JVM, JS, Native</span>. Он не привязан к JUnit, Mocha или XCTest - но умеет работать с каждым из них, если ты подключаешь соответствующий адаптер. На JVM это может быть <code class="code" id="z9669ya_802">kotlin-test-junit</code>, <code class="code" id="z9669ya_803">kotlin-test-junit5</code>, <code class="code" id="z9669ya_804">kotlin-test-testng</code>. На JavaScript - интеграция с Mocha. На Native - своя реализация, написанная на C interop. API при этом остаётся единым.</p><p id="z9669ya_788">Под капотом, конечно, никакого волшебства нет: <code class="code" id="z9669ya_805">assertEquals</code> делегирует на <code class="code" id="z9669ya_806">org.junit.jupiter.api.Assertions.assertEquals</code> только если ты сам подключил <code class="code" id="z9669ya_807">kotlin-test-junit5</code>. Нет JUnit будет <code class="code" id="z9669ya_808">NoClassDefFoundError</code>. Никаких запасных планов. <code class="code" id="z9669ya_809">kotlin.test</code> это не runtime-инфраструктура, а чисто <span class="control" id="z9669ya_810">API-слой</span>, такой же как <code class="code" id="z9669ya_811">kotlin.collections</code>. Kotlin предоставляет общее имя, реализация зависит от того, на какой платформе ты находишься и что положил в classpath.</p><p id="z9669ya_789">Именно поэтому <code class="code" id="z9669ya_812">kotlin.test</code> часто недооценивают: на JVM он не кажется самостоятельным, выглядит как прокладка, иногда как костыль. Но за этим решением стоит другая философия не расширять JUnit, а уйти от него. Сделать API тестирования таким же, как стандартные функции в Kotlin: лаконичным, предсказуемым, платформонейтральным. У Kotlin нет своего <code class="code" id="z9669ya_813">@Synchronized</code>, своего <code class="code" id="z9669ya_814">List</code> или <code class="code" id="z9669ya_815">File</code>, потому что есть JVM-шные аналоги. Но у него есть <code class="code" id="z9669ya_816">kotlin.test.assertEquals</code> и это не просто синтаксический сахар.</p><p id="z9669ya_790">Пример минимального теста в духе этой философии:</p><div class="code-block" data-lang="kotlin">
@Test
fun testSum() {
    assertEquals(4, 2 + 2)
}
</div><p id="z9669ya_792">Без <code class="code" id="z9669ya_817">@RunWith</code>, без <code class="code" id="z9669ya_818">@DisplayName</code>, без <code class="code" id="z9669ya_819">assertThat(...).isEqualTo(...)</code>. Просто функция, просто проверка. Как будто ты пишешь не тест, а обычный код и это ключевой замысел. Не выносить тестирование в отдельный мир с ритуалами и аннотациями, а встраивать его в обычную практику разработки, сделать его естественным, как <code class="code" id="z9669ya_820">println()</code>.</p><p id="z9669ya_793">Но у этой строгости есть и предел. В какой-то момент тебе хочется группировать тесты по контексту, писать <code class="code" id="z9669ya_821">beforeEach</code>, использовать <code class="code" id="z9669ya_822">property-based testing</code>, делать ассерт не одного значения, а целой структуры. И вот здесь начинается другая история - история Kotest.</p><section class="chapter"><h3 id="kotest-kotlin-first" data-toc="kotest-kotlin-first">Kotest - лучшая Kotlin First тестовая библиотека?</h3><p id="z9669ya_823">Kotest - это не обёртка над <code class="code" id="z9669ya_838">kotlin.test</code> и не альтернатива JUnit в классическом смысле. Это попытка переосмыслить саму структуру тестов, убрав их из мира фреймворков и вернуть в язык. Не симулировать <code class="code" id="z9669ya_839">JUnit DSL с Kotlin-нотками</code>, а написать тесты как код, а не как декларации.</p><p id="z9669ya_824">В Kotest нет <code class="code" id="z9669ya_840">@Test</code>. Вместо этого - структуры и декларативные конструкции. Спецификации (<code class="code" id="z9669ya_841">FunSpec</code>, <code class="code" id="z9669ya_842">DescribeSpec</code>, <code class="code" id="z9669ya_843">BehaviorSpec</code> и другие) задают форму теста: ты не навешиваешь аннотацию на метод, ты описываешь, как ведёт себя система в определённом контексте. DSL делает это без ceremony.</p><div class="code-block" data-lang="kotlin">
class MathSpec : FunSpec({
    test(&quot;2 + 2 should be 4&quot;) {
        2 + 2 shouldBe 4
    }
})
</div><p id="z9669ya_826">Это не просто коротко. Это читается как спецификация. Kotest позволяет писать тесты в форме, близкой к документации, но без потери точности или контроля над структурой. Ты явно задаёшь контекст, ожидаемое поведение, границы. Это не набор методов - это дерево.</p><p id="z9669ya_827">У каждого стиля (Spec) - своя семантика. <code class="code" id="z9669ya_844">FunSpec</code> - минимализм, <code class="code" id="z9669ya_845">DescribeSpec</code> - BDD, <code class="code" id="z9669ya_846">ShouldSpec</code> - поведенческое описание, <code class="code" id="z9669ya_847">WordSpec</code> - текстовая вложенность, <code class="code" id="z9669ya_848">FreeSpec</code> - произвольная свобода, <code class="code" id="z9669ya_849">ExpectSpec</code> - JUnit-стиль. Это не косметика - это разные способы мыслить о тестах.</p><p id="z9669ya_828">Kotest работает через <code class="code" id="z9669ya_850">TestEngine</code>, который интегрируется с JUnit Platform. Без JUnit Platform он не запускается - и это принципиальный момент: Kotest <span class="control" id="z9669ya_851">не отвергает JUnit</span>, он использует его как точку входа, но полностью заменяет внутреннюю механику. Это не костыль поверх JUnit 5, а самостоятельный фреймворк, который использует JUnit только как bootstrap и канал для IDE и Gradle.</p><p id="z9669ya_829">Каждый тест может быть <code class="code" id="z9669ya_852">suspend</code>. Корутинные тесты не требуют никаких обёрток или расширений. <code class="code" id="z9669ya_853">delay</code>, <code class="code" id="z9669ya_854">Flow</code>, <code class="code" id="z9669ya_855">runBlockingTest</code> - всё работает из коробки. Это особенно важно, если ты тестируешь то, что и так построено на suspend-функциях. В <code class="code" id="z9669ya_856">kotlin.test</code> это возможно, но не на всех уровнях одинаково гладко.</p><p id="z9669ya_830">Matchers в Kotest - отдельная тема. Ты не делаешь <code class="code" id="z9669ya_857">assertEquals</code>, ты пишешь <code class="code" id="z9669ya_858">value shouldBe expected</code>. Или <code class="code" id="z9669ya_859">list shouldContainExactly listOf(...)</code>. Или <code class="code" id="z9669ya_860">exception shouldHaveMessage &quot;Invalid state&quot;</code>. Это не просто синтаксис. Это способ избавиться от лишнего уровня абстракции: не писать &quot;assert X о Y&quot;, а описывать свойства Y как есть.</p><p id="z9669ya_831">Существует <code class="code" id="z9669ya_861">assertSoftly</code>, которое позволяет в одном тесте проверять сразу несколько свойств и видеть все ошибки сразу, а не только первую. Это удобно, когда ты тестируешь сложный объект и не хочешь писать пять отдельных тестов на каждое поле.</p><p id="z9669ya_832">Kotest также поддерживает property-based testing через <code class="code" id="z9669ya_862">forAll</code>, <code class="code" id="z9669ya_863">checkAll</code>, <code class="code" id="z9669ya_864">Gen</code>. Это ближе к QuickCheck, чем к JUnit. Тесты становятся не списком кейсов, а генератором гипотез. В мире строго типизированного языка с мощным компилятором - это логичное продолжение.</p><div class="code-block" data-lang="kotlin">
class EmailValidatorTest : StringSpec({
    &quot;should only accept valid emails&quot; {
        forAll(Gen.email()) { email -&gt;
            isValidEmail(email)
        }
    }
})
</div><p id="z9669ya_834">Kotest можно использовать на JS и Native, но не с той же глубиной. Его настоящая сила в JVM. Именно там ты получаешь весь спектр: DSL, корутины, матчеры, генераторы, спецификации, soft-asserts, глобальные конфигурации, hooks и extensions. Это не просто библиотека, это целая тестовая среда.</p><p id="z9669ya_835">Но есть и границы. Kotest сложнее стартовать. Он не такой лёгкий, как <code class="code" id="z9669ya_865">kotlin.test</code>. Его интеграция с IDE не всегда бесшовна. Иногда нужно понимать, как устроен lifecycle, особенно если ты пишешь расширения или работаешь с Before/After-hooks. Документация покрывает многое, но не всё. Если ты новичок в Kotlin или хочешь просто проверить, что функция возвращает true тебе, возможно, не нужен весь этот DSL.</p><p id="z9669ya_836">И вот здесь и возникает выбор. Если тебе нужно писать простые тесты быстро и платформонейтрально <code class="code" id="z9669ya_866">kotlin.test</code> даст всё, что нужно. Он строг, предсказуем и не требует инфраструктуры. Но если ты хочешь описывать поведение системы в терминах, близких к языку, если тебе важна выразительность, вложенность, property-based тестирование, гибкая конфигурация и DSL, написанный именно для Kotlin Kotest берёт это всё на себя. Не по лицензии. По замыслу.</p><p id="z9669ya_837">И делает это лучше всех на JVM.</p></section></section><section class="chapter"><h2 id="8" data-toc="8">8. Заключение: Тесты как мышление, а не как процедура</h2><p id="z9669ya_867">Мы прошли путь от <code class="code" id="z9669ya_874">assertEquals(expected, actual)</code> до архитектуры JUnit Platform. От простого сравнения двух значений до понимания того, как работает вся инфраструктура тестирования на JVM. Это не случайность. Тестирование начинается с философии, а заканчивается инженерией.</p><p id="z9669ya_868">Если вы запомните из этой статьи только одну мысль, пусть это будет следующая: <span class="control" id="z9669ya_875">тест - это не проверка, а модель</span>. Когда вы пишете <code class="code" id="z9669ya_876">assertTrue(user.isActive())</code>, вы не проверяете, активен ли пользователь в реальности. Вы фиксируете соглашение о том, что в заданных условиях свойство <code class="code" id="z9669ya_877">isActive</code> должно возвращать <code class="code" id="z9669ya_878">true</code>. Это контракт между вами и системой. И когда тест падает - нарушается не &quot;истина&quot;, а именно этот контракт.</p><p id="z9669ya_869">Test Doubles - stub, mock, fake, spy - это не просто технические приёмы. Это способы построения контролируемых миров, где можно изолированно проверить отдельные аспекты поведения. Выбор между ними отражает ваш подход к архитектуре: что важно контролировать, что можно упростить, а что необходимо сохранить в первозданном виде.</p><p id="z9669ya_870">JUnit прошёл эволюцию от процедурного фреймворка к платформе. Сегодня JUnit 5 - это не просто библиотека для написания unit-тестов, это инфраструктура, на которой строятся другие подходы к тестированию: от Kotest с его выразительным DSL до Cucumber с BDD-сценариями. Понимание этой архитектуры даёт возможность не только использовать готовые решения, но и создавать свои.</p><p id="z9669ya_871">Kotlin привносит в тестирование ту же философию, что и в основной код: лаконичность без потери выразительности, строгость без излишней ceremony. <code class="code" id="z9669ya_879">kotlin.test</code> даёт платформонейтральный минимум. Kotest - богатую экосистему для тех, кто хочет описывать поведение системы как спецификацию, а не как набор процедур.</p><p id="z9669ya_872">Но главное не в выборе инструментов. Главное - в понимании того, что вы тестируете и зачем. Каждый <code class="code" id="z9669ya_880">@Test</code> - это гипотеза о поведении системы. Каждый assert - это граница между допустимым и недопустимым. И чем яснее эти границы, тем надёжнее система и тем проще её развивать.</p><p id="z9669ya_873">В следующих частях серии мы углубимся в практические аспекты: как работают популярные фреймворки для тестирования, как работает тестовая инфраструктура под капотом, как избежать иллюзий стабильности и построить пирамиду тестов, которая действительно работает. Но основа уже заложена. Тесты - это не проверка того, что код работает. Это способ формализовать то, как он должен работать. И если вы это понимаете - вы уже на правильном пути.</p></section><div class="last-modified">30 июля 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="decompose-save-state-internal.html" class="navigation-links__prev">Decompose и Essenty: под капотом сохранения состояния без ViewModel</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>