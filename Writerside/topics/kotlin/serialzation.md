# Введение

В этой статье мы рассмотрим технологии сериализации и десериализации данных в контексте экосистемы Android, Java, Kotlin JVM и Kotlin Native.

Сериализация и десериализация являются фундаментальными операциями в современной разработке. Эти процессы используются повсеместно: от хранения данных в локальном хранилище устройства до передачи информации по сети. Многие NoSQL базы данных применяют собственные форматы сериализации для оптимизации производительности. Наиболее распространённые форматы обмена данными — JSON, XML, Protocol Buffers, MessagePack и другие — тесно связаны с процессами сериализации.

Существует два основных подхода к реализации сериализации. Первый основан на рефлексии (reflection), которая позволяет анализировать структуру объектов во время выполнения (runtime), но сопряжена с накладными расходами на производительность. Второй подход использует кодогенерацию во время компиляции (compile-time), что значительно ускоряет обработку данных за счёт генерации специализированного кода. Например, Protocol Buffers требует предварительного описания контракта данных в `.proto` файлах, что позволяет генерировать оптимизированный код и устранять избыточные операции при десериализации.

При оценке решений для сериализации обычно приоритетным является скорость обработки, затем — размер сериализованных данных, и лишь потом — потребление оперативной памяти. Впрочем, для мобильных устройств и встраиваемых систем баланс этих факторов может смещаться в пользу минимизации памяти и размера данных.

В рамках данной статьи мы проанализируем существующие библиотеки и подходы к сериализации объектов в JVM и Native экосистемах, проведём сравнительное тестирование их производительности и выясним, какие решения являются наиболее эффективными в различных сценариях использования. Помимо получения конкретных метрик, мы также исследуем технические причины, определяющие производительность каждого подхода.

Для единообразия терминологии начнём с определения базовых понятий и терминов.


## Базис

**Сериализация** — процесс преобразования структурированных данных (объектов, структур данных) в последовательность байтов или текстовое представление, пригодное для хранения или передачи. Сериализация «упаковывает» состояние объекта в формат, который можно сохранить в файл, передать по сети или поместить в базу данных.

**Десериализация** — обратный процесс восстановления объекта из его сериализованного представления. Десериализация «распаковывает» последовательность байтов или текст обратно в структурированный объект с сохранением его типа и данных.

**Рефлексия (Reflection)** — механизм времени выполнения, позволяющий программе анализировать и модифицировать свою собственную структуру и поведение. В контексте сериализации рефлексия используется для динамического обхода полей объектов без предварительной генерации кода.

**Кодогенерация (Code Generation)** — автоматическое создание исходного кода во время компиляции на основе аннотаций, схем данных или других метаданных. Кодогенерация устраняет накладные расходы рефлексии за счёт создания специализированных классов-сериализаторов.

**Контракт данных (Data Contract/Schema)** — формальное описание структуры данных, определяющее типы полей, их названия и правила валидации. Используется в Protocol Buffers (.proto файлы), Apache Avro и других схемо-ориентированных форматах.