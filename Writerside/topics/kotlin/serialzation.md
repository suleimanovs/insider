# Введение

В этой статье мы рассмотрим технологии сериализации и десериализации данных в контексте экосистемы Android, Java, Kotlin JVM и Kotlin Native.

Сериализация и десериализация являются фундаментальными операциями в современной разработке. Эти процессы используются повсеместно: от хранения данных в локальном хранилище устройства до передачи информации по сети. Многие NoSQL базы данных применяют собственные форматы сериализации для оптимизации производительности. Наиболее распространённые форматы обмена данными (JSON, XML, Protocol Buffers, MessagePack и другие) тесно связаны с процессами сериализации.

Существует два основных подхода к реализации сериализации. Первый основан на рефлексии (reflection), которая позволяет анализировать структуру объектов во время выполнения (runtime), но сопряжена с накладными расходами на производительность. Второй подход использует кодогенерацию во время компиляции (compile-time), что значительно ускоряет обработку данных за счёт генерации специализированного кода. Например, Protocol Buffers требует предварительного описания контракта данных в `.proto` файлах, что позволяет генерировать оптимизированный код и устранять избыточные операции при десериализации.

При оценке решений для сериализации обычно приоритетным является скорость обработки, затем размер сериализованных данных, и лишь потом потребление оперативной памяти. Впрочем, для мобильных устройств и встраиваемых систем баланс этих факторов может смещаться в пользу минимизации памяти и размера данных.

В рамках данной статьи мы проанализируем существующие библиотеки и подходы к сериализации объектов в JVM и Native экосистемах. Мы детально рассмотрим четыре основных подхода: классический `Serializable` из Java, его расширение `Externalizable`, специфичный для Android `Parcelable`, а также современный `kotlinx.serialization`. Для каждого из них мы проведём сравнительное тестирование производительности и выясним, какие решения являются наиболее эффективными в различных сценариях использования. Помимо получения конкретных метрик, мы также исследуем технические причины, определяющие производительность каждого подхода.

Для единообразия терминологии начнём с определения базовых понятий и терминов.


## Базис

**Сериализация** — это процесс преобразования структурированных данных (объектов, структур данных) в последовательность байтов или текстовое представление, пригодное для хранения или передачи. Сериализация «упаковывает» состояние объекта в формат, который можно сохранить в файл, передать по сети или поместить в базу данных.

**Десериализация** — это обратный процесс восстановления объекта из его сериализованного представления. Десериализация «распаковывает» последовательность байтов или текст обратно в структурированный объект с сохранением его типа и данных.

![serialization.svg](serialization.svg)


**Рефлексия (Reflection)** — это механизм времени выполнения, позволяющий программе анализировать и модифицировать свою собственную структуру и поведение. В контексте сериализации рефлексия используется для динамического обхода полей объектов без предварительной генерации кода. Естественно неформально рефлексия в мире разработки считается темной магией.

**Кодогенерация (Code Generation)** — это автоматическое создание исходного кода во время компиляции на основе аннотаций, схем данных или других метаданных. Кодогенерация устраняет накладные расходы рефлексии за счёт создания специализированных классов-сериализаторов. Сама кодогенерация так же достигается благодаря рефлексии или же hook-ов компилятора. В мире JVM это долгое время было APT, позже KAPT, далее эволюция Kotlin подарила KSP.

**Контракт данных (Data Contract/Schema)** — это формальное описание структуры данных, определяющее типы полей, их названия и правила валидации. Используется в Protocol Buffers (.proto файлы), Apache Avro и других схемо-ориентированных форматах.

Теперь, когда мы определились с базовой терминологией, перейдем к рассмотрению конкретных способов сериализации. Мы рассмотрим их в порядке исторической эволюции с точки зрения Kotlin и Android. Что интересно, в мире Java эволюции как таковой не произошло: первое решение, появившееся еще в ранних версиях JDK, продолжает использоваться и по сей день.

## Интерфейс Serializable

Начнем наше погружение с интерфейса `Serializable`, который является самым первым и, пожалуй, наиболее распространенным способом сериализации в мире JVM. `Serializable` представляет собой интерфейс-маркер, то есть интерфейс, не содержащий никакой логики. Рассмотрим его исходный код:
```java
package java.io;

public interface Serializable {
}
```

Как видите, интерфейс абсолютно пуст. Возникает логичный вопрос: как же пустой интерфейс может что-то делать? На самом деле, `Serializable` работает как маркер для JVM, сигнализирующий, что класс разрешает свою сериализацию. Вся магия происходит на уровне runtime через рефлексию, о чем мы подробно поговорим дальше.

Давайте создадим простой класс и посмотрим, как работает сериализация на практике. Для примера возьмем класс `Person` с базовой информацией о человеке:

```kotlin
data class Person( 
    val name: String, 
    val dateOfBirth: Int, 
    val address: String
): Serializable
```

Обратите внимание, что для превращения обычного класса в сериализуемый нам достаточно добавить `: Serializable` после объявления класса. Никаких дополнительных методов или полей реализовывать не нужно.

Теперь давайте попробуем сериализовать объект этого класса и сохранить его в файл. Процесс будет выглядеть следующим образом:

```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("serialization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```

Что здесь происходит? Мы создаём объект `Person` с данными о John Wick, затем создаём файл `serialization.bin`, открываем поток для записи в этот файл и, наконец, оборачиваем его в `ObjectOutputStream`. Именно вызов `writeObject(person)` запускает весь механизм сериализации, превращая наш объект в последовательность байтов.

После выполнения кода мы получим файл `serialization.bin` с нашими сериализованными данными. Из любопытства давайте попробуем открыть этот файл в текстовом редакторе. Вот что мы увидим:
```text
�� sr PersonTZ���c I dateOfBirthL addresst Ljava/lang/String;L nameq ~ xp  �t New Yorkt John Doe
```
Выглядит жутковато, не правда ли? Файл явно не предназначен для чтения человеком из-за бинарного формата, и текстовый редактор с трудом пытается интерпретировать байты как UTF-8 символы. Тем не менее, если присмотреться, среди "кракозябр" можно разглядеть вполне читаемые фрагменты: названия полей (`name`, `address`), их типы (`Ljava/lang/String`), название класса (`Person`) и даже значения полей (`New York`, `John Doe`).

Вы можете задаться вопросом: если сериализация представляет собой превращение объекта в байты, то почему мы видим не нули и единицы, а относительно читаемый текст? Ответ прост: текстовый редактор пытается интерпретировать байты как символы UTF-8. Некоторые байтовые последовательности случайно совпадают с кодами печатных символов, поэтому мы и видим эти фрагменты текста среди непонятных символов.

Но откуда же в файле взялась вся эта информация о структуре нашего класса? Мы ведь нигде явно не указывали, какие поля сохранять и как их называть. Здесь начинается самое интересное: `Serializable` полностью работает на основе Reflection API. JVM автоматически анализирует структуру нашего класса во время выполнения и извлекает всю необходимую метаинформацию.

Рефлексия и вся магия `Serializable` проявляется с момента создания `ObjectOutputStream`, а если быть точнее, с момента вызова функции `writeObject`. Именно в этом методе происходит вся основная работа: он берет наш объект класса `Person`, сериализует его и затем записывает в файл `serialization.bin`.

Важно понимать архитектуру: сам `ObjectOutputStream` на самом деле ничего не знает о нашем файле `serialization.bin`. Вместо этого `ObjectOutputStream` работает с `FileOutputStream`, который и является посредником между файлом и объектом. Это классический паттерн проектирования "Декоратор" (Decorator). На самом деле, большинство видов Stream-ов (наследники `InputStream` и `OutputStream`) являются декораторами, добавляющие дополнительную функциональность к базовому потоку.

Процесс десериализации работает зеркально:
```kotlin
fun main(args: Array<String>) {
    val file = File("serialization.bin")
    val fileInputStream = FileInputStream(file)
    val objectInputStream = ObjectInputStream(fileInputStream).use { stream ->
        print(stream.readObject() as Person)
    }
}
```

Мы находим файл и затем передаем его в `FileInputStream`, чтобы восстановить объект `Person` из сохраненного набора байтов. Давайте убедимся, что интерфейс `Serializable` действительно необходим. Если мы уберем у класса `Person` наследование от интерфейса `Serializable`, то получим такую ошибку:
```
Exception in thread "main" java.io.NotSerializableException: Person
```

Эта ошибка подтверждает, что маркерный интерфейс `Serializable` является обязательным условием для сериализации объекта.

### Внутреннее устройство

Теперь давайте погрузимся глубже и посмотрим, как работает сериализация под капотом. Рассмотрим исходный код метода `writeObject` класса `ObjectOutputStream`, ведь именно он принимает объект класса `Person` и преобразует его в набор байтов:
```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    public final void writeObject(Object obj) throws IOException {
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            writeObject0(obj, false);
        } catch (IOException ex) {
            if (depth == 0) {
                writeFatalException(ex);
            }
            throw ex;
        }
    }
}
```

Этот метод своего рода Provider, если от класса унаследовались и переопределили открытый метод для переопределения, то будет использована
логика наследника, иначе вызов передается методу `writeObject0` который является стандартным у `ObjectOutputStream`, в нашем случае мы не наследовались от ObjectOutputStream
поэтому мы попадаем в метод `writeObject0`:

```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeObject0(Object obj, boolean unshared)
            throws IOException
    {
        ...
        ObjectStreamClass desc = ObjectStreamClass.lookup(cl, true);
        ...
        
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(
                        cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
        ...
    }
}
```

Метод `writeObject0` содержит обширную логику по проверке объекта (например, проверки на not nullable, no classable, not streamable). В приведенном выше фрагменте оставлена только та часть логики, которая непосредственно отвечает за работу сериализации стандартного объекта.

Обратите внимание на важную строку, которую мы специально оставили в коде: создание объекта `ObjectStreamClass`. Этот объект играет ключевую роль во всем процессе сериализации. Рассмотрим подробнее вызов `ObjectStreamClass.lookup(cl, true)`. Именно здесь начинается реальная работа сериализации. 
Этот метод создает дескриптор класса (объект `ObjectStreamClass`), который фиксирует всю метаинформацию о типе, необходимую для его записи в поток. 
По сути, это сериализационный аналог рефлексии, но не на уровне исполнения, а на уровне протокола (контракта).

Метод `lookup` сначала проверяет внутренний кэш. Если дескриптор для данного класса уже существовал, он возвращается повторно. 
Если нет, то создается новый. В процессе создания выполняется полный анализ структуры класса:
определяются сериализуемые поля объекта, вычисляется `serialVersionUID`, проверяется наличие специальных методов (`writeObject`, `readObject`, `readResolve`, `writeReplace`), устанавливается связь с родительским дескриптором, фиксируются флаги, указывающие на природу класса (`enum`, `proxy`, `externalizable`, `record`).

Параметр `true` во втором аргументе означает, что дескрипторы создаются не только для самого класса, но и для всей цепочки его сериализуемых предков. Это важно: сериализация в Java всегда знает структуру объекта вплоть до первого не-`Serializable` родителя, и именно `lookup` формирует эту иерархию.

Результатом вызова становится объект `desc`, который будет передан в `writeOrdinaryObject`. Все дальнейшие шаги (запись сигнатуры, `serialVersionUID`, набора полей и их значений) выполняются строго в соответствии с тем, что описано в этом дескрипторе. Если дескриптор изменить, изменится и байтовое представление.

Таким образом, `ObjectStreamClass.lookup` является точкой перехода от уровня кода к уровню протокола сериализации. 
До этого момента JVM работала с объектом как с экземпляром типа, после же работает с набором описанных структур и байтов, имея всю информацию о том, кто перед ним сейчас. Сам по себе этот вызов в первый раз занимает очень много времени и памяти, это первый залп использования рефлексии для сериализации.

Вернемся к методу `writeObject0` и рассмотрим последовательность проверок, которые он выполняет. После создания дескриптора класса начинается каскад проверок типа объекта:

1. Сначала проверяется, является ли объект строкой (`String`). Строковые значения обрабатываются специальным образом, так как сериализуются более эффективно.
2. Далее проверяется, является ли класс массивом.
3. После идет проверка на `enum`.

> Любой enum в JVM является Serializable по умолчанию, все потому что все enum классы не явно наследуются от настоящего класса java.lang.Enum. А класс java.lang.Enum уже наследуется от интерфейса Serializable

4. Наконец, если объект не подпадает ни под одну из специальных категорий, проверяется, реализует ли он интерфейс `Serializable`.

По итогу всех этих проверок происходит одно из двух: либо мы попадаем под категорию `Serializable` и продолжаем сериализацию, либо получаем ошибку `NotSerializableException`.

Для классов, реализующих `Serializable`, вызывается метод `writeOrdinaryObject`. После того как `writeObject0` определяет, что данный объект действительно реализует интерфейс `Serializable`, управление передаётся в этот метод.
Именно он отвечает за запись «обычного» объекта в поток, то есть объекта, не являющегося строкой, массивом, перечислением или экземпляром `Externalizable`. 
В этом месте начинается реальная работа сериализационного механизма. Метод выглядит следующим образом, далее мы увидим его разбор:
```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
            throws IOException
    {
        ...
            desc.checkSerialize();

            bout.writeByte(TC_OBJECT);
            writeClassDesc(desc, false);
            handles.assign(unshared ? null : obj);

            if (desc.isRecord()) {
                writeRecordData(obj, desc);
            } else if (desc.isExternalizable() && !desc.isProxy()) {
                writeExternalData((Externalizable) obj);
            } else {
                writeSerialData(obj, desc);
            }
        }
        ...
    }
}
```

Первое, что делает `writeOrdinaryObject`, это вызов `desc.checkSerialize()`.
Этот вызов не просто формальность, а гарантия того, что класс, описанный `ObjectStreamClass desc`, удовлетворяет всем требованиям контракта сериализации. 
Здесь происходит верификация флага `Serializable`, проверка корректности сигнатуры специальных методов `writeObject` и `readObject`, а также проверка соответствия вычисленного `serialVersionUID` тому, что объявлен явно. 
Если класс нарушает контракт, поток прерывается исключением `NotSerializableException`. Таким образом, сериализация никогда не начнётся для объекта, который не способен пройти эти структурные проверки.

После успешной валидации в поток записывается первый управляющий байт `TC_OBJECT`. Этот байт представляет собой сериализационный маркер, используемый `ObjectInputStream` при чтении потока для распознавания того, что далее следует именно объектная структура, а не строка, массив, ссылка или иной тип элемента.
Механизм Object Serialization в Java использует фиксированный бинарный протокол, где каждый элемент (объект, класс, поле, массив и т.д.) предваряется своим маркером. Для объекта это `0x73`, то есть байт `TC_OBJECT`. Таким образом, запись объекта всегда начинается с этого маркера.

Следом вызывается `writeClassDesc(desc, false)`.
В этом месте сериализация переходит от конкретного экземпляра к описанию его класса. Метод `writeClassDesc` отвечает за запись дескриптора класса, то есть структуры, содержащей имя класса, `serialVersionUID`, количество и типы сериализуемых полей, а также ссылки на суперклассы.
Если этот дескриптор уже встречался ранее в потоке, то вместо полного описания записывается ссылка `TC_REFERENCE`, указывающая на уже существующий дескриптор. Это экономит место и поддерживает консистентность структуры потока. Если же класс сериализуется впервые, то в поток последовательно записываются имя, версия, список полей и другие метаданные.
Именно благодаря `writeClassDesc` десериализация на другой стороне способна понять, как восстанавливать объект: какой класс использовать, какие поля прочитать и в каком порядке.

После записи дескриптора выполняется `handles.assign(unshared ? null : obj)`.
Это ключевой момент, связанный с таблицей хэндлов (handle table). Object Serialization в Java гарантирует сохранение ссылочной целостности: если один и тот же объект встречается несколько раз в графе, сериализатор не будет писать его заново, а запишет ссылку (`TC_REFERENCE`) на уже записанный экземпляр.
Для этого все объекты, прошедшие через поток, регистрируются в таблице хэндлов, где каждому объекту присваивается уникальный идентификатор.
Вызов `assign` выполняет именно это назначение. Если же объект помечен как `unshared`, то он не регистрируется, и в дальнейшем на него нельзя будет сослаться повторно. Такой флаг используется редко, но имеет значение при необходимости полного разрыва ссылочной связанности между частями сериализуемого графа.

На следующем этапе `writeOrdinaryObject` определяет конкретную природу класса. Здесь начинается развилка на три категории:

1. Если класс является `record`, вызывается `writeRecordData`.
2. Если класс реализует `Externalizable` (и при этом не является proxy), вызывается `writeExternalData`.
3. Во всех остальных случаях используется классическая ветвь `writeSerialData`.

Рассмотрим их последовательно.

**1. Record.**
Если `desc.isRecord()` возвращает `true`, то текущий класс является Java Record. Сериализация record-классов подчиняется отдельной логике, введённой начиная с Java 16. В отличие от обычных классов, record не имеет изменяемого состояния, все его поля являются компонентами, определёнными в сигнатуре конструктора.
Метод `writeRecordData` проходит по всем компонентам record в порядке их объявления и записывает их значения напрямую, без вызова `writeObject` или `writeExternal`. Это обеспечивает стабильный, детерминированный формат сериализации, независимый от пользовательских переопределений.
> Если вы из старой школы, и писали на Java 8,11 то вы не успели достать Record классы, это своего рода аналог data class в Kotlin 

**2. Externalizable.**
Про Externalizable мы так же подробно пройдемся в этой статье, но пока для контекста его стоит тоже учитывать.
Если класс реализует интерфейс `Externalizable`, управление передаётся в `writeExternalData`. В этом случае сериализация полностью делегируется самому объекту.
Метод `writeExternalData` вызывает `obj.writeExternal(ObjectOutput)`. Здесь именно класс решает, какие данные и в каком порядке записывать в поток. В отличие от `Serializable`, где платформа управляет сериализацией автоматически, `Externalizable` предоставляет полную свободу, но и полную ответственность разработчику.
Важно отметить, что `writeOrdinaryObject` вызывает этот путь только если класс действительно Externalizable и не является proxy, поскольку динамические proxy обрабатываются иначе.

**3. Serializable (обычный случай).**
Если объект не является record и не Externalizable, остаётся классическая сериализация `Serializable`.
В этом случае вызывается `writeSerialData(obj, desc)`.
Именно этот метод и есть ядро стандартной сериализации Java. Он отвечает за последовательную запись всех сериализуемых полей объекта, включая унаследованные от суперклассов, а также за вызов пользовательских методов `writeObject`, если они определены в классе.
Внутри `writeSerialData` сначала записываются данные суперклассов, затем поля текущего класса. Если в классе определён метод `private void writeObject(ObjectOutputStream oos)`, он вызывается с передачей текущего потока, что позволяет переопределить стандартный формат записи.
Если такого метода нет, вызывается `defaultWriteFields`, который просто записывает все поля по описанию из `ObjectStreamClass desc`.

Таким образом, `writeOrdinaryObject` не содержит непосредственно логики записи самих данных. Он лишь определяет маршрут, то есть какую стратегию применить для конкретного типа класса. Это точка маршрутизации, своего рода диспетчер сериализации, обеспечивающий единообразие протокола при сохранении гибкости для различных типов.

После выполнения одной из ветвей (record, externalizable или serializable) объект полностью записан в поток, а таблица хэндлов зафиксирована для поддержания ссылочной целостности. Нас особенно интересует третья ветвь — обычная сериализация через `Serializable`. Давайте рассмотрим метод `writeSerialData` более подробно:

```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeSerialData(Object obj, ObjectStreamClass desc)
            throws IOException
    {
        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
        for (int i = 0; i < slots.length; i++) {
            ObjectStreamClass slotDesc = slots[i].desc;
            if (slotDesc.hasWriteObjectMethod()) {
                PutFieldImpl oldPut = curPut;
                curPut = null;
                SerialCallbackContext oldContext = curContext;

                if (extendedDebugInfo) {
                    debugInfoStack.push(
                            "custom writeObject data (class \"" +
                                    slotDesc.getName() + "\")");
                }
                try {
                    curContext = new SerialCallbackContext(obj, slotDesc);
                    bout.setBlockDataMode(true);
                    slotDesc.invokeWriteObject(obj, this);
                    bout.setBlockDataMode(false);
                    bout.writeByte(TC_ENDBLOCKDATA);
                } finally {
                    curContext.setUsed();
                    curContext = oldContext;
                    if (extendedDebugInfo) {
                        debugInfoStack.pop();
                    }
                }

                curPut = oldPut;
            } else {
                defaultWriteFields(obj, slotDesc);
            }
        }
    }

}
```

Как мы помним из предыдущего раздела, этот метод вызывается для объектов, которые не являются ни record, ни externalizable, а представляют собой обычные классы, реализующие `Serializable`. Метод `writeSerialData` является тем местом, на который в большинстве случаев и замыкается сериализация. Если `writeOrdinaryObject` можно назвать маршрутизатором, то `writeSerialData` является исполнителем — именно здесь происходит фактическая запись состояния объекта.

В начале метода формируется массив `slots`, получаемый через `desc.getClassDataLayout()`. Это внутреннее представление иерархии классов, участвующих в сериализации. Каждый элемент массива представляет собой `ClassDataSlot`, содержащий ссылку на `ObjectStreamClass` конкретного уровня наследования. Таким образом, `slots` задаёт строгий порядок обхода цепочки классов сверху вниз, от самого предка, объявившего сериализуемые поля, до конечного потомка.

Далее выполняется цикл по этим слотам. Для каждого класса, представленного в `slotDesc`, сериализатор проверяет, определён ли в нём пользовательский метод `writeObject(ObjectOutputStream)`. Проверка осуществляется вызовом `slotDesc.hasWriteObjectMethod()`. Это та самая возможность, которая позволяет классу вмешаться в процесс сериализации и частично управлять тем, какие данные и в каком виде попадут в поток.

Если пользовательский `writeObject` найден, то создаётся контекст сериализационного коллбэка, представляющий собой объект `SerialCallbackContext`. Он необходим для корректного управления вложенными вызовами, в частности для обеспечения симметричной работы с `readObject` при десериализации. После этого включается блочный режим записи (`bout.setBlockDataMode(true)`), который группирует данные, записанные в процессе пользовательского `writeObject`, в единый блок. Это гарантирует, что весь пользовательский сегмент данных будет интерпретирован при чтении как одно логическое целое.

Далее вызывается сам метод `slotDesc.invokeWriteObject(obj, this)`. Это точка, где фактическое управление передаётся пользовательскому коду. Если класс переопределил `writeObject`, его логика выполняется здесь, с возможностью напрямую вызывать `defaultWriteObject()` или вручную записывать отдельные поля. После завершения блока запись возвращается в нормальный режим (`bout.setBlockDataMode(false)`), а затем в поток добавляется байт `TC_ENDBLOCKDATA`, обозначающий конец пользовательских данных.

Все временные структуры (`curPut`, `curContext`) восстанавливаются, чтобы состояние сериализатора осталось консистентным. Если же `extendedDebugInfo` включён, стек отладочной информации очищается. В случае отсутствия пользовательского метода выполняется стандартный путь: `defaultWriteFields(obj, slotDesc)`. Этот метод последовательно проходит по всем полям, определённым в `ObjectStreamClass`, и записывает их значения с использованием соответствующих механизмов сериализации (для примитивов это прямое бинарное значение, для ссылочных типов это рекурсивный вызов `writeObject0`).

Именно здесь завершается реальная работа сериализации объекта. После завершения цикла по всем слотам поток содержит полную бинарную структуру экземпляра, от базовых классов до финальных полей, с учётом всех пользовательских переопределений. Таким образом, `writeSerialData` является той точкой, где логическая модель класса превращается в поток байтов. Всё, что было подготовлено до этого (дескрипторы, таблицы хэндлов, метаданные), служит лишь инфраструктурой, обеспечивающей, чтобы эти байты могли быть восстановлены обратно в идентичный объект. После завершения `writeSerialData` объект считается полностью сериализованным, а поток готов к переходу к следующему элементу.
