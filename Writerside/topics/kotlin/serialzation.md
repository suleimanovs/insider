![serializationBanner.svg](serializationBanner.svg)

# Введение

В этой статье мы рассмотрим технологии сериализации и десериализации данных в контексте экосистемы Android, Java, Kotlin JVM и Kotlin Native.

Сериализация и десериализация являются фундаментальными операциями в современной разработке. Эти процессы используются повсеместно: от хранения данных в локальном хранилище устройства до передачи информации по сети. Многие NoSQL базы данных применяют собственные форматы сериализации для оптимизации производительности. Наиболее распространённые форматы обмена данными (JSON, XML, Protocol Buffers, MessagePack и другие) тесно связаны с процессами сериализации.

Существует два основных подхода к реализации сериализации. Первый основан на рефлексии (reflection), которая позволяет анализировать структуру объектов во время выполнения (runtime), но сопряжена с накладными расходами на производительность. Второй подход использует кодогенерацию во время компиляции (compile-time), что значительно ускоряет обработку данных за счёт генерации специализированного кода. Например, Protocol Buffers требует предварительного описания контракта данных в `.proto` файлах, что позволяет генерировать оптимизированный код и устранять избыточные операции при десериализации.

При оценке решений для сериализации обычно приоритетным является скорость обработки, затем размер сериализованных данных, и лишь потом потребление оперативной памяти. Впрочем, для мобильных устройств и встраиваемых систем баланс этих факторов может смещаться в пользу минимизации памяти и размера данных.

В рамках данной статьи мы проанализируем существующие библиотеки и подходы к сериализации объектов в JVM и Native экосистемах. Мы детально рассмотрим четыре основных подхода: классический `Serializable` из Java, его расширение `Externalizable`, специфичный для Android `Parcelable`, а также современный `kotlinx.serialization`. Для каждого из них мы проведём сравнительное тестирование производительности и выясним, какие решения являются наиболее эффективными в различных сценариях использования. Помимо получения конкретных метрик, мы также исследуем технические причины, определяющие производительность каждого подхода.

Для единообразия терминологии начнём с определения базовых понятий и терминов.


## Базис

**Сериализация** — это процесс преобразования структурированных данных (объектов, структур данных) в последовательность байтов или текстовое представление, пригодное для хранения или передачи. Сериализация «упаковывает» состояние объекта в формат, который можно сохранить в файл, передать по сети или поместить в базу данных.

**Десериализация** — это обратный процесс восстановления объекта из его сериализованного представления. Десериализация «распаковывает» последовательность байтов или текст обратно в структурированный объект с сохранением его типа и данных.

![serialization.svg](serialization.svg)


**Рефлексия (Reflection)** — это механизм времени выполнения, позволяющий программе анализировать и модифицировать свою собственную структуру и поведение. В контексте сериализации рефлексия используется для динамического обхода полей объектов без предварительной генерации кода. Естественно неформально рефлексия в мире разработки считается темной магией.

**Кодогенерация (Code Generation)** — это автоматическое создание исходного кода во время компиляции на основе аннотаций, схем данных или других метаданных. Кодогенерация устраняет накладные расходы рефлексии за счёт создания специализированных классов-сериализаторов. Сама кодогенерация так же достигается благодаря рефлексии или же hook-ов компилятора. В мире JVM это долгое время было APT, позже KAPT, далее эволюция Kotlin подарила KSP. Начиная с Kotlin 2.0 теперь так же есть возможность реализовать плагины компилятора, которая ранее была закрыта для сторонних разработчиков.
![codeGeneration.svg](codeGeneration.svg)


**Контракт данных (Data Contract/Schema)** — это формальное описание структуры данных, определяющее типы полей, их названия и правила валидации. Используется в Protocol Buffers (.proto файлы), Apache Avro и других схемо-ориентированных форматах.
![codeProtocolScheme.svg](codeProtocolScheme.svg)

Теперь, когда мы определились с базовой терминологией, перейдем к рассмотрению конкретных способов сериализации. Мы рассмотрим их в порядке исторической эволюции с точки зрения Kotlin и Android. Что интересно, в мире Java эволюции как таковой не произошло: первое решение, появившееся еще в ранних версиях JDK, продолжает использоваться и по сей день.
Сначала мы пройдемся по каждому из подходов, разберем их под лупой, но никаких выводов по производительности не будем пока не рассмотрим все способы, в конце мы рсавним каждый из подходов что бы понять какой из них оптимальнее в использований.

## Интерфейс Serializable

Начнем наше погружение с интерфейса `Serializable`, который является самым первым и, пожалуй, наиболее распространенным способом сериализации в мире JVM. `Serializable` представляет собой интерфейс-маркер, то есть интерфейс, не содержащий никакой логики. Рассмотрим его исходный код:
```java
package java.io;

public interface Serializable {
}
```

Как видите, интерфейс абсолютно пуст. Возникает логичный вопрос: как же пустой интерфейс может что-то делать? На самом деле, `Serializable` работает как маркер для JVM, сигнализирующий, что класс разрешает свою сериализацию. Вся магия происходит на уровне runtime через рефлексию, о чем мы подробно поговорим дальше.

Давайте создадим простой класс и посмотрим, как работает сериализация на практике. Для примера возьмем класс `Person` с базовой информацией о человеке:

```kotlin
data class Person( 
    val name: String, 
    val dateOfBirth: Int, 
    val address: String
): Serializable
```

Обратите внимание, что для превращения обычного класса в сериализуемый нам достаточно добавить `: Serializable` после объявления класса. Никаких дополнительных методов или полей реализовывать не нужно.

Теперь давайте попробуем сериализовать объект этого класса и сохранить его в файл. Процесс будет выглядеть следующим образом:

```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("serialization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```

Что здесь происходит? Мы создаём объект `Person` с данными о John Wick, затем создаём файл `serialization.bin`, открываем поток(FileOutputStream) для записи в этот файл и, наконец, оборачиваем его в `ObjectOutputStream`. Именно вызов `writeObject(person)` запускает весь механизм сериализации, превращая наш объект в последовательность байтов.

После выполнения кода мы получим файл `serialization.bin` с нашими сериализованными данными. Из любопытства давайте попробуем открыть этот файл в текстовом редакторе. Вот что мы увидим:
```text
�� sr PersonTZ���c I dateOfBirthL addresst Ljava/lang/String;L nameq ~ xp  �t New Yorkt John Wick
```
Выглядит жутковато, не правда ли? Файл явно не предназначен для чтения человеком из-за бинарного формата, и текстовый редактор с трудом пытается интерпретировать байты как UTF-8 символы. Тем не менее, если присмотреться, среди "кракозябр" можно разглядеть вполне читаемые фрагменты: названия полей (`name`, `address`), их типы (`Ljava/lang/String`), название класса (`Person`) и даже значения полей (`New York`, `John Wick`).

Вы можете задаться вопросом: если сериализация представляет собой превращение объекта в байты, то почему мы видим не нули и единицы, а относительно читаемый текст? Ответ прост: текстовый редактор пытается интерпретировать байты как символы UTF-8. Некоторые байтовые последовательности случайно совпадают с кодами печатных символов, поэтому мы и видим эти фрагменты текста среди непонятных символов.

Но откуда же в файле взялась вся эта информация о структуре нашего класса? Мы ведь нигде явно не указывали, какие поля сохранять и как их называть. Здесь начинается самое интересное: `Serializable` полностью работает на основе Reflection API. JVM автоматически анализирует структуру нашего класса во время выполнения и извлекает всю необходимую метаинформацию.

Рефлексия и вся магия `Serializable` проявляется с момента создания `ObjectOutputStream`, а если быть точнее, с момента вызова функции `writeObject`. Именно в этом методе происходит вся основная работа: он берет наш объект класса `Person`, сериализует его и затем записывает в файл `serialization.bin`.

Важно понимать архитектуру: сам `ObjectOutputStream` на самом деле ничего не знает о нашем файле `serialization.bin`. Вместо этого `ObjectOutputStream` работает с `FileOutputStream`, который и является посредником между файлом и объектом. Это классический паттерн проектирования "Декоратор" (Decorator). На самом деле, большинство видов Stream-ов (наследники `InputStream` и `OutputStream`) являются декораторами, добавляющие дополнительную функциональность к базовому потоку(stream).

Процесс десериализации работает зеркально:
```kotlin
fun main(args: Array<String>) {
    val file = File("serialization.bin")
    val fileInputStream = FileInputStream(file)
    val objectInputStream = ObjectInputStream(fileInputStream).use { stream ->
        print(stream.readObject() as Person)
    }
}
```

Мы находим файл и затем передаем его в `FileInputStream`, чтобы восстановить объект `Person` из сохраненного набора байтов. Давайте убедимся, что интерфейс `Serializable` действительно необходим. Если мы уберем у класса `Person` наследование от интерфейса `Serializable`, то получим такую ошибку:
```
Exception in thread "main" java.io.NotSerializableException: Person
```

Эта ошибка подтверждает, что маркерный интерфейс `Serializable` является обязательным условием для сериализации объекта.

### Внутреннее устройство Serializable

Теперь давайте погрузимся глубже и посмотрим, как работает сериализация под капотом. Рассмотрим исходный код метода `writeObject` класса `ObjectOutputStream`, ведь именно он принимает объект класса `Person` и преобразует его в набор байтов:
```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    public final void writeObject(Object obj) throws IOException {
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            writeObject0(obj, false);
        } catch (IOException ex) {
            if (depth == 0) {
                writeFatalException(ex);
            }
            throw ex;
        }
    }
}
```

Этот метод своего рода Provider, если от класса унаследовались и переопределили открытый метод для переопределения, то будет использована
логика наследника, иначе вызов передается методу `writeObject0` который является стандартным у `ObjectOutputStream`, в нашем случае мы не наследовались от ObjectOutputStream
поэтому мы попадаем в метод `writeObject0`:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeObject0(Object obj, boolean unshared)
            throws IOException
    {
        ...
        ObjectStreamClass desc = ObjectStreamClass.lookup(cl, true);
        ...
        
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(
                        cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
        ...
    }
}
```

Метод `writeObject0` содержит обширную логику по проверке объекта (например, проверки на not nullable, no classable, not streamable). В приведенном выше фрагменте оставлена только та часть логики, которая непосредственно отвечает за работу сериализации стандартного объекта.

Обратите внимание на важную строку, которую мы специально оставили в коде: создание объекта `ObjectStreamClass`. Этот объект играет ключевую роль во всем процессе сериализации. Рассмотрим подробнее вызов `ObjectStreamClass.lookup(cl, true)`. Именно здесь начинается реальная работа сериализации. 
Этот метод создает дескриптор класса (объект `ObjectStreamClass`), который фиксирует всю метаинформацию о типе, необходимую для его записи в поток. 
По сути, это сериализационный аналог рефлексии, но не на уровне исполнения, а на уровне протокола (контракта).

Метод `lookup` сначала проверяет внутренний кэш. Если дескриптор для данного класса уже существовал, он возвращается повторно. 
Если нет, то создается новый. В процессе создания выполняется полный анализ структуры класса:
определяются сериализуемые поля объекта, вычисляется `serialVersionUID`, проверяется наличие специальных методов (`writeObject`, `readObject`, `readResolve`, `writeReplace`), устанавливается связь с родительским дескриптором, фиксируются флаги, указывающие на природу класса (`enum`, `proxy`, `externalizable`, `record`).

Параметр `true` во втором аргументе означает, что дескрипторы создаются не только для самого класса, но и для всей цепочки его сериализуемых предков. Это важно: сериализация в Java всегда знает структуру объекта вплоть до первого не-`Serializable` родителя, и именно `lookup` формирует эту иерархию.

Результатом вызова становится объект `desc`, который будет передан в `writeOrdinaryObject`. Все дальнейшие шаги (запись сигнатуры, `serialVersionUID`, набора полей и их значений) выполняются строго в соответствии с тем, что описано в этом дескрипторе. Если дескриптор изменить, изменится и байтовое представление.

Таким образом, `ObjectStreamClass.lookup` является точкой перехода от уровня кода к уровню протокола сериализации. 
До этого момента JVM работала с объектом как с экземпляром типа, после же работает с набором описанных структур и байтов, имея всю информацию о том, кто перед ним сейчас. Сам по себе этот вызов в первый раз занимает очень много времени и памяти, это первый залп использования рефлексии для сериализации.

Вернемся к методу `writeObject0` и рассмотрим последовательность проверок, которые он выполняет. После создания дескриптора класса начинается каскад проверок типа объекта:

1. Сначала проверяется, является ли объект строкой (`String`). Строковые значения обрабатываются специальным образом, так как сериализуются более эффективно.
2. Далее проверяется, является ли класс массивом.
3. После идет проверка на `enum`.

> Любой enum в JVM является Serializable по умолчанию, все потому что все enum классы не явно наследуются от настоящего класса java.lang.Enum. А класс java.lang.Enum уже наследуется от интерфейса Serializable

4. Наконец, если объект не подпадает ни под одну из специальных категорий, проверяется, реализует ли он интерфейс `Serializable`.

По итогу всех этих проверок происходит одно из двух: либо мы попадаем под категорию `Serializable` и продолжаем сериализацию, либо получаем ошибку `NotSerializableException`.

Для классов, реализующих `Serializable`, вызывается метод `writeOrdinaryObject`. После того как `writeObject0` определяет, что данный объект действительно реализует интерфейс `Serializable`, управление передаётся в этот метод.
Именно он отвечает за запись «обычного» объекта в поток(stream), то есть объекта, не являющегося строкой, массивом, перечислением или экземпляром `Externalizable`(про него будет далее в статье). 
В этом месте начинается реальная работа сериализационного механизма. Метод выглядит следующим образом, далее мы увидим его разбор:
```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
            throws IOException
    {
        ...
            desc.checkSerialize();

            bout.writeByte(TC_OBJECT);
            writeClassDesc(desc, false);
            handles.assign(unshared ? null : obj);

            if (desc.isRecord()) {
                writeRecordData(obj, desc);
            } else if (desc.isExternalizable() && !desc.isProxy()) {
                writeExternalData((Externalizable) obj);
            } else {
                writeSerialData(obj, desc);
            }
        }
        ...
    }
}
```

Первое, что делает `writeOrdinaryObject`, это вызов `desc.checkSerialize()`.
Этот вызов не просто формальность, а гарантия того, что класс, описанный `ObjectStreamClass desc`, удовлетворяет всем требованиям контракта сериализации. 
Здесь происходит верификация флага `Serializable`, проверка корректности сигнатуры специальных методов `writeObject`, `readObject`, `readResolve`, `writeReplace`, а также проверка соответствия вычисленного `serialVersionUID` тому, что объявлен явно. 
Если класс нарушает контракт, поток прерывается исключением `NotSerializableException`. Таким образом, сериализация никогда не начнётся для объекта, который не способен пройти эти структурные проверки.

После успешной валидации в поток записывается первый управляющий байт `TC_OBJECT`. Этот байт представляет собой сериализационный маркер, используемый `ObjectInputStream` при чтении потока для распознавания того, что далее следует именно объектная структура, а не строка, массив, ссылка или иной тип элемента.
Механизм Object Serialization в Java использует фиксированный бинарный протокол, где каждый элемент (объект, класс, поле, массив и т.д.) предваряется своим маркером. Для объекта это `0x73`, то есть байт `TC_OBJECT`. Таким образом, запись объекта всегда начинается с этого маркера.

Следом вызывается `writeClassDesc(desc, false)`.
В этом месте сериализация переходит от конкретного экземпляра к описанию его класса. Метод `writeClassDesc` отвечает за запись дескриптора класса, то есть структуры, содержащей имя класса, `serialVersionUID`, количество и типы сериализуемых полей, а также ссылки на суперклассы.
Если этот дескриптор уже встречался ранее в потоке, то вместо полного описания записывается ссылка `TC_REFERENCE`, указывающая на уже существующий дескриптор. Это экономит место и поддерживает консистентность структуры потока. Если же класс сериализуется впервые, то в поток последовательно записываются имя, версия, список полей и другие метаданные.
Именно благодаря `writeClassDesc` десериализация на другой стороне способна понять, как восстанавливать объект: какой класс использовать, какие поля прочитать и в каком порядке.

После записи дескриптора выполняется `handles.assign(unshared ? null : obj)`.
Это ключевой момент, связанный с таблицей хэндлов (handle table). Object Serialization в Java гарантирует сохранение ссылочной целостности: если один и тот же объект встречается несколько раз в графе, сериализатор не будет писать его заново, а запишет ссылку (`TC_REFERENCE`) на уже записанный экземпляр.
Для этого все объекты, прошедшие через поток, регистрируются в таблице хэндлов, где каждому объекту присваивается уникальный идентификатор.
Вызов `assign` выполняет именно это назначение. Если же объект помечен как `unshared`, то он не регистрируется, и в дальнейшем на него нельзя будет сослаться повторно. Такой флаг используется редко, но имеет значение при необходимости полного разрыва ссылочной связанности между частями сериализуемого графа.

На следующем этапе `writeOrdinaryObject` определяет конкретную природу класса. Здесь начинается развилка на три категории:

1. Если класс является `record`, вызывается `writeRecordData`.
2. Если класс реализует `Externalizable` (и при этом не является proxy), вызывается `writeExternalData`.
3. Во всех остальных случаях используется классическая ветвь `writeSerialData`.

Рассмотрим их последовательно.

**1. Record.**
Если `desc.isRecord()` возвращает `true`, то текущий класс является Java Record. Сериализация record-классов подчиняется отдельной логике, введённой начиная с Java 16. В отличие от обычных классов, record не имеет изменяемого состояния, все его поля являются компонентами, определёнными в сигнатуре конструктора.
Метод `writeRecordData` проходит по всем компонентам record в порядке их объявления и записывает их значения напрямую, без вызова `writeObject` или `writeExternal`. Это обеспечивает стабильный, детерминированный формат сериализации, независимый от пользовательских переопределений.
> Если вы из той самой(старой) школы, где последняя знакомая версия Java это 8 или 11, то record-классы могли пройти мимо вас. Они появились только с Java 16 и стали для Java тем, чем data class давно является для Kotlin, то есть лаконичным способом объявить неизменяемую структуру данных, где конструктор, equals, hashCode и toString генерируются компилятором. Разница лишь в том, что Java сделала это без излишнего синтаксического романтизма.

**2. Externalizable.**
Про Externalizable мы так же подробно пройдемся в этой статье, но пока для контекста его стоит тоже учитывать.
Если класс реализует интерфейс `Externalizable`, управление передаётся в `writeExternalData`. В этом случае сериализация полностью делегируется самому объекту.
Метод `writeExternalData` вызывает `obj.writeExternal(ObjectOutput)`. Здесь именно класс решает, какие данные и в каком порядке записывать в поток. В отличие от `Serializable`, где платформа управляет сериализацией автоматически, `Externalizable` предоставляет полную свободу, но и полную ответственность разработчику.
Важно отметить, что `writeOrdinaryObject` вызывает этот путь только если класс действительно Externalizable и не является proxy, поскольку динамические proxy обрабатываются иначе.

**3. Serializable (обычный случай).**
Если объект не является record и не Externalizable, остаётся классическая сериализация `Serializable`.
В этом случае вызывается `writeSerialData(obj, desc)`.
Именно этот метод и есть ядро стандартной сериализации Java. Он отвечает за последовательную запись всех сериализуемых полей объекта, включая унаследованные от суперклассов, а также за вызов пользовательских методов `writeObject`, если они определены в классе.
Внутри `writeSerialData` сначала записываются данные суперклассов, затем поля текущего класса. Если в классе определён метод `private void writeObject(ObjectOutputStream oos)`, он вызывается с передачей текущего потока, что позволяет переопределить стандартный формат записи.
Если такого метода нет, вызывается `defaultWriteFields`, который просто записывает все поля по описанию из `ObjectStreamClass desc`.

Таким образом, `writeOrdinaryObject` не содержит непосредственно логики записи самих данных. Он лишь определяет маршрут, то есть какую стратегию применить для конкретного типа класса. Это точка маршрутизации, своего рода диспетчер сериализации, обеспечивающий единообразие протокола при сохранении гибкости для различных типов.

После выполнения одной из ветвей (record, externalizable или serializable) объект полностью записан в поток, а таблица хэндлов зафиксирована для поддержания ссылочной целостности. Нас особенно интересует третья ветвь, то есть обычная сериализация через `Serializable`. Давайте рассмотрим метод `writeSerialData` более подробно:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeSerialData(Object obj, ObjectStreamClass desc)
            throws IOException
    {
        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
        for (int i = 0; i < slots.length; i++) {
            ObjectStreamClass slotDesc = slots[i].desc;
            if (slotDesc.hasWriteObjectMethod()) {
                PutFieldImpl oldPut = curPut;
                curPut = null;
                SerialCallbackContext oldContext = curContext;

                try {
                    curContext = new SerialCallbackContext(obj, slotDesc);
                    bout.setBlockDataMode(true);
                    slotDesc.invokeWriteObject(obj, this);
                    bout.setBlockDataMode(false);
                    bout.writeByte(TC_ENDBLOCKDATA);
                } finally {
                    curContext.setUsed();
                    curContext = oldContext;
                }

                curPut = oldPut;
            } else {
                defaultWriteFields(obj, slotDesc);
            }
        }
    }

}
```

Как мы помним из предыдущего раздела, этот метод вызывается для объектов, которые не являются ни record, ни externalizable, а представляют собой обычные классы, реализующие `Serializable`. Метод `writeSerialData` является тем местом, на который в большинстве случаев и замыкается сериализация. Если `writeOrdinaryObject` можно назвать маршрутизатором, то `writeSerialData` является исполнителем, именно здесь происходит фактическая запись состояния объекта.

В начале метода формируется массив `slots`, получаемый через `desc.getClassDataLayout()`. Это внутреннее представление иерархии классов, участвующих в сериализации. Каждый элемент массива представляет собой `ClassDataSlot`, содержащий ссылку на `ObjectStreamClass` конкретного уровня наследования. Таким образом, `slots` задаёт строгий порядок обхода цепочки классов сверху вниз, от самого предка, объявившего сериализуемые поля, до конечного потомка.

Далее выполняется цикл по этим слотам. Для каждого класса, представленного в `slotDesc`, сериализатор проверяет, определён ли в нём пользовательский метод `writeObject(ObjectOutputStream)`. Проверка осуществляется вызовом `slotDesc.hasWriteObjectMethod()`. Это та самая возможность, которая позволяет классу вмешаться в процесс сериализации и частично управлять тем, какие данные и в каком виде попадут в поток.

Если пользовательский `writeObject` найден, то создаётся контекст сериализационного коллбэка, представляющий собой объект `SerialCallbackContext`. Он необходим для корректного управления вложенными вызовами, в частности для обеспечения симметричной работы с `readObject` при десериализации. После этого включается блочный режим записи (`bout.setBlockDataMode(true)`), который группирует данные, записанные в процессе пользовательского `writeObject`, в единый блок. Это гарантирует, что весь пользовательский сегмент данных будет интерпретирован при чтении как одно логическое целое.

Далее вызывается сам метод `slotDesc.invokeWriteObject(obj, this)`. Это точка, где фактическое управление передаётся пользовательскому коду. Если класс переопределил `writeObject`, его логика выполняется здесь, с возможностью напрямую вызывать `defaultWriteObject()` или вручную записывать отдельные поля. После завершения блока запись возвращается в нормальный режим (`bout.setBlockDataMode(false)`), а затем в поток добавляется байт `TC_ENDBLOCKDATA`, обозначающий конец пользовательских данных.

Все временные структуры (`curPut`, `curContext`) восстанавливаются, чтобы состояние сериализатора осталось консистентным. Если же `extendedDebugInfo` включён, стек отладочной информации очищается. В случае отсутствия пользовательского метода выполняется стандартный путь: `defaultWriteFields(obj, slotDesc)`. Этот метод последовательно проходит по всем полям, определённым в `ObjectStreamClass`, и записывает их значения с использованием соответствующих механизмов сериализации (для примитивов это прямое бинарное значение, для ссылочных типов это рекурсивный вызов `writeObject0`).

Именно здесь завершается реальная работа сериализации объекта. После завершения цикла по всем слотам поток содержит полную бинарную структуру экземпляра, от базовых классов до финальных полей, с учётом всех пользовательских переопределений. Таким образом, `writeSerialData` является той точкой, где логическая модель класса превращается в поток байтов. Всё, что было подготовлено до этого (дескрипторы, таблицы хэндлов, метаданные), служит лишь инфраструктурой, обеспечивающей, чтобы эти байты могли быть восстановлены обратно в идентичный объект. После завершения `writeSerialData` объект считается полностью сериализованным, а поток готов к переходу к следующему элементу.

### Контроль над процессом сериализации

Теперь поговорим о нескольких важных механизмах, которые позволяют контролировать процесс сериализации. Представьте ситуацию: вы сериализовали объект и сохранили его в файл. Спустя месяц вы изменили класс, добавили новое поле или удалили старое. Что произойдет, если попытаться десериализовать старый файл? JVM может просто отказаться это делать, выбросив `InvalidClassException`. Для решения этой проблемы существует специальное поле `serialVersionUID`. Это уникальный идентификатор версии класса, который записывается в поток при сериализации. При десериализации JVM сравнивает `serialVersionUID` из потока с `serialVersionUID` текущего класса. Если они совпадают, десериализация продолжается, если нет, выбрасывается исключение. Если не указывать `serialVersionUID` явно, JVM вычислит его автоматически на основе структуры класса (имен полей, методов, модификаторов доступа). Проблема в том, что любое малейшее изменение в классе изменит этот хеш, и старые сериализованные объекты станут несовместимыми.

```kotlin
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
) : Serializable {
    companion object {
        private const val serialVersionUID: Long = 1L
    }
}
```

Иногда в классе есть поля, которые не нужно или нельзя сериализовать. Например, это могут быть временные вычисляемые значения, кеши или чувствительные данные вроде паролей. В Java для этого существует ключевое слово `transient`, а в Kotlin используется аннотация `@Transient`. При сериализации все помеченные поля будут проигнорированы, а при десериализации они получат значения по умолчанию (null для объектов, 0 для чисел, false для boolean).

```kotlin
data class User(
    val username: String,
    @Transient val password: String = "",
    @Transient val cache: Cache? = null
) : Serializable
```

Что если стандартной сериализации недостаточно? Может быть, вы хотите зашифровать данные перед записью или выполнить какую-то предобработку? Для этого можно переопределить специальные методы `writeObject` и `readObject`:

```kotlin
class SecureUser(
    val username: String,
    private var password: String
) : Serializable {
    
    @Throws(IOException::class)
    private fun writeObject(out: ObjectOutputStream) {
        out.defaultWriteObject()
        val encrypted = encrypt(password)
        out.writeObject(encrypted)
    }
    
    @Throws(IOException::class, ClassNotFoundException::class)
    private fun readObject(input: ObjectInputStream) {
        input.defaultReadObject()
        val encrypted = input.readObject() as String
        password = decrypt(encrypted)
    }
    
    companion object {
        private const val serialVersionUID = 1L
    }
}
```

Обратите внимание, что эти методы должны быть `private`. Это может показаться странным, ведь обычно private методы не вызываются извне, но JVM использует рефлексию для их вызова.

Еще один интересный случай связан с синглтонами. При десериализации JVM создаст новый экземпляр объекта, нарушив паттерн Singleton. У вас появятся два "синглтона"! Чтобы этого избежать, используется метод `readResolve`:

```kotlin
object DatabaseConnection : Serializable {
    private const val serialVersionUID = 1L
    
    var host: String = "localhost"
    var port: Int = 5432
    
    private fun readResolve(): Any = DatabaseConnection
}
```

Метод вызывается сразу после десериализации объекта и может вернуть либо тот же объект, либо совершенно другой. В случае синглтона мы просто возвращаем существующий экземпляр, игнорируя десериализованный. Аналогично работает `writeReplace()`, который вызывается перед сериализацией и полезен, когда вы хотите сериализовать объект в более компактном виде.

Несмотря на кажущуюся простоту, `Serializable` таит в себе немало проблем. Использование рефлексии делает сериализацию медленной, каждый раз при сериализации JVM анализирует структуру класса через Reflection API. Бинарный формат Java содержит много метаинформации (имена классов, пакеты, типы полей), что увеличивает размер сериализованных данных. Изменение структуры класса легко ломает совместимость, даже добавление нового метода может изменить автоматически вычисляемый `serialVersionUID`. Десериализация непроверенных данных может привести к уязвимостям, когда злоумышленник создает специально сформированный поток байтов, который при десериализации выполнит вредоносный код. Наконец, при десериализации JVM создает объект, обходя конструктор, что означает, что любые проверки валидности в конструкторе будут проигнорированы.

При этом, все те возможности, которые мы только что рассмотрели (serialVersionUID, transient, writeObject, readResolve), на самом деле не решают главную проблему. Наше вмешательство минимально. Эти механизмы больше похожи на хуки или стандартные конфигурации, которые позволяют `Serializable` правильно работать в специфических случаях. Поле `serialVersionUID` нужно для версионирования, `readResolve` сохраняет синглтоны, `@Transient` исключает ненужные поля. Но ни один из этих методов не дает нам реального контроля над процессом сериализации и десериализации. Мы по-прежнему не можем влиять на производительность, не можем оптимизировать размер данных, не можем изменить формат записи. JVM продолжает использовать рефлексию, продолжает записывать всю метаинформацию, продолжает работать медленно. Мы просто пассажиры в этом процессе, которым разрешили настроить пару параметров.

Что если мы хотим большего? Что если нам нужен реальный контроль над тем, как именно сериализуются наши объекты? Для таких случаев у `Serializable` есть брат на стероидах.

## Интерфейс Externalizable

Если вы помните, в начале статьи мы говорили, что `Serializable` является маркерным интерфейсом без единого метода. JVM видит этот маркер и автоматически запускает механизм рефлексии. `Externalizable` работает совершенно иначе. Это не маркер, это контракт с двумя явными методами:

```java
public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}
```

Обратите внимание, что `Externalizable` наследуется от `Serializable`. Это важная деталь, которая означает, что объекты `Externalizable` по-прежнему участвуют в общем механизме Java сериализации, но с принципиально другим подходом. JVM больше не использует рефлексию для обхода полей. Вместо этого она просто вызывает ваши методы `writeExternal` и `readExternal`, полностью перекладывая ответственность на вас. Полностью напоминает Parcelable из Android, не так ли?

Давайте перепишем наш класс `Person` с использованием `Externalizable`:

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = ""
) : Externalizable {
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeUTF(name)
        out.writeInt(dateOfBirth)
        out.writeUTF(address)
    }
    
    override fun readExternal(input: ObjectInput) {
        name = input.readUTF()
        dateOfBirth = input.readInt()
        address = input.readUTF()
    }
}
```

Сразу видна первая особенность: класс должен иметь конструктор без параметров. Это критическое требование. При десериализации JVM сначала создает экземпляр класса через этот конструктор, а затем вызывает `readExternal` для заполнения полей. Если конструктор отсутствует, вы получите `InvalidClassException`. В Kotlin это решается через параметры со значениями по умолчанию, как показано выше.
Далее попробуем так же сериализоваться, на этот раз наш класс реализует Externalizable, по этому фаил назовем "externalization.bin"
```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("externalization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```
Попробуем открыть файл как текстовый, видим что информации гораздо меньше, чем в случае с Serializable. Первым идет полное имя класса. Далее бросается в глаза, что отсутствуют имена полей и явные типы значений, привязанные к классам. За нечитаемым текстом находятся служебные маркеры протокола сериализации и последовательности байтов, соответствующие данным, записанным в writeExternal. Эти маркеры, такие как STREAM_MAGIC, STREAM_VERSION, TC_OBJECT, TC_CLASSDESC, TC_STRING, TC_ENDBLOCKDATA, TC_NULL, TC_REFERENCE, TC_BLOCKDATA и другие, играют роль структурных разделителей, позволяя JVM при десериализации понимать, где начинается и где заканчивается каждый элемент, а также определять их тип и контекст.

```text
�� sr Person��K��T  xpw 	John Wick  � New Yorkx
```

Теперь посмотрим, что происходит внутри. Помните метод `writeOrdinaryObject` из разбора `Serializable`? Тот самый каскад проверок типа объекта? Там была проверка на `Externalizable`, и если класс реализует этот интерфейс, управление передается в метод `writeExternalData`. 

Давайте посмотрим на его реализацию:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeExternalData(Externalizable obj) throws IOException {
        PutFieldImpl oldPut = curPut;
        curPut = null;

        SerialCallbackContext oldContext = curContext;
        try {
            curContext = null;
            if (protocol == PROTOCOL_VERSION_1) {
                obj.writeExternal(this);
            } else {
                bout.setBlockDataMode(true);
                obj.writeExternal(this);
                bout.setBlockDataMode(false);
                bout.writeByte(TC_ENDBLOCKDATA);
            }
        } finally {
            curContext = oldContext;
        }

        curPut = oldPut;
    }
}
```

Код выглядит значительно проще, чем вся та сложная машинерия с обходом полей через рефлексию, которую мы видели в `writeSerialData`. Да, дескриптор класса всё равно создается через `ObjectStreamClass.lookup` в методе `writeOrdinaryObject` до вызова `writeExternalData`, это необходимо для записи информации о самом классе (его имени, иерархии). Но вот чего здесь нет, так это рекурсивного обхода иерархии классов для записи полей каждого уровня, нет вызова `defaultWriteFields`, который через рефлексию читает значения всех полей. JVM просто вызывает `obj.writeExternal(this)`, передавая управление вашему коду. Вся ответственность за то, какие данные и как записывать, лежит на вас.

Обратите внимание на работу с блочным режимом данных (`setBlockDataMode`). Это технический момент, который обеспечивает правильную структуру сериализационного потока. В PROTOCOL_VERSION_2 (который используется по умолчанию с Java 1.2) данные записываются блоками, и каждый блок завершается маркером `TC_ENDBLOCKDATA`. Это позволяет JVM корректно определять границы данных объекта в потоке.

Процесс десериализации работает зеркально. Вместо сложного механизма восстановления полей через рефлексию, JVM создает объект через конструктор без параметров и вызывает `readExternal`:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void readExternalData(Externalizable obj, ObjectStreamClass desc)
            throws IOException {
        SerialCallbackContext oldContext = curContext;
        if (oldContext != null)
            oldContext.check();
        curContext = null;
        try {
            boolean blocked = desc.hasBlockExternalData();
            if (blocked) {
                bin.setBlockDataMode(true);
            }
            if (obj != null) {
                try {
                    obj.readExternal(this);
                } catch (ClassNotFoundException ex) {
                    handles.markException(passHandle, ex);
                }
            }
            if (blocked) {
                skipCustomData();
            }
        } finally {
            if (oldContext != null)
                oldContext.check();
            curContext = oldContext;
        }
    }
}
```

Снова видим, насколько это проще по сравнению с `Serializable`. Нет восстановления метаданных, нет рекурсивного чтения иерархии классов. Вызов `obj.readExternal(this)` и всё. Вы сами решаете, в каком порядке читать поля и как их интерпретировать.

Здесь важно понимать ключевое различие. При использовании `Serializable` JVM автоматически записывает в поток метаданные класса (имена полей, типы, информацию о пакетах). Помните тот "грязный" вывод файла serialization.bin, где среди байтов мы видели названия полей и типов? Всё это метаинформация, которую JVM добавляет автоматически. С `Externalizable` этого не происходит. В поток попадают только те данные, которые вы явно записали. Это делает сериализованные объекты значительно меньше по размеру.

Но с большой силой приходит большая ответственность. Вы должны гарантировать, что порядок записи в `writeExternal` точно соответствует порядку чтения в `readExternal`. Если вы запишете сначала String, потом Int, потом String, вы обязаны читать в том же порядке. Любое несоответствие приведет к неправильной десериализации или исключению. JVM больше не следит за этим за вас.

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = ""
) : Externalizable {
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeUTF(name)
        out.writeInt(dateOfBirth)
        out.writeUTF(address)
    }
    
    override fun readExternal(input: ObjectInput) {
        name = input.readUTF()          // Порядок совпадает!
        dateOfBirth = input.readInt()   // Порядок совпадает!
        address = input.readUTF()       // Порядок совпадает!
    }
}
```

Еще один важный момент касается версионирования. С `Serializable` мы использовали `serialVersionUID` для контроля совместимости версий. С `Externalizable` вы можете реализовать собственную логику версионирования:

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = "",
    var phoneNumber: String = ""
) : Externalizable {
    
    companion object {
        private const val VERSION = 2
    }
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeInt(VERSION)
        // ... запись остальных полей
        out.writeUTF(phoneNumber)  // Новое поле в версии 2
    }
    
    override fun readExternal(input: ObjectInput) {
        val version = input.readInt()
        // ... чтение остальных полей
        
        if (version >= 2) {
            phoneNumber = input.readUTF()
        }
    }
}
```

Такой подход дает гибкость в управлении обратной совместимостью. Вы можете добавлять новые поля, изменять формат данных, и всё это будет работать, пока ваша логика в `readExternal` корректно обрабатывает разные версии.

Производительность `Externalizable` теоретически выше, чем у `Serializable`, потому что отсутствует overhead рефлексии. Но это не означает автоматический выигрыш. Если вы пишете неэффективный код в `writeExternal` или `readExternal`, производительность может быть хуже. Реальные цифры мы увидим в разделе бенчмарков.

Когда стоит использовать `Externalizable`? Когда вам нужен полный контроль над форматом данных, когда критичен размер сериализованных объектов, или когда стандартная сериализация работает неэффективно для вашей структуры данных. Но помните, что с этим контролем приходит и ответственность за корректность реализации. Один промах в порядке чтения/записи, и ваша десериализация сломается способами, которые сложно диагностировать.

### От JVM к Android: почему Externalizable не подошел

Мы разобрали оба подхода к сериализации в JVM экосистеме. `Serializable` дает простоту использования, но платит за это производительностью и избыточностью данных. `Externalizable` предоставляет контроль, но требует больше кода и внимательности. Казалось бы, идеальное решение найдено, особенно для мобильных устройств, где важны и производительность, и размер данных.

Но когда Google разрабатывал Android, инженеры столкнулись с фундаментальной проблемой. Android это не просто Java на мобильном устройстве. Это экосистема с жесткими ограничениями: ограниченная память, батарея, процессоры с меньшей вычислительной мощностью (на момент создания Android). Но главное, это специфическая архитектура межпроцессного взаимодействия (IPC) через механизм Binder.

Давайте разберемся, в чем проблема. Оба механизма сериализации, которые мы рассмотрели, разрабатывались для JVM с определенными предположениями. Первое: сериализация обычно используется для долговременного хранения или передачи по сети. Второе: overhead создания потоков (`ObjectOutputStream`, `ObjectInputStream`) приемлем, потому что данные затем передаются куда-то далеко (на диск, по сети). Третье: формат должен быть совместим между разными версиями Java и даже разными JVM.

В Android всё иначе. Когда вы запускаете новый Activity, передаете данные в Service или отправляете broadcast, это не сетевая операция и не запись на диск. Это IPC между процессами на одном устройстве через Binder. Объекты нужно сериализовать и десериализовать не для отправки в другую страну, а для передачи в соседний процесс. Это происходит постоянно, сотни раз в секунду. Каждый лишний байт, каждая лишняя операция напрямую влияют на отзывчивость интерфейса.

Попробуйте использовать `Serializable` для передачи Intent с данными между Activity. Это работает, Android поддерживает это. Но за кулисами происходит следующее: создается `ObjectOutputStream`, запускается механизм рефлексии (даже несмотря на Dalvik/ART, это всё равно медленно), записываются метаданные класса, создается множество временных объектов, создается `ObjectInputStream` на другой стороне, запускается обратная рефлексия, снова создаются временные объекты. И вот здесь начинается настоящая проблема для Android. Каждый временный объект это работа для Garbage Collector. На старых Android устройствах с ограниченной памятью и примитивным GC паузы сборки мусора напрямую влияют на плавность интерфейса. Пользователь видит подтормаживания, лаги, фризы. Всё это для того, чтобы передать объект в процесс, который находится рядом. Это как заказывать грузовик с целой логистической цепочкой, чтобы перенести коробку к соседу.

А что насчет `Externalizable`? Он быстрее `Serializable`, да, и дает больше контроля. Технически, его можно использовать даже в памяти через `ByteArrayOutputStream`, без реальных файлов или сокетов. При хорошей реализации в обычной JVM с оптимизирующим JIT компилятором `Externalizable` может показывать отличную производительность, иногда даже сравнимую или превосходящую `Parcelable` по чистой скорости сериализации/десериализации объекта.

Но в контексте Android IPC проблемы не в скорости самого `Externalizable`, а в том, что он не был спроектирован для этой задачи. Первая проблема: формат данных привязан к Java сериализационному протоколу с его служебными маркерами (TC_OBJECT, TC_ENDBLOCKDATA и прочее), которые добавляют лишние байты в каждую передачу. Вторая: вызовы `writeExternal` и `readExternal` проходят через слой абстракции `ObjectOutputStream`/`ObjectInputStream`, даже если работают с `ByteArrayOutputStream` в памяти. Эти потоки не интегрированы с Binder и требуют дополнительного копирования данных. Третья: это всё еще создает больше временных объектов и нагружает GC по сравнению с прямой записью в `Parcel`. Четвертая: нет нативной интеграции с Android runtime (ART), в то время как `Parcel` работает напрямую с механизмами IPC на уровне ядра.

Другими словами, `Externalizable` это быстрый механизм для JVM, но не оптимальный для специфики Android, где каждая IPC операция должна быть максимально эффективной, а интеграция с Binder критически важна.

Binder работает иначе. Он минимизирует копирование данных между процессами, используя однократное копирование через ядро Linux. Данные пишутся напрямую в буфер `Parcel`, который затем передается через Binder driver с минимальными издержками. Для этого нужен механизм сериализации, который "понимает" эту специфику и работает напрямую с бинарным буфером без промежуточных слоев абстракции.

Именно поэтому был создан `Parcelable`. Концептуально он очень похож на `Externalizable`: вы реализуете два метода (`writeToParcel` и конструктор из `Parcel`), вы сами контролируете, что и как пишете, вы отвечаете за порядок записи и чтения. Идея ручного управления процессом сериализации явно пришла из `Externalizable`. Но реализация полностью переработана для Android. Вместо потоков используется `Parcel`, который работает с flat, untyped binary buffer. Вместо Java сериализационного протокола используется минималистичный формат без метаданных о типах. Вместо создания временных объектов данные пишутся напрямую в буфер, что минимизирует нагрузку на GC.

Важная особенность: `Parcel` это untyped buffer. В нем нет информации о типах данных, нет имен полей, нет версионирования. Это означает, что совместимости между версиями класса (как у `Serializable` с его `serialVersionUID`) здесь нет. Вы полностью отвечаете за обратную совместимость. Если вы измените порядок полей в `writeToParcel` и забудете обновить порядок чтения в конструкторе, данные будут прочитаны неверно, и вы получите трудноотлавливаемые баги. В этом плане `Serializable` был более "прощающим", автоматически обнаруживая несовместимость версий.

Изначально `Parcelable` приходилось писать вручную, что было утомительно и чревато ошибками. С появлением Kotlin ситуация изменилась. Плагин `kotlin-parcelize` (аннотация `@Parcelize`) автоматически генерирует весь boilerplate код во время компиляции, гарантируя корректность порядка записи и чтения полей. Это объединило контроль `Externalizable` с удобством `Serializable`.

Для тех кто сразу же начал распознавать Parcelable в Externalizable, да, `Externalizable` стал философской основой для `Parcelable`. Оба говорят: "не доверяй автоматике, возьми контроль в свои руки". Но `Parcelable` идет дальше, отбрасывая весь багаж JVM сериализации и создавая решение с нуля, оптимизированное под специфику Android: минимальное копирование через ядро, отсутствие временных объектов, прямая работа с бинарным буфером без типизации.

## Интерфейс Parcelable

Мы только что выяснили, почему Google не мог использовать существующие JVM решения для Android. `Serializable` слишком медленный из-за рефлексии и создает избыточную нагрузку на Garbage Collector через множество временных объектов. `Externalizable`, хоть и быстрее, но не интегрирован с Binder и привязан к Java сериализационному протоколу со всеми его маркерами и метаданными. Требовалось решение, специально спроектированное для мобильной платформы: быстрое, компактное и работающее напрямую с Binder механизмом Android.

Именно таким решением стал `Parcelable`. Давайте начнем с интерфейса и посмотрим, что он от нас требует:

```java
public interface Parcelable {
    int describeContents();
    void writeToParcel(Parcel dest, int flags);
    
    interface Creator<T> {
        T createFromParcel(Parcel source);
        T[] newArray(int size);
    }
}
```

В отличие от `Serializable`, который был просто пустым маркером, здесь мы видим реальные методы, которые нужно реализовать. Метод `writeToParcel()` отвечает за запись данных объекта в специальный контейнер `Parcel`, а `describeContents()` сообщает системе о наличии специальных ресурсов (об этом позже). Кроме того, каждый класс должен предоставить `CREATOR` - специальный объект, который умеет создавать экземпляры из `Parcel`.

Давайте попробуем реализовать наш знакомый класс `Person` с использованием `Parcelable`. Вот как это выглядело до появления автоматической генерации:

```kotlin
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
) : Parcelable {
    
    constructor(parcel: Parcel) : this(
        parcel.readString()!!,
        parcel.readInt(),
        parcel.readString()!!
    )
    
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeInt(dateOfBirth)
        parcel.writeString(address)
    }
    
    override fun describeContents(): Int = 0
    
    companion object CREATOR : Parcelable.Creator<Person> {
        override fun createFromParcel(parcel: Parcel): Person {
            return Person(parcel)
        }
        
        override fun newArray(size: Int): Array<Person?> {
            return arrayOfNulls(size)
        }
    }
}
```

Посмотрите на этот код внимательно. Для трех простых полей нам потребовалось написать почти 40 строк boilerplate кода. Мы вручную прописываем, как записывать каждое поле в методе `writeToParcel()`, затем в точно таком же порядке читаем их в конструкторе из `Parcel`, и наконец создаем `CREATOR` с двумя методами. Причем порядок записи и чтения должен совпадать абсолютно точно. Если вы случайно запишете `writeInt(dateOfBirth)` перед `writeString(name)`, а при чтении сделаете наоборот, вы получите баг, который будет очень сложно отловить.

Android Studio попыталась облегчить жизнь разработчикам, добавив готовый шаблон: достаточно было нажать Alt+Insert (или Cmd+N на Mac) и выбрать "Parcelable implementation", чтобы IDE сгенерировала весь необходимый код. Но это решало проблему лишь частично. Стоило вам добавить новое поле в класс или изменить порядок существующих, и приходилось вручную обновлять все методы сериализации. Забыли добавить новое поле в `writeToParcel`? Получите тихий баг на продакшене.

Ситуация кардинально изменилась с появлением Kotlin. Сначала в плагине `kotlinx-android-extensions` появилась аннотация `@Parcelize`, которая автоматически генерировала всю реализацию во время компиляции. Теперь наш класс `Person` можно было записать так:

```kotlin
@Parcelize
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
) : Parcelable
```

Три строки вместо сорока! Одна аннотация, и компилятор сам генерирует весь необходимый код, гарантируя корректность порядка записи и чтения.

Правда, `kotlinx-android-extensions` оказался слишком широким плагином. Помимо `@Parcelize`, он включал синтетические импорты для view (знаменитые `import kotlinx.android.synthetic.main.*`), которые через несколько лет признали антипаттерном и deprec ated в пользу ViewBinding. В итоге плагин разделили, и `@Parcelize` переехала в свой собственный компактный модуль `kotlin-parcelize`. Сейчас для его использования достаточно добавить в `build.gradle`:

```kotlin
plugins {
    id("kotlin-parcelize")
}
```

И всё. Никаких runtime зависимостей, никаких дополнительных библиотек. Вся генерация происходит на уровне компилятора, создавая оптимальный байткод.

### Как это работает на практике

Прежде чем погружаться в технические детали, давайте посмотрим на реальное использование `Parcelable` в Android. Если вы заметили, в отличие от примеров с `Serializable` и `Externalizable`, где мы создавали файлы и смотрели их содержимое, здесь мы этого не делали. Почему?

Причина проста: `Parcelable` создавался не для сохранения в файлы, а для передачи данных между компонентами Android. Давайте посмотрим типичный сценарий: передача объекта из одного Activity в другой.

```kotlin
// FirstActivity.kt
val person = Person("John Wick", 1964, "New York")
val intent = Intent(this, SecondActivity::class.java)
intent.putExtra("person_data", person) // person реализует Parcelable
startActivity(intent)
```

```kotlin
// SecondActivity.kt
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    val person = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
        intent.getParcelableExtra("person_data", Person::class.java)
    } else {
        @Suppress("DEPRECATION")
        intent.getParcelableExtra<Person>("person_data")
    }
    
    println(person) // Person(name=John Wick, dateOfBirth=1964, address=New York)
}
```

Что происходит за кулисами? Когда вы вызываете `intent.putExtra()`, Android сериализует объект `Person` в `Parcel`, передает этот буфер через Binder в новый процесс (если Activity запускается в другом процессе) или просто в новый компонент, а там десериализует обратно. Весь процесс занимает микросекунды. Никаких файлов, никаких потоков ввода-вывода, никакого длительного хранения.

А что если мы все-таки захотим посмотреть, как выглядят сериализованные данные? Технически это возможно:

```kotlin
val person = Person("John Wick", 1964, "New York")
val parcel = Parcel.obtain()

try {
    person.writeToParcel(parcel, 0)
    val bytes = parcel.marshall() // Получаем ByteArray
    
    println("Размер: ${bytes.size} байт")
    println("Данные (hex): ${bytes.joinToString(" ") { "%02x".format(it) }}")
    
    // Первые несколько байт в читаемом виде
    val readable = bytes.filter { it in 32..126 }.map { it.toInt().toChar() }.joinToString("")
    println("Читаемые символы: $readable")
} finally {
    parcel.recycle()
}
```

Вывод будет примерно таким:
```
Размер: 56 байт
Данные (hex): 09 00 00 00 4a 6f 68 6e 20 57 69 63 6b ac 07 00 00 08 00 00 00 4e 65 77 20 59 6f 72 6b
Читаемые символы: John WickNew York
```

Видите разницу с `Serializable`? Вспомните тот файл, где было полно метаданных: имя класса `Person`, типы полей `Ljava/lang/String`, маркеры протокола. Здесь только чистые данные: длина строки (4 байта), сама строка "John Wick", число 1964 (4 байта), длина и строка "New York". Ни одного лишнего байта. Именно поэтому размер всего 56 байт против примерно 130-150 байт у `Serializable`.

Кстати, `Serializable` тоже работает в Android через Intent:

```kotlin
// Это тоже валидный код, если Person реализует Serializable
val person = Person("John Wick", 1964, "New York")
intent.putExtra("person_data", person) // Android поддерживает и Serializable
```

Но за кулисами творится совсем другое. Android вынужден создать `ObjectOutputStream`, запустить рефлексию, записать все метаданные, создать множество временных объектов. На другой стороне то же самое: `ObjectInputStream`, рефлексия, парсинг метаданных, создание объектов. Результат тот же, но работает в 10-20 раз медленнее и создает значительную нагрузку на Garbage Collector. Именно поэтому в документации Android вы везде увидите рекомендацию: используйте `Parcelable` для передачи данных между компонентами.

Но давайте вернемся к вопросу: что же такое этот `Parcel`, в который мы пишем данные? Помните, мы говорили о том, что Android нужен механизм, работающий напрямую с памятью, без промежуточных слоев абстракции? Вот здесь и начинается самое интересное. `Parcel` - это не просто еще один Java класс для работы с данными. Это тонкая обертка над нативной C++ структурой, и работает он через JNI (Java Native Interface):

```java
public final class Parcel {
    private long mNativePtr; // Указатель на нативную структуру
    
    public final void writeString(String val) {
        nativeWriteString(mNativePtr, val);
    }
    
    private static native void nativeWriteString(long nativePtr, String val);
}
```

Обратите внимание на поле `mNativePtr` - это просто число типа `long`, которое хранит указатель на C++ структуру. Когда вы вызываете `parcel.writeString("John Wick")`, на Java стороне происходит только перенаправление вызова в нативный метод `nativeWriteString()`. А дальше начинается работа C++ кода.

Нативная реализация находится в файле `frameworks/native/libs/binder/Parcel.cpp` в исходниках Android. Этот код работает напрямую с памятью: строка конвертируется в UTF-16, к ней добавляется информация о длине, и все это записывается в линейный буфер памяти. Никаких временных Java объектов, никаких слоев абстракции в виде `ObjectOutputStream`, просто запись байтов в память.

Теперь представьте, что происходит, когда вы передаете объект через `Intent.putExtra()` между Activity. Этот буфер памяти отправляется через Binder driver, который работает на уровне ядра Linux. Binder использует механизм copy-on-write, минимизируя копирование данных. На принимающей стороне создается новый `Parcel`, который получает указатель на этот буфер памяти, и вы просто читаете из него данные в том же порядке, в котором записывали. Вспомните `ObjectOutputStream` с его слоями абстракции, протоколами и метаданными - здесь ничего подобного нет. Только память, указатели и минимум накладных расходов.

Давайте теперь посмотрим, какой именно код генерирует компилятор для нашего простого класса `Person` с аннотацией `@Parcelize`. Если открыть скомпилированный `.class` файл через декомпилятор, мы увидим что-то вроде этого:

```kotlin
@Parcelize
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
) : Parcelable {
    
    // Сгенерировано компилятором
    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeInt(dateOfBirth)
        parcel.writeString(address)
    }
    
    override fun describeContents(): Int = 0
    
    companion object {
        @JvmField
        val CREATOR = object : Parcelable.Creator<Person> {
            override fun createFromParcel(parcel: Parcel): Person {
                return Person(
                    parcel.readString()!!,
                    parcel.readInt(),
                    parcel.readString()!!
                )
            }
            
            override fun newArray(size: Int): Array<Person?> {
                return arrayOfNulls(size)
            }
        }
    }
}
```

Посмотрите на порядок операций: при записи мы вызываем `writeString`, затем `writeInt`, затем снова `writeString`. При чтении порядок абсолютно идентичен: `readString`, `readInt`, `readString`. Это не случайность и не прихоть. Это критически важное требование, потому что `Parcel` - это untyped buffer, плоский массив байтов без какой-либо информации о типах данных.

Когда вы вызываете `parcel.readInt()`, он просто берет следующие 4 байта из буфера и интерпретирует их как integer. Нет никакой проверки "а точно ли здесь int?". Если вы случайно нарушите порядок - например, сначала запишете int, а при чтении попытаетесь прочитать string, вы получите совершенно некорректные данные или краш приложения. Именно поэтому ручная реализация `Parcelable` была такой опасной: одна ошибка, и баг готов.

С `@Parcelize` эта проблема решена на уровне компилятора. Он анализирует primary конструктор, генерирует методы записи и чтения в правильном порядке, и гарантирует их синхронизацию. Вы не можете ошибиться, потому что не пишете код вручную.

Теперь давайте рассмотрим более сложный случай: nullable поля. Как `Parcel` работает с null значениями, если это просто байты в памяти без метаданных о типах?

```kotlin
@Parcelize
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String?
) : Parcelable
```

Для nullable `address` генерируется код с проверкой:

```kotlin
override fun writeToParcel(parcel: Parcel, flags: Int) {
    parcel.writeString(name)
    parcel.writeInt(dateOfBirth)
    parcel.writeString(address) // Даже если address == null, это работает!
}
```

Ответ прост и элегантен: `writeString()` имеет встроенную поддержку null. Когда вы передаете null, метод записывает специальный маркер - значение -1 в качестве длины строки. При чтении `readString()` видит этот маркер и возвращает null. Получается, что Android поддерживал null-safety на уровне своего API еще до того, как Kotlin сделал эту концепцию центральной в языке. Интересно, что разработчики Android изначально заложили поддержку nullable типов, хотя Java этого вообще не знала.

Теперь давайте поговорим о методе `describeContents()`, который в нашем примере просто возвращает 0. Вы могли заметить, что мы никогда его не переопределяем, компилятор генерирует его автоматически. Зачем он вообще нужен? В 99% случаев действительно нужно просто вернуть 0. Но есть один специальный сценарий: file descriptors.

Представьте, что ваш класс содержит `ParcelFileDescriptor` - это может быть открытый файл, сокет или другой системный ресурс. Такие ресурсы требуют особой обработки при передаче между процессами, потому что это не просто данные в памяти, это реальные объекты операционной системы. В таком случае нужно вернуть `Parcelable.CONTENTS_FILE_DESCRIPTOR`, чтобы Binder понимал, что объект содержит системные ресурсы и обработал их корректно:

```kotlin
@Parcelize
data class FileWrapper(val fd: ParcelFileDescriptor) : Parcelable {
    override fun describeContents(): Int = Parcelable.CONTENTS_FILE_DESCRIPTOR
}
```

Второй параметр метода `writeToParcel(Parcel dest, int flags)` - это `flags`. В большинстве случаев он игнорируется, но может содержать флаг `Parcelable.PARCELABLE_WRITE_RETURN_VALUE`. Этот флаг говорит, что объект передается как возвращаемое значение из Binder вызова, и после записи некоторые ресурсы можно освободить, потому что на отправляющей стороне они больше не нужны.

А теперь посмотрим на более сложный сценарий: вложенные объекты. В реальных приложениях мы редко работаем с простыми классами из трех примитивных полей. Обычно у нас есть целые графы объектов, где один класс содержит другие классы. Например, `Person` может содержать объект `Address`:

```kotlin
@Parcelize
data class Address(val city: String, val street: String) : Parcelable

@Parcelize
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: Address
) : Parcelable
```

Что происходит при сериализации? Когда компилятор доходит до поля `address` в классе `Person`, он генерирует вызов `parcel.writeParcelable(address, flags)`. Этот метод в свою очередь вызывает `address.writeToParcel()`, и весь вложенный объект сериализуется рекурсивно. При десериализации происходит обратный процесс: `parcel.readParcelable<Address>(Address::class.java.classLoader)` читает данные и воссоздает объект `Address`. Вся рекурсия обрабатывается автоматически, без runtime накладных расходов, потому что все генерируется на этапе компиляции.

Теперь рассмотрим еще один распространенный случай: коллекции. Списки, множества, карты - стандартные структуры данных в любом приложении. Как `Parcel` работает с ними?

```kotlin
@Parcelize
data class Team(
    val name: String,
    val members: List<String>
) : Parcelable
```

Генерируется код:

```kotlin
override fun writeToParcel(parcel: Parcel, flags: Int) {
    parcel.writeString(name)
    parcel.writeStringList(members)
}
```

Для коллекций `Parcel` предоставляет специализированные оптимизированные методы. `writeStringList()` сначала записывает размер списка как integer, затем последовательно записывает каждую строку. При чтении `readStringList()` сначала читает размер, создает ArrayList нужной емкости, а затем читает строки одну за другой. Аналогично работают `writeIntArray()`, `writeParcelableList()`, `writeMap()` и множество других методов для различных типов коллекций. Каждый из них оптимизирован для конкретного типа данных, что делает сериализацию максимально эффективной.

Но у `@Parcelize` есть важное ограничение, о котором нужно помнить. Компилятор генерирует код только на основе primary конструктора класса. Если у вас есть свойства, объявленные вне конструктора, они просто проигнорируются:

```kotlin
@Parcelize
data class Person(
    val name: String,
    val dateOfBirth: Int
) : Parcelable {
    var address: String = "" // Это поле НЕ будет сериализовано!
}
```

Почему так? Потому что компилятор анализирует только сигнатуру primary конструктора. Он не знает и не может знать о свойствах, которые вы инициализируете в теле класса или через init блоки. Если вам нужно сериализовать такое свойство, просто добавьте его в primary конструктор.

Иногда встречаются ситуации, когда автоматической генерации недостаточно. Например, вам нужно сериализовать класс из сторонней библиотеки, который не реализует `Parcelable`. Или требуется специальная логика сериализации - скажем, шифрование данных перед записью. Для таких случаев существует интерфейс `Parceler`, который позволяет определить кастомную логику:

```kotlin
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
)

object PersonParceler : Parceler<Person> {
    override fun create(parcel: Parcel): Person {
        return Person(
            parcel.readString()!!,
            parcel.readInt(),
            parcel.readString()!!
        )
    }
    
    override fun Person.write(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeInt(dateOfBirth)
        parcel.writeString(address)
    }
}

@Parcelize
@TypeParceler<Person, PersonParceler>
data class Team(
    val name: String,
    val leader: Person
) : Parcelable
```

Вы получаете полный контроль над процессом сериализации конкретного типа, при этом остальные поля класса обрабатываются автоматически.

Теперь давайте поговорим о самом важном: производительности. Мы много времени потратили на объяснение внутреннего устройства `Parcelable`, и вы могли заметить, насколько он отличается от `Serializable`. Нативная реализация в C++, прямая работа с памятью без промежуточных объектов, отсутствие рефлексии, интеграция с Binder на уровне ядра Linux. Все это дает потрясающий результат: в типичных бенчмарках `Parcelable` работает в 10-20 раз быстрее, чем `Serializable` на том же объекте. Мы увидим конкретные цифры в разделе с бенчмарками, но уже сейчас понятно, почему Google сделал именно такой выбор для Android.

Но было бы нечестно рассказать только о достоинствах. У `Parcelable` есть серьезные ограничения, которые нужно понимать.

**Привязка к платформе.** `Parcelable` работает только на Android. Это не кроссплатформенное решение. Представьте, что вы разрабатываете мобильное приложение с общим бизнес-слоем для Android и iOS. Ваши модели данных должны работать на обеих платформах. Но `Parcelable` существует только в Android SDK. На iOS его просто нет. Более того, с ростом популярности Kotlin Multiplatform появилась потребность в едином коде, который работает везде: на Android, iOS, в браузере через Kotlin/JS, на бэкенде через Kotlin/JVM, даже в нативных приложениях через Kotlin/Native. `Parcelable` в этой картине мира не вписывается никак.

**Отсутствие версионирования.** Помните `serialVersionUID` у `Serializable`? Здесь такого механизма нет. Если вы измените структуру класса между версиями приложения - добавите поле, удалите поле, поменяете порядок - вам придется вручную обрабатывать совместимость, как мы видели в примере с `Externalizable`. Это ваша ответственность, и никакой автоматической проверки не будет.

**Ограниченность применения.** `Parcel` оптимизирован для IPC, но не для долговременного хранения. Вы можете сохранить сериализованный `Parcel` в файл или SharedPreferences, технически это возможно. Но делать этого не стоит. Формат `Parcel` может измениться между версиями Android, и ваши сохраненные данные станут нечитаемыми после обновления системы. `Parcel` создавался для передачи данных между компонентами здесь и сейчас, а не для хранения на диск.

**Отсутствие выбора формата.** `Parcelable` сериализует данные в один единственный бинарный формат, оптимизированный для Binder. Но что если вам нужно отправить данные по сети? Современные API обмениваются JSON или Protocol Buffers. Что если нужно сохранить конфигурацию в человекочитаемом виде? Нужен YAML или TOML. `Parcelable` для этого не подходит. Он решает одну задачу - IPC в Android, и решает её блестяще. Но только эту одну задачу.

Именно эти ограничения создали запрос на универсальное решение. Представьте себе идеал: библиотеку, которая работает на всех платформах Kotlin, поддерживает множество форматов данных (JSON, Protobuf, CBOR, XML), использует кодогенерацию для максимальной производительности, обеспечивает type-safety на уровне компилятора, и при этом остается такой же простой в использовании, как `@Parcelize`.

Звучит слишком хорошо, чтобы быть правдой? Но именно такое решение создала команда JetBrains. Встречайте финального героя нашей истории.

## kotlinx.serialization

### История появления и философия

В 2017 году Kotlin переживал настоящий бум. Google объявила его официальным языком для Android разработки, сообщество активно росло, а JetBrains начала амбициозный проект - Kotlin Multiplatform (KMP). Идея была революционной: писать код один раз и запускать его везде. На Android через Kotlin/JVM и Android Runtime, на iOS через Kotlin/Native с компиляцией в нативный код, в браузере через Kotlin/JS, на сервере через обычный JVM. Но для реализации этой идеи не хватало одного критически важного элемента.

Представьте разработчика, который пишет мобильное приложение с общим бизнес-слоем. Модели данных, сетевые запросы, работа с API - всё это должно работать одинаково на Android и iOS. На Android у него есть `Parcelable` для IPC, есть Gson или Moshi для JSON, есть множество готовых решений. Но стоит скомпилировать этот код для iOS через Kotlin/Native, и всё ломается. `Parcelable` не существует. Gson использует рефлексию, которая работает совсем по-другому (или вообще не работает) в native окружении. Moshi требует кодогенерации через KAPT, который не поддерживается в Kotlin/Native.

Получался замкнутый круг: KMP обещал "пиши один раз, запускай везде", но для базовой задачи - сериализации данных - приходилось писать разный код для каждой платформы. JSON парсинг на Android решался одной библиотекой, на iOS другой, в JS третьей. А ведь сериализация - это фундаментальная операция, без которой не обходится ни один проект.

Команда JetBrains понимала: для успеха Kotlin Multiplatform нужна кроссплатформенная библиотека сериализации, которая работает одинаково хорошо на всех поддерживаемых платформах. Но просто "ещё одна библиотека сериализации" была бы половинчатым решением. Нужно было создать что-то принципиально новое, учитывающее уникальные особенности Kotlin как языка и опыт всех предыдущих решений.

В 2018 году в статусе experimental появилась первая версия `kotlinx.serialization`. Библиотека сразу выделялась своим подходом. В отличие от Gson, который использует рефлексию в runtime, `kotlinx.serialization` полностью работает через плагин компилятора. Аннотация `@Serializable` запускает генерацию специализированного кода еще на этапе компиляции. Это означает несколько важных вещей.

**Производительность.** Никакой рефлексии в runtime, никакого анализа структуры классов во время выполнения. Всё уже готово и оптимизировано на этапе компиляции. В JVM это дает скорость, сравнимую с Moshi или даже превосходящую его. В Kotlin/Native, где рефлексия ограничена и медленна, это критически важно.

**Безопасность типов.** Компилятор анализирует вашу структуру данных и генерирует типобезопасный код. Если вы попытаетесь сериализовать тип, для которого нет сериализатора, вы получите ошибку компиляции, а не runtime exception в продакшене. Это огромное преимущество по сравнению с reflection-based решениями, где ошибки проявляются только при выполнении.

**Кроссплатформенность.** Плагин компилятора работает на всех целевых платформах Kotlin. Один и тот же код с `@Serializable` компилируется в оптимальный байткод для JVM, в JavaScript для браузера, в нативный код для iOS. Нет никаких platform-specific зависимостей, нет различий в API между платформами.

**Множественность форматов.** В отличие от `Parcelable`, который работает только с одним форматом, `kotlinx.serialization` устроена модульно. Есть ядро библиотеки, которое определяет, как структура классов превращается в последовательность операций записи и чтения. А формат - это отдельный модуль. Хотите JSON? Подключите `kotlinx-serialization-json`. Нужен Protobuf? `kotlinx-serialization-protobuf`. CBOR для компактного бинарного представления? `kotlinx-serialization-cbor`. Тот же класс с одной аннотацией `@Serializable` может быть сериализован в любой из этих форматов без изменения кода.

К 2020 году библиотека вышла из experimental статуса и достигла версии 1.0, став стабильной и готовой к production использованию. Сегодня это де-факто стандарт для сериализации в Kotlin Multiplatform проектах и серьезная альтернатива Gson/Moshi в чистых JVM/Android приложениях.

Давайте посмотрим, как это работает на практике.
