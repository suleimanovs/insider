# Введение

В этой статье мы рассмотрим технологии сериализации и десериализации данных в контексте экосистемы Android, Java, Kotlin JVM и Kotlin Native.

Сериализация и десериализация являются фундаментальными операциями в современной разработке. Эти процессы используются повсеместно: от хранения данных в локальном хранилище устройства до передачи информации по сети. Многие NoSQL базы данных применяют собственные форматы сериализации для оптимизации производительности. Наиболее распространённые форматы обмена данными (JSON, XML, Protocol Buffers, MessagePack и другие) тесно связаны с процессами сериализации.

Существует два основных подхода к реализации сериализации. Первый основан на рефлексии (reflection), которая позволяет анализировать структуру объектов во время выполнения (runtime), но сопряжена с накладными расходами на производительность. Второй подход использует кодогенерацию во время компиляции (compile-time), что значительно ускоряет обработку данных за счёт генерации специализированного кода. Например, Protocol Buffers требует предварительного описания контракта данных в `.proto` файлах, что позволяет генерировать оптимизированный код и устранять избыточные операции при десериализации.

При оценке решений для сериализации обычно приоритетным является скорость обработки, затем размер сериализованных данных, и лишь потом потребление оперативной памяти. Впрочем, для мобильных устройств и встраиваемых систем баланс этих факторов может смещаться в пользу минимизации памяти и размера данных.

В рамках данной статьи мы проанализируем существующие библиотеки и подходы к сериализации объектов в JVM и Native экосистемах. Мы детально рассмотрим четыре основных подхода: классический `Serializable` из Java, его расширение `Externalizable`, специфичный для Android `Parcelable`, а также современный `kotlinx.serialization`. Для каждого из них мы проведём сравнительное тестирование производительности и выясним, какие решения являются наиболее эффективными в различных сценариях использования. Помимо получения конкретных метрик, мы также исследуем технические причины, определяющие производительность каждого подхода.

Для единообразия терминологии начнём с определения базовых понятий и терминов.


## Базис

**Сериализация** — это процесс преобразования структурированных данных (объектов, структур данных) в последовательность байтов или текстовое представление, пригодное для хранения или передачи. Сериализация «упаковывает» состояние объекта в формат, который можно сохранить в файл, передать по сети или поместить в базу данных.

**Десериализация** — это обратный процесс восстановления объекта из его сериализованного представления. Десериализация «распаковывает» последовательность байтов или текст обратно в структурированный объект с сохранением его типа и данных.

![serialization.svg](serialization.svg)


**Рефлексия (Reflection)** — это механизм времени выполнения, позволяющий программе анализировать и модифицировать свою собственную структуру и поведение. В контексте сериализации рефлексия используется для динамического обхода полей объектов без предварительной генерации кода. Естественно неформально рефлексия в мире разработки считается темной магией.

**Кодогенерация (Code Generation)** — это автоматическое создание исходного кода во время компиляции на основе аннотаций, схем данных или других метаданных. Кодогенерация устраняет накладные расходы рефлексии за счёт создания специализированных классов-сериализаторов. Сама кодогенерация так же достигается благодаря рефлексии или же hook-ов компилятора. В мире JVM это долгое время было APT, позже KAPT, далее эволюция Kotlin подарила KSP. Начиная с Kotlin 2.0 теперь так же есть возможность реализовать плагины компилятора, которая ранее была закрыта для сторонних разработчиков.
![codeGeneration.svg](codeGeneration.svg)


**Контракт данных (Data Contract/Schema)** — это формальное описание структуры данных, определяющее типы полей, их названия и правила валидации. Используется в Protocol Buffers (.proto файлы), Apache Avro и других схемо-ориентированных форматах.
![codeProtocolScheme.svg](codeProtocolScheme.svg)

Теперь, когда мы определились с базовой терминологией, перейдем к рассмотрению конкретных способов сериализации. Мы рассмотрим их в порядке исторической эволюции с точки зрения Kotlin и Android. Что интересно, в мире Java эволюции как таковой не произошло: первое решение, появившееся еще в ранних версиях JDK, продолжает использоваться и по сей день.
Сначала мы пройдемся по каждому из подходов, разберем их под лупой, но никаких выводов по производительности не будем пока не рассмотрим все способы, в конце мы рсавним каждый из подходов что бы понять какой из них оптимальнее в использований.

## Интерфейс Serializable

Начнем наше погружение с интерфейса `Serializable`, который является самым первым и, пожалуй, наиболее распространенным способом сериализации в мире JVM. `Serializable` представляет собой интерфейс-маркер, то есть интерфейс, не содержащий никакой логики. Рассмотрим его исходный код:
```java
package java.io;

public interface Serializable {
}
```

Как видите, интерфейс абсолютно пуст. Возникает логичный вопрос: как же пустой интерфейс может что-то делать? На самом деле, `Serializable` работает как маркер для JVM, сигнализирующий, что класс разрешает свою сериализацию. Вся магия происходит на уровне runtime через рефлексию, о чем мы подробно поговорим дальше.

Давайте создадим простой класс и посмотрим, как работает сериализация на практике. Для примера возьмем класс `Person` с базовой информацией о человеке:

```kotlin
data class Person( 
    val name: String, 
    val dateOfBirth: Int, 
    val address: String
): Serializable
```

Обратите внимание, что для превращения обычного класса в сериализуемый нам достаточно добавить `: Serializable` после объявления класса. Никаких дополнительных методов или полей реализовывать не нужно.

Теперь давайте попробуем сериализовать объект этого класса и сохранить его в файл. Процесс будет выглядеть следующим образом:

```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("serialization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```

Что здесь происходит? Мы создаём объект `Person` с данными о John Wick, затем создаём файл `serialization.bin`, открываем поток(FileOutputStream) для записи в этот файл и, наконец, оборачиваем его в `ObjectOutputStream`. Именно вызов `writeObject(person)` запускает весь механизм сериализации, превращая наш объект в последовательность байтов.

После выполнения кода мы получим файл `serialization.bin` с нашими сериализованными данными. Из любопытства давайте попробуем открыть этот файл в текстовом редакторе. Вот что мы увидим:
```text
�� sr PersonTZ���c I dateOfBirthL addresst Ljava/lang/String;L nameq ~ xp  �t New Yorkt John Wick
```
Выглядит жутковато, не правда ли? Файл явно не предназначен для чтения человеком из-за бинарного формата, и текстовый редактор с трудом пытается интерпретировать байты как UTF-8 символы. Тем не менее, если присмотреться, среди "кракозябр" можно разглядеть вполне читаемые фрагменты: названия полей (`name`, `address`), их типы (`Ljava/lang/String`), название класса (`Person`) и даже значения полей (`New York`, `John Wick`).

Вы можете задаться вопросом: если сериализация представляет собой превращение объекта в байты, то почему мы видим не нули и единицы, а относительно читаемый текст? Ответ прост: текстовый редактор пытается интерпретировать байты как символы UTF-8. Некоторые байтовые последовательности случайно совпадают с кодами печатных символов, поэтому мы и видим эти фрагменты текста среди непонятных символов.

Но откуда же в файле взялась вся эта информация о структуре нашего класса? Мы ведь нигде явно не указывали, какие поля сохранять и как их называть. Здесь начинается самое интересное: `Serializable` полностью работает на основе Reflection API. JVM автоматически анализирует структуру нашего класса во время выполнения и извлекает всю необходимую метаинформацию.

Рефлексия и вся магия `Serializable` проявляется с момента создания `ObjectOutputStream`, а если быть точнее, с момента вызова функции `writeObject`. Именно в этом методе происходит вся основная работа: он берет наш объект класса `Person`, сериализует его и затем записывает в файл `serialization.bin`.

Важно понимать архитектуру: сам `ObjectOutputStream` на самом деле ничего не знает о нашем файле `serialization.bin`. Вместо этого `ObjectOutputStream` работает с `FileOutputStream`, который и является посредником между файлом и объектом. Это классический паттерн проектирования "Декоратор" (Decorator). На самом деле, большинство видов Stream-ов (наследники `InputStream` и `OutputStream`) являются декораторами, добавляющие дополнительную функциональность к базовому потоку(stream).

Процесс десериализации работает зеркально:
```kotlin
fun main(args: Array<String>) {
    val file = File("serialization.bin")
    val fileInputStream = FileInputStream(file)
    val objectInputStream = ObjectInputStream(fileInputStream).use { stream ->
        print(stream.readObject() as Person)
    }
}
```

Мы находим файл и затем передаем его в `FileInputStream`, чтобы восстановить объект `Person` из сохраненного набора байтов. Давайте убедимся, что интерфейс `Serializable` действительно необходим. Если мы уберем у класса `Person` наследование от интерфейса `Serializable`, то получим такую ошибку:
```
Exception in thread "main" java.io.NotSerializableException: Person
```

Эта ошибка подтверждает, что маркерный интерфейс `Serializable` является обязательным условием для сериализации объекта.

### Внутреннее устройство Serializable

Теперь давайте погрузимся глубже и посмотрим, как работает сериализация под капотом. Рассмотрим исходный код метода `writeObject` класса `ObjectOutputStream`, ведь именно он принимает объект класса `Person` и преобразует его в набор байтов:
```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    public final void writeObject(Object obj) throws IOException {
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            writeObject0(obj, false);
        } catch (IOException ex) {
            if (depth == 0) {
                writeFatalException(ex);
            }
            throw ex;
        }
    }
}
```

Этот метод своего рода Provider, если от класса унаследовались и переопределили открытый метод для переопределения, то будет использована
логика наследника, иначе вызов передается методу `writeObject0` который является стандартным у `ObjectOutputStream`, в нашем случае мы не наследовались от ObjectOutputStream
поэтому мы попадаем в метод `writeObject0`:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeObject0(Object obj, boolean unshared)
            throws IOException
    {
        ...
        ObjectStreamClass desc = ObjectStreamClass.lookup(cl, true);
        ...
        
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(
                        cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
        ...
    }
}
```

Метод `writeObject0` содержит обширную логику по проверке объекта (например, проверки на not nullable, no classable, not streamable). В приведенном выше фрагменте оставлена только та часть логики, которая непосредственно отвечает за работу сериализации стандартного объекта.

Обратите внимание на важную строку, которую мы специально оставили в коде: создание объекта `ObjectStreamClass`. Этот объект играет ключевую роль во всем процессе сериализации. Рассмотрим подробнее вызов `ObjectStreamClass.lookup(cl, true)`. Именно здесь начинается реальная работа сериализации. 
Этот метод создает дескриптор класса (объект `ObjectStreamClass`), который фиксирует всю метаинформацию о типе, необходимую для его записи в поток. 
По сути, это сериализационный аналог рефлексии, но не на уровне исполнения, а на уровне протокола (контракта).

Метод `lookup` сначала проверяет внутренний кэш. Если дескриптор для данного класса уже существовал, он возвращается повторно. 
Если нет, то создается новый. В процессе создания выполняется полный анализ структуры класса:
определяются сериализуемые поля объекта, вычисляется `serialVersionUID`, проверяется наличие специальных методов (`writeObject`, `readObject`, `readResolve`, `writeReplace`), устанавливается связь с родительским дескриптором, фиксируются флаги, указывающие на природу класса (`enum`, `proxy`, `externalizable`, `record`).

Параметр `true` во втором аргументе означает, что дескрипторы создаются не только для самого класса, но и для всей цепочки его сериализуемых предков. Это важно: сериализация в Java всегда знает структуру объекта вплоть до первого не-`Serializable` родителя, и именно `lookup` формирует эту иерархию.

Результатом вызова становится объект `desc`, который будет передан в `writeOrdinaryObject`. Все дальнейшие шаги (запись сигнатуры, `serialVersionUID`, набора полей и их значений) выполняются строго в соответствии с тем, что описано в этом дескрипторе. Если дескриптор изменить, изменится и байтовое представление.

Таким образом, `ObjectStreamClass.lookup` является точкой перехода от уровня кода к уровню протокола сериализации. 
До этого момента JVM работала с объектом как с экземпляром типа, после же работает с набором описанных структур и байтов, имея всю информацию о том, кто перед ним сейчас. Сам по себе этот вызов в первый раз занимает очень много времени и памяти, это первый залп использования рефлексии для сериализации.

Вернемся к методу `writeObject0` и рассмотрим последовательность проверок, которые он выполняет. После создания дескриптора класса начинается каскад проверок типа объекта:

1. Сначала проверяется, является ли объект строкой (`String`). Строковые значения обрабатываются специальным образом, так как сериализуются более эффективно.
2. Далее проверяется, является ли класс массивом.
3. После идет проверка на `enum`.

> Любой enum в JVM является Serializable по умолчанию, все потому что все enum классы не явно наследуются от настоящего класса java.lang.Enum. А класс java.lang.Enum уже наследуется от интерфейса Serializable

4. Наконец, если объект не подпадает ни под одну из специальных категорий, проверяется, реализует ли он интерфейс `Serializable`.

По итогу всех этих проверок происходит одно из двух: либо мы попадаем под категорию `Serializable` и продолжаем сериализацию, либо получаем ошибку `NotSerializableException`.

Для классов, реализующих `Serializable`, вызывается метод `writeOrdinaryObject`. После того как `writeObject0` определяет, что данный объект действительно реализует интерфейс `Serializable`, управление передаётся в этот метод.
Именно он отвечает за запись «обычного» объекта в поток(stream), то есть объекта, не являющегося строкой, массивом, перечислением или экземпляром `Externalizable`(про него будет далее в статье). 
В этом месте начинается реальная работа сериализационного механизма. Метод выглядит следующим образом, далее мы увидим его разбор:
```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
            throws IOException
    {
        ...
            desc.checkSerialize();

            bout.writeByte(TC_OBJECT);
            writeClassDesc(desc, false);
            handles.assign(unshared ? null : obj);

            if (desc.isRecord()) {
                writeRecordData(obj, desc);
            } else if (desc.isExternalizable() && !desc.isProxy()) {
                writeExternalData((Externalizable) obj);
            } else {
                writeSerialData(obj, desc);
            }
        }
        ...
    }
}
```

Первое, что делает `writeOrdinaryObject`, это вызов `desc.checkSerialize()`.
Этот вызов не просто формальность, а гарантия того, что класс, описанный `ObjectStreamClass desc`, удовлетворяет всем требованиям контракта сериализации. 
Здесь происходит верификация флага `Serializable`, проверка корректности сигнатуры специальных методов `writeObject`, `readObject`, `readResolve`, `writeReplace`, а также проверка соответствия вычисленного `serialVersionUID` тому, что объявлен явно. 
Если класс нарушает контракт, поток прерывается исключением `NotSerializableException`. Таким образом, сериализация никогда не начнётся для объекта, который не способен пройти эти структурные проверки.

После успешной валидации в поток записывается первый управляющий байт `TC_OBJECT`. Этот байт представляет собой сериализационный маркер, используемый `ObjectInputStream` при чтении потока для распознавания того, что далее следует именно объектная структура, а не строка, массив, ссылка или иной тип элемента.
Механизм Object Serialization в Java использует фиксированный бинарный протокол, где каждый элемент (объект, класс, поле, массив и т.д.) предваряется своим маркером. Для объекта это `0x73`, то есть байт `TC_OBJECT`. Таким образом, запись объекта всегда начинается с этого маркера.

Следом вызывается `writeClassDesc(desc, false)`.
В этом месте сериализация переходит от конкретного экземпляра к описанию его класса. Метод `writeClassDesc` отвечает за запись дескриптора класса, то есть структуры, содержащей имя класса, `serialVersionUID`, количество и типы сериализуемых полей, а также ссылки на суперклассы.
Если этот дескриптор уже встречался ранее в потоке, то вместо полного описания записывается ссылка `TC_REFERENCE`, указывающая на уже существующий дескриптор. Это экономит место и поддерживает консистентность структуры потока. Если же класс сериализуется впервые, то в поток последовательно записываются имя, версия, список полей и другие метаданные.
Именно благодаря `writeClassDesc` десериализация на другой стороне способна понять, как восстанавливать объект: какой класс использовать, какие поля прочитать и в каком порядке.

После записи дескриптора выполняется `handles.assign(unshared ? null : obj)`.
Это ключевой момент, связанный с таблицей хэндлов (handle table). Object Serialization в Java гарантирует сохранение ссылочной целостности: если один и тот же объект встречается несколько раз в графе, сериализатор не будет писать его заново, а запишет ссылку (`TC_REFERENCE`) на уже записанный экземпляр.
Для этого все объекты, прошедшие через поток, регистрируются в таблице хэндлов, где каждому объекту присваивается уникальный идентификатор.
Вызов `assign` выполняет именно это назначение. Если же объект помечен как `unshared`, то он не регистрируется, и в дальнейшем на него нельзя будет сослаться повторно. Такой флаг используется редко, но имеет значение при необходимости полного разрыва ссылочной связанности между частями сериализуемого графа.

На следующем этапе `writeOrdinaryObject` определяет конкретную природу класса. Здесь начинается развилка на три категории:

1. Если класс является `record`, вызывается `writeRecordData`.
2. Если класс реализует `Externalizable` (и при этом не является proxy), вызывается `writeExternalData`.
3. Во всех остальных случаях используется классическая ветвь `writeSerialData`.

Рассмотрим их последовательно.

**1. Record.**
Если `desc.isRecord()` возвращает `true`, то текущий класс является Java Record. Сериализация record-классов подчиняется отдельной логике, введённой начиная с Java 16. В отличие от обычных классов, record не имеет изменяемого состояния, все его поля являются компонентами, определёнными в сигнатуре конструктора.
Метод `writeRecordData` проходит по всем компонентам record в порядке их объявления и записывает их значения напрямую, без вызова `writeObject` или `writeExternal`. Это обеспечивает стабильный, детерминированный формат сериализации, независимый от пользовательских переопределений.
> Если вы из той самой(старой) школы, где последняя знакомая версия Java это 8 или 11, то record-классы могли пройти мимо вас. Они появились только с Java 16 и стали для Java тем, чем data class давно является для Kotlin, то есть лаконичным способом объявить неизменяемую структуру данных, где конструктор, equals, hashCode и toString генерируются компилятором. Разница лишь в том, что Java сделала это без излишнего синтаксического романтизма.

**2. Externalizable.**
Про Externalizable мы так же подробно пройдемся в этой статье, но пока для контекста его стоит тоже учитывать.
Если класс реализует интерфейс `Externalizable`, управление передаётся в `writeExternalData`. В этом случае сериализация полностью делегируется самому объекту.
Метод `writeExternalData` вызывает `obj.writeExternal(ObjectOutput)`. Здесь именно класс решает, какие данные и в каком порядке записывать в поток. В отличие от `Serializable`, где платформа управляет сериализацией автоматически, `Externalizable` предоставляет полную свободу, но и полную ответственность разработчику.
Важно отметить, что `writeOrdinaryObject` вызывает этот путь только если класс действительно Externalizable и не является proxy, поскольку динамические proxy обрабатываются иначе.

**3. Serializable (обычный случай).**
Если объект не является record и не Externalizable, остаётся классическая сериализация `Serializable`.
В этом случае вызывается `writeSerialData(obj, desc)`.
Именно этот метод и есть ядро стандартной сериализации Java. Он отвечает за последовательную запись всех сериализуемых полей объекта, включая унаследованные от суперклассов, а также за вызов пользовательских методов `writeObject`, если они определены в классе.
Внутри `writeSerialData` сначала записываются данные суперклассов, затем поля текущего класса. Если в классе определён метод `private void writeObject(ObjectOutputStream oos)`, он вызывается с передачей текущего потока, что позволяет переопределить стандартный формат записи.
Если такого метода нет, вызывается `defaultWriteFields`, который просто записывает все поля по описанию из `ObjectStreamClass desc`.

Таким образом, `writeOrdinaryObject` не содержит непосредственно логики записи самих данных. Он лишь определяет маршрут, то есть какую стратегию применить для конкретного типа класса. Это точка маршрутизации, своего рода диспетчер сериализации, обеспечивающий единообразие протокола при сохранении гибкости для различных типов.

После выполнения одной из ветвей (record, externalizable или serializable) объект полностью записан в поток, а таблица хэндлов зафиксирована для поддержания ссылочной целостности. Нас особенно интересует третья ветвь, то есть обычная сериализация через `Serializable`. Давайте рассмотрим метод `writeSerialData` более подробно:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeSerialData(Object obj, ObjectStreamClass desc)
            throws IOException
    {
        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
        for (int i = 0; i < slots.length; i++) {
            ObjectStreamClass slotDesc = slots[i].desc;
            if (slotDesc.hasWriteObjectMethod()) {
                PutFieldImpl oldPut = curPut;
                curPut = null;
                SerialCallbackContext oldContext = curContext;

                try {
                    curContext = new SerialCallbackContext(obj, slotDesc);
                    bout.setBlockDataMode(true);
                    slotDesc.invokeWriteObject(obj, this);
                    bout.setBlockDataMode(false);
                    bout.writeByte(TC_ENDBLOCKDATA);
                } finally {
                    curContext.setUsed();
                    curContext = oldContext;
                }

                curPut = oldPut;
            } else {
                defaultWriteFields(obj, slotDesc);
            }
        }
    }

}
```

Как мы помним из предыдущего раздела, этот метод вызывается для объектов, которые не являются ни record, ни externalizable, а представляют собой обычные классы, реализующие `Serializable`. Метод `writeSerialData` является тем местом, на который в большинстве случаев и замыкается сериализация. Если `writeOrdinaryObject` можно назвать маршрутизатором, то `writeSerialData` является исполнителем, именно здесь происходит фактическая запись состояния объекта.

В начале метода формируется массив `slots`, получаемый через `desc.getClassDataLayout()`. Это внутреннее представление иерархии классов, участвующих в сериализации. Каждый элемент массива представляет собой `ClassDataSlot`, содержащий ссылку на `ObjectStreamClass` конкретного уровня наследования. Таким образом, `slots` задаёт строгий порядок обхода цепочки классов сверху вниз, от самого предка, объявившего сериализуемые поля, до конечного потомка.

Далее выполняется цикл по этим слотам. Для каждого класса, представленного в `slotDesc`, сериализатор проверяет, определён ли в нём пользовательский метод `writeObject(ObjectOutputStream)`. Проверка осуществляется вызовом `slotDesc.hasWriteObjectMethod()`. Это та самая возможность, которая позволяет классу вмешаться в процесс сериализации и частично управлять тем, какие данные и в каком виде попадут в поток.

Если пользовательский `writeObject` найден, то создаётся контекст сериализационного коллбэка, представляющий собой объект `SerialCallbackContext`. Он необходим для корректного управления вложенными вызовами, в частности для обеспечения симметричной работы с `readObject` при десериализации. После этого включается блочный режим записи (`bout.setBlockDataMode(true)`), который группирует данные, записанные в процессе пользовательского `writeObject`, в единый блок. Это гарантирует, что весь пользовательский сегмент данных будет интерпретирован при чтении как одно логическое целое.

Далее вызывается сам метод `slotDesc.invokeWriteObject(obj, this)`. Это точка, где фактическое управление передаётся пользовательскому коду. Если класс переопределил `writeObject`, его логика выполняется здесь, с возможностью напрямую вызывать `defaultWriteObject()` или вручную записывать отдельные поля. После завершения блока запись возвращается в нормальный режим (`bout.setBlockDataMode(false)`), а затем в поток добавляется байт `TC_ENDBLOCKDATA`, обозначающий конец пользовательских данных.

Все временные структуры (`curPut`, `curContext`) восстанавливаются, чтобы состояние сериализатора осталось консистентным. Если же `extendedDebugInfo` включён, стек отладочной информации очищается. В случае отсутствия пользовательского метода выполняется стандартный путь: `defaultWriteFields(obj, slotDesc)`. Этот метод последовательно проходит по всем полям, определённым в `ObjectStreamClass`, и записывает их значения с использованием соответствующих механизмов сериализации (для примитивов это прямое бинарное значение, для ссылочных типов это рекурсивный вызов `writeObject0`).

Именно здесь завершается реальная работа сериализации объекта. После завершения цикла по всем слотам поток содержит полную бинарную структуру экземпляра, от базовых классов до финальных полей, с учётом всех пользовательских переопределений. Таким образом, `writeSerialData` является той точкой, где логическая модель класса превращается в поток байтов. Всё, что было подготовлено до этого (дескрипторы, таблицы хэндлов, метаданные), служит лишь инфраструктурой, обеспечивающей, чтобы эти байты могли быть восстановлены обратно в идентичный объект. После завершения `writeSerialData` объект считается полностью сериализованным, а поток готов к переходу к следующему элементу.

### Контроль над процессом сериализации

Теперь поговорим о нескольких важных механизмах, которые позволяют контролировать процесс сериализации. Представьте ситуацию: вы сериализовали объект и сохранили его в файл. Спустя месяц вы изменили класс, добавили новое поле или удалили старое. Что произойдет, если попытаться десериализовать старый файл? JVM может просто отказаться это делать, выбросив `InvalidClassException`. Для решения этой проблемы существует специальное поле `serialVersionUID`. Это уникальный идентификатор версии класса, который записывается в поток при сериализации. При десериализации JVM сравнивает `serialVersionUID` из потока с `serialVersionUID` текущего класса. Если они совпадают, десериализация продолжается, если нет, выбрасывается исключение. Если не указывать `serialVersionUID` явно, JVM вычислит его автоматически на основе структуры класса (имен полей, методов, модификаторов доступа). Проблема в том, что любое малейшее изменение в классе изменит этот хеш, и старые сериализованные объекты станут несовместимыми.

```kotlin
data class Person(
    val name: String,
    val dateOfBirth: Int,
    val address: String
) : Serializable {
    companion object {
        private const val serialVersionUID: Long = 1L
    }
}
```

Иногда в классе есть поля, которые не нужно или нельзя сериализовать. Например, это могут быть временные вычисляемые значения, кеши или чувствительные данные вроде паролей. В Java для этого существует ключевое слово `transient`, а в Kotlin используется аннотация `@Transient`. При сериализации все помеченные поля будут проигнорированы, а при десериализации они получат значения по умолчанию (null для объектов, 0 для чисел, false для boolean).

```kotlin
data class User(
    val username: String,
    @Transient val password: String = "",
    @Transient val cache: Cache? = null
) : Serializable
```

Что если стандартной сериализации недостаточно? Может быть, вы хотите зашифровать данные перед записью или выполнить какую-то предобработку? Для этого можно переопределить специальные методы `writeObject` и `readObject`:

```kotlin
class SecureUser(
    val username: String,
    private var password: String
) : Serializable {
    
    @Throws(IOException::class)
    private fun writeObject(out: ObjectOutputStream) {
        out.defaultWriteObject()
        val encrypted = encrypt(password)
        out.writeObject(encrypted)
    }
    
    @Throws(IOException::class, ClassNotFoundException::class)
    private fun readObject(input: ObjectInputStream) {
        input.defaultReadObject()
        val encrypted = input.readObject() as String
        password = decrypt(encrypted)
    }
    
    companion object {
        private const val serialVersionUID = 1L
    }
}
```

Обратите внимание, что эти методы должны быть `private`. Это может показаться странным, ведь обычно private методы не вызываются извне, но JVM использует рефлексию для их вызова.

Еще один интересный случай связан с синглтонами. При десериализации JVM создаст новый экземпляр объекта, нарушив паттерн Singleton. У вас появятся два "синглтона"! Чтобы этого избежать, используется метод `readResolve`:

```kotlin
object DatabaseConnection : Serializable {
    private const val serialVersionUID = 1L
    
    var host: String = "localhost"
    var port: Int = 5432
    
    private fun readResolve(): Any = DatabaseConnection
}
```

Метод вызывается сразу после десериализации объекта и может вернуть либо тот же объект, либо совершенно другой. В случае синглтона мы просто возвращаем существующий экземпляр, игнорируя десериализованный. Аналогично работает `writeReplace()`, который вызывается перед сериализацией и полезен, когда вы хотите сериализовать объект в более компактном виде.

Несмотря на кажущуюся простоту, `Serializable` таит в себе немало проблем. Использование рефлексии делает сериализацию медленной, каждый раз при сериализации JVM анализирует структуру класса через Reflection API. Бинарный формат Java содержит много метаинформации (имена классов, пакеты, типы полей), что увеличивает размер сериализованных данных. Изменение структуры класса легко ломает совместимость, даже добавление нового метода может изменить автоматически вычисляемый `serialVersionUID`. Десериализация непроверенных данных может привести к уязвимостям, когда злоумышленник создает специально сформированный поток байтов, который при десериализации выполнит вредоносный код. Наконец, при десериализации JVM создает объект, обходя конструктор, что означает, что любые проверки валидности в конструкторе будут проигнорированы.

При этом, все те возможности, которые мы только что рассмотрели (serialVersionUID, transient, writeObject, readResolve), на самом деле не решают главную проблему. Наше вмешательство минимально. Эти механизмы больше похожи на хуки или стандартные конфигурации, которые позволяют `Serializable` правильно работать в специфических случаях. Поле `serialVersionUID` нужно для версионирования, `readResolve` сохраняет синглтоны, `@Transient` исключает ненужные поля. Но ни один из этих методов не дает нам реального контроля над процессом сериализации и десериализации. Мы по-прежнему не можем влиять на производительность, не можем оптимизировать размер данных, не можем изменить формат записи. JVM продолжает использовать рефлексию, продолжает записывать всю метаинформацию, продолжает работать медленно. Мы просто пассажиры в этом процессе, которым разрешили настроить пару параметров.

Что если мы хотим большего? Что если нам нужен реальный контроль над тем, как именно сериализуются наши объекты? Для таких случаев у `Serializable` есть брат на стероидах.

## Интерфейс Externalizable

Если вы помните, в начале статьи мы говорили, что `Serializable` является маркерным интерфейсом без единого метода. JVM видит этот маркер и автоматически запускает механизм рефлексии. `Externalizable` работает совершенно иначе. Это не маркер, это контракт с двумя явными методами:

```java
public interface Externalizable extends java.io.Serializable {
    void writeExternal(ObjectOutput out) throws IOException;
    void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;
}
```

Обратите внимание, что `Externalizable` наследуется от `Serializable`. Это важная деталь, которая означает, что объекты `Externalizable` по-прежнему участвуют в общем механизме Java сериализации, но с принципиально другим подходом. JVM больше не использует рефлексию для обхода полей. Вместо этого она просто вызывает ваши методы `writeExternal` и `readExternal`, полностью перекладывая ответственность на вас. Полностью напоминает Parcelable из Android, не так ли?

Давайте перепишем наш класс `Person` с использованием `Externalizable`:

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = ""
) : Externalizable {
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeUTF(name)
        out.writeInt(dateOfBirth)
        out.writeUTF(address)
    }
    
    override fun readExternal(input: ObjectInput) {
        name = input.readUTF()
        dateOfBirth = input.readInt()
        address = input.readUTF()
    }
}
```

Сразу видна первая особенность: класс должен иметь конструктор без параметров. Это критическое требование. При десериализации JVM сначала создает экземпляр класса через этот конструктор, а затем вызывает `readExternal` для заполнения полей. Если конструктор отсутствует, вы получите `InvalidClassException`. В Kotlin это решается через параметры со значениями по умолчанию, как показано выше.
Далее попробуем так же сериализоваться, на этот раз наш класс реализует Externalizable, по этому фаил назовем "externalization.bin"
```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("externalization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```
Попробуем открыть файл как текстовый, видим что информации гораздо меньше, чем в случае с Serializable. Первым идет полное имя класса. Далее бросается в глаза, что отсутствуют имена полей и явные типы значений, привязанные к классам. За нечитаемым текстом находятся служебные маркеры протокола сериализации и последовательности байтов, соответствующие данным, записанным в writeExternal. Эти маркеры, такие как STREAM_MAGIC, STREAM_VERSION, TC_OBJECT, TC_CLASSDESC, TC_STRING, TC_ENDBLOCKDATA, TC_NULL, TC_REFERENCE, TC_BLOCKDATA и другие, играют роль структурных разделителей, позволяя JVM при десериализации понимать, где начинается и где заканчивается каждый элемент, а также определять их тип и контекст.

```text
�� sr Person��K��T  xpw 	John Wick  � New Yorkx
```

Теперь посмотрим, что происходит внутри. Помните метод `writeOrdinaryObject` из разбора `Serializable`? Тот самый каскад проверок типа объекта? Там была проверка на `Externalizable`, и если класс реализует этот интерфейс, управление передается в метод `writeExternalData`. 

Давайте посмотрим на его реализацию:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeExternalData(Externalizable obj) throws IOException {
        PutFieldImpl oldPut = curPut;
        curPut = null;

        SerialCallbackContext oldContext = curContext;
        try {
            curContext = null;
            if (protocol == PROTOCOL_VERSION_1) {
                obj.writeExternal(this);
            } else {
                bout.setBlockDataMode(true);
                obj.writeExternal(this);
                bout.setBlockDataMode(false);
                bout.writeByte(TC_ENDBLOCKDATA);
            }
        } finally {
            curContext = oldContext;
        }

        curPut = oldPut;
    }
}
```

Код выглядит значительно проще, чем вся та сложная машинерия с обходом полей через рефлексию, которую мы видели в `writeSerialData`. Да, дескриптор класса всё равно создается через `ObjectStreamClass.lookup` в методе `writeOrdinaryObject` до вызова `writeExternalData`, это необходимо для записи информации о самом классе (его имени, иерархии). Но вот чего здесь нет, так это рекурсивного обхода иерархии классов для записи полей каждого уровня, нет вызова `defaultWriteFields`, который через рефлексию читает значения всех полей. JVM просто вызывает `obj.writeExternal(this)`, передавая управление вашему коду. Вся ответственность за то, какие данные и как записывать, лежит на вас.

Обратите внимание на работу с блочным режимом данных (`setBlockDataMode`). Это технический момент, который обеспечивает правильную структуру сериализационного потока. В PROTOCOL_VERSION_2 (который используется по умолчанию с Java 1.2) данные записываются блоками, и каждый блок завершается маркером `TC_ENDBLOCKDATA`. Это позволяет JVM корректно определять границы данных объекта в потоке.

Процесс десериализации работает зеркально. Вместо сложного механизма восстановления полей через рефлексию, JVM создает объект через конструктор без параметров и вызывает `readExternal`:

```java
public class ObjectOutputStream extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void readExternalData(Externalizable obj, ObjectStreamClass desc)
            throws IOException {
        SerialCallbackContext oldContext = curContext;
        if (oldContext != null)
            oldContext.check();
        curContext = null;
        try {
            boolean blocked = desc.hasBlockExternalData();
            if (blocked) {
                bin.setBlockDataMode(true);
            }
            if (obj != null) {
                try {
                    obj.readExternal(this);
                } catch (ClassNotFoundException ex) {
                    handles.markException(passHandle, ex);
                }
            }
            if (blocked) {
                skipCustomData();
            }
        } finally {
            if (oldContext != null)
                oldContext.check();
            curContext = oldContext;
        }
    }
}
```

Снова видим, насколько это проще по сравнению с `Serializable`. Нет восстановления метаданных, нет рекурсивного чтения иерархии классов. Вызов `obj.readExternal(this)` и всё. Вы сами решаете, в каком порядке читать поля и как их интерпретировать.

Здесь важно понимать ключевое различие. При использовании `Serializable` JVM автоматически записывает в поток метаданные класса (имена полей, типы, информацию о пакетах). Помните тот "грязный" вывод файла serialization.bin, где среди байтов мы видели названия полей и типов? Всё это метаинформация, которую JVM добавляет автоматически. С `Externalizable` этого не происходит. В поток попадают только те данные, которые вы явно записали. Это делает сериализованные объекты значительно меньше по размеру.

Но с большой силой приходит большая ответственность. Вы должны гарантировать, что порядок записи в `writeExternal` точно соответствует порядку чтения в `readExternal`. Если вы запишете сначала String, потом Int, потом String, вы обязаны читать в том же порядке. Любое несоответствие приведет к неправильной десериализации или исключению. JVM больше не следит за этим за вас.

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = ""
) : Externalizable {
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeUTF(name)
        out.writeInt(dateOfBirth)
        out.writeUTF(address)
    }
    
    override fun readExternal(input: ObjectInput) {
        name = input.readUTF()          // Порядок совпадает!
        dateOfBirth = input.readInt()   // Порядок совпадает!
        address = input.readUTF()       // Порядок совпадает!
    }
}
```

Еще один важный момент касается версионирования. С `Serializable` мы использовали `serialVersionUID` для контроля совместимости версий. С `Externalizable` вы можете реализовать собственную логику версионирования:

```kotlin
class Person(
    var name: String = "",
    var dateOfBirth: Int = 0,
    var address: String = "",
    var phoneNumber: String = ""
) : Externalizable {
    
    companion object {
        private const val VERSION = 2
    }
    
    override fun writeExternal(out: ObjectOutput) {
        out.writeInt(VERSION)
        // ... запись остальных полей
        out.writeUTF(phoneNumber)  // Новое поле в версии 2
    }
    
    override fun readExternal(input: ObjectInput) {
        val version = input.readInt()
        // ... чтение остальных полей
        
        if (version >= 2) {
            phoneNumber = input.readUTF()
        }
    }
}
```

Такой подход дает гибкость в управлении обратной совместимостью. Вы можете добавлять новые поля, изменять формат данных, и всё это будет работать, пока ваша логика в `readExternal` корректно обрабатывает разные версии.

Производительность `Externalizable` теоретически выше, чем у `Serializable`, потому что отсутствует overhead рефлексии. Но это не означает автоматический выигрыш. Если вы пишете неэффективный код в `writeExternal` или `readExternal`, производительность может быть хуже. Реальные цифры мы увидим в разделе бенчмарков.

Когда стоит использовать `Externalizable`? Когда вам нужен полный контроль над форматом данных, когда критичен размер сериализованных объектов, или когда стандартная сериализация работает неэффективно для вашей структуры данных. Но помните, что с этим контролем приходит и ответственность за корректность реализации. Один промах в порядке чтения/записи, и ваша десериализация сломается способами, которые сложно диагностировать.

### От JVM к Android: почему Externalizable не подошел

Мы разобрали оба подхода к сериализации в JVM экосистеме. `Serializable` дает простоту использования, но платит за это производительностью и избыточностью данных. `Externalizable` предоставляет контроль, но требует больше кода и внимательности. Казалось бы, идеальное решение найдено, особенно для мобильных устройств, где важны и производительность, и размер данных.

Но когда Google разрабатывал Android, инженеры столкнулись с фундаментальной проблемой. Android это не просто Java на мобильном устройстве. Это экосистема с жесткими ограничениями: ограниченная память, батарея, процессоры с меньшей вычислительной мощностью (на момент создания Android). Но главное, это специфическая архитектура межпроцессного взаимодействия (IPC) через механизм Binder.

Давайте разберемся, в чем проблема. Оба механизма сериализации, которые мы рассмотрели, разрабатывались для JVM с определенными предположениями. Первое: сериализация обычно используется для долговременного хранения или передачи по сети. Второе: overhead создания потоков (`ObjectOutputStream`, `ObjectInputStream`) приемлем, потому что данные затем передаются куда-то далеко (на диск, по сети). Третье: формат должен быть совместим между разными версиями Java и даже разными JVM.

В Android всё иначе. Когда вы запускаете новый Activity, передаете данные в Service или отправляете broadcast, это не сетевая операция и не запись на диск. Это IPC между процессами на одном устройстве через Binder. Объекты нужно сериализовать и десериализовать не для отправки в другую страну, а для передачи в соседний процесс. Это происходит постоянно, сотни раз в секунду. Каждый лишний байт, каждая лишняя операция напрямую влияют на отзывчивость интерфейса.

Попробуйте использовать `Serializable` для передачи Intent с данными между Activity. Это работает, Android поддерживает это. Но за кулисами происходит следующее: создается `ObjectOutputStream`, запускается механизм рефлексии (даже несмотря на Dalvik/ART, это всё равно медленно), записываются метаданные класса, создается множество временных объектов, создается `ObjectInputStream` на другой стороне, запускается обратная рефлексия, снова создаются временные объекты. И вот здесь начинается настоящая проблема для Android. Каждый временный объект это работа для Garbage Collector. На старых Android устройствах с ограниченной памятью и примитивным GC паузы сборки мусора напрямую влияют на плавность интерфейса. Пользователь видит подтормаживания, лаги, фризы. Всё это для того, чтобы передать объект в процесс, который находится рядом. Это как заказывать грузовик с целой логистической цепочкой, чтобы перенести коробку к соседу.

А что насчет `Externalizable`? Он быстрее, да, и дает больше контроля. Технически, его можно использовать даже в памяти через `ByteArrayOutputStream`, без реальных файлов или сокетов. Android даже мог бы теоретически адаптировать его для IPC. Но проблемы остаются. Первая: формат данных всё равно привязан к Java сериализационному протоколу с его служебными маркерами (TC_OBJECT, TC_ENDBLOCKDATA и прочее), которые добавляют overhead. Вторая: вызовы `writeExternal` и `readExternal` всё равно проходят через слой абстракции потоков. Третья: это всё еще создает лишние объекты и нагружает GC, хоть и меньше, чем `Serializable`.

Binder работает иначе. Он минимизирует копирование данных между процессами, используя однократное копирование через ядро Linux. Данные пишутся напрямую в буфер `Parcel`, который затем передается через Binder driver с минимальными издержками. Для этого нужен механизм сериализации, который "понимает" эту специфику и работает напрямую с бинарным буфером без промежуточных слоев абстракции.

Именно поэтому был создан `Parcelable`. Концептуально он очень похож на `Externalizable`: вы реализуете два метода (`writeToParcel` и конструктор из `Parcel`), вы сами контролируете, что и как пишете, вы отвечаете за порядок записи и чтения. Идея ручного управления процессом сериализации явно пришла из `Externalizable`. Но реализация полностью переработана для Android. Вместо потоков используется `Parcel`, который работает с flat, untyped binary buffer. Вместо Java сериализационного протокола используется минималистичный формат без метаданных о типах. Вместо создания временных объектов данные пишутся напрямую в буфер, что минимизирует нагрузку на GC.

Важная особенность: `Parcel` это untyped buffer. В нем нет информации о типах данных, нет имен полей, нет версионирования. Это означает, что совместимости между версиями класса (как у `Serializable` с его `serialVersionUID`) здесь нет. Вы полностью отвечаете за обратную совместимость. Если вы измените порядок полей в `writeToParcel` и забудете обновить порядок чтения в конструкторе, данные будут прочитаны неверно, и вы получите трудноотлавливаемые баги. В этом плане `Serializable` был более "прощающим", автоматически обнаруживая несовместимость версий.

Изначально `Parcelable` приходилось писать вручную, что было утомительно и чревато ошибками. С появлением Kotlin ситуация изменилась. Плагин `kotlin-parcelize` (аннотация `@Parcelize`) автоматически генерирует весь boilerplate код во время компиляции, гарантируя корректность порядка записи и чтения полей. Это объединило контроль `Externalizable` с удобством `Serializable`.

Для тех кто сразу же начал распознавать Parcelable в Externalizable, да, `Externalizable` стал философской основой для `Parcelable`. Оба говорят: "не доверяй автоматике, возьми контроль в свои руки". Но `Parcelable` идет дальше, отбрасывая весь багаж JVM сериализации и создавая решение с нуля, оптимизированное под специфику Android: минимальное копирование через ядро, отсутствие временных объектов, прямая работа с бинарным буфером без типизации.

## Интерфейс Parcelable
