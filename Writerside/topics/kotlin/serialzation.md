# Введение

В этой статье мы рассмотрим технологии сериализации и десериализации данных в контексте экосистемы Android, Java, Kotlin JVM и Kotlin Native.

Сериализация и десериализация являются фундаментальными операциями в современной разработке. Эти процессы используются повсеместно: от хранения данных в локальном хранилище устройства до передачи информации по сети. Многие NoSQL базы данных применяют собственные форматы сериализации для оптимизации производительности. Наиболее распространённые форматы обмена данными (JSON, XML, Protocol Buffers, MessagePack и другие) тесно связаны с процессами сериализации.

Существует два основных подхода к реализации сериализации. Первый основан на рефлексии (reflection), которая позволяет анализировать структуру объектов во время выполнения (runtime), но сопряжена с накладными расходами на производительность. Второй подход использует кодогенерацию во время компиляции (compile-time), что значительно ускоряет обработку данных за счёт генерации специализированного кода. Например, Protocol Buffers требует предварительного описания контракта данных в `.proto` файлах, что позволяет генерировать оптимизированный код и устранять избыточные операции при десериализации.

При оценке решений для сериализации обычно приоритетным является скорость обработки, затем размер сериализованных данных, и лишь потом потребление оперативной памяти. Впрочем, для мобильных устройств и встраиваемых систем баланс этих факторов может смещаться в пользу минимизации памяти и размера данных.

В рамках данной статьи мы проанализируем существующие библиотеки и подходы к сериализации объектов в JVM и Native экосистемах, проведём сравнительное тестирование их производительности и выясним, какие решения являются наиболее эффективными в различных сценариях использования. Помимо получения конкретных метрик, мы также исследуем технические причины, определяющие производительность каждого подхода.

Для единообразия терминологии начнём с определения базовых понятий и терминов.


## Базис

**Сериализация** — это процесс преобразования структурированных данных (объектов, структур данных) в последовательность байтов или текстовое представление, пригодное для хранения или передачи. Сериализация «упаковывает» состояние объекта в формат, который можно сохранить в файл, передать по сети или поместить в базу данных.

**Десериализация** — это обратный процесс восстановления объекта из его сериализованного представления. Десериализация «распаковывает» последовательность байтов или текст обратно в структурированный объект с сохранением его типа и данных.

![serialization.svg](serialization.svg)


**Рефлексия (Reflection)** — это механизм времени выполнения, позволяющий программе анализировать и модифицировать свою собственную структуру и поведение. В контексте сериализации рефлексия используется для динамического обхода полей объектов без предварительной генерации кода.

**Кодогенерация (Code Generation)** — это автоматическое создание исходного кода во время компиляции на основе аннотаций, схем данных или других метаданных. Кодогенерация устраняет накладные расходы рефлексии за счёт создания специализированных классов-сериализаторов.

**Контракт данных (Data Contract/Schema)** — это формальное описание структуры данных, определяющее типы полей, их названия и правила валидации. Используется в Protocol Buffers (.proto файлы), Apache Avro и других схемо-ориентированных форматах.

Раз мы определились с базисом, теперь перейдем постепенно к способам сериализации в порядке эволюции, с точки зрения Kotlin и Android, с
точки зрения Java эволюции не было, первое решение и остается последним.

## Интерфейс Serializable
В мире JVM, Serializable пожалуй является самым первым и частым способом сериализации, сам Serializable является интерфейсом маркером, то есть
не имеющим никакой логики в себе, далее глянем на его исходники:
```java
package java.io;

public interface Serializable {
}
```
Для того чтобы мы могли сериализовать объект, нам достаточно наследоваться от этого интерфейса:

```kotlin
data class Person( 
    val name: String, 
    val dateOfBirth:Int, 
    val address:String
): Serializable
```

Теперь попробуем сериализовать объект данного класса, используя OutputStream:
```kotlin
fun main(args: Array<String>) {
    val person = Person("John Wick", 1964, "New York")
    val file = File("serialization.bin").apply(File::createNewFile)

    val fileOutputStream = FileOutputStream(file)
    val objectOutputStream = ObjectOutputStream(fileOutputStream).use { stream ->
        stream.writeObject(person)
        stream.flush()
    }
}
```

На выходе мы получим файл serialization.bin с сериализованными объектами, если попробуем прочесть этот файл как текстовый формат, то есть .txt, то увидим следующее:
```text
�� sr PersonTZ���c I dateOfBirthL addresst Ljava/lang/String;L nameq ~ xp  �t New Yorkt John Doe
```
Конечно же этот файл для нас не читаем, и кодировка UTF-8 видимо не подходящая, но все же можно увидеть названия полей, их типы, названия класса, и даже значения включая название пакетов.
Вы можете задаваться вопросом, если сериализация это превращение объекта в байты, то почему мы не видим нули и единицы а видим плюс минус читаемый текст? то все дело в том что мы открыли файл как text, то за нас уже произошла некоторая декодировка при превращения байтов в текст.
Теперь нас интересует откуда взялась вся информация о классе этого объекта который сериализован, и тут мы узнаем что Serializable полностью работает
с помощью Reflection API, но прежде чем углубиться в это, давайте разберемся в логике выше.
Первым делом мы создаем объект класса Person, создаем объект для John Wick(Да, да, тот самый),
Далее мы создаем файл в корне текущего проекта, и задавая имя serialization.bin,
После этого мы создаем FileOutputStream, его работа лишь в том чтобы открыть нам возможность записывать что-либо
в наш файл, представьте его как ручку, на этом этапе и до этого этапа еще нет никакой сериализации, и рефлексии.

Рефлексия и магия Serializable проявляется с момента создания ObjectOutputStream, а если быть точнее, то с момента
вызова функции writeObject, вся работа происходит именно в нем, что он делает? Берет наш объект класса Person, и постарается его сериализовать, а затем записать в наш файл serialization.bin
Сам ObjectOutputStream на самом деле ничего не знает о нашем файле serialization.bin, ObjectOutputStream работает с FileOutputStream, вот FileOutputStream и является посредником между нашим файлом и объектом.

Интересный момент, большинство видов Stream-ов, в лице наследников InputStream и OutputStream являются декораторами, например FileOutputStream и сам ObjectOutputStream всего лишь декораторы.

Процесс десериализации с Serializable будет выглядеть таким образом:
```kotlin

fun main(args: Array<String>) {

    val file = File("serialization.bin")
    val fileInputStream = FileInputStream(file)
    
    val objectInputStream = ObjectInputStream(fileInputStream).use { stream ->
        print(stream.readObject() as Person)
    }
}
```

Здесь мы сначала находим файл и затем прокидываем его в FileInputStream чтобы сохраненный набор байтов
обратно десериализовать и восстановить из него объект Person.

Сначала убедимся в том что Serializable точно играет роли, если мы уберем у класса Person наследование от интерфейса Serialzable, то
получим такого рода ошибку:
```
Exception in thread "main" java.io.NotSerializableException: Person
```

Глянем в исходники ObjectOutputStream и глянем на метод writeObject, ведь именно он принимает 
объект класса Person и сериализует его в набор байтов, далее исходники метода:
```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    public final void writeObject(Object obj) throws IOException {
        if (enableOverride) {
            writeObjectOverride(obj);
            return;
        }
        try {
            writeObject0(obj, false);
        } catch (IOException ex) {
            if (depth == 0) {
                writeFatalException(ex);
            }
            throw ex;
        }
    }
}
```

Этот метод своего рода Provider, если от класса унаследовались и переопределили открытый метод для переопределения, то будет использована
логика наследника, иначе вызов передается методу `writeObject0` который является стандартным у `ObjectOutputStream`, в нашем случае мы не наследовались от ObjectOutputStream
поэтому мы попадаем в метод `writeObject0`:

```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeObject0(Object obj, boolean unshared)
            throws IOException
    {
        ...
        ObjectStreamClass desc = ObjectStreamClass.lookup(cl, true);
        ...
        
        if (obj instanceof String) {
            writeString((String) obj, unshared);
        } else if (cl.isArray()) {
            writeArray(obj, desc, unshared);
        } else if (obj instanceof Enum) {
            writeEnum((Enum<?>) obj, desc, unshared);
        } else if (obj instanceof Serializable) {
            writeOrdinaryObject(obj, desc, unshared);
        } else {
            if (extendedDebugInfo) {
                throw new NotSerializableException(
                        cl.getName() + "\n" + debugInfoStack.toString());
            } else {
                throw new NotSerializableException(cl.getName());
            }
        }
        ...
    }
}
```

Метод writeObject0 содержит большую логику по проверке объекта, например на not nullable, no classable, not streamable, выше оставлена только
та логика которая в конечном итоге отвечает за работу сериализации стандартного объекта.

Но мы так же решили специально оставить создание объекта ObjectStreamClass, так как он играет важную роль в сериализации.

Рассмотрим вызов `ObjectStreamClass.lookup(cl, true)`. Именно здесь начинается реальная работа сериализации. 
Этот метод создает дескриптор класса (объект `ObjectStreamClass`), который фиксирует всю метаинформацию о типе, необходимую для его записи в поток. 
По сути, это сериализационный аналог рефлексии, но не на уровне исполнения, а на уровне протокола (контракта).

Метод `lookup` сначала проверяет внутренний кэш. Если дескриптор для данного класса уже существовал, он возвращается повторно. 
Если нет, то создается новый. В процессе создания выполняется полный анализ структуры класса:
определяются сериализуемые поля объекта, вычисляется `serialVersionUID`, проверяется наличие специальных методов (`writeObject`, `readObject`, `readResolve`, `writeReplace`), устанавливается связь с родительским дескриптором, фиксируются флаги, указывающие на природу класса (`enum`, `proxy`, `externalizable`, `record`).

Параметр `true` во втором аргументе означает, что дескрипторы создаются не только для самого класса, но и для всей цепочки его сериализуемых предков. Это важно: сериализация в Java всегда знает структуру объекта вплоть до первого не-`Serializable` родителя, и именно `lookup` формирует эту иерархию.

Результатом вызова становится объект `desc`, который будет передан в `writeOrdinaryObject`. Все дальнейшие шаги (запись сигнатуры, `serialVersionUID`, набора полей и их значений) выполняются строго в соответствии с тем, что описано в этом дескрипторе. Если дескриптор изменить, изменится и байтовое представление.

Таким образом, `ObjectStreamClass.lookup` является точкой перехода от уровня кода к уровню протокола сериализации. 
До этого момента JVM работала с объектом как с экземпляром типа, после же работает с набором описанных структур и байтов, имея всю информацию о том, кто перед ним сейчас. Сам по себе этот вызов в первый раз занимает очень много времени и памяти, это первый залп использования рефлексии для сериализации.

Теперь после этой строки, сосредочимся на проверках которые мы видим:
Сначала идет проверка на String, обычно String-овые значения сериализуются легче, далее проверка на массивность, после идет проверка на enum,

> Любой enum в JVM является Serializable по умолчанию, все потому что все enum классы не явно наследуются от настоящего класса java.lang.Enum. А класс java.lang.Enum уже наследуется от интерфейса Serializable

По итогу всех проверок, мы попадаем под категорию Serializable, или же получаем ошибку NotSerializableException,
Для классов наследующийхся от Serializable вызывается метод writeOrdinaryObject

После того как `writeObject0` определяет, что данный объект действительно реализует интерфейс `Serializable`, управление передаётся в метод `writeOrdinaryObject`.
Именно он отвечает за запись «обычного» объекта в поток, то есть объекта, не являющегося строкой, массивом, перечислением или экземпляром `Externalizable`. 
В этом месте начинается реальная работа сериализационного механизма. Метод выглядит следующим образом, далее мы увидим его разбор:
```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {
    
    private void writeOrdinaryObject(Object obj,
                                     ObjectStreamClass desc,
                                     boolean unshared)
            throws IOException
    {
        ...
            desc.checkSerialize();

            bout.writeByte(TC_OBJECT);
            writeClassDesc(desc, false);
            handles.assign(unshared ? null : obj);

            if (desc.isRecord()) {
                writeRecordData(obj, desc);
            } else if (desc.isExternalizable() && !desc.isProxy()) {
                writeExternalData((Externalizable) obj);
            } else {
                writeSerialData(obj, desc);
            }
        }
        ...
    }
}
```

Первое, что делает `writeOrdinaryObject`, это вызов `desc.checkSerialize()`.
Этот вызов не просто формальность, а гарантия того, что класс, описанный `ObjectStreamClass desc`, удовлетворяет всем требованиям контракта сериализации. 
Здесь происходит верификация флага `Serializable`, проверка корректности сигнатуры специальных методов `writeObject` и `readObject`, а также проверка соответствия вычисленного `serialVersionUID` тому, что объявлен явно. 
Если класс нарушает контракт, поток прерывается исключением `NotSerializableException`. Таким образом, сериализация никогда не начнётся для объекта, который не способен пройти эти структурные проверки.

После успешной валидации в поток записывается первый управляющий байт `TC_OBJECT`. Этот байт представляет собой сериализационный маркер, используемый `ObjectInputStream` при чтении потока для распознавания того, что далее следует именно объектная структура, а не строка, массив, ссылка или иной тип элемента.
Механизм Object Serialization в Java использует фиксированный бинарный протокол, где каждый элемент (объект, класс, поле, массив и т.д.) предваряется своим маркером. Для объекта это `0x73`, то есть байт `TC_OBJECT`. Таким образом, запись объекта всегда начинается с этого маркера.

Следом вызывается `writeClassDesc(desc, false)`.
В этом месте сериализация переходит от конкретного экземпляра к описанию его класса. Метод `writeClassDesc` отвечает за запись дескриптора класса, то есть структуры, содержащей имя класса, `serialVersionUID`, количество и типы сериализуемых полей, а также ссылки на суперклассы.
Если этот дескриптор уже встречался ранее в потоке, то вместо полного описания записывается ссылка `TC_REFERENCE`, указывающая на уже существующий дескриптор. Это экономит место и поддерживает консистентность структуры потока. Если же класс сериализуется впервые, то в поток последовательно записываются имя, версия, список полей и другие метаданные.
Именно благодаря `writeClassDesc` десериализация на другой стороне способна понять, как восстанавливать объект: какой класс использовать, какие поля прочитать и в каком порядке.

После записи дескриптора выполняется `handles.assign(unshared ? null : obj)`.
Это ключевой момент, связанный с таблицей хэндлов (handle table). Object Serialization в Java гарантирует сохранение ссылочной целостности: если один и тот же объект встречается несколько раз в графе, сериализатор не будет писать его заново, а запишет ссылку (`TC_REFERENCE`) на уже записанный экземпляр.
Для этого все объекты, прошедшие через поток, регистрируются в таблице хэндлов, где каждому объекту присваивается уникальный идентификатор.
Вызов `assign` выполняет именно это назначение. Если же объект помечен как `unshared`, то он не регистрируется, и в дальнейшем на него нельзя будет сослаться повторно. Такой флаг используется редко, но имеет значение при необходимости полного разрыва ссылочной связанности между частями сериализуемого графа.

На следующем этапе `writeOrdinaryObject` определяет конкретную природу класса. Здесь начинается развилка на три категории:

1. Если класс является `record`, вызывается `writeRecordData`.
2. Если класс реализует `Externalizable` (и при этом не является proxy), вызывается `writeExternalData`.
3. Во всех остальных случаях используется классическая ветвь `writeSerialData`.

Рассмотрим их последовательно.

**1. Record.**
Если `desc.isRecord()` возвращает `true`, то текущий класс является Java Record. Сериализация record-классов подчиняется отдельной логике, введённой начиная с Java 16. В отличие от обычных классов, record не имеет изменяемого состояния, все его поля являются компонентами, определёнными в сигнатуре конструктора.
Метод `writeRecordData` проходит по всем компонентам record в порядке их объявления и записывает их значения напрямую, без вызова `writeObject` или `writeExternal`. Это обеспечивает стабильный, детерминированный формат сериализации, независимый от пользовательских переопределений.
> Если вы из старой школы, и писали на Java 8,11 то вы не успели достать Record классы, это своего рода аналог data class в Kotlin 

**2. Externalizable.**
Про Externalizable мы так же подробно пройдемся в этой статье, но пока для контекста его стоит тоже учитывать.
Если класс реализует интерфейс `Externalizable`, управление передаётся в `writeExternalData`. В этом случае сериализация полностью делегируется самому объекту.
Метод `writeExternalData` вызывает `obj.writeExternal(ObjectOutput)`. Здесь именно класс решает, какие данные и в каком порядке записывать в поток. В отличие от `Serializable`, где платформа управляет сериализацией автоматически, `Externalizable` предоставляет полную свободу, но и полную ответственность разработчику.
Важно отметить, что `writeOrdinaryObject` вызывает этот путь только если класс действительно Externalizable и не является proxy, поскольку динамические proxy обрабатываются иначе.

**3. Serializable (обычный случай).**
Если объект не является record и не Externalizable, остаётся классическая сериализация `Serializable`.
В этом случае вызывается `writeSerialData(obj, desc)`.
Именно этот метод и есть ядро стандартной сериализации Java. Он отвечает за последовательную запись всех сериализуемых полей объекта, включая унаследованные от суперклассов, а также за вызов пользовательских методов `writeObject`, если они определены в классе.
Внутри `writeSerialData` сначала записываются данные суперклассов, затем поля текущего класса. Если в классе определён метод `private void writeObject(ObjectOutputStream oos)`, он вызывается с передачей текущего потока, что позволяет переопределить стандартный формат записи.
Если такого метода нет, вызывается `defaultWriteFields`, который просто записывает все поля по описанию из `ObjectStreamClass desc`.

Таким образом, `writeOrdinaryObject` не содержит непосредственно логики записи самих данных. Он лишь определяет маршрут, то есть какую стратегию применить для конкретного типа класса. Это точка маршрутизации, своего рода диспетчер сериализации, обеспечивающий единообразие протокола при сохранении гибкости для различных типов.

После выполнения одной из ветвей (record, externalizable или serializable) объект полностью записан в поток, а таблица хэндлов зафиксирована для поддержания ссылочной целостности.

```java
public class ObjectOutputStream
        extends OutputStream implements ObjectOutput, ObjectStreamConstants {

    private void writeSerialData(Object obj, ObjectStreamClass desc)
            throws IOException
    {
        ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();
        for (int i = 0; i < slots.length; i++) {
            ObjectStreamClass slotDesc = slots[i].desc;
            if (slotDesc.hasWriteObjectMethod()) {
                PutFieldImpl oldPut = curPut;
                curPut = null;
                SerialCallbackContext oldContext = curContext;

                if (extendedDebugInfo) {
                    debugInfoStack.push(
                            "custom writeObject data (class \"" +
                                    slotDesc.getName() + "\")");
                }
                try {
                    curContext = new SerialCallbackContext(obj, slotDesc);
                    bout.setBlockDataMode(true);
                    slotDesc.invokeWriteObject(obj, this);
                    bout.setBlockDataMode(false);
                    bout.writeByte(TC_ENDBLOCKDATA);
                } finally {
                    curContext.setUsed();
                    curContext = oldContext;
                    if (extendedDebugInfo) {
                        debugInfoStack.pop();
                    }
                }

                curPut = oldPut;
            } else {
                defaultWriteFields(obj, slotDesc);
            }
        }
    }

}
```

Нас интересует вызов writeSerialData, он вызывается в случае если объект не record, не externalizable, а именно serializable. Метод `writeSerialData` является тем местом, на который в большинстве случаев и замыкается сериализация. Если `writeOrdinaryObject` можно назвать маршрутизатором, то `writeSerialData` является исполнителем, именно здесь происходит фактическая запись состояния объекта.

В начале метода формируется массив `slots`, получаемый через `desc.getClassDataLayout()`. Это внутреннее представление иерархии классов, участвующих в сериализации. Каждый элемент массива представляет собой `ClassDataSlot`, содержащий ссылку на `ObjectStreamClass` конкретного уровня наследования. Таким образом, `slots` задаёт строгий порядок обхода цепочки классов сверху вниз, от самого предка, объявившего сериализуемые поля, до конечного потомка.

Далее выполняется цикл по этим слотам. Для каждого класса, представленного в `slotDesc`, сериализатор проверяет, определён ли в нём пользовательский метод `writeObject(ObjectOutputStream)`. Проверка осуществляется вызовом `slotDesc.hasWriteObjectMethod()`. Это та самая возможность, которая позволяет классу вмешаться в процесс сериализации и частично управлять тем, какие данные и в каком виде попадут в поток.

Если пользовательский `writeObject` найден, то создаётся контекст сериализационного коллбэка, представляющий собой объект `SerialCallbackContext`. Он необходим для корректного управления вложенными вызовами, в частности для обеспечения симметричной работы с `readObject` при десериализации. После этого включается блочный режим записи (`bout.setBlockDataMode(true)`), который группирует данные, записанные в процессе пользовательского `writeObject`, в единый блок. Это гарантирует, что весь пользовательский сегмент данных будет интерпретирован при чтении как одно логическое целое.

Далее вызывается сам метод `slotDesc.invokeWriteObject(obj, this)`. Это точка, где фактическое управление передаётся пользовательскому коду. Если класс переопределил `writeObject`, его логика выполняется здесь, с возможностью напрямую вызывать `defaultWriteObject()` или вручную записывать отдельные поля. После завершения блока запись возвращается в нормальный режим (`bout.setBlockDataMode(false)`), а затем в поток добавляется байт `TC_ENDBLOCKDATA`, обозначающий конец пользовательских данных.

Все временные структуры (`curPut`, `curContext`) восстанавливаются, чтобы состояние сериализатора осталось консистентным. Если же `extendedDebugInfo` включён, стек отладочной информации очищается. В случае отсутствия пользовательского метода выполняется стандартный путь: `defaultWriteFields(obj, slotDesc)`. Этот метод последовательно проходит по всем полям, определённым в `ObjectStreamClass`, и записывает их значения с использованием соответствующих механизмов сериализации (для примитивов это прямое бинарное значение, для ссылочных типов это рекурсивный вызов `writeObject0`).

Именно здесь завершается реальная работа сериализации объекта. После завершения цикла по всем слотам поток содержит полную бинарную структуру экземпляра, от базовых классов до финальных полей, с учётом всех пользовательских переопределений.

Таким образом, `writeSerialData` является той точкой, где логическая модель класса превращается в поток байтов. Всё, что было подготовлено до этого (дескрипторы, таблицы хэндлов, метаданные), служит лишь инфраструктурой, обеспечивающей, чтобы эти байты могли быть восстановлены обратно в идентичный объект. После завершения `writeSerialData` объект считается полностью сериализованным, а поток готов к переходу к следующему элементу.

