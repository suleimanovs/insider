---
title: 'Инструментальные тесты под капотом: как Android выполняет ваш код'
excerpt: 'Исследование внутренней кухни инструментальных тестов Android: от AndroidJUnitRunner и TestInstrumentationRunner до ActivityTestRule и ActivityScenario. Как инструментатор взаимодействует с приложением и что на самом деле происходит при запуске тестов на устройстве или эмуляторе.'
publishDate: 2025-08-08
readingTime: 25
locked: false
series: "Android под капотом: Тестирование без иллюзий"
    part: 2
category: "Android"
---

## 1. Введение: От симуляций к реальности

В первой части мы исследовали философские основы тестирования: как `assertEquals(expected, actual)` превращается в акт утверждения, зачем нужны Test Doubles и что означает контролируемое окружение. Мы говорили о тестах как о моделях поведения, о второй вселенной, где время стоит на месте, а зависимости делают только то, что мы им разрешаем.

Но что происходит, когда эта вторая вселенная сталкивается с первой? Когда ваш тест должен запуститься не в изолированной JVM, а на настоящем Android-устройстве, где есть реальный UI, настоящие Activity, живые сервисы и непредсказуемые состояния системы?

Добро пожаловать в мир **инструментальных тестов** — место, где философия встречается с жестокой реальностью Android Runtime.

Если unit-тесты — это контролируемые лабораторные условия, то инструментальные тесты — это полевые испытания. Здесь ваш код работает не в вакууме JVM, а внутри Android-процесса, где он делит память с системными службами, конкурирует за ресурсы с другими приложениями и подчиняется законам платформы, которые невозможно замокать.

Инструментальные тесты — это **параллельные миры в одном устройстве**. Ваше тестируемое приложение живет в одном процессе, а тестовый код — в другом. Они общаются через границы процессов, используют общие ресурсы системы и при этом должны оставаться изолированными друг от друга настолько, чтобы тест мог контролировать поведение приложения.

Это архитектурная задача огромной сложности. И Android решает её через механизм **Instrumentation** — систему, которая позволяет одному APK управлять жизненным циклом другого, вмешиваться в его работу и наблюдать за его поведением. Но как именно это работает под капотом?

В этой части мы разберём весь путь: от момента, когда вы запускаете `./gradlew connectedAndroidTest`, до того момента, когда ваш тестовый метод получает контроль над Activity. Мы изучим `AndroidJUnitRunner`, который оркеструет весь процесс, поймём разницу между `ActivityTestRule` и `ActivityScenario`, и раскроем тайну того, как тестовый код попадает внутрь процесса приложения.

Это история о том, как Android превращает хаос реального устройства в контролируемое окружение для тестов. И о том, какую цену мы платим за эту магию.

## 2. Анатомия инструментации: Два мира в одном устройстве

Чтобы понять, как работают инструментальные тесты, нужно сначала понять фундаментальное отличие Android от обычной JVM. В desktop Java-приложении ваш `main()` метод — это царь и бог. Он контролирует жизненный цикл программы от начала до конца. В Android такой роли нет.

Android-приложение — это не программа, а **набор компонентов**, управляемых системой. Activity, Service, BroadcastReceiver, ContentProvider — все они создаются, запускаются и уничтожаются не вами, а **Android Runtime**. Ваш код только реагирует на события жизненного цикла: `onCreate()`, `onStart()`, `onResume()`, `onDestroy()`.

Это создаёт проблему для тестирования. Как протестировать код, которым вы не управляете напрямую? Как запустить конкретную Activity в нужном состоянии? Как убедиться, что `onSaveInstanceState()` вызывается корректно?

Android решает эту проблему через **концепцию инструментации**. Instrumentation — это не просто библиотека или фреймворк. Это **привилегированный участник системы**, который имеет доступ к внутренним механизмам Android Runtime и может управлять жизненным циклом других приложений.

### Архитектура из двух APK

Когда вы запускаете инструментальные тесты, на устройство устанавливаются **два отдельных APK**:

1. **Application APK** — это ваше основное приложение в том виде, в котором его увидят пользователи в Google Play или установят через adb. Это полноценный Android-артефакт, содержащий весь ваш production-код: Activity, Fragment'ы, сервисы, ресурсы, манифест с декларациями компонентов. Когда я говорю "основное приложение", я имею в виду именно тот APK, который живёт своей обычной жизнью на устройстве, ничего не зная о том, что его будут тестировать. В контексте нашего примера это будет `com.suleimanov.instrumentation.apk` с обычной структурой Android-приложения.

2. **Test APK** — это принципиально иной тип артефакта, хотя формально он тоже является Android-приложением. Он содержит ваши тестовые классы, AndroidJUnitRunner, всю тестовую инфраструктуру, но самое важное — специальные декларации в манифесте, которые дают ему права на управление первым APK. Это не приложение в том смысле, как мы привыкли думать о приложениях. У него нет launcher activity, пользователь его никогда не запустит, он не появится в меню. Это системный инструмент, единственная цель которого — получить привилегированный доступ к основному приложению и выполнить тестовый код в контролируемых условиях. В нашем случае это будет `com.suleimanov.instrumentation.test.apk`.

Ключевое слово здесь — **отдельное**. Это не один процесс с двумя наборами классов. Это два полноценных Android-приложения, каждое со своим процессом, своим Application классом, своим контекстом и своими ресурсами.

Но между ними есть особая связь, объявленная в `AndroidManifest.xml` тестового APK:

```xml
<instrumentation 
    android:name="androidx.test.runner.AndroidJUnitRunner"
    android:targetPackage="com.suleimanov.instrumentation" />
```

Эта строчка говорит Android: *тестовый APK должен иметь права на управление приложением `com.suleimanov.instrumentation`*. Это не обычные права из `uses-permission`. Это **системные привилегии**, которые позволяют инструментации:

- Запускать и останавливать Activity тестируемого приложения
- Вызывать методы жизненного цикла принудительно
- Отправлять Intent'ы от имени тестируемого приложения  
- Получать доступ к его Application контексту
- Мониторить состояние его компонентов

Но здесь возникает философский вопрос доверия. Если любой APK может объявить себя тестом для моего `com.suleimanov.instrumentation` и получить такие привилегии, то где же безопасность? Android решает эту проблему элегантно и беспощадно: **криптографическим доверием**. Тестовый APK и основное приложение должны быть подписаны одним и тем же ключом. Не просто "тем же разработчиком" в смысле одинаковой подписи в Google Play Console, а именно тем же приватным ключом, который используется для подписи релизных версий.

Это означает, что если злоумышленник хочет создать тестовый APK для чужого приложения, ему потребуется не только исходный код тестов, но и приватный ключ разработчика. А если у него есть приватный ключ, то проблемы у владельца приложения намного серьёзнее, чем возможность запуска тестов.

Когда система устанавливает оба APK, происходит нечто интересное с точки зрения архитектуры безопасности Android. Обычно каждое приложение получает уникальный User ID для полной изоляции от других приложений. Но в случае инструментации Android нарушает это правило: тестовый APK `com.suleimanov.instrumentation.test` получает тот же User ID, что и основное приложение `com.suleimanov.instrumentation`. Это не ошибка, а осознанное архитектурное решение.

Одинаковый User ID означает, что тестовый процесс может напрямую читать и записывать файлы основного приложения. Все те SharedPreferences, базы данных SQLite, private-файлы в `/data/data/com.suleimanov.instrumentation/` становятся доступными тестовому коду для чтения и модификации. Именно поэтому в инструментальных тестах можно проверять, что данные корректно сохранились в базу, или подготавливать тестовые данные напрямую через file system операции.

Но эта архитектура накладывает и фундаментальные ограничения. Поскольку тестовый код и код приложения выполняются в разных процессах, между ними невозможен прямой обмен объектами. Вы не можете взять экземпляр своего `UserRepository` из основного приложения и передать его в тест для проверки состояния. Все взаимодействие должно идти либо через публичные API (Intent'ы, Broadcast'ы), либо через файловую систему, либо через механизмы Instrumentation.

Именно поэтому Espresso кажется таким магическим. Когда вы пишете `onView(withId(R.id.button)).perform(click())`, за этой простой строчкой скрывается сложная хореография межпроцессного взаимодействия: тестовый процесс сериализует описание View для поиска, отправляет его через IPC в процесс приложения, там Instrumentation ищет нужный View в иерархии, эмулирует клик, и результат возвращается обратно в тестовый процесс. Все эти IPC-вызовы делают инструментальные тесты медленнее unit-тестов не только из-за реального UI, но и из-за постоянных переключений между процессами.

#### Разрешения и системные диалоги

Runtime‑разрешения обрабатываются инструментированным раннером и системой: `GrantPermissionRule` формирует соответствующие системные вызовы от имени тестового процесса. Взаимодействие с системными диалогами и внешними окнами выполняется через `UiDevice`/`UiAutomation`, которые делегируют команды системным сервисам вне процесса приложения. Модель безопасности сохраняется: управление другими приложениями ограничено разрешениями и политиками платформы.

И здесь есть ещё одна деталь, которая может удивить тех, кто впервые сталкивается с инструментальными тестами. После завершения выполнения `./gradlew connectedAndroidTest` вы не найдёте тестовый APK `com.suleimanov.instrumentation.test` на устройстве. Он исчезнет, как будто его никогда и не было. Это не ошибка и не случайность — это осознанное решение Android Gradle Plugin.

Начиная с версии AGP 8.1.0, система **автоматически удаляет тестовый APK после завершения инструментальных тестов**. Философия здесь проста: тестовый APK — это временный артефакт, который нужен только на время выполнения тестов. Как только его работа закончена, он становится цифровым мусором, который может помешать следующим запускам тестов или повлиять на состояние устройства.

Представьте, что будет, если на CI-сервере после каждого прогона тестов будут оставаться десятки тестовых APK от разных веток и коммитов. Или если на вашем development-устройстве накопятся тестовые APK от разных версий приложения, каждый из которых пытается получить права на управление основным приложением. Автоматическое удаление — это гигиена тестового окружения.

Если по какой-то причине вам нужно оставить тестовый APK на устройстве (например, для отладки или исследования), начиная с AGP 8.3.0 можно добавить в `gradle.properties` флаг:

```properties
android.injected.androidTest.leaveApksInstalledAfterRun=true
```

Но помните: если вы используете этот флаг, вы берёте на себя ответственность за управление состоянием устройства и возможные конфликты между разными версиями тестовых APK.

### Кто такой Instrumentation?

`Instrumentation` — это системный класс Android, который служит **мостом между тестовым APK и тестируемым приложением**. Каждое Android-приложение имеет свой экземпляр Instrumentation, но обычно он используется только системой для управления жизненным циклом.

В случае тестов всё иначе. Тестовый APK получает **расширенный экземпляр Instrumentation**, который может не только наблюдать за происходящим, но и активно вмешиваться в процессы.

Посмотрите на ключевые методы класса `Instrumentation`:

```java
public class Instrumentation {

    // Управление Activity
    public Activity startActivitySync(Intent intent) { ... }
    public void callActivityOnCreate(Activity activity, Bundle icicle) { ... }
    public void callActivityOnStart(Activity activity) { ... }
    public void callActivityOnResume(Activity activity) { ... }
    public void callActivityOnPause(Activity activity) { ... }
    public void callActivityOnStop(Activity activity) { ... }      
    public void callActivityOnDestroy(Activity activity) { ... }   

    // Отправка событий ввода
    public void sendKeyDownUpSync(int key) { ... }
    public void sendPointerSync(MotionEvent event) { ... }

    // Мониторинг запуска Activity
    public ActivityMonitor addMonitor(ActivityMonitor monitor) { ... }
    public Activity waitForMonitor(ActivityMonitor monitor) { ... }                 
    public Activity waitForMonitorWithTimeout(ActivityMonitor m, long timeout) { ... } 
}

```

Каждый из этих методов — это **прямое вмешательство в работу тестируемого приложения**. `callActivityOnCreate()` принудительно вызывает `onCreate()` у Activity. `startActivitySync()` запускает Activity и **блокирует выполнение до тех пор, пока Activity не будет полностью инициализирована**. `sendKeyDownUpSync()` эмулирует нажатия клавиш на уровне системы.

Это возможно, потому что Instrumentation работает **внутри того же процесса**, что и тестируемое приложение. Не в том же процессе, что и тестовый код — в том же процессе, что и само приложение.

### Участники архитектуры

Архитектура инструментальных тестов включает три основных участника с различными ролями. Корректное понимание их функций важно для объяснения того, почему инструментальные тесты работают именно так.

**Test Process** — процесс, в котором выполняется тестовый код: методы `@Test`, `AndroidJUnitRunner`, JUnit Platform. Процесс запускается из тестового APK `com.suleimanov.instrumentation.test` и содержит логику того, что и как тестировать. Ограничение: отсутствует прямое взаимодействие с целевым приложением (невозможно напрямую создать `Activity`, кликнуть по кнопке или прочитать `TextView`), возможна только формулировка намерений с передачей через границы процессов.

**Application Process** — процесс приложения `com.suleimanov.instrumentation`, где выполняется бизнес‑логика, создаются `Activity` и `View`, происходят пользовательские взаимодействия. Он создаётся и управляется системой так же, как при запуске пользователем. Процесс не осведомлён о факте тестирования.

**Instrumentation Bridge** — механизм, позволяющий `Test Process` управлять `Application Process`. Состоит из: экземпляра `Instrumentation` внутри процесса приложения; каналов Binder IPC для передачи команд между процессами; механизмов синхронизации для корректного переключения между `UI Thread` и фоновыми потоками. Этот механизм объединяет два изолированных процесса в единую тестовую систему.

### Последовательность взаимодействий: от теории к практике

Для иллюстрации последовательности взаимодействий рассмотрим полный путь выполнения конкретного теста. Базовый сценарий: Activity с одной кнопкой; проверяется изменение текста по клику.

Несмотря на кажущуюся простоту, сценарий демонстрирует архитектурную сложность инструментального тестирования. Каждый шаг — запуск `Activity`, поиск кнопки, эмуляция клика, проверка результата — координируется между `Test Process`, `Application Process` и `Instrumentation Bridge`: формулирование намерений в тестовом процессе, передача через IPC, выполнение в приложении и возврат результатов.

Возьмём простую Activity с одной кнопкой, которая меняет свой текст в зависимости от клика:

```kotlin
class MainActivity : AppCompatActivity() {

    private val button: AppCompatButton by lazy { findViewById(R.id.button) }
    private var isButtonClicked: Boolean = false
    private val buttonText: String get() = if (isButtonClicked) "Clicked!" else "Click Me"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        button.text = buttonText
        button.setOnClickListener {
            isButtonClicked = !isButtonClicked
            button.text = buttonText
        }
    }
}
```

Эта Activity живёт в процессе нашего основного приложения `com.suleimanov.instrumentation`. Она ничего не знает о том, что её будут тестировать — это обычный Android-компонент, который реагирует на пользовательские взаимодействия и обновляет свой UI. Для полноты картины, вот layout этой Activity:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.appcompat.widget.AppCompatButton
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="56dp"
        android:layout_gravity="center"
        android:layout_margin="48.dp" />
</FrameLayout>
```

Теперь создадим тест, который будет проверять поведение этой кнопки. Казалось бы, что может быть проще — кликнуть по кнопке и убедиться, что текст изменился:

```kotlin
@RunWith(AndroidJUnit4::class)
class ExampleInstrumentedTest {

    @get:Rule
    val activityRule = ActivityScenarioRule(MainActivity::class.java)

    @Test
    fun testButtonClick() {
        onView(withId(R.id.button)).perform(click())
        onView(withId(R.id.button)).check(matches(withText("Clicked!")))
    }
}
```

Прежде чем погружаться в архитектурную сложность выполнения этого теста, стоит понять, из каких компонентов он состоит и откуда эти компоненты берутся. Этот небольшой фрагмент кода объединяет в себе несколько различных библиотек и фреймворков, каждый из которых решает свою задачу в экосистеме Android-тестирования.

`@Test` и `@get:Rule` — это классические аннотации **JUnit**, той самой тестовой платформы, которую мы подробно изучали в первой части. Они принадлежат не Android-миру, а обычному JVM-тестированию и работают точно так же, как в любом Java или Kotlin проекте. `@Test` помечает метод как тестовый случай, а `@get:Rule` позволяет внедрить дополнительную логику в жизненный цикл теста.

`@RunWith(AndroidJUnit4::class)` — это мост между стандартным JUnit и Android-реальностью. `AndroidJUnit4` принадлежит библиотеке **androidx.test**, и его задача — адаптировать обычный JUnit Runner для работы в условиях Android. Именно эта аннотация говорит JUnit Platform: "этот тест должен выполняться не как обычный unit-тест, а как инструментальный тест с доступом к Android API".

`ActivityScenarioRule` — это компонент **Android JUnit Extensions** (androidx.test.ext.junit), современного подхода к управлению жизненным циклом Activity в тестах. Он заменил устаревший ActivityTestRule и предоставляет более гибкий API для работы с Activity. Это Rule автоматически запускает указанную Activity перед каждым тестом и закрывает её после завершения.

`onView()`, `withId()`, `perform()`, `check()`, `matches()`, `withText()` — вся эта цепочка принадлежит **Espresso**, библиотеке Google для UI-тестирования Android. Espresso предоставляет декларативный API для поиска View-компонентов, выполнения действий и проверки результатов. `withId(R.id.button)` — это ViewMatcher, который ищет View по resource ID. `click()` — это ViewAction, которая эмулирует клик. `withText("Clicked!")` — это Matcher, который проверяет текстовое содержимое View.

Интересно, что в этом простом тесте сочетаются компоненты четырёх разных уровней абстракции: базовый JUnit для структуры теста, AndroidJUnit4 для интеграции с Android, ActivityScenarioRule для управления жизненным циклом и Espresso для взаимодействия с UI. Каждый уровень решает свою задачу, но все они должны работать согласованно в рамках архитектуры инструментальных тестов.

Этот тест выглядит обманчиво просто — всего две строчки логики. Но за этими двумя строчками скрывается удивительно сложная последовательность операций, которая демонстрирует всю мощь и всю сложность архитектуры инструментальных тестов.

Когда AndroidJUnitRunner запускает этот тест, происходит сложная межпроцессная хореография. Сначала ActivityScenarioRule запускает нашу MainActivity в процессе приложения `com.suleimanov.instrumentation`. Затем тестовый код в процессе `com.suleimanov.instrumentation.test` формирует намерение: найти View с ID `R.id.button` и эмулировать на нём клик. Это намерение сериализуется и отправляется через Instrumentation Bridge в процесс приложения, где Instrumentation ищет нужный View, генерирует MotionEvent и передаёт его в View через стандартный механизм обработки touch событий Android. Результат этого взаимодействия — изменение текста кнопки — затем проверяется аналогичным образом: тестовый процесс отправляет запрос на получение текста кнопки, получает ответ "Clicked!" и сравнивает его с ожидаемым значением.

### Почему архитектурная сложность неизбежна

Глядя на эту сложную межпроцессную хореографию, естественно возникает вопрос: неужели нельзя было сделать проще? Почему бы не запустить тестовый код в том же процессе, что и приложение, и избежать всех этих IPC-вызовов, сериализации намерений и переключений между потоками?

Ответ лежит в самой природе того, что мы пытаемся достичь через тестирование. Инструментальные тесты должны проверять не просто корректность алгоритмов — для этого есть unit-тесты. Они должны проверять поведение приложения как системы, включая его взаимодействие с Android Runtime, реакцию на системные события, корректность управления жизненными циклами.

Чтобы проверить, как приложение ведёт себя при смене конфигурации, тест должен иметь возможность убить и пересоздать процесс приложения. Чтобы убедиться, что приложение корректно восстанавливается после недостатка памяти, тест должен иметь возможность принудительно вызвать `onTrimMemory()`. Чтобы проверить обработку входящих звонков или push-уведомлений, тест должен уметь эмулировать системные события, которые недоступны обычным приложениям.

Если тестовый код работает в том же процессе, что и приложение, он теряет эту возможность внешнего контроля. Падение теста может привести к падению всего приложения, состояние одного теста может влиять на другой, а самое главное — тест не сможет наблюдать за приложением со стороны и управлять его жизненным циклом.

Разделение на процессы превращает тесты в **привилегированных наблюдателей**. Они получают возможности, которых нет у обычных Android-приложений: возможность принудительно вызывать методы жизненного цикла Activity, возможность эмулировать системные события, возможность перезапускать приложение в контролируемых условиях. Это и есть настоящая ценность инструментальных тестов.

Конечно, эта архитектурная сложность имеет свою цену. IPC-вызовы делают тесты медленными. Серializация данных создаёт накладные расходы. Отладка через границы процессов усложняется. Но это цена за возможность тестировать реальное поведение Android-приложения в условиях, максимально приближенных к production.

Инструментация — это не просто инструмент для запуска тестов. Это архитектурное решение, которое превращает хаос реального Android-устройства в контролируемую среду для проверки гипотез о поведении приложения. И чтобы эффективно использовать эту мощь, нужно понимать того, кто этой мощью управляет.

Мы разобрали архитектуру из двух APK, поняли роли трёх участников танца, проследили межпроцессную хореографию на практическом примере. Мы увидели, как простой клик по кнопке превращается в сложную последовательность IPC-вызовов, как тестовые компоненты из разных библиотек работают согласованно, почему архитектурная сложность неизбежна. Но остался главный вопрос: кто или что координирует всю эту сложность?

Ведь кто-то должен запустить тестовый процесс, кто-то должен создать процесс приложения, кто-то должен установить Instrumentation Bridge между ними. Кто-то должен инициализировать AndroidJUnit4, ActivityScenarioRule и Espresso так, чтобы они работали в согласии. Кто-то должен обеспечить правильную последовательность создания Application, запуска Activity, выполнения тестовых методов и очистки ресурсов после завершения.

В обычном JVM-тестировании эту роль играет JUnit Platform, который мы подробно изучали в первой части. Но Android — это не JVM. Здесь нет `main()` метода, здесь компоненты управляются системой, здесь жизненный цикл диктует не программист, а Android Runtime. JUnit Platform не знает, что такое Activity, он не умеет работать с Android-контекстами, он не понимает специфики межпроцессного взаимодействия в Android.

Именно поэтому Android-экосистема нуждается в собственном дирижёре — компоненте, который понимает как язык JUnit, так и диалект Android, который может переводить намерения тестов в команды для Android Runtime и обратно.

## 3. AndroidJUnitRunner: Дирижёр оркестра тестов

В первой части мы подробно разобрали, как JUnit Platform оркеструет выполнение тестов на JVM. Но что происходит, когда этот процесс должен быть адаптирован для Android — системы с совершенно иной архитектурой, где нет `main()` метода, где компоненты управляются системой, а не программистом?

`AndroidJUnitRunner` — это не просто адаптер между JUnit и Android. Это философский компромисс между двумя принципиально разными мирами. С одной стороны, мир JUnit, где тесты — это обычные методы, которые можно вызвать из `main()`, где всё предсказуемо и детерминированно. С другой стороны, мир Android, где приложение — это не программа, а набор компонентов, управляемых системой, где жизненный цикл диктуется не кодом, а пользовательскими действиями и системными событиями.

AndroidJUnitRunner должен примирить эти две реальности. Он должен взять хаос Android-окружения — с его Activity, Service, жизненными циклами, системными службами, межпроцессным взаимодействием — и превратить его в контролируемую среду, понятную JUnit Platform. При этом он не может потерять ни мощь JUnit (структурированное выполнение тестов, отчётность, расширяемость), ни аутентичность Android (реальные компоненты, настоящие жизненные циклы, системная интеграция).

Эта задача требует от AndroidJUnitRunner быть одновременно инженером, дипломатом и фокусником. Инженером — потому что нужно координировать сложнейшую архитектуру из множества процессов, потоков и IPC-каналов. Дипломатом — потому что нужно заставить работать вместе компоненты, изначально не предназначенные для совместной работы. Фокусником — потому что нужно создать иллюзию простоты там, где на самом деле скрывается архитектурная сложность.

### Архитектурная генеалогия

История AndroidJUnitRunner — это история эволюции понимания того, как должно быть устроено тестирование в Android. Он не появился в один день как готовое решение, а вырос из потребности объединить мощь системного класса `Instrumentation` с гибкостью тестового фреймворка JUnit.

В основе этой иерархии лежит `Instrumentation` — один из самых могущественных классов Android API. Instrumentation существует с первых версий Android и изначально создавался не для тестирования, а для системного мониторинга и управления приложениями. Это класс, который даёт возможность одному приложению контролировать жизненный цикл другого — возможность, которой обычно нет ни у одного Android-компонента.

`MonitoringInstrumentation` добавляет к базовым возможностям слой наблюдения и логирования, превращая Instrumentation из инструмента контроля в инструмент анализа. Он умеет отслеживать производительность, запоминать события, собирать метрики — всё то, что необходимо для диагностики поведения приложения.

`AndroidJUnitRunner` завершает эту эволюцию, встраивая в архитектуру мониторинга и контроля язык тестирования JUnit. Он берёт системные возможности Instrumentation, аналитические способности MonitoringInstrumentation и соединяет их с тестовой философией JUnit Platform.

Принципиальное отличие от обычного JUnit кроется в точке входа. В JVM-мире тесты начинаются с `main()` метода, который программист контролирует полностью. В Android-мире тесты начинаются с `onCreate()` метода Instrumentation, который вызывается Android системой по её собственным правилам и в её собственное время. AndroidJUnitRunner не выбирает, когда ему запускаться — он просто реагирует на системный вызов и делает всё возможное, чтобы в этих условиях создать знакомую тестовую среду.

### Жизненный цикл AndroidJUnitRunner: от команды до исполнения

Путь от команды `./gradlew connectedAndroidTest` до выполнения первого `@Test` метода — это путь через несколько слоёв абстракции, каждый из которых трансформирует человеческое намерение "запустить тесты" в машинные команды, понятные Android Runtime.

Когда Gradle получает команду запустить connected tests, он не просто выполняет тесты — он оркеструет сложный процесс подготовки тестового окружения. Сначала собираются два APK: основное приложение `com.suleimanov.instrumentation.apk` и тестовое приложение `com.suleimanov.instrumentation.test.apk`. Затем оба APK устанавливаются на устройство, и система создаёт связи между ними через механизмы PackageManager.

Финальная команда `adb shell am instrument -w com.suleimanov.instrumentation.test/androidx.test.runner.AndroidJUnitRunner` — это уже не человеческий язык, а системный протокол. Эта команда говорит ActivityManagerService: "создай процесс для пакета `com.suleimanov.instrumentation.test`, но управлять им будет не обычный Application класс, а AndroidJUnitRunner, который имеет права на инструментацию пакета `com.suleimanov.instrumentation`".

В этот момент происходит нечто уникальное в мире Android-разработки: система создаёт процесс приложения, но вместо обычного Application.onCreate() вызывается Instrumentation.onCreate(). AndroidJUnitRunner получает контроль над процессом ещё до того, как основной код приложения узнает о своём существовании.

```java
public class AndroidJUnitRunner extends MonitoringInstrumentation {
    
    @Override
    public void onCreate(Bundle arguments) {
        super.onCreate(arguments);
        
        // Анализ параметров тестирования из командной строки
        parseRunnerArguments(arguments);
        
        // Подготовка тестового окружения
        setupTestEnvironment();
        
        // Интеграция с JUnit Platform
        createTestPlatform();
        
        // Сигнал системе о готовности
        start();
    }
}
```

Этот момент критически важен для понимания природы инструментального тестирования. AndroidJUnitRunner находится в уникальной позиции: он ещё не тестовый код (тесты пока не запущены), но уже не обычное приложение. Он существует в промежуточном состоянии, где есть доступ к системным возможностям Android, но ещё нет привязки к конкретной бизнес-логике. Это позволяет ему подготовить почву для тестирования, не нарушая чистоту тестового окружения.

Следующий этап — одна из самых деликатных операций во всём процессе инструментального тестирования. AndroidJUnitRunner должен инициализировать тестируемое приложение `com.suleimanov.instrumentation`, но сделать это контролируемо, не позволяя приложению "жить полной жизнью".

```java
@Override
public void onStart() {
    super.onStart();
    
    // Получение контекста целевого приложения
    Context targetContext = getTargetContext();
    
    // Контролируемая инициализация Application
    callApplicationOnCreate();
    
    // Переход к выполнению тестов
    runTests();
    
    // Завершение с отчётом
    finish(RESULT_OK, Bundle.EMPTY);
}
```

Вызов `getTargetContext()` — это не просто получение ссылки на объект. Это момент, когда AndroidJUnitRunner устанавливает связь с душой тестируемого приложения. Возвращаемый контекст принадлежит не тестовому APK `com.suleimanov.instrumentation.test`, а основному приложению `com.suleimanov.instrumentation`. Через этот контекст тесты получают доступ к ресурсам, настройкам, файлам, базам данных приложения — ко всему тому, что делает приложение приложением, а не просто набором классов.

Примечание о выборе контекста:

- `InstrumentationRegistry.getContext()` возвращает контекст тестового APK (ресурсы/окружение тестов) и используется раннером.
- `InstrumentationRegistry.getTargetContext()`/`ApplicationProvider.getApplicationContext()` возвращают контекст целевого приложения; современные реализации раннера используют абстракции поверх него. Это влияет на то, какие ресурсы и хранилища доступны при выполнении тестов и где происходит инициализация `Application`.

Но здесь кроется философская дилемма: как инициализировать приложение, не запуская его? AndroidJUnitRunner решает её хирургически точно. Он вызывает `callApplicationOnCreate()`, что приводит к созданию Application класса и вызову его `onCreate()` метода. Приложение "просыпается", инициализируется, подготавливает свою внутреннюю инфраструктуру. Но Activity не создаются, UI не отрисовывается, пользовательский интерфейс остаётся невидимым. Приложение живёт, но не показывается.

Теперь настаёт момент истины — AndroidJUnitRunner должен интегрировать JUnit Platform в Android-реальность. Это не просто техническая операция, а философское примирение двух миров. JUnit Platform, который мы подробно изучали в первой части, изначально создавался для JVM-окружения, где нет Android-специфики. AndroidJUnitRunner должен заставить эту JVM-платформу работать внутри Android-процесса, подчиняющегося совершенно иным законам.

```java
public class AndroidJUnitRunner extends MonitoringInstrumentation {
    
    private void runTests() {
        // Создание тестового плана в Android-контексте
        LauncherDiscoveryRequest request = createDiscoveryRequest();
        TestPlan testPlan = launcher.discover(request);
        
        // Выполнение с Android-адаптированными слушателями
        launcher.execute(testPlan, 
            new AndroidTestListener(),
            new InstrumentationResultReporter()
        );
    }
}
```

Ключевое отличие от обычного JUnit кроется не в коде, а в контексте выполнения. В JVM-тестах Launcher работает в предсказуемом окружении, где есть полный контроль над потоками, памятью, жизненным циклом. В Android Launcher работает внутри процесса, управляемого системой, где Main Thread принадлежит не тестам, а UI, где память может быть освобождена системой в любой момент, где жизненный цикл диктуется не программой, а пользователем и системными событиями.

### Дирижирование потоками: танец между Main и Background

Одна из самых сложных философских проблем AndroidJUnitRunner — примирение мира Android, где потоки имеют строгие роли, с миром тестирования, где код должен выполняться линейно и предсказуемо. В Android UI Thread (Main Thread) священен — только он может прикасаться к View, только он может управлять жизненным циклом Activity, только он может отрисовывать интерфейс. Background Thread, напротив, предназначен для тяжёлых вычислений, сетевых запросов, операций с базой данных.

Но тестовый код живёт по другим законам. Тест хочет создать Activity, кликнуть по кнопке, проверить результат — и всё это в рамках одного метода, в одном потоке выполнения. Тест не думает о том, что создание Activity требует Main Thread, а выполнение ассертов может происходить в Background Thread. Тест просто хочет работать.

AndroidJUnitRunner должен стать невидимым переводчиком между этими мирами. Когда тестовый код говорит "создай Activity", AndroidJUnitRunner должен переключиться на Main Thread, выполнить операцию, дождаться завершения и вернуть контроль тестовому коду. Когда тест хочет выполнить ассерт, AndroidJUnitRunner должен убедиться, что это безопасно для обоих потоков.

```java
public class AndroidJUnitRunner extends MonitoringInstrumentation {
    
    @Override
    public void onStart() {
        // Тестовый код изолируется в отдельном потоке
        Thread backgroundThread = new Thread(() -> {
            runTests();
        });
        backgroundThread.start();
        
        // Main Thread остаётся доступным для UI операций
        runOnMainLooper();
    }
    
    private void runOnMainLooper() {
        // Поддержка жизненного цикла Main Looper
        Looper.prepare();
        Looper.loop();
    }
}
```

Эта архитектура создаёт уникальную ситуацию: тесты выполняются в Background Thread, но имеют возможность "занимать" Main Thread для UI операций. Каждый раз, когда тест обращается к UI, происходит невидимая для программиста магия переключения контекста:

```kotlin
@Test
fun testButtonClick() {
    // Тестовый код начинается в Background Thread
    
    val activity = ActivityScenario.launch(MainActivity::class.java)
    // launch() переключается на Main Thread, создаёт Activity и возвращается
    
    onView(withId(R.id.button)).perform(click())
    // perform() снова переключается на Main Thread для клика
    
    onView(withId(R.id.textView)).check(matches(withText("Hello")))
    // check() может остаться в Background Thread для ассерта
}
```

За этой кажущейся простотой скрывается сложная хореография синхронизации потоков. AndroidJUnitRunner должен убедиться, что переключения происходят безопасно, что Main Thread не блокируется надолго тестовым кодом, что Background Thread корректно ждёт завершения UI операций.

### Очищение памяти системы: искусство забывания

Одна из самых философских проблем тестирования — проблема памяти. Не памяти в смысле RAM, а памяти в смысле следов, которые оставляет каждое действие в сложной системе. В JVM-мире эта проблема решается просто: каждый тест получает новые экземпляры объектов, старые объекты собираются сборщиком мусора, состояние сбрасывается автоматически.

В Android мир намного сложнее. Android — это не просто программа, это операционная система с глобальным состоянием. Activity создаются и живут в системном стеке. Настройки сохраняются в системных службах. Файлы записываются в файловую систему. Разрешения предоставляются на уровне пакета. Уведомления висят в системном трее. База данных сохраняет данные между запусками.

Каждый тест может изменить это глобальное состояние, и эти изменения повлияют на следующий тест. AndroidJUnitRunner должен стать мастером забывания — он должен уметь стирать следы каждого теста так, чтобы следующий тест думал, что он первый.

```java
@Override
public void onDestroy() {
    // Стирание всех Activity из системного стека
    finishAllActivities();
    super.onDestroy();
}

private void resetSystemState() {
    // Возвращение анимаций к тестовому состоянию
    setSystemAnimationsScale(0.0f);
    
    // Очистка системных уведомлений
    clearNotifications();
    
    // Сброс runtime-разрешений к исходному состоянию
    resetPermissions();
}

private void cleanupResources() {
    // Закрытие всех тестовых баз данных
    closeTestDatabases();
    
    // Удаление временных файлов
    clearTestFiles();
    
    // Отписка от BroadcastReceiver
    unregisterTestReceivers();
}
```

Это искусство забывания требует глубокого понимания того, какие следы может оставить каждый тест. AndroidJUnitRunner должен быть параноидально внимательным к деталям — он должен помнить обо всём, чтобы потом всё забыть.

Примечание об окружении устройства:

- Для стабильности тестов отключайте анимации системы (developer options или через `settings put`/`wm`), фиксируйте локаль/ориентацию/сеть.
- Используйте Managed Virtual Devices (AGP/Gradle) для воспроизводимого окружения на CI.

### Система как партнёр: интеграция с Android Runtime

AndroidJUnitRunner работает не вопреки Android-системе, а в партнёрстве с ней. Он не пытается обойти системные ограничения или создать альтернативную реальность — он использует те же механизмы, которые используют обычные приложения, но получает к ним привилегированный доступ.

Когда AndroidJUnitRunner создаёт Activity, он обращается к тому же ActivityManagerService, который управляет всеми Activity в системе. Когда он взаимодействует с UI, он использует тот же WindowManagerService, который отрисовывает все окна. Когда он получает информацию о приложении, он обращается к тому же PackageManagerService, который знает обо всех установленных пакетах.

Эта интеграция — не техническая необходимость, а философский выбор. AndroidJUnitRunner мог бы попытаться создать изолированную среду, где все системные вызовы заменены мокированными версиями. Но тогда тесты проверяли бы не реальное поведение приложения, а поведение тестовой симуляции. AndroidJUnitRunner выбирает сложность интеграции ради аутентичности тестирования.

### Цена аутентичности

Решение AndroidJUnitRunner работать с реальной Android-системой, а не создавать тестовую симуляцию, имеет глубокие последствия. Каждый вызов к системной службе — это потенциальная точка непредсказуемости. Каждое взаимодействие с реальным устройством — это возможность столкнуться с неожиданным поведением.

Отладка становится детективным расследованием — ошибка может произойти в тестовом процессе, в процессе приложения, в системной службе или в межпроцессном взаимодействии между ними. Производительность страдает от постоянных переключений контекста между потоками и процессами. Стабильность зависит от состояния устройства, версии Android, настроек пользователя.

Но эта цена оправдана. AndroidJUnitRunner предоставляет то, что невозможно получить никаким другим способом — возможность тестировать приложение в условиях, максимально приближенных к реальному использованию. Когда инструментальный тест проходит, он даёт уверенность в том, что приложение будет работать не только в контролируемой тестовой среде, но и в хаотичной реальности пользовательских устройств.

AndroidJUnitRunner — это архитектурный компромисс между контролем и аутентичностью, между простотой и реализмом, между скоростью и уверенностью. Понимание этого компромисса критически важно для тех, кто хочет эффективно использовать инструментальные тесты в разработке Android-приложений.

## 4. От ActivityTestRule к ActivityScenario: Эволюция контроля

В предыдущей главе мы изучили AndroidJUnitRunner — дирижёра, который координирует весь оркестр инструментального тестирования. Но даже самый талантливый дирижёр не может играть на каждом инструменте. У AndroidJUnitRunner есть своя область ответственности: он управляет процессами, потоками, системной интеграцией. Но кто управляет жизнью и смертью конкретной Activity?

Эта задача кажется простой только на первый взгляд. В обычном приложении Activity создаёт и управляет ею Android система в ответ на действия пользователя или системные события. В тестах эту роль должен взять на себя тестовый код. Но как точно воспроизвести сложный танец жизненного цикла Activity — от создания до уничтожения, через все промежуточные состояния, включая пересоздание при смене конфигурации и восстановление из savedInstanceState?

За годы развития Android-тестирования было несколько попыток решить эту проблему. Каждое решение отражало понимание того времени о том, как должна быть устроена архитектура тестов, какой уровень контроля должен быть у программиста, какой баланс между простотой и гибкостью является оптимальным. История эволюции от `ActivityTestRule` к `ActivityScenario` — это история перехода от декларативной простоты к императивному контролю, от автоматизации к ручному управлению, от ограничений к свободе.

### ActivityTestRule: философия автоматизации

`ActivityTestRule` появился в эпоху, когда Android-тестирование делало первые неуверенные шаги. Тогда казалось, что лучший способ упростить тестирование — это максимально автоматизировать рутинные операции. Зачем заставлять программиста каждый раз писать код для создания Activity, если можно сделать это автоматически?

ActivityTestRule воплощал философию доброжелательной опеки. Он брал на себя всю ответственность за жизненный цикл Activity, освобождая программиста от необходимости думать о технических деталях. Создать Activity, настроить окружение, обеспечить правильную очистку после теста — всё это ActivityTestRule делал незаметно, за кулисами.

```kotlin
class MainActivityTest {
    
    @get:Rule
    val activityRule = ActivityTestRule(MainActivity::class.java)
    
    @Test
    fun testButtonVisibility() {
        // Activity уже живёт и готова к работе
        val activity = activityRule.activity
        onView(withId(R.id.button)).check(matches(isDisplayed()))
    }
}
```

В этом коде скрыта целая философия тестирования. Тест не заботится о том, как создалась Activity, в каком она состоянии, что произошло в её `onCreate()`. Тест просто использует готовый объект, как если бы Activity всегда существовала. ActivityTestRule превращает тестирование в декларативное искусство: "дай мне MainActivity, и я проверю, что кнопка видна".

Магия ActivityTestRule основана на элегантном использовании JUnit Rules — механизма, который позволяет встраивать дополнительную логику в стандартный жизненный цикл теста. Правило (Rule) в JUnit — это способ сказать: "перед выполнением теста сделай это, а после теста — то". ActivityTestRule превращает этот простой механизм в мощный инструмент управления жизненным циклом Activity.

```java
public class ActivityTestRule<T extends Activity> implements TestRule {
    
    @Override
    public Statement apply(Statement base, Description description) {
        return new ActivityStatement(base);
    }
    
    private class ActivityStatement extends Statement {
        
        @Override
        public void evaluate() throws Throwable {
            try {
                // Рождение Activity перед тестом
                launchActivity();
                
                // Тест работает с живой Activity
                base.evaluate();
                
            } finally {
                // Смерть Activity после теста
                finishActivity();
            }
        }
    }
}
```

Внутри `launchActivity()` скрывается уже знакомый нам механизм Instrumentation — тот самый мост между тестовым и приложенческим процессами, который мы изучали в предыдущих главах:

```java
private void launchActivity() {
    Intent intent = getActivityIntent();
    activity = (T) instrumentation.startActivitySync(intent);
}
```

ActivityTestRule создаёт иллюзию простоты, но за этой простотой скрывается фундаментальное ограничение. Activity рождается один раз, в начале теста, живёт на протяжении всего теста и умирает в конце. Это предопределённый жизненный цикл, где нет места для экспериментов. Если вы хотите протестировать, что происходит при повороте экрана, при пересоздании Activity, при восстановлении из savedInstanceState — ActivityTestRule беспомощен. Он знает только один сценарий: родиться, жить, умереть.

Проблемы декларативной философии стали очевидными, когда Android-приложения усложнились, а требования к тестированию выросли. ActivityTestRule создавался в эпоху относительно простых приложений, где Activity была в основном контейнером для UI. Но современные приложения используют Activity как сложные компоненты с собственным жизненным циклом, состоянием, взаимодействием с архитектурными компонентами.

```kotlin
@Test
fun testConfigurationChange() {
    // Activity уже создана и живёт в RESUMED
    
    // Но как протестировать самый критический сценарий — поворот экрана?
    // Как убедиться, что onSaveInstanceState() сохраняет правильные данные?
    // Как проверить, что onCreate() корректно восстанавливает состояние?
    // Как протестировать полный цикл уничтожения и пересоздания?
    
    // ActivityTestRule может только наблюдать, но не управлять
}
```

ActivityTestRule построен на философии статичности: Activity создаётся один раз и существует в неизменном виде на протяжении всего теста. Но реальная жизнь Android-приложения динамична. Activity рождается из Intent с параметрами, переходит через состояния CREATED → STARTED → RESUMED, может быть приостановлена системой, может быть уничтожена при нехватке памяти, может быть пересоздана при смене конфигурации. Весь этот сложный танец жизненного цикла остаётся за рамками возможностей ActivityTestRule.

### ActivityScenario: императивная свобода

Появление `ActivityScenario` ознаменовало философскую революцию в Android-тестировании. Вместо доброжелательной опеки ActivityTestRule, которая упрощала жизнь программисту ценой ограничения возможностей, ActivityScenario предложил императивную свободу. Он не предполагает, что тест хочет делать с Activity — он даёт полный контроль над каждым аспектом её существования.

```kotlin
@Test
fun testActivityLifecycle() {
    // Осознанное создание Activity
    val scenario = ActivityScenario.launch<MainActivity>()
    
    // Точное управление каждым переходом
    scenario.moveToState(Lifecycle.State.CREATED)
    scenario.moveToState(Lifecycle.State.STARTED)  
    scenario.moveToState(Lifecycle.State.RESUMED)
    
    // Эмуляция реальных системных событий
    scenario.recreate()
    
    // Контролируемое завершение
    scenario.close()
}
```

Различие не только техническое, но и философское. ActivityTestRule воплощает принцип "удобство через ограничения": он делает простые случаи очень простыми, но сложные случаи невозможными. ActivityScenario воплощает принцип "свобода через ответственность": он не делает ничего автоматически, но даёт возможность сделать всё вручную. Это переход от декларативного "дай мне Activity" к императивному "я сам управляю Activity".

#### Архитектурная философия ActivityScenario

ActivityScenario представляет собой не просто техническое улучшение над ActivityTestRule, а философское переосмысление того, как должно быть устроено тестирование в эпоху современных архитектурных компонентов. Он построен на фундаменте Jetpack Architecture Components — особенно `Lifecycle` и `LifecycleOwner` — что делает его не внешним инструментом для манипуляции Activity, а интегральной частью современной Android-архитектуры.

```java
public final class ActivityScenario<A extends Activity> implements AutoCloseable {
    
    private final Instrumentation instrumentation;
    private final Class<A> activityClass;
    
    // Текущее состояние контролируется через современный Lifecycle API
    private Lifecycle.State currentState;
    
    public static <A extends Activity> ActivityScenario<A> launch(Class<A> activityClass) {
        return launch(activityClass, null);
    }
    
    public static <A extends Activity> ActivityScenario<A> launch(Class<A> activityClass, Bundle activityOptions) {
        Intent startActivityIntent = Intent.makeMainActivity(
            new ComponentName(getApplicationContext(), activityClass)
        );
        
        return new ActivityScenario<>(activityClass, startActivityIntent, activityOptions);
    }
}
```

Обратите внимание на деталь, которая может показаться незначительной, но на самом деле революционна: ActivityScenario хранит `Lifecycle.State currentState`. Это не просто техническая подробность — это философская декларация. ActivityScenario не просто манипулирует Activity как чёрным ящиком, он понимает её внутреннее состояние, думает в терминах современной архитектуры, говорит на языке Lifecycle API.

Ключевая магия ActivityScenario кроется в методе `moveToState()` — возможности программно переводить Activity между состояниями жизненного цикла:

```java
public ActivityScenario<A> moveToState(Lifecycle.State newState) {
    instrumentation.runOnMainSync(() -> {
        switch (newState) {
            case CREATED:
                moveToCreatedState();
                break;
            case STARTED: 
                moveToStartedState();
                break;
            case RESUMED:
                moveToResumedState();
                break;
            case DESTROYED:
                moveToDestroyedState();
                break;
        }
    });
    return this;
}
```

Но самое интересное происходит внутри каждого перехода. ActivityScenario не просто вызывает один метод — он понимает, что переход между состояниями в Android может требовать прохождения через промежуточные состояния:

```java
private void moveToStartedState() {
    if (currentState == Lifecycle.State.CREATED) {
        // Прямой переход CREATED → STARTED
        instrumentation.callActivityOnStart(activity);
    } else if (currentState == Lifecycle.State.RESUMED) {
        // Переход RESUMED → STARTED требует промежуточного PAUSED
        instrumentation.callActivityOnPause(activity);
    }
    currentState = Lifecycle.State.STARTED;
}
```

Это уже не просто техническая реализация — это понимание семантики Android жизненного цикла. ActivityScenario знает, что переход из RESUMED в STARTED не может произойти напрямую, он должен пройти через состояние PAUSED. Это отражение реальности Android-системы в тестовом коде.

Самая впечатляющая возможность ActivityScenario — метод `recreate()`, который воспроизводит один из самых сложных и критических сценариев в жизни Android-приложения: полное пересоздание Activity. Этот сценарий происходит при повороте экрана, изменении языка, переключении в тёмную тему — во всех случаях, когда система решает, что проще создать Activity заново, чем адаптировать существующую.

```java
public ActivityScenario<A> recreate() {
    instrumentation.runOnMainSync(() -> {
        // Этап 1: Система просит Activity сохранить своё состояние
        Bundle savedInstanceState = new Bundle();
        instrumentation.callActivityOnSaveInstanceState(activity, savedInstanceState);
        
        // Этап 2: Полный цикл смерти Activity
        instrumentation.callActivityOnPause(activity);
        instrumentation.callActivityOnStop(activity); 
        instrumentation.callActivityOnDestroy(activity);
        
        // Этап 3: Рождение новой Activity из пепла старой
        recreateActivity(savedInstanceState);
        
        // Этап 4: Восстановление души через savedInstanceState
        instrumentation.callActivityOnRestoreInstanceState(activity, savedInstanceState);
    });
    return this;
}
```

Это не имитация пересоздания — это настоящее пересоздание. Activity действительно умирает и рождается заново. Старый объект Activity уничтожается сборщиком мусора, создаётся новый объект с новым состоянием памяти. Единственная связь между старой и новой Activity — это Bundle savedInstanceState, который Activity должна правильно заполнить перед смертью и правильно прочитать после рождения. Именно эта связь определяет, насколько хорошо приложение переживёт пересоздание.

Примечание о ресурсных сценариях и ограничениях:

- `recreate()` моделирует пересоздание Activity, но не симулирует убийство всего процесса системой.
- Для проверки поведения при убийстве процесса используйте `adb shell am kill`/`force-stop` и повторный запуск, учитывая восстановление из persistent‑хранилищ и обработку сигналов памяти (`onTrimMemory`).

### Два подхода: сравнение возможностей

Сравнение ActivityTestRule и ActivityScenario показывает эволюцию подходов к управлению жизненным циклом Activity в тестах.

ActivityTestRule предлагает декларативный подход: вы описываете, что хотите тестировать, а система сама управляет жизненным циклом Activity. Activity автоматически создаётся и уничтожается в рамках каждого теста, всегда находится в готовом к работе состоянии. Этот подход прост и предсказуем, но ограничен в возможностях.

ActivityScenario предлагает императивный подход: вы сами контролируете каждый аспект жизненного цикла Activity. Можете создавать, уничтожать, переводить между состояниями, эмулировать пересоздание. Этот подход более гибкий, но требует понимания особенностей Android-архитектуры.

Практические различия проявляются уже в самых простых сценариях:

```kotlin
// ActivityTestRule: защитительная простота
class ConservativeTest {
    @get:Rule
    val activityRule = ActivityTestRule(MainActivity::class.java)
    
    @Test 
    fun testWhatWeCanTest() {
        // Activity уже живёт, но что мы можем с ней сделать?
        onView(withId(R.id.text)).check(matches(withText("Hello")))
        
        // Хотим протестировать поворот экрана? Извините, это невозможно
        // Хотим проверить восстановление состояния? Увы, не предусмотрено
        // Хотим эмулировать background/foreground? Не получится
    }
}

// ActivityScenario: императивная свобода
class ModernTest {
    @Test
    fun testWhatWeWantToTest() {
        val scenario = ActivityScenario.launch<MainActivity>()
        
        // Проверяем нормальное состояние
        scenario.onActivity { activity ->
            assertEquals("Hello", activity.findViewById<TextView>(R.id.text).text)
        }
        
        // Эмулируем смерть и воскрешение Activity
        scenario.recreate()
        
        // Проверяем, выжила ли она
        scenario.onActivity { activity ->
            assertEquals("Hello", activity.findViewById<TextView>(R.id.text).text)
        }
        
        scenario.close()
    }
}
```

Разница не только в коде, но и в мышлении. ActivityTestRule заставляет думать в терминах "что есть", ActivityScenario позволяет думать в терминах "что должно быть".

### Интеграция с современной архитектурой

ActivityScenario создавался с учётом Architecture Components — ViewModel, LiveData, Navigation. Когда Android-архитектура изменилась, инструменты тестирования должны были измениться вместе с ней.

ActivityTestRule создавался в то время, когда Activity содержала большую часть бизнес-логики. ActivityScenario появился, когда Activity стала в основном презентационным слоем, а логика переместилась в ViewModel.

Важное отличие проявляется при тестировании ключевого принципа современной архитектуры: ViewModel должна переживать пересоздание Activity.

```kotlin
@Test
fun testViewModelSurvivesRecreation() {
    val scenario = ActivityScenario.launch<MainActivity>()
    
    var originalViewModel: MainViewModel? = null
    var recreatedViewModel: MainViewModel? = null
    
    // Получаем ViewModel и устанавливаем данные
    scenario.onActivity { activity ->
        originalViewModel = ViewModelProvider(activity)[MainViewModel::class.java]
        originalViewModel!!.data.value = "Critical Data"
    }
    
    // Пересоздаём Activity
    scenario.recreate()
    
    // Получаем ViewModel после пересоздания
    scenario.onActivity { activity ->
        recreatedViewModel = ViewModelProvider(activity)[MainViewModel::class.java]
    }
    
    // ViewModel должна быть той же самой и сохранить данные
    assertSame(originalViewModel, recreatedViewModel)
    assertEquals("Critical Data", recreatedViewModel!!.data.value)
}
```

Такой тест невозможен с ActivityTestRule, поскольку он не предоставляет возможности эмулировать пересоздание Activity. ActivityTestRule создавался для более простой архитектуры, где Activity содержала основную логику приложения.

### Компромиссы гибкости

ActivityScenario предоставляет больше возможностей, но требует больше ответственности от разработчика. ActivityTestRule автоматически управлял жизненным циклом Activity, защищая от многих ошибок. ActivityScenario передаёт этот контроль разработчику.

Это означает дополнительную сложность: нужно явно управлять состояниями Activity, помнить о закрытии ресурсов, правильно обрабатывать переходы. Простые тесты требуют больше кода. Возрастает вероятность ошибок — можно забыть вызвать `close()`, неправильно интерпретировать состояния или создать нестабильные тесты.

Взамен ActivityScenario даёт возможность тестировать реальное поведение приложения в сложных сценариях: повороты экрана, восстановление из background, эмуляция нехватки памяти. Это позволяет убедиться, что приложение работает не только в идеальных условиях, но и в непредсказуемых ситуациях реального мира.

### Миграция: практические аспекты

Переход от ActivityTestRule к ActivityScenario требует изменения подхода к написанию тестов. Декларативный стиль "дай мне Activity" заменяется императивным "я создаю сценарий". Это изменение влияет не только на код, но и на способ мышления о тестах.

Первый этап эволюции — механическая замена. Старый код, который полагался на автоматическое управление жизненным циклом, получает минимальные изменения, необходимые для работы с новым API:

```kotlin
// Прошлое: полное доверие автоматизации
@get:Rule
val activityRule = ActivityTestRule(MainActivity::class.java)

@Test
fun whenButtonClicked_thenSomethingHappens() {
    onView(withId(R.id.button)).perform(click())
}

// Настоящее: осознанное управление жизненным циклом
@Test
fun whenButtonClicked_thenSomethingHappens() {
    ActivityScenario.launch<MainActivity>().use { scenario ->
        onView(withId(R.id.button)).perform(click())
    }
}
```

Второй этап — принятие ответственности за жизненный цикл. Программист начинает использовать возможности, которых не было в старом мире:

```kotlin
@Test
fun whenAppGoesToBackground_thenStatePreserved() {
    ActivityScenario.launch<MainActivity>().use { scenario ->
        // Устанавливаем начальное состояние
        onView(withId(R.id.input)).perform(typeText("Important Data"))
        
        // Эмулируем переход в фоновый режим
        scenario.moveToState(Lifecycle.State.CREATED)
        
        // Возвращаем на передний план
        scenario.moveToState(Lifecycle.State.RESUMED) 
        
        // Проверяем выживание данных
        onView(withId(R.id.input)).check(matches(withText("Important Data")))
    }
}
```

Третий этап — использование всех возможностей ActivityScenario. Тесты начинают покрывать сценарии, которые были недоступны с ActivityTestRule:

```kotlin
@Test
fun whenConfigurationChanges_thenArchitectureProvesSolid() {
    val customIntent = Intent().apply {
        putExtra("critical_data", "Must Survive")
    }
    
    ActivityScenario.launch<MainActivity>(customIntent).use { scenario ->
        // Проверяем правильную обработку Intent
        scenario.onActivity { activity ->
            assertEquals("Must Survive", activity.intent.getStringExtra("critical_data"))
        }
        
        // Тестируем архитектурную устойчивость
        scenario.recreate()
        
        // Проверяем полный цикл состояний
        scenario.moveToState(Lifecycle.State.STARTED)
        scenario.moveToState(Lifecycle.State.RESUMED)
        
        // Убеждаемся, что приложение не просто выжило, но процветает
        scenario.onActivity { activity ->
            assertNotNull(activity.findViewById<View>(R.id.main_content))
        }
    }
}
```

### Выбор инструмента

Выбор между ActivityTestRule и ActivityScenario зависит от конкретных потребностей проекта и архитектуры приложения.

ActivityTestRule подходит для простых тестов, особенно в legacy-проектах, где нужно добавить базовое тестирование без изменения существующей архитектуры. Он автоматически управляет жизненным циклом Activity и требует минимального кода для базовых проверок.

ActivityScenario рекомендуется для современных приложений, особенно использующих Architecture Components (ViewModel, LiveData). Он необходим для тестирования:
- Сохранения состояния при смене конфигурации
- Переходов между состояниями жизненного цикла  
- Восстановления Activity после пересоздания
- Комплексных сценариев взаимодействия с системой

Переход от ActivityTestRule к ActivityScenario отражает эволюцию Android-разработки от простых монолитных Activity к архитектурно сложным приложениям с разделёнными ответственностями. Современные тесты должны проверять не только базовую функциональность, но и корректное поведение в различных состояниях системы.

Следующая глава рассматривает технические детали того, как тестовый код получает доступ к процессу приложения через механизм Instrumentation.

## 5. Анатомия инъекции: Как тестовый код попадает в приложение

В предыдущих главах мы рассмотрели AndroidJUnitRunner и управление жизненным циклом Activity, но остался важный вопрос: как тестовый код из одного процесса может управлять Activity в другом процессе?

Это основная техническая проблема инструментального тестирования. Android строится на принципах изоляции процессов: каждое приложение выполняется в отдельном процессе, защищённом от вмешательства других приложений. Но тестирование требует взаимодействия между процессами — тест должен управлять приложением, запускать Activity, проверять UI.

Решение этой проблемы основано на двух ключевых механизмах Android:
1. **Instrumentation** — специальный класс, который может внедряться в процесс приложения
2. **Binder IPC** — система межпроцессного взаимодействия для передачи команд

Рассмотрим детально, как работает этот механизм инъекции тестового кода.

### Изоляция процессов: архитектурное ограничение

Основная проблема инструментального тестирования связана с изоляцией процессов в Android. Каждое приложение выполняется в отдельном процессе с собственным виртуальным адресным пространством.

```
┌─────────────────┐            ┌─────────────────┐
│   Test Process  │ ◄────────► │  App Process    │
│                 │            │                 │
│ @Test methods   │            │ MainActivity    │
│ AndroidJUnit    │            │ Application     │
│ Runner          │            │ Services        │
└─────────────────┘            └─────────────────┘
```

Процессы не могут напрямую обращаться к памяти друг друга. Когда тестовый процесс создаёт переменную `MainActivity activity`, она существует только в его памяти. Настоящая MainActivity живёт в памяти процесса приложения. Прямое обращение к объектам другого процесса невозможно — это приведёт к ошибке доступа к памяти.

Изоляция процессов — это основа безопасности Android. Система гарантирует, что приложения не могут получить несанкционированный доступ к данным друг друга. Но тестирование требует доступа к внутреннему состоянию приложения: проверки View, управления Activity, контроля жизненного цикла.

### Внедрение Instrumentation в процесс приложения

Решение проблемы изоляции основано на внедрении специального объекта Instrumentation непосредственно в процесс приложения. Вместо попыток преодолеть барьеры между процессами, Android помещает контролирующий код внутрь целевого процесса.

Instrumentation создаётся не в тестовом процессе, а в процессе приложения, получая прямой доступ к его внутреннему состоянию. Когда система запускает инструментальные тесты, процесс приложения создаётся в специальном режиме с внедрённым Instrumentation.

```java
// Это происходит в самом сердце процесса приложения
public class ActivityThread {
    
    private void handleBindApplication(AppBindData data) {
        // Создание обычного Application происходит как всегда
        Application app = data.info.makeApplication();
        
        // Но если обнаружен тестовый контекст...
        if (data.instrumentationName != null) {
            // Внедрение тестового агента в процесс приложения
            Instrumentation instrumentation = 
                (Instrumentation) cl.loadClass(data.instrumentationName).newInstance();
                
            // Предоставление агенту полных полномочий  
            instrumentation.init(this, app, this.context, 
                data.instrumentationArgs, data.instrumentationWatcher);
                
            // Активация агента
            instrumentation.onCreate(data.instrumentationArgs);
            instrumentation.onStart();
        }
    }
}
```

В результате в процессе приложения создаётся объект Instrumentation, который имеет доступ к внутреннему состоянию приложения и одновременно может получать команды от тестового процесса.

Instrumentation получает полный доступ к компонентам приложения: прямые ссылки на Application и его контекст, возможность вызывать методы Activity, контроль над Main Looper и UI Thread, интеграцию с системными службами Android. Это позволяет управлять приложением изнутри, имея доступ ко всем его компонентам.

### Межпроцессное взаимодействие через Binder IPC

Instrumentation внедрён в процесс приложения, но остаётся вопрос: как тестовый код отправляет ему команды? Решение основано на системе Binder IPC — основном механизме межпроцессного взаимодействия в Android.

Binder позволяет объектам в разных процессах вызывать методы друг друга, создавая видимость работы в одном адресном пространстве. Система автоматически обрабатывает сериализацию данных, их передачу между процессами и десериализацию в целевом процессе.

```java
// В тестовом процессе — здесь рождаются намерения
public class AndroidJUnitRunner extends MonitoringInstrumentation {
    
    private IInstrumentationWatcher instrumentationWatcher;
    
    @Override
    public void onStart() {
        // Получение ссылки на Instrumentation в процессе приложения
        instrumentationWatcher = IInstrumentationWatcher.Stub.asInterface(
            ServiceManager.getService("instrumentation_watcher")
        );
        
        // Запуск тестов через IPC
        runTests();
    }
}
```

Метод `IInstrumentationWatcher.Stub.asInterface()` создаёт прокси-объект для межпроцессного взаимодействия. Этот объект выглядит как обычный Java-объект, но фактически является интерфейсом для отправки команд в другой процесс. Когда тестовый код вызывает метод на этом прокси, происходит следующее: вызов автоматически сериализуется, отправляется через Binder в процесс приложения, где десериализуется и выполняется объектом Instrumentation. Результат передаётся обратно тем же путём.

### Последовательность выполнения теста

Рассмотрим детальную последовательность действий при выполнении простого теста. Три строки кода запускают сложную цепочку взаимодействий между процессами:

```kotlin
@Test
fun testButtonClick() {
    val scenario = ActivityScenario.launch<MainActivity>()
    onView(withId(R.id.button)).perform(click())
    scenario.close()
}
```

За этой простотой скрывается сложная последовательность технических операций.

#### Этап 1: Инициализация процессов

```bash
# Команда, которая запускает цепную реакцию
adb shell am instrument -w com.suleimanov.instrumentation.test/androidx.test.runner.AndroidJUnitRunner
```

Эта команда не просто запускает тест — она создаёт архитектурную реальность, в которой тест может существовать. Android система получает команду и начинает сложный ритуал:

Команда запускает инструментирование: система создаёт процесс целевого приложения `com.suleimanov.instrumentation` с внедрённым `Instrumentation` (`AndroidJUnitRunner`), отдельный процесс тестового APK `com.suleimanov.instrumentation.test` и устанавливает Binder‑соединение между процессами.

#### Параметры выполнения, фильтрация и шардинг

Аргументы инструментирования передаются как `Bundle` в `Instrumentation.onCreate()` и парсятся раннером (см. `parseRunnerArguments`). Фильтрация по классам/пакетам/аннотациям преобразуется в запрос дискавери JUnit (selectors/filters) и влияет на состав `TestPlan`. Параметры шардинга (`numShards`/`shardIndex`) делят итоговый план на независимые подмножества. Флаг отладки (`debug=true`) приводит к ожиданию присоединения отладчика (через `waitForDebugger()`).

#### Акт второй: Первое касание через пропасть

```kotlin
val scenario = ActivityScenario.launch<MainActivity>()
```

В тестовом процессе `ActivityScenario` формирует `Intent` для `MainActivity` и отправляет его через Binder в процесс приложения, где `Instrumentation` получает и исполняет команду.

`Instrumentation` запускает Activity через `ActivityManagerService`. Ссылка на созданную Activity возвращается в тестовый процесс.

#### Акт третий: Прикосновение к пользовательскому интерфейсу

```kotlin
onView(withId(R.id.button)).perform(click())
```

Espresso в тестовом процессе создаёт `ViewMatcher` для `R.id.button` и отправляет запрос через Binder в процесс приложения.

В Main Thread приложения `Instrumentation` находит View, генерирует `MotionEvent` и передаёт его в `dispatchTouchEvent()`.

Результат возвращается в тестовый процесс, где его интерпретирует Espresso.

### Синхронизация сквозь пространство и время

Одна из самых фундаментальных и сложных проблем архитектуры инъекции — управление потоками выполнения, которые не просто разделены по времени, но разделены по пространству процессов. Тестовый код живёт в Background Thread тестового процесса, но большинство операций с UI должно происходить в Main Thread процесса приложения. Это не просто техническое ограничение — это основополагающий принцип Android-архитектуры, нарушение которого приводит к немедленному краху приложения.

Instrumentation решает эту проблему через изящный механизм синхронизации, который превращает асинхронные межпроцессные вызовы в синхронные операции, создавая иллюзию единого потока выполнения:

```java
public class Instrumentation {
    
    public void runOnMainSync(Runnable runner) {
        SyncRunnable sr = new SyncRunnable(runner);
        
        // Размещение задачи в очереди Main Thread процесса приложения
        getHandler().post(sr);
        
        // Блокировка текущего потока до завершения выполнения
        sr.waitForComplete();
    }
    
    private static final class SyncRunnable implements Runnable {
        private volatile boolean complete = false;
        
        public void run() {
            // Этот код выполняется в Main Thread процесса приложения
            runnable.run();
            
            // Освобождение ожидающего потока
            synchronized (this) {
                complete = true;
                notifyAll();
            }
        }
        
        public void waitForComplete() {
            synchronized (this) {
                while (!complete) {
                    try {
                    wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                    }
                }
            }
        }
    }
}
```

Этот код создаёт архитектурную иллюзию синхронности в асинхронном мире. Тестовый код в Background Thread тестового процесса отправляет команду, которая упаковывается в SyncRunnable и размещается в очереди сообщений Main Thread процесса приложения. Затем тестовый поток блокируется, ожидая сигнала о завершении выполнения. Когда Main Thread процесса приложения дошёл до этой задачи в своей очереди, он выполняет её и сигнализирует о завершении, освобождая заблокированный тестовый поток.

Результат — тестовый код может писаться как будто он выполняется синхронно в Main Thread приложения, хотя на самом деле он координирует сложную хореографию между процессами и потоками.

### Система наблюдения за приложением

Instrumentation — это не только исполнитель команд, но и механизм наблюдения за состоянием приложения. В условиях асинхронных операций, анимаций, фоновых задач и изменяемых жизненных циклов возможность фиксировать текущее состояние системы критична для стабильности тестов.

Instrumentation ведёт непрерывное наблюдение за состоянием приложения: какие Activity сейчас активны и в каком состоянии жизненного цикла они находятся, выполняются ли фоновые операции, которые могут повлиять на результаты теста, есть ли незавершённые анимации, которые могут сделать UI нестабильным, происходят ли системные события, которые могут изменить поведение приложения.

```java
public class Instrumentation {
    
    private final List<ActivityMonitor> monitors = new ArrayList<>();
    
    public ActivityMonitor addMonitor(ActivityMonitor monitor) {
        synchronized (monitors) {
            monitors.add(monitor);
        }
        return monitor;
    }
    
    public Activity waitForMonitorWithTimeout(ActivityMonitor monitor, long timeOut) {
        synchronized (monitor) {
            while (!monitor.hasHit()) {
                try {
                    monitor.wait(timeOut);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("Monitoring interrupted", e);
                }
            }
            return monitor.getLastActivity();
        }
    }
}
```

Этот механизм позволяет тестам ожидать конкретных событий вместо использования `Thread.sleep()` или иных ненадёжных способов синхронизации. `ActivityMonitor` обеспечивает ожидание наступления заданного события и повышает предсказуемость выполнения.

#### Сервисы и широковещательные приёмники в инструментальных тестах

`ServiceTestRule` управляет жизненным циклом `Service` через вызовы Instrumentation и системные сервисы, обеспечивая синхронные точки входа (bind/start) и корректное завершение. `Intents` API перехватывает/верифицирует взаимодействия на уровне Intent‑диспетчеризации, что позволяет проверять межпроцессные контракты без прямого доступа к объектам в другом процессе.

### Ограничения архитектуры

Механизм инъекции — это архитектурное чудо, но как всякое чудо, он имеет свою цену. Сложность, которая делает возможным тестирование реальных Android-приложений, одновременно создаёт фундаментальные ограничения, которые невозможно обойти без потери самой сути инструментального тестирования.

#### Производительность

Каждое действие теста проходит через архитектурный лабиринт: сериализация намерений для передачи через Binder, межпроцессный вызов с переключением контекста между ядрами процессора, синхронизация между потоками в разных процессах, десериализация результатов для интерпретации в тестовом коде.

Простой клик по кнопке в unit-тесте — прямой вызов метода в памяти. В инструментальном тесте тот же клик проходит через межпроцессные границы, синхронизацию потоков и системные службы. Разница в производительности может быть кратной десяткам. Это обусловлено архитектурой.

#### Отладка

Когда инструментальный тест падает, начинается детективное расследование в архитектурном лабиринте. Ошибка может произойти в тестовом коде, работающем в изолированном процессе, при сериализации данных для IPC-передачи, в Instrumentation агенте процесса приложения, в самом приложении при выполнении UI-действий.

Стек‑трейсы отражают не все этапы выполнения. Часть происходит в другом процессе, некоторые детали скрываются слоями Binder IPC и синхронизацией потоков. Это усложняет локализацию причин сбоев.

#### Границы привилегий

Instrumentation получает расширенные права, но не безграничную власть. Android не позволяет ему взаимодействовать с другими приложениями без явного разрешения в манифесте, изменять системные настройки за пределами разрешённых API, получать доступ к защищённым ресурсам системы или обходить модель безопасности Android.

Эти ограничения — сознательные архитектурные решения, защищающие модель безопасности и изоляции Android.

#### Зависимость от внешнего мира

Инструментальные тесты живут в реальном мире, а реальный мир непредсказуем. Они могут падать из-за изменений в новых версиях Android, различий в поведении между устройствами разных производителей, влияния других приложений, работающих на том же устройстве, нестабильности эмулятора или состояния батареи.

Эта непредсказуемость — цена за тестирование в реальных условиях. Unit-тесты стабильны, потому что они изолированы от внешнего мира. Инструментальные тесты нестабильны, потому что они тестируют приложение в том же непредсказуемом мире, в котором оно будет работать у пользователей.

### Альтернативные подходы

Сложность и ограничения инъекционного механизма породили альтернативные подходы, каждый из которых представляет собой различный баланс между простотой и аутентичностью:

**Robolectric** эмулирует Android на JVM, устраняя необходимость в устройствах и IPC, с потерей части аутентичности среды выполнения.

**UI Automator** использует системные API для тестирования поверх UI, без инъекции в приложение, с меньшим доступом к внутреннему состоянию.

**Firebase Test Lab** предоставляет облачное выполнение на реальных устройствах, снимая инфраструктурные проблемы, при зависимости от внешнего сервиса и усложнении процессов.

Каждый подход — это философский выбор о том, что важнее: простота или аутентичность, скорость или достоверность, предсказуемость или реализм. Инструментальные тесты с инъекцией остаются золотым стандартом для тех, кто выбирает аутентичность, достоверность и реализм.

### Эволюция при сохранении основы

Механизм инъекции эволюционирует в деталях, но остаётся неизменным в основе. Jetpack Test улучшает API для работы с современными архитектурными компонентами, Compose Test адаптирует тестирование к декларативной парадигме UI, Android Test Orchestrator улучшает изоляцию между тестами, различные инициативы работают над уменьшением flakiness.

#### Android Test Orchestrator (обзор)

Orchestrator создаёт новый процесс приложения на каждый тест и инициирует очистку данных между запусками. Это усиливает изоляцию и снижает влияние состояния между тестами, увеличивая накладные расходы на запуск. Механизм работает на уровне инструментирования и диспетчеризации тестов в AGP.

Базовая архитектура — `Instrumentation` как агент в процессе приложения, Binder IPC как мост между процессами, синхронизация потоков — остаётся фундаментом и подтверждена практикой.

Понимание этого механизма — не академическое упражнение, а практическая необходимость для каждого, кто хочет писать надёжные инструментальные тесты. Знание архитектуры позволяет понимать ограничения, предугадывать проблемы и использовать всю мощь инструментации осознанно и эффективно.

## 6. Заключение

Подведём итог ключевым аспектам архитектуры инструментального тестирования Android: от принципов тестирования до технических деталей межпроцессного взаимодействия, от эволюции управления жизненным циклом до механизма инъекции тестового кода.

Команда `./gradlew connectedAndroidTest` инициирует архитектурную последовательность: установка и связывание двух APK, запуск двух процессов, взаимодействие через Binder IPC, выполнение через `Instrumentation` и `AndroidJUnitRunner`.

Каждый компонент этой системы — результат десятилетий эволюции понимания того, как должно быть устроено качественное тестирование в мире мобильных приложений. Эта сложность не возникла случайно. Она не является результатом технической неряшливости или отсутствия видения. Это осознанная архитектурная цена, которую Android-экосистема платит за возможность тестировать приложения в условиях, максимально приближенных к реальности пользовательского опыта.

### Аутентичность

Архитектурная сложность обеспечивает аутентичность выполнения: тесты работают в реальном Android‑окружении при контролируемых условиях. Это не симуляция и не эмуляция.

Инструментальные тесты выполняются на реальном устройстве и используют реальные системные службы, UI‑рендеринг и ограничения среды.

Тест видит полный жизненный цикл приложения — от момента создания Application до финального уничтожения Activity, включая все промежуточные состояния, неожиданные смены конфигурации и сложные процессы восстановления из savedInstanceState. Он наблюдает настоящую интеграцию с системными службами: взаимодействие с ActivityManagerService при смене состояний, обращения к WindowManagerService при отрисовке интерфейса, работу с системными диалогами и разрешениями.

Время в инструментальных тестах — это реальное время. Анимации занимают столько миллисекунд, сколько им положено, асинхронные операции выполняются с той же скоростью, что и у пользователя, задержки сети и отклики базы данных такие же непредсказуемые, как в production.

### Издержки реализма

Но за каждый аспект этой аутентичности приходится платить архитектурную цену. Сложность понимания — каждый тест требует понимания не только тестируемого кода, но и архитектуры процессов, тонкостей жизненных циклов, особенностей IPC-механизмов. Программист должен думать не только о том, что тестировать, но и о том, как эти тесты будут взаимодействовать с многослойной архитектурой Android-системы.

Производительность становится жертвой аутентичности. Каждое взаимодействие с UI проходит через границы процессов, каждый вызов метода превращается в путешествие через Binder IPC, каждая проверка состояния требует синхронизации между мирами. То, что в unit-тесте занимает микросекунды, в инструментальном тесте может занимать секунды.

Инструментальные тесты зависят от состояния устройства, версии Android и влияния других приложений, что повышает риск нестабильности. Отладка осложняется распределённым выполнением и IPC.

#### Покрытие и диагностика

Для androidTest сбор покрытия (`testCoverageEnabled`) и отчёты (например, JaCoCo) опираются на хук инструментирования и реальное исполнение в процессе приложения, что влияет на точность метрик. Для диагностики: `debug=true` заставляет раннер ждать отладчика (`waitForDebugger()`), а целевые логи/скриншоты/видео помогают привязать симптомы к межпроцессному контексту выполнения.

### Эволюция тестирования

История перехода от ActivityTestRule к ActivityScenario — это не просто техническая эволюция API, это трансформация самого понимания того, что означает тестировать Android-приложение. Эра ActivityTestRule была эрой статического мышления: получить готовую Activity в определённом состоянии и проверить, соответствует ли она ожиданиям. Это было тестирование снимков, тестирование моментов времени, тестирование того, что есть.

Переход к `ActivityScenario` сместил акцент на тестирование процессов и переходов состояний, включая пересоздание, сохранение и восстановление состояния.

ActivityScenario позволил нам тестировать не только результат, но и путь к нему. Не только "что получилось", но и "как это получилось". Не только финальное состояние, но и все промежуточные трансформации, которые к нему привели.

### Роль в пирамиде тестирования

Инструментальные тесты занимают вершину пирамиды тестирования не случайно. Они находятся там не потому, что они лучше других типов тестов, а потому, что они решают уникальную задачу, которую не может решить никто другой — проверку интеграции всех компонентов системы в условиях, максимально приближенных к реальности.

Это функциональные системные тесты, проверяющие взаимодействие компонентов в реальной Android‑среде.

Именно поэтому их должно быть немного. Каждый инструментальный тест — это дорогостоящая операция, которая должна оправдывать свою стоимость проверкой критически важного сценария, который невозможно адекватно покрыть на более низких уровнях пирамиды. Это тесты для самых важных пользовательских сценариев, для самых рискованных интеграций, для самых сложных переходов состояний.

### Осознанный выбор

Погружение в архитектурные глубины инструментального тестирования даёт вам нечто более ценное, чем техническое знание — оно даёт мудрость осознанного выбора. Теперь, когда вы понимаете, что стоит за каждым вызовом API, вы можете принимать решения не интуитивно, а на основе глубокого понимания архитектурных компромиссов.

Выбор между `ActivityScenario` и `ActivityTestRule` — архитектурное решение. Следует учитывать объём IPC, подход к синхронизации (включая Espresso Idling Resources) и требования к стабильности.

### Ограниченность подхода

Глубокое понимание инструментальных тестов неизбежно приводит к пониманию их ограниченности. Они не универсальное решение для всех задач тестирования, а специализированный инструмент с чётко определённой областью применения.

Инструментальные тесты плохо подходят для быстрой итерации разработки — их скорость выполнения делает невозможными классические TDD-циклы с мгновенной обратной связью. Они неэффективны для тестирования сложной бизнес-логики — unit-тесты справляются с проверкой алгоритмов намного лучше, без накладных расходов на архитектурную сложность. Они испытывают трудности с воспроизводством редких состояний и edge cases — реальная система слишком сложна и непредсказуема для контролируемого моделирования всех возможных сценариев. Они плохо подходят для изоляции отдельных компонентов — слишком много внешних зависимостей и системных влияний делает такую изоляцию практически невозможной.

### Альтернативный подход: Robolectric

Альтернативой инструментальному тестированию является Robolectric. Он создаёт Android‑подобное окружение в JVM, что позволяет выполнять тесты без реальных устройств, отдельных процессов и IPC‑взаимодействий, сохраняя доступ к Android API.

Подход продолжает традицию виртуализации и эмуляции, известную по виртуальным машинам, эмуляторам и симуляторам. В контексте Android‑тестирования Robolectric заменяет инъекцию в реальную систему виртуальным окружением на JVM.

Практический эффект: выполнение тестов с близкой к unit‑тестам скоростью, отсутствие зависимости от устройств и эмуляторов, возможность тестировать `Activity`, `Service`, `BroadcastReceiver` как обычные классы JVM.

Подход имеет ограничения и компромиссы. Далее будет рассмотрено, как Robolectric использует Shadow‑классы и имитирует Android Runtime в JVM, почему такие тесты не являются полноценными Android‑тестами в строгом смысле, и при этом полезны для определённых задач.

Также будет разобран выбор между инструментальными тестами (аутентичность и архитектурная сложность) и Robolectric (скорость и упрощённая среда) с позиции уровня требуемой уверенности и затрат. Понимание обеих архитектур необходимо для принятия взвешенных решений.
