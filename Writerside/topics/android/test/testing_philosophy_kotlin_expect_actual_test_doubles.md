---
title: "Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles"
excerpt: "Глубокое погружение в философский фундамент тестирования на Kotlin: что означают expect/actual, в чём разница между Unit и JUnit
тестами, а также концептуальные роли mocks, stubs, fakes и spies. Понимание тестов как контролируемых симуляций реальности."
publishDate: 2025-08-01
readingTime: 20
locked: true
series: "Android под капотом: Тестирование без иллюзий"
part: 1
category: "Android"
---

## 1. Введение: Почему тесты - это не проверка, а модель

Эта статья открывает серию «Android под капотом: Тестирование без иллюзий». Семь частей - семь углублений, от фундамента до системной
архитектуры, от синтаксиса до этики. Перед вами первая: философская база. Она нужна, чтобы все остальные статьи не висели в воздухе.

Если вы давно тестируете - это напоминание о том, *зачем* вы это делаете. Если вы только начинаете - это фундамент, без которого всё
остальное превращается в механическое повторение шаблонов по tutorial-ам и "Best Practice".

Тесты часто представляют как механизм проверки: мол, есть код, и нужно проверить, правильно ли он работает. Но программное обеспечение - не
прибор. У нас нет датчиков, которыми можно измерить корректность. У нас есть только модели поведения. И тесты - это не проверка, а
реализация этих моделей в виде исполняемого кода.

Когда мы пишем тест, мы создаём вторую вселенную, то есть виртуального пользователя. Она похожа на настоящую, но лучше контролируема.
В ней время стоит на месте, зависимости делают только то, что мы им разрешаем, а сама система ведёт себя предсказуемо.
Это не копия продакшена - это его реконструкция. Более того:это реконструкция, основанная не на фактах, а на **намерениях**.
Мы тестируем не то, как система работает - а то, как мы *хотим*, чтобы она работала.

Вот почему тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется - тест падает, частая практика не так ли?).
Не потому, что код стал хуже. А потому, что зеркало, в которое мы смотрели, больше не совпадает с формой оригинала.

Тест - это артефакт доверия. Он фиксирует границы допустимого, которые мы согласились считать истиной.
Каждый`assertEquals(expected, actual)` - это не факт, это акт утверждения. Он говорит: *мы согласны, что если `actual == expected`,
то всё хорошо*. Это соглашение. Это договор.

Kotlin хорошо подходит для тестирования, потому что даёт те же инструменты, что и для основного кода: лямбды, DSL, расширения, корутины,
строгую типизацию. Тесты на Kotlin не ощущаются как отдельный язык - они пишутся теми же средствами, в той же парадигме. Нет ощущения
«тест - это вторая лига». Благодаря компактному синтаксису, читаемости и отсутствию лишнего шаблонного кода, тест выглядит как часть
архитектуры, а не как надстройка над ней.

Во всей серии примеры будут на Kotlin - не потому что «так модно», а потому что это стандарт Android-разработки и полноценный язык для
продакшена, независимо от платформы. Kotlin уже используется в Spring, Ktor, Compose, KMP - и везде он одинаково хорош для тестов.

---

## 2. Базис: Лексикон тестирования

Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Без него любые рассуждения - словно попытка
строить архитектуру без понятий "стена", "связь" и "опора". Ниже - не полный глоссарий, а именно тот минимум, на который будет опираться вся
серия.

#### Assertion

Assertion - это программное утверждение, выражающее ожидание. Если оно не выполняется - тест считается неуспешным. В большинстве фреймворков
assertion реализован как функция, выбрасывающая исключение при расхождении:

```kotlin
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
```

Важно понимать: assertion не описывает поведение - он фиксирует его. Это финальная точка сценария, где тест явно заявляет: *вот то, что я
считаю допустимым*. Всё остальное - лишь подготовка к этому моменту.

#### Test Case

Test Case - это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и
проверка результата (assert). В Kotlin это обычно функция с аннотацией `@Test`.

```kotlin
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login("admin", "wrong")
    assertFalse(result.success)
}
```

Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения - он быстро теряет свою надёжность.

#### Test Suite

Test Suite - это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно
это класс, файл или структура DSL. Назначение suite-а - собрать родственные кейсы и запускать их совместно, например, при CI-сборке или
нагрузочном прогоне.

Хорошо организованный suite - это не просто папка с тестами. Это карта покрытия. Он показывает, где есть тесты, а где - только надежда на
интуицию разработчиков.

#### Test Runner

Test Runner - это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение,
репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через
Gradle (или build system IDE), где runner интегрирован в пайплайн.

Хороший runner не замечается. Плохой - ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.

---

#### Test Double

Test Double - это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не
отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.

Существует несколько типов Test Double-ов - и каждый из них решает свою задачу.

**Stub** используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем.
Его задача - быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.

**Mock** применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с
какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.

**Fake** - это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В
отличие от stub-ов и mock-ов, фейк умеет «жить» - накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.

**Spy** похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда
вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.

Test Double - это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения.
И если код не поддаётся тестированию с такими объектами - проблема обычно не в тестах, а в архитектуре.

#### Unit vs Integration

Unit-тест - это тест, который полностью контролирует окружение. Все внешние зависимости заменяются на подставные объекты (Test Doubles),
состояние стабильно, внешних эффектов нет. Такой тест проверяет поведение конкретной единицы кода: функции, метода, класса - в изоляции.

Integration-тест допускает реальные зависимости: базу данных, файловую систему, сеть. Его цель - проверить, как компоненты взаимодействуют
друг с другом в условиях, приближенных к боевым.

Разделение между ними не бинарное. Это шкала. Есть тесты, которые используют, например, настоящий генератор UUID или текущее время -
формально это уже не "чистый" Unit. Но такие компромиссы допустимы, если они осознаны. Главное - понимать, что вы контролируете, а что -
нет.

Критерий здесь не в размере функции или скорости выполнения, а в уровне изоляции. Чем больше вы контролируете, тем ближе тест к Unit. Чем
больше полагаетесь на реальные зависимости - тем ближе он к Integration. Это не про формат, это про доверие.

#### Тест как артефакт

Тест - это не костыль и не подстраховка. Это полноценный исполняемый артефакт, живущий в том же репозитории, что и основной код. Он проходит
через компиляцию, участвует в CI/CD пайплайне, ломается при неудачном рефакторинге и требует сопровождения. Если продакшен-код описывает
*как* работает система, то тест - *что считается допустимым* в её поведении.

Хороший тест не объясняет. Он формализует. И в этом его ценность: он позволяет автоматизировать договор между человеком и системой.

## 3. Концепция: Что вообще мы тестируем?

Если упростить до предела, то тест - это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно.
Он подтверждает, что **в заданных условиях** она ведёт себя **определённым образом**.

Мы не тестируем "истину". Мы тестируем поведение в симулированной среде.

---

### Симуляция, а не доказательство

Распространённая ошибка - считать, что наличие тестов означает корректность системы. Это не так. Тест - это не формальное доказательство, а
ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.

Если поведение системы изменилось, но тесты всё ещё проходят - это не значит, что поведение правильное. Это значит, что тест об этом не
знает.

Например: раньше `isPremiumUser` возвращал `true`, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь `true`
возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними - и продолжают проходить. Только теперь они
подтверждают совсем не то, что раньше. Просто не знают, что смысл `true` изменился.

Тест проверяет не всю систему, а **конкретный срез**: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось
«допустимым». Если позже меняется бизнес-логика, интерфейс или требования - тест становится устаревшим. Это не баг, это свойство теста как
инструмента.

---

### Контролируемое окружение

Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время,
потоки, гонки, кеши. Тест же создаёт **контролируемое окружение**, где всё поведение заранее известно и управляется вручную: от стабов и
фейков до фиктивного времени и UUID.

Разница принципиальна. В production ошибки могут быть случайными. В тестах они - либо детерминированы, либо не обнаруживаются вовсе. Поэтому
тест никогда не может гарантировать "всё работает". Он может только сказать: *в этих условиях - да*.

---

### Уровень доверия

Каждый тест даёт разработчику определённый уровень уверенности. Но важно понимать, откуда именно эта уверенность берётся. Unit-тесты дают
быструю обратную связь: запускаются мгновенно, падения легко локализуются, работают стабильно. Но они покрывают только локальную логику -
изолированную от остальной системы. Их надёжность держится на том, что окружение подменено, а поведение - строго контролируется.

Интеграционные тесты покрывают больше связей. Они проверяют, как компоненты работают вместе: контроллер, сервис, база, кэш, очередь. Они
ближе к реальности, но требуют больше инфраструктуры, сложнее в запуске, и их падения труднее отлаживать. Тем не менее, именно они ловят те
ошибки, которые unit-прогон никогда не заметит.

Это всегда компромисс. Между скоростью и полнотой. Между удобством и точностью. Между временем отклика и глубиной сигнала. И пока эти
компромиссы не осознаны - ни одно число покрытия не имеет смысла. «100% покрытие» может означать как надёжную защиту, так и пустой ритуал -
всё зависит от того, *что именно* вы покрыли, и *зачем*.

---

### Что мы действительно тестируем

На практике, когда мы пишем тест, мы не «проверяем весь модуль» - мы проверяем конкретное поведение в конкретной ситуации. Например: что при
определённых входных данных метод вызывает другой компонент с нужным параметром. Или что система возвращает ожидаемый результат. Или что в
случае ошибки происходит fallback, а не крэш. Или что состояние сохраняется при переходе экрана.

Это не «абсолютная проверка системы». Это фрагмент поведения, проверенный в специально собранном окружении - со стабами, фейками и полной
симуляцией контекста. Мы руками собираем эту модель и утверждаем: *вот в таких условиях система должна вести себя так-то*.

Чем ближе этот контекст к продакшену - тем ценнее тест. Чем дальше - тем он быстрее, дешевле и проще, но локальнее по смыслу. И в этом нет
ничего плохого. Главное - понимать, что именно мы тестируем, и почему.

Тест - это не способ доказать, что всё работает. Это способ убедиться, что **в заданных условиях** ничего не сломано.
И если условия выбраны правильно - этого уже достаточно, чтобы тест выполнял свою работу честно.

## 4. Expect / Actual: Слова, которые всё говорят

Почти в каждом тесте есть одна и та же сцена: мы сравниваем то, что получилось, с тем, что мы ожидали. Чаще всего - через
`assertEquals(expected, actual)`, `assertTrue(condition)`, `assertFailsWith<SomeException>()` или их аналоги. И вроде бы всё очевидно:
проверяем, что результат совпадает с ожиданием. Но даже в этих простых вызовах есть неочевидный момент.

---

### Не просто сравнение, а утверждение

Когда мы вызываем `assertEquals(expected, actual)`, мы не просто сверяем два значения. Мы делаем утверждение. Мы говорим: *если actual не
совпадает с expected - значит, нарушен контракт*. Это не операция сравнения, это **тест на согласие с нашей моделью**.

Важно понимать: `assert*` - это не отладка. Не исследование. Это декларация. Тест либо пройден, либо нет. Нет «почти», нет «предупреждения».
И если условие не выполняется - не система сломалась, а **наши ожидания не совпали с реальностью**.

---

### Expected/Actual - порядок, который важен

Почти все assert-функции следуют одному и тому же порядку: сначала `expected`, потом `actual`. И это не случайность. Это отражение позиции:
«мы считаем, что вот это - правильно, а теперь проверим, совпадает ли с тем, что вышло». В этом смысле `actual` - первичен. Он результат.
Он - реальность. А `expected` - это наша гипотеза.

Если местами их перепутать, тест всё равно будет работать. Но смысл высказывания становится неявным. Падает читаемость. И, главное, исчезает
ощущение, **что именно** пошло не так: то ли мы ошиблись в модели, то ли код нарушил контракт.

---

### assertTrue / assertFalse - примитив, но с той же логикой

Функции `assertTrue` и `assertFalse` не используют expected/actual явно, но логика та же: вы передаёте условие, которое считаете *
*допустимым**. Если оно ложно - тест не пройден. Значит, что-то пошло не так в коде, в контракте или в наших представлениях о корректности.

По сути, каждая `assert*` - это бинарный фильтр: либо да, либо нет. Это инструмент для фиксации допусков, а не для поиска ошибок. И чем
яснее мы это осознаём - тем точнее пишем тесты.

---

### Ключевые слова Kotlin Native? Не об этом речь

Да, в Kotlin Native действительно есть ключевые слова `expect` и `actual`. Они используются в механизме мультиплатформенности: `expect`
задаёт интерфейс, `actual` - реализацию для конкретной платформы. Это может сбить с толку - особенно начинающих. Но в контексте тестирования
мы говорим совсем о другом. Здесь `expected` и `actual` - это **соглашение на уровне мышления**, а не синтаксиса. Это структура суждения: "я
ожидаю X, и вижу Y - совпали ли они?"

Если воспринимать тест как акт сверки - `expected` и `actual` не более чем параметры. Но если понимать, что тест - это **артефакт соглашения
**, то `expected` - это наш манифест. А `actual` - это отражение реальности. И когда они не совпадают, вопрос не в ошибке, а в расхождении
между тем, что система делает, и тем, что мы от неё хотели.

Писать тест - значит формализовать ожидания. А `assertEquals(expected, actual)` - это не просто вызов функции. Это фраза. Она что-то
утверждает. И если её читать именно как утверждение - структура начинает играть значение.

## 5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies

Когда мы говорим о Test Double, мы имеем в виду объекты, которые заменяют настоящие зависимости в тесте. Они позволяют запускать код в
изоляции, без доступа к базе, сети, времени или другим внешним эффектам. Это делает тесты контролируемыми. Но важно понимать, что Double -
это не просто «заглушка». Это модель. И выбор модели влияет на то, *что именно* мы тестируем.

Есть четыре основных типа Test Double, и у каждого - своя цель.

**Stub** - самый простой тестовый двойник. Он всегда возвращает заранее заданные значения и никак не реагирует на входные данные. Stub не
проверяет, что ему передали, не логирует вызовы и не участвует в бизнес-логике - он просто стабилизирует поведение зависимости.
Используется, когда зависимость нужна «для галочки»: достаточно вернуть нужное значение, чтобы тест мог продолжиться. Stub - это фон, а не
часть сцены. Например, в тесте сервиса пользователей можно создать заглушку репозитория, которая всегда возвращает одного и того же
пользователя, игнорируя запрошенный ID:

```kotlin
interface UserRepository {
    fun findById(id: String): User
}

class UserRepositoryStub : UserRepository {
    override fun findById(id: String): User {
        // Намеренно игнорируем id - Stub всегда возвращает одно и то же
        return User(id = "stub-id", name = "John Doe")
    }
}

// Использование в тесте
val stubRepo = UserRepositoryStub()
val service = UserService(stubRepo)
val user = service.getUser("123")
check(user.name == "John Doe")
```

> **В примере выше поведение Stub проявляется в том, что `UserRepositoryStub` всегда возвращает один и тот же результат (`John Doe`),
независимо от входного параметра `id`. Он не анализирует, что ему передали, и служит лишь для стабилизации окружения.**

---

**Mock** - объект, который фиксирует, как с ним взаимодействовали. Он запоминает, какие методы вызвали, с какими параметрами и сколько раз.
Задача mock-объекта - не возвращать данные, а подтвердить, что код выполнил определённые действия. Mock используют там, где важно проверить,
*как* происходило взаимодействие: был ли вызван логгер, ушло ли письмо, вызвался ли callback. Это объект-наблюдатель, с помощью которого
тест проверяет поведение. Например, можно создать фальшивый логгер, который будет сохранять записанные сообщения вместо реального вывода, а
затем убедиться в тесте, что нужный метод вызывался с ожидаемыми параметрами:

```kotlin
interface Logger {
    fun log(message: String)
}

class LoggerMock : Logger {
    val receivedMessages = mutableListOf<String>()

    override fun log(message: String) {
        receivedMessages.add(message)
    }
}

// Использование
val logger = LoggerMock()
val service = UserService(logger = logger)
service.createUser("Alice")
check(logger.receivedMessages.size == 1)
check(logger.receivedMessages.first() == "User created")
```

> **В примере выше поведение Mock проявляется в том, что `LoggerMock` запоминает все вызовы метода `log`. В тесте мы проверяем, что
сообщение действительно было зафиксировано. Это и есть суть mock - не поведение, а проверка взаимодействия.**

💡 *Mock часто реализуют с помощью библиотек вроде Mockito или MockK, но здесь он показан вручную, чтобы разобрать суть концепции.*

---

**Fake** - рабочая подделка. Это не имитация отдельных вызовов, а полноценная, но упрощённая реализация зависимости. Например, in-memory
база данных или фейковый API, который хранит данные в памяти. Fake не просто «притворяется» - он действительно ведёт себя как настоящая
система, только без использования реальных ресурсов. Его используют, когда нужна реальная логика взаимодействия, но не нужна тяжелая
инфраструктура. Например, вместо обращения к настоящей базе данных можно использовать фейковый репозиторий, который хранит пользователей в
памяти:

```kotlin
interface UserRepository {
    fun save(user: User)
    fun findById(id: String): User?
}

class FakeUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()

    override fun save(user: User) {
        users[user.id] = user
    }

    override fun findById(id: String): User? {
        return users[id]
    }
}

// Использование
val repo = FakeUserRepository()
repo.save(User("1", "Alice"))
val result = repo.findById("1")
check(result?.name == "Alice")
```

> **В примере выше поведение Fake проявляется в том, что `FakeUserRepository` действительно сохраняет и возвращает данные, как настоящий
репозиторий, но без настоящей базы данных. Это полноценная логика - только in-memory.**

---

**Spy** - «двойной агент». Он оборачивает реальный объект, но отслеживает, что с ним происходило. Spy не подменяет поведение (как mock) и не
заменяет всю реализацию (как fake). Вместо этого он делегирует вызовы настоящему объекту и параллельно фиксирует обращения (например,
считает вызовы или сохраняет параметры). Это компромисс между прозрачным поведением и возможностью анализировать взаимодействие. Например,
можно обернуть реальный (или фейковый) репозиторий в класс-Spy, который будет делегировать вызовы базовому объекту и считать, сколько раз
вызывался метод поиска пользователя:

```kotlin
class UserRepositorySpy(private val realRepo: UserRepository) : UserRepository {
    var findByIdCallCount = 0
    val capturedIds = mutableListOf<String>()

    override fun save(user: User) {
        realRepo.save(user)
    }

    override fun findById(id: String): User? {
        findByIdCallCount++
        capturedIds.add(id)
        return realRepo.findById(id)
    }
}

// Использование
val realRepo = FakeUserRepository()
realRepo.save(User("1", "Bob"))
val spy = UserRepositorySpy(realRepo)
val user = spy.findById("1")
check(user?.name == "Bob")
check(spy.findByIdCallCount == 1)
check(spy.capturedIds.contains("1"))
```

> **В примере выше поведение Spy проявляется в том, что `UserRepositorySpy` делегирует вызовы `realRepo`,
> но при этом фиксирует: сколько раз вызывался метод `findById`, какие значения передавались.**

💡 *Spy полезен там, где поведение важно сохранить, но при этом нужно наблюдать за взаимодействиями. Мы видим как "что вызвали", так и "что
реально произошло".*

---

Иногда выбор типа Double кажется техническим: что проще заиспользовать, что быстрее написать. Но на самом деле он отражает **подход к
архитектуре**. Если мы используем stub - мы говорим: эта зависимость не важна. Если fake - мы признаём, что логика важна, но
инфраструктура - нет. Если mock - мы хотим проконтролировать, как именно система взаимодействует. Spy - мы хотим знать детали, но не мешать
процессу.

Это выбор: **моделировать поведение или структуру**. Проверять результат или отслеживать путь. Упростить окружение или сохранить его
поведение. И когда Double выбран неправильно - тест может быть зелёным, но бессмысленным.

Поэтому вопрос не в том, *какой* Double использовать, а в том, *что именно мы хотим зафиксировать в этом тесте*.

---

## 6. Unit vs JUnit: Что действительно стоит за словами

Слово **unit** в программировании означает *единицу поведения* — минимальный фрагмент системы, который можно протестировать изолированно.
Это может быть функция, метод, модуль или класс. Главное — он должен быть **самодостаточным**: то есть его поведение можно проверить без
запуска всей системы.

Тест такого фрагмента называют **unit-тестом** — он фокусируется не на всей программе, а на её **наименьшей значимой части**, изолируя
внешние зависимости (через stub, mock, fake и т. д.).

> Unit = Единица (поведения)
> , Unit Test = Проверка этой единицы
> , JUnit = Java Unit Testing Framework

**JUnit** — это инструмент, изначально созданный для того, чтобы **писать и запускать unit-тесты на Java**. Название — это сокращение от
*Java + Unit*. Но за 20 лет JUnit стал не просто библиотекой, а полноценной **тестовой платформой**, которую можно использовать для чего
угодно: от простейших проверок до интеграционных и property-based тестов.

Чтобы понимать, как писать хорошие тесты, важно разобраться не только в коде, но и в истории: как JUnit развивался, и какие идеи он принёс.

---

### История JUnit: от процедур до DSL

**JUnit 3** появился в начале 2000-х. Это был процедурный фреймворк, построенный на соглашениях, а не на аннотациях или конфигурациях. Чтобы
метод считался тестом, он должен был начинаться с `test`, а класс — расширять `TestCase`. Всё наследовалось напрямую, никакой инверсии,
никакой метаинформации.

```java
public class UserServiceTest extends TestCase {
    public void testUserIsCreated() {
        UserService service = new UserService();
        User user = service.create("Alice");
        assertEquals("Alice", user.getName());
    }
}
```

Никакой магии. JUnit по имени искал методы, начинал их выполнять и сигнализировал о падениях через `AssertionFailedError` или исключения.
Всё держалось на соглашениях и строгом порядке.

---

**JUnit 4** стал поворотной точкой. Он избавился от необходимости наследования `TestCase` и перешёл к декларативному стилю на базе
аннотаций. Метод помечался `@Test`, и это было достаточно, чтобы фреймворк понял — перед ним тест.

```kotlin
class UserServiceTest {

    @Test
    fun userIsCreated() {
        val service = UserService()
        val user = service.create("Alice")
        assertEquals("Alice", user.name)
    }
}
```

Появились `@Before`, `@After`, `@Ignore`, а также возможность писать кастомные раннеры. Но при всём этом JUnit 4 оставался процедурным.
Каждый тест — по сути обычная функция, просто обёрнутая инфраструктурой.

---

**JUnit 5** — уже не фреймворк, а **платформа**. Он разделён на три части: `Platform`, `Jupiter` и `Vintage`.

`JUnit Platform` — это базовый механизм обнаружения и запуска тестов. Он взаимодействует с Gradle, Maven, IDE и CI-системами. Через него
тесты регистрируются, исполняются и репортуются. Это слой интеграции, а не логики.
`JUnit Jupiter` — это современный API и тестовый движок. Он поддерживает всё, что появилось в JUnit 5: вложенные тестовые классы (
`@Nested`), настраиваемые названия (`@DisplayName`), параметризованные и динамические тесты (`@ParameterizedTest`, `@TestFactory`). Jupiter
делает тесты декларативными и выразительными, приближая их к DSL.
`JUnit Vintage` — это адаптер. Он позволяет запускать старые тесты, написанные на JUnit 3 и 4, внутри новой платформы. Благодаря Vintage
проекты могут мигрировать постепенно, без полного переписывания.

Синтаксис стал выразительным. Теперь тесты можно строить как декларации поведения, использовать параметры, вводить структуры.

```kotlin
@ParameterizedTest
@ValueSource(strings = ["admin", "user", "guest"])
fun `roles should not be empty`(role: String) {
    val system = RoleService()
    val permissions = system.getPermissions(role)
    assertTrue(permissions.isNotEmpty())
}
```

JUnit 5 перестал быть "юнит"-фреймворком в узком смысле. Он стал каркасом для любых тестов: юнитов, интеграций, property-based подхода,
контрактных проверок. Всё, что можно выразить в виде исполняемого DSL с проверками — теперь помещается внутрь.

JUnit не только принял декларативность, но и сам стал частью архитектурного мышления. И теперь, говоря `@Test`, мы запускаем не просто
метод — мы инициируем часть тестового пайплайна, где поведение фиксируется как артефакт.

### Почему это важно в CI

JUnit-интеграции в IDE, Gradle, Maven, Bazel и CI-системы (например, GitHub Actions) ожидают строго определённую структуру: `@Test`-методы
автоматически индексируются, изолируются и репортятся. Без этой аннотации метод — просто функция, недоступная для раннера.

Отлично, вот переработанный блок **по аннотациям JUnit 5** — без лишних классов там, где они не нужны, и с полноценным объяснением каждой
аннотации (2–3 предложения), строго в авторском техническом стиле.

---

### Знакомство с основами JUnit 5

Если в JUnit 4 аннотации были просто флажками, то в JUnit 5 они стали формализованными элементами контракта.
Через них описывается жизненный цикл, поведение, параметры и точки интеграции тестов.
Ниже — минимально необходимый набор аннотаций, чтобы уверенно ориентироваться в Jupiter.

`@Test`
Это главная точка входа. Без неё метод — просто функция. С ней — полноценный тест, который JUnit включит в жизненный цикл: вызовет
`@BeforeEach`, сам тест, `@AfterEach`, соберёт результат и отобразит в отчёте.

Метод с `@Test` должен быть открытым (`public`), без параметров, без возвращаемого значения (`Unit`) и не `static` (в Java) или
`companion` (в Kotlin). Если тест бросает исключение — он считается проваленным. Если нет — прошёл успешно.

```kotlin
@Test
fun `user is created`() {
    val service = UserService()
    val user = service.create("Alice")
    assertEquals("Alice", user.name)
}
```

JUnit вызывает этот метод как автономную единицу — отдельно от других, в новом инстансе класса (если не указано иначе). Это часть контракта:
тест не должен зависеть от других тестов и делиться с ними состоянием.


---

`@BeforeEach` / `@AfterEach`
Вызываются перед и после каждого `@Test`. Используются для настройки окружения и его очистки: создание файлов, сброс состояний, закрытие
ресурсов. Каждый тест запускается на новом экземпляре класса, так что состояния между методами не сохраняются.

```kotlin
@BeforeEach
fun setUp() {
    initDatabase()
}

@AfterEach
fun tearDown() {
    cleanupTempFiles()
}
```

---

`@BeforeAll` / `@AfterAll`
Запускаются один раз до и после всех тестов в классе. Используются для тяжёлой инициализации (например, поднятие embedded Redis, Kafka,
Docker-контейнеров). В Kotlin требуют `@TestInstance(PER_CLASS)`.

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@BeforeAll
fun initSuite() {
    EmbeddedRedis.start()
}
```

---

`@TestInstance(...)`
Определяет, как JUnit создаёт экземпляры тестового класса.

По умолчанию используется `PER_METHOD`, при котором **для каждого метода с `@Test` создаётся отдельный объект**. Это обеспечивает изоляцию
между тестами, но не позволяет сохранять общее состояние между ними.

Если указать `PER_CLASS`, то **один объект создаётся на весь класс**. Это позволяет использовать `@BeforeAll` и `@AfterAll` как обычные
методы (не в `companion object`), а также делиться состоянием между тестами.

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ConfiguredTestLifecycle {

    private var counter = 0

    @BeforeAll
    fun initOnce() {
        counter = 10
    }

    @Test
    fun testA() {
        assert(counter >= 10)
    }

    @Test
    fun testB() {
        counter++ // состояние сохраняется между тестами
    }
}
```

Такой подход используют, когда инициализация тяжёлая или состояние нужно сохранить между тестами. Но в большинстве случаев `PER_METHOD` —
безопаснее.

`@DisplayName`
Позволяет задать читаемое название теста. Отображается в IDE и CI, особенно полезно в параметризованных или BDD-ориентированных тестах.
Работает и на методах, и на классах.

```kotlin
@DisplayName("Пользователь с ролью admin получает все доступы")
@Test
fun adminGetsAllPermissions() {
    ...
}
```

---

`@Disabled`
Пропускает тест. Используется для временного отключения (например, нестабильный код, баг в зависимости). В отчётах видно, что тест отключён.

```kotlin
@Disabled("Отключён до фикса external API")
@Test
fun flakyIntegrationTest() {
    ...
}
```

---

`@Nested`
Позволяет структурировать тесты в иерархии — с вложенными контекстами. Применяется только к `inner class`, иначе инстанс не создаётся.
Удобен для Given/When/Then-структур.

```kotlin
@Nested
inner class WhenUserIsGuest {
    @Test
    fun `should not access admin panel`() {
        ...
    }
}
```

---

`@ParameterizedTest`
Запускает один и тот же метод несколько раз с разными параметрами. Требует указания источника данных через `@ValueSource`, `@CsvSource`,
`@EnumSource` и др. Метод должен принимать аргументы.

```kotlin
@ParameterizedTest
@ValueSource(strings = ["admin", "user", "guest"])
fun testRoles(role: String) {
    assertTrue(role.isNotBlank())
}
```

---

`@ValueSource`, `@CsvSource`, `@EnumSource`, `@MethodSource`, `@ArgumentsSource`
Аннотации для генерации данных в параметризованных тестах. `@ValueSource` — для простых значений. `@CsvSource` — для табличных данных.
`@MethodSource` — ссылка на метод, возвращающий `Stream<Arguments>`. `@EnumSource` — прокидывает значения enum. `@ArgumentsSource` —
настраиваемый источник данных.

```kotlin
@ParameterizedTest
@CsvSource("admin, true", "guest, false")
fun rolePermissionTest(role: String, allowed: Boolean) {
    assertEquals(allowed, checkAccess(role))
}
```

---

`@RepeatedTest`
Запускает один и тот же тест несколько раз. Удобен для проверки нестабильных сценариев: флаки, гонки, недетерминированные вычисления. Метод
может принимать `RepetitionInfo`.

```kotlin
@RepeatedTest(3)
fun unstableTest() {
    assertTrue(runComputation().isSuccessful)
}
```

---

`@Timeout`
Завершает тест с ошибкой, если он выполняется дольше заданного времени. Применяется на метод и на весь класс. Полезен для защиты от
зависаний.

```kotlin
@Timeout(5)
@Test
fun longRunningProcessCompletes() {
    performHeavyOperation()
}
```

---

`@Tag`
Добавляет произвольные метки тестам. Используются в CI/CD для фильтрации: можно запускать только тесты с нужным тегом (`@Tag("slow")`,
`@Tag("ci")`).

```kotlin
@Tag("integration")
@Test
fun savesToDatabase() {
    saveToDb()
}
```

---

`@ExtendWith(...)`
Подключает расширения (Mockito, Spring, Testcontainers, кастомные хуки). Extension-интерфейсы могут внедрять зависимости, слушать события,
управлять окружением.

```kotlin
@ExtendWith(SpringExtension::class)
class UserServiceSpringTest { ... }
```

---

`@TestFactory`
Позволяет генерировать тесты динамически во время выполнения. Метод должен возвращать `Collection<DynamicTest>` или `Stream<DynamicTest>`.
Применяется при неизвестном числе кейсов (например, из JSON-файла).

```kotlin
@TestFactory
fun dynamicTestsFromFile(): List<DynamicTest> {
    return File("cases.txt").readLines().map { line ->
        dynamicTest("Case: $line") {
            check(line.isNotBlank())
        }
    }
}
```

В статье не будет практического примера по использованию этих аннотаций, для этого существует официальная документация https://docs.junit.org/current/user-guide/
которая очень подробно описывает использование Junit 5.

### Как JUnit 5 запускает ваш `@Test`: от команды до метода

Давайте на основе примера возьмем что-то простое, например загрузка изображения, пример не является синтетическим, а полностью рабочий код
который хорошо подходит для демонстраций:

```kotlin
class ImageDownloader {
    fun downloadImage(url: String): ByteArray {
        val inputStream = URI(url).toURL().openStream()
        return inputStream.use { it.readAllBytes() }
    }
}
```

Далее сам тест для ImageDownloader с использованием Junit 5:

```kotlin
@TestInstance(TestInstance.Lifecycle.PER_METHOD)
@DisplayName("Загрузка изображения и сохранение в файл")
class ImageDownloaderTest {

    private lateinit var tempFile: File
    private lateinit var outputStream: FileOutputStream

    private val imageUrl = "https://i.postimg.cc/26h8JBpH/QYbec-Thl-Qy7mcx-ZBYp-C0m-BDp16no-Mt-R5vwe-St-Wmv-large.jpg"

    @BeforeEach
    fun setUp() {
        tempFile = File("image-test.jpg")
        outputStream = FileOutputStream(tempFile,true)
    }

    @Test
    @DisplayName("Изображение должно быть скачано и записано в файл")
    fun `downloaded image is saved to file`() {
        val downloader = ImageDownloader()
        val bytes = downloader.downloadImage(imageUrl)

        requireNotNull(bytes) { "Скачанные данные не должны быть null" }

        outputStream.write(bytes)
        outputStream.flush()

        assertTrue(tempFile.length() > 0, "Файл после загрузки не должен быть пустым")
    }

    @AfterEach
    fun tearDown() {
        outputStream.close()
        tempFile.delete()
    }
}
```
Наш тест на самом деле достаточно прост, есть один тест `downloaded image is saved to file`, который загружает изображение,
далее происходит проверка на тот что наш файл скачан и он не пуст, перед запуском теста в setUp создается временный файл и stream
а в tearDown мы удаляем этот файл так как он только для теста и закрываем stream, так же используем DisplayName что бы
в CI/ IDE увидеть понятные нам названия и читаемые


Представим, что вы запускаете `./gradlew :test --tests "test.ImageDownloaderTest"
` или кликаете «Run» в IDE — начинается не просто выполнение функций, а целый процесс с
несколькими важными этапами:

---

#### 1. Запуск через Test Engine

Когда команда вызывает `useJUnitPlatform()` или IDE запускает тесты, выполняется **JUnit Platform Launcher**. Он строит
`LauncherDiscoveryRequest` — запрос на обнаружение тестов — и передаёт его в `LauncherFactory.create().execute(request)`.

Внутри платформы этот запрос обрабатывается через `LauncherDiscoveryRequestBuilder` — он отражает селекторы (пакеты, классы, фильтры) и
загружает их в `EngineDiscoveryOrchestrator`. ([junit.org][1], [Stack Overflow][2])

---

#### 2. Обнаружение тестов (Discovery)

**Jupiter TestEngine** (основной движок JUnit 5) анализирует классы по reflection. Он ищет аннотации `@Test`, `@ParameterizedTest`,
`@Nested` и строит `TestDescriptor` для каждого тест-кейса и контейнера. Это происходит в модулях **junit-jupiter-engine**.

Обнаруженные тесты собираются в `TestPlan`, структура отражает иерархию классов и методов. ([junit.org][1])

---

#### 3. Построение плана выполнения

Модель `TestPlan` содержит всё: от классов до конкретных методов тестов. Когда план готов, `Launcher` начинает **execution**, и каждому
`TestDescriptor` сопоставляется жизненный цикл:

* `LifecycleMethodExecutor` вызывает `@BeforeEach`/`@BeforeAll`
* Затем — сам целевой метод `@Test`
* После — `@AfterEach`/`@AfterAll`

Раз создаётся **новый экземпляр тестового класса** для каждого метода `@Test`, обеспечивается изоляция состояния между тестами.

---

#### 4. Выполнение теста

Метод вызывается через reflection (`ExecutableInvoker.invoke()`), exceptions ловятся и классифицируются: `AssertionFailedError` — как
провал, другие — как ошибка. Статус передаётся дальше в `TestReporter`.

---

#### 5. Репортинг и вывод

После исполнения всех тестов `Launcher` собирает `TestExecutionSummary`, который включает:

* количество успешных/проваленных тестов,
* duration запуска,
* stack trace ошибок,
* пропуски.

Эти данные фонтаном отдаются в Gradle, IDE или CI для отображения, анализа или логирования.

---

#### Почему это всё важно

* Метки `@BeforeEach`, `@AfterAll` и пр. **встраиваются в execution flow**, не являются синтаксическим сахаром.
* Reflection и `TestDescriptor` дают гибкость: фильтры, теги, повторные запуски.
* Каждый тест изолирован — благодаря созданию нового экземпляра класса.
* Discovery и execution разделены — позволяет пакетировать, фильтровать, запускать вручную или динамически.

Разница между JUnit 3 и 5 не только в синтаксисе, а в архитектуре:

* Раньше — поиск тестов по именам;
* Сейчас — discovery → план → execution → report — весь жизненный цикл выстроен, конфигурируется и расширяется через API.

Если нужно — могу приложить ссылки на соответствующие исходники `LauncherDiscoveryRequest.java` и `EngineDiscoveryOrchestrator.java` для
гиков и желающих копать глубже.

[1]: https://junit.org/junit5/docs/5.0.0/user-guide/?utm_source=chatgpt.com "JUnit 5 User Guide"

[2]: https://stackoverflow.com/questions/66227706/testengine-with-id-junit-jupiter-failed-to-discover-tests-caused-by-org-jun?utm_source=chatgpt.com "TestEngine with ID 'junit-jupiter' failed to discover tests - Caused by ..."

---

### Что делает `@Test` частью контракта

Аннотация фиксирует несколько инженерных соглашений:

* **Изолируемость**: тест должен быть самодостаточным. Его можно запустить отдельно.
* **Предсказуемость**: тест не зависит от глобального состояния, иначе он станет flaky.
* **Детерминизм**: один и тот же вход → один и тот же результат. Без этого невозможна автоматизация.

JUnit создаёт инстанс тестового класса на каждый `@Test`, чтобы избежать shared-state. Это часть контракта.

---

### `@VisibleForTesting`: не тест, но для теста

Аннотация `@VisibleForTesting` — это **информационный маркер**, который говорит: «этот метод или поле доступны шире, чем нужно — только ради
тестов». Она не влияет на рантайм и не делает метод тестом. Но:

* подчёркивает, что доступность **искусственно расширена**;
* сигнализирует: в продакшене не использовать.

Используется часто в Kotlin и Java, особенно в Android-проектах, как соглашение на уровне команды.

```kotlin
@VisibleForTesting
internal fun recalculateChecksum() {
    // метод открыт не для продакшена, а чтобы тест мог вызвать напрямую
}
```

---

### Почему JUnit 5 — это уже не просто про юниты

Когда говорят «JUnit 5», чаще всего имеют в виду просто современную библиотеку для написания юнит-тестов. И это правда — JUnit 5 вполне
можно использовать как обычный инструмент: подключить, написать тесты, запускать из IDE или Gradle.

Но это поверхностный взгляд. Потому что JUnit 5 — это не просто библиотека. Это фреймворк, из которого можно собирать другие фреймворки.
Внутри него — JUnit Platform, модуль, который работает как рантайм-движок: он не диктует, как должны выглядеть тесты, он умеет обнаруживать,
исполнять и агрегировать любые тестовые единицы, если они реализованы в рамках платформенного контракта.

На этом контракте уже сегодня построено множество других библиотек. Они не используют JUnit «как есть», они строят свои абстракции, свои
DSL’ы, но под капотом всё это всё равно исполняется через JUnit Platform. Ниже — несколько ярких примеров:

⸻

Kotest
Фреймворк, который кардинально переосмысливает, как должен выглядеть тест в языке Kotlin. Вместо привычной структуры “класс + методы”, здесь
декларативный DSL, приближённый к структуре документации: "should do something" внутри "describe this behavior". Kotest также встроенно
поддерживает property-based testing, матчер-DSL, тестовые генераторы и детерминированные стратегии повторения. Но что важно — всё это
работает через JUnit Platform, а значит, совместимо с IDE, Gradle и CI из коробки.

⸻

Spek
Минималистичный фреймворк, ориентированный на спецификацию поведения, а не реализацию. Тесты в Spek пишутся как цепочки вложенных блоков
given / on / it, приближаясь к форме технического задания. В отличие от Kotest, Spek делает акцент на чистоте и лаконичности, особенно в
микросервисных сценариях. И снова — под всей этой структурой лежит не собственный раннер, а именно JUnit Platform.

⸻

Cucumber
BDD-фреймворк, который строится вокруг Gherkin-сценариев. Вы описываете поведение системы в .feature-файле на естественном языке, а
реализацию шагов связываете с кодом. Для запуска этих сценариев, Cucumber использует свой адаптер, который регистрирует себя как TestEngine
JUnit Platform. Это позволяет запускать BDD-тесты в той же среде, что и обычные unit или integration тесты, не ломая пайплайн.

⸻

JQwik
Property-based testing на Java и Kotlin, вдохновлённый QuickCheck. Вместо написания конкретных примеров, вы описываете свойства, которые
система должна удовлетворять для произвольных входов. Генерация данных, shrink’инг, случайность — всё встроено. И опять же: он не делает
свою экосистему — он интегрируется через JUnit Platform.

⸻

JUnit 5 — это не вершина тестирования. Это скорее почва, на которой растут разные формы тестирования: декларативные, спецификационные, BDD,
property-based. И возможность строить поверх него — это не побочный эффект, это основа архитектурного замысла.

Это не библиотека для “написать тест и забыть”, это платформа, к которой можно подключить своё видение того, что такое тест вообще.

---

## 7. Kotlin Test: Строгая минималистика

* Kotlin Test - не "Kotlin обёртка над JUnit", а другая философия.
* Kotlin First: лямбды, DSL-подход, выразительность.
* Пример теста без boilerplate.
* Почему многие так и не поняли силу `kotest`, `kotlin.test`, `assertSoftly` и т.д.

---

## 8. Заключение: Тест как управляемая иллюзия реальности

* Тест - это симуляция, которой мы *хотим верить*.
* Но именно потому, что это иллюзия, она должна быть контролируемой.
* И чем честнее тест, тем проще продакшен.

---
