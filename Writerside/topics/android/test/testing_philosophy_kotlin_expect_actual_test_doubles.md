---
title: "Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles"
excerpt: "Глубокое погружение в философский фундамент тестирования на Kotlin: что означают expect/actual, в чём разница между Unit и JUnit
тестами, а также концептуальные роли mocks, stubs, fakes и spies. Понимание тестов как контролируемых симуляций реальности."
publishDate: 2025-08-01
readingTime: 20
locked: true
series: "Android под капотом: Тестирование без иллюзий"
part: 1
category: "Android"
---

## 1. Введение: Почему тесты - это не проверка, а модель

Эта статья открывает серию «Android под капотом: Тестирование без иллюзий». Семь частей - семь углублений, от фундамента до системной
архитектуры, от синтаксиса до этики. Перед вами первая: философская база. Она нужна, чтобы все остальные статьи не висели в воздухе.

Если вы давно тестируете - это напоминание о том, *зачем* вы это делаете. Если вы только начинаете - это фундамент, без которого всё
остальное превращается в механическое повторение шаблонов по tutorial-ам и "Best Practice".

Тесты часто представляют как механизм проверки: мол, есть код, и нужно проверить, правильно ли он работает. Но программное обеспечение - не
прибор. У нас нет датчиков, которыми можно измерить корректность. У нас есть только модели поведения. И тесты - это не проверка, а
реализация этих моделей в виде исполняемого кода.

Когда мы пишем тест, мы создаём вторую вселенную, то есть виртуального пользователя. Она похожа на настоящую, но лучше контролируема.
В ней время стоит на месте, зависимости делают только то, что мы им разрешаем, а сама система ведёт себя предсказуемо.
Это не копия продакшена - это его реконструкция. Более того:это реконструкция, основанная не на фактах, а на **намерениях**.
Мы тестируем не то, как система работает - а то, как мы *хотим*, чтобы она работала.

Вот почему тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется - тест падает, частая практика не так ли?).
Не потому, что код стал хуже. А потому, что зеркало, в которое мы смотрели, больше не совпадает с формой оригинала.

Тест - это артефакт доверия. Он фиксирует границы допустимого, которые мы согласились считать истиной.
Каждый`assertEquals(expected, actual)` - это не факт, это акт утверждения. Он говорит: *мы согласны, что если `actual == expected`,
то всё хорошо*. Это соглашение. Это договор.

Kotlin хорошо подходит для тестирования, потому что даёт те же инструменты, что и для основного кода: лямбды, DSL, расширения, корутины,
строгую типизацию. Тесты на Kotlin не ощущаются как отдельный язык - они пишутся теми же средствами, в той же парадигме. Нет ощущения
«тест - это вторая лига». Благодаря компактному синтаксису, читаемости и отсутствию лишнего шаблонного кода, тест выглядит как часть
архитектуры, а не как надстройка над ней.

Во всей серии примеры будут на Kotlin - не потому что «так модно», а потому что это стандарт Android-разработки и полноценный язык для
продакшена, независимо от платформы. Kotlin уже используется в Spring, Ktor, Compose, KMP - и везде он одинаково хорош для тестов.

---

## 2. Базис: Лексикон тестирования

Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Без него любые рассуждения - словно попытка
строить архитектуру без понятий "стена", "связь" и "опора". Ниже - не полный глоссарий, а именно тот минимум, на который будет опираться вся
серия.

#### Assertion

Assertion - это программное утверждение, выражающее ожидание. Если оно не выполняется - тест считается неуспешным. В большинстве фреймворков
assertion реализован как функция, выбрасывающая исключение при расхождении:

```kotlin
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
```

Важно понимать: assertion не описывает поведение - он фиксирует его. Это финальная точка сценария, где тест явно заявляет: *вот то, что я
считаю допустимым*. Всё остальное - лишь подготовка к этому моменту.

#### Test Case

Test Case - это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и
проверка результата (assert). В Kotlin это обычно функция с аннотацией `@Test`.

```kotlin
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login("admin", "wrong")
    assertFalse(result.success)
}
```

Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения - он быстро теряет свою надёжность.

#### Test Suite

Test Suite - это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно
это класс, файл или структура DSL. Назначение suite-а - собрать родственные кейсы и запускать их совместно, например, при CI-сборке или
нагрузочном прогоне.

Хорошо организованный suite - это не просто папка с тестами. Это карта покрытия. Он показывает, где есть тесты, а где - только надежда на
интуицию разработчиков.

#### Test Runner

Test Runner - это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение,
репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через
Gradle (или build system IDE), где runner интегрирован в пайплайн.

Хороший runner не замечается. Плохой - ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.

---

#### Test Double

Test Double - это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не
отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.

Существует несколько типов Test Double-ов - и каждый из них решает свою задачу.

**Stub** используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем.
Его задача - быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.

**Mock** применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с
какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.

**Fake** - это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В
отличие от stub-ов и mock-ов, фейк умеет «жить» - накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.

**Spy** похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда
вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.

Test Double - это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения.
И если код не поддаётся тестированию с такими объектами - проблема обычно не в тестах, а в архитектуре.

#### Unit vs Integration

Unit-тест - это тест, который полностью контролирует окружение. Все внешние зависимости заменяются на подставные объекты (Test Doubles),
состояние стабильно, внешних эффектов нет. Такой тест проверяет поведение конкретной единицы кода: функции, метода, класса - в изоляции.

Integration-тест допускает реальные зависимости: базу данных, файловую систему, сеть. Его цель - проверить, как компоненты взаимодействуют
друг с другом в условиях, приближенных к боевым.

Разделение между ними не бинарное. Это шкала. Есть тесты, которые используют, например, настоящий генератор UUID или текущее время -
формально это уже не "чистый" Unit. Но такие компромиссы допустимы, если они осознаны. Главное - понимать, что вы контролируете, а что -
нет.

Критерий здесь не в размере функции или скорости выполнения, а в уровне изоляции. Чем больше вы контролируете, тем ближе тест к Unit. Чем
больше полагаетесь на реальные зависимости - тем ближе он к Integration. Это не про формат, это про доверие.

#### Тест как артефакт

Тест - это не костыль и не подстраховка. Это полноценный исполняемый артефакт, живущий в том же репозитории, что и основной код. Он проходит
через компиляцию, участвует в CI/CD пайплайне, ломается при неудачном рефакторинге и требует сопровождения. Если продакшен-код описывает
*как* работает система, то тест - *что считается допустимым* в её поведении.

Хороший тест не объясняет. Он формализует. И в этом его ценность: он позволяет автоматизировать договор между человеком и системой.

## 3. Концепция: Что вообще мы тестируем?

Если упростить до предела, то тест - это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно.
Он подтверждает, что **в заданных условиях** она ведёт себя **определённым образом**.

Мы не тестируем "истину". Мы тестируем поведение в симулированной среде.

---

### Симуляция, а не доказательство

Распространённая ошибка - считать, что наличие тестов означает корректность системы. Это не так. Тест - это не формальное доказательство, а
ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.

Если поведение системы изменилось, но тесты всё ещё проходят - это не значит, что поведение правильное. Это значит, что тест об этом не
знает.

Например: раньше `isPremiumUser` возвращал `true`, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь `true`
возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними - и продолжают проходить. Только теперь они
подтверждают совсем не то, что раньше. Просто не знают, что смысл `true` изменился.

Тест проверяет не всю систему, а **конкретный срез**: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось
«допустимым». Если позже меняется бизнес-логика, интерфейс или требования - тест становится устаревшим. Это не баг, это свойство теста как
инструмента.

---

### Контролируемое окружение

Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время,
потоки, гонки, кеши. Тест же создаёт **контролируемое окружение**, где всё поведение заранее известно и управляется вручную: от стабов и
фейков до фиктивного времени и UUID.

Разница принципиальна. В production ошибки могут быть случайными. В тестах они - либо детерминированы, либо не обнаруживаются вовсе. Поэтому
тест никогда не может гарантировать "всё работает". Он может только сказать: *в этих условиях - да*.

---

### Уровень доверия

Каждый тест даёт разработчику определённый уровень уверенности. Но важно понимать, откуда именно эта уверенность берётся. Unit-тесты дают
быструю обратную связь: запускаются мгновенно, падения легко локализуются, работают стабильно. Но они покрывают только локальную логику -
изолированную от остальной системы. Их надёжность держится на том, что окружение подменено, а поведение - строго контролируется.

Интеграционные тесты покрывают больше связей. Они проверяют, как компоненты работают вместе: контроллер, сервис, база, кэш, очередь. Они
ближе к реальности, но требуют больше инфраструктуры, сложнее в запуске, и их падения труднее отлаживать. Тем не менее, именно они ловят те
ошибки, которые unit-прогон никогда не заметит.

Это всегда компромисс. Между скоростью и полнотой. Между удобством и точностью. Между временем отклика и глубиной сигнала. И пока эти
компромиссы не осознаны - ни одно число покрытия не имеет смысла. «100% покрытие» может означать как надёжную защиту, так и пустой ритуал -
всё зависит от того, *что именно* вы покрыли, и *зачем*.

---

### Что мы действительно тестируем

На практике, когда мы пишем тест, мы не «проверяем весь модуль» - мы проверяем конкретное поведение в конкретной ситуации. Например: что при
определённых входных данных метод вызывает другой компонент с нужным параметром. Или что система возвращает ожидаемый результат. Или что в
случае ошибки происходит fallback, а не крэш. Или что состояние сохраняется при переходе экрана.

Это не «абсолютная проверка системы». Это фрагмент поведения, проверенный в специально собранном окружении - со стабами, фейками и полной
симуляцией контекста. Мы руками собираем эту модель и утверждаем: *вот в таких условиях система должна вести себя так-то*.

Чем ближе этот контекст к продакшену - тем ценнее тест. Чем дальше - тем он быстрее, дешевле и проще, но локальнее по смыслу. И в этом нет
ничего плохого. Главное - понимать, что именно мы тестируем, и почему.

Тест - это не способ доказать, что всё работает. Это способ убедиться, что **в заданных условиях** ничего не сломано.
И если условия выбраны правильно - этого уже достаточно, чтобы тест выполнял свою работу честно.

## 4. Expect / Actual: Слова, которые всё говорят

Почти в каждом тесте есть одна и та же сцена: мы сравниваем то, что получилось, с тем, что мы ожидали. Чаще всего - через
`assertEquals(expected, actual)`, `assertTrue(condition)`, `assertFailsWith<SomeException>()` или их аналоги. И вроде бы всё очевидно:
проверяем, что результат совпадает с ожиданием. Но даже в этих простых вызовах есть неочевидный момент.

---

### Не просто сравнение, а утверждение

Когда мы вызываем `assertEquals(expected, actual)`, мы не просто сверяем два значения. Мы делаем утверждение. Мы говорим: *если actual не
совпадает с expected - значит, нарушен контракт*. Это не операция сравнения, это **тест на согласие с нашей моделью**.

Важно понимать: `assert*` - это не отладка. Не исследование. Это декларация. Тест либо пройден, либо нет. Нет «почти», нет «предупреждения».
И если условие не выполняется - не система сломалась, а **наши ожидания не совпали с реальностью**.

---

### Expected/Actual - порядок, который важен

Почти все assert-функции следуют одному и тому же порядку: сначала `expected`, потом `actual`. И это не случайность. Это отражение позиции:
«мы считаем, что вот это - правильно, а теперь проверим, совпадает ли с тем, что вышло». В этом смысле `actual` - первичен. Он результат.
Он - реальность. А `expected` - это наша гипотеза.

Если местами их перепутать, тест всё равно будет работать. Но смысл высказывания становится неявным. Падает читаемость. И, главное, исчезает
ощущение, **что именно** пошло не так: то ли мы ошиблись в модели, то ли код нарушил контракт.

---

### assertTrue / assertFalse - примитив, но с той же логикой

Функции `assertTrue` и `assertFalse` не используют expected/actual явно, но логика та же: вы передаёте условие, которое считаете *
*допустимым**. Если оно ложно - тест не пройден. Значит, что-то пошло не так в коде, в контракте или в наших представлениях о корректности.

По сути, каждая `assert*` - это бинарный фильтр: либо да, либо нет. Это инструмент для фиксации допусков, а не для поиска ошибок. И чем
яснее мы это осознаём - тем точнее пишем тесты.

---

### Ключевые слова Kotlin Native? Не об этом речь

Да, в Kotlin Native действительно есть ключевые слова `expect` и `actual`. Они используются в механизме мультиплатформенности: `expect`
задаёт интерфейс, `actual` - реализацию для конкретной платформы. Это может сбить с толку - особенно начинающих. Но в контексте тестирования
мы говорим совсем о другом. Здесь `expected` и `actual` - это **соглашение на уровне мышления**, а не синтаксиса. Это структура суждения: "я
ожидаю X, и вижу Y - совпали ли они?"

Если воспринимать тест как акт сверки - `expected` и `actual` не более чем параметры. Но если понимать, что тест - это **артефакт соглашения
**, то `expected` - это наш манифест. А `actual` - это отражение реальности. И когда они не совпадают, вопрос не в ошибке, а в расхождении
между тем, что система делает, и тем, что мы от неё хотели.

Писать тест - значит формализовать ожидания. А `assertEquals(expected, actual)` - это не просто вызов функции. Это фраза. Она что-то
утверждает. И если её читать именно как утверждение - структура начинает играть значение.

## 5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies

Когда мы говорим о Test Double, мы имеем в виду объекты, которые заменяют настоящие зависимости в тесте. Они позволяют запускать код в
изоляции, без доступа к базе, сети, времени или другим внешним эффектам. Это делает тесты контролируемыми. Но важно понимать, что Double -
это не просто «заглушка». Это модель. И выбор модели влияет на то, *что именно* мы тестируем.

Есть четыре основных типа Test Double, и у каждого - своя цель.

**Stub** - самый простой тестовый двойник. Он всегда возвращает заранее заданные значения и никак не реагирует на входные данные. Stub не
проверяет, что ему передали, не логирует вызовы и не участвует в бизнес-логике - он просто стабилизирует поведение зависимости.
Используется, когда зависимость нужна «для галочки»: достаточно вернуть нужное значение, чтобы тест мог продолжиться. Stub - это фон, а не
часть сцены. Например, в тесте сервиса пользователей можно создать заглушку репозитория, которая всегда возвращает одного и того же
пользователя, игнорируя запрошенный ID:

```kotlin
interface UserRepository {
    fun findById(id: String): User
}

class UserRepositoryStub : UserRepository {
    override fun findById(id: String): User {
        // Намеренно игнорируем id - Stub всегда возвращает одно и то же
        return User(id = "stub-id", name = "John Doe")
    }
}

// Использование в тесте
val stubRepo = UserRepositoryStub()
val service = UserService(stubRepo)
val user = service.getUser("123")
check(user.name == "John Doe")
```

> **В примере выше поведение Stub проявляется в том, что `UserRepositoryStub` всегда возвращает один и тот же результат (`John Doe`), независимо от входного параметра `id`. Он не анализирует, что ему передали, и служит лишь для стабилизации окружения.**

---

**Mock** - объект, который фиксирует, как с ним взаимодействовали. Он запоминает, какие методы вызвали, с какими параметрами и сколько раз.
Задача mock-объекта - не возвращать данные, а подтвердить, что код выполнил определённые действия. Mock используют там, где важно проверить,
*как* происходило взаимодействие: был ли вызван логгер, ушло ли письмо, вызвался ли callback. Это объект-наблюдатель, с помощью которого
тест проверяет поведение. Например, можно создать фальшивый логгер, который будет сохранять записанные сообщения вместо реального вывода, а
затем убедиться в тесте, что нужный метод вызывался с ожидаемыми параметрами:

```kotlin
interface Logger {
    fun log(message: String)
}

class LoggerMock : Logger {
    val receivedMessages = mutableListOf<String>()

    override fun log(message: String) {
        receivedMessages.add(message)
    }
}

// Использование
val logger = LoggerMock()
val service = UserService(logger = logger)
service.createUser("Alice")
check(logger.receivedMessages.size == 1)
check(logger.receivedMessages.first() == "User created")
```

> **В примере выше поведение Mock проявляется в том, что `LoggerMock` запоминает все вызовы метода `log`. В тесте мы проверяем, что сообщение действительно было зафиксировано. Это и есть суть mock - не поведение, а проверка взаимодействия.**

💡 *Mock часто реализуют с помощью библиотек вроде Mockito или MockK, но здесь он показан вручную, чтобы разобрать суть концепции.*

---

**Fake** - рабочая подделка. Это не имитация отдельных вызовов, а полноценная, но упрощённая реализация зависимости. Например, in-memory
база данных или фейковый API, который хранит данные в памяти. Fake не просто «притворяется» - он действительно ведёт себя как настоящая
система, только без использования реальных ресурсов. Его используют, когда нужна реальная логика взаимодействия, но не нужна тяжелая
инфраструктура. Например, вместо обращения к настоящей базе данных можно использовать фейковый репозиторий, который хранит пользователей в
памяти:

```kotlin
interface UserRepository {
    fun save(user: User)
    fun findById(id: String): User?
}

class FakeUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()

    override fun save(user: User) {
        users[user.id] = user
    }

    override fun findById(id: String): User? {
        return users[id]
    }
}

// Использование
val repo = FakeUserRepository()
repo.save(User("1", "Alice"))
val result = repo.findById("1")
check(result?.name == "Alice")
```
 
> **В примере выше поведение Fake проявляется в том, что `FakeUserRepository` действительно сохраняет и возвращает данные, как настоящий репозиторий, но без настоящей базы данных. Это полноценная логика - только in-memory.**

---

**Spy** - «двойной агент». Он оборачивает реальный объект, но отслеживает, что с ним происходило. Spy не подменяет поведение (как mock) и не
заменяет всю реализацию (как fake). Вместо этого он делегирует вызовы настоящему объекту и параллельно фиксирует обращения (например,
считает вызовы или сохраняет параметры). Это компромисс между прозрачным поведением и возможностью анализировать взаимодействие. Например,
можно обернуть реальный (или фейковый) репозиторий в класс-Spy, который будет делегировать вызовы базовому объекту и считать, сколько раз
вызывался метод поиска пользователя:

```kotlin
class UserRepositorySpy(private val realRepo: UserRepository) : UserRepository {
    var findByIdCallCount = 0
    val capturedIds = mutableListOf<String>()

    override fun save(user: User) {
        realRepo.save(user)
    }

    override fun findById(id: String): User? {
        findByIdCallCount++
        capturedIds.add(id)
        return realRepo.findById(id)
    }
}

// Использование
val realRepo = FakeUserRepository()
realRepo.save(User("1", "Bob"))
val spy = UserRepositorySpy(realRepo)
val user = spy.findById("1")
check(user?.name == "Bob")
check(spy.findByIdCallCount == 1)
check(spy.capturedIds.contains("1"))
```

> **В примере выше поведение Spy проявляется в том, что `UserRepositorySpy` делегирует вызовы `realRepo`, 
> но при этом фиксирует: сколько раз вызывался метод `findById`, какие значения передавались.**

💡 *Spy полезен там, где поведение важно сохранить, но при этом нужно наблюдать за взаимодействиями. Мы видим как "что вызвали", так и "что реально произошло".*

---

Иногда выбор типа Double кажется техническим: что проще заиспользовать, что быстрее написать. Но на самом деле он отражает **подход к
архитектуре**. Если мы используем stub - мы говорим: эта зависимость не важна. Если fake - мы признаём, что логика важна, но
инфраструктура - нет. Если mock - мы хотим проконтролировать, как именно система взаимодействует. Spy - мы хотим знать детали, но не мешать
процессу.

Это выбор: **моделировать поведение или структуру**. Проверять результат или отслеживать путь. Упростить окружение или сохранить его
поведение. И когда Double выбран неправильно - тест может быть зелёным, но бессмысленным.

Поэтому вопрос не в том, *какой* Double использовать, а в том, *что именно мы хотим зафиксировать в этом тесте*.

---

## 6. Unit vs JUnit: Что действительно стоит за словами

Слово **unit** в программировании означает *единицу поведения* — минимальный фрагмент системы, который можно протестировать изолированно. Это может быть функция, метод, модуль или класс. Главное — он должен быть **самодостаточным**: то есть его поведение можно проверить без запуска всей системы.

Тест такого фрагмента называют **unit-тестом** — он фокусируется не на всей программе, а на её **наименьшей значимой части**, изолируя внешние зависимости (через stub, mock, fake и т. д.).

> Unit = Единица (поведения)
>, Unit Test = Проверка этой единицы
>, JUnit = Java Unit Testing Framework

**JUnit** — это инструмент, изначально созданный для того, чтобы **писать и запускать unit-тесты на Java**. Название — это сокращение от *Java + Unit*. Но за 20 лет JUnit стал не просто библиотекой, а полноценной **тестовой платформой**, которую можно использовать для чего угодно: от простейших проверок до интеграционных и property-based тестов.

Чтобы понимать, как писать хорошие тесты, важно разобраться не только в коде, но и в истории: как JUnit развивался, и какие идеи он принёс.

---

### История JUnit: от процедур до DSL

**JUnit 3** появился в начале 2000-х. Это был процедурный фреймворк, построенный на соглашениях, а не на аннотациях или конфигурациях. Чтобы метод считался тестом, он должен был начинаться с `test`, а класс — расширять `TestCase`. Всё наследовалось напрямую, никакой инверсии, никакой метаинформации.

```java
public class UserServiceTest extends TestCase {
    public void testUserIsCreated() {
        UserService service = new UserService();
        User user = service.create("Alice");
        assertEquals("Alice", user.getName());
    }
}
```

Никакой магии. JUnit по имени искал методы, начинал их выполнять и сигнализировал о падениях через `AssertionFailedError` или исключения. Всё держалось на соглашениях и строгом порядке.

---

**JUnit 4** стал поворотной точкой. Он избавился от необходимости наследования `TestCase` и перешёл к декларативному стилю на базе аннотаций. Метод помечался `@Test`, и это было достаточно, чтобы фреймворк понял — перед ним тест.

```kotlin
class UserServiceTest {

    @Test
    fun userIsCreated() {
        val service = UserService()
        val user = service.create("Alice")
        assertEquals("Alice", user.name)
    }
}
```

Появились `@Before`, `@After`, `@Ignore`, а также возможность писать кастомные раннеры. Но при всём этом JUnit 4 оставался процедурным. Каждый тест — по сути обычная функция, просто обёрнутая инфраструктурой.

---

**JUnit 5** — уже не фреймворк, а **платформа**. Он разделён на три части: `Platform`, `Jupiter` и `Vintage`.

`JUnit Platform` — это базовый механизм обнаружения и запуска тестов. Он взаимодействует с Gradle, Maven, IDE и CI-системами. Через него тесты регистрируются, исполняются и репортуются. Это слой интеграции, а не логики.
`JUnit Jupiter` — это современный API и тестовый движок. Он поддерживает всё, что появилось в JUnit 5: вложенные тестовые классы (`@Nested`), настраиваемые названия (`@DisplayName`), параметризованные и динамические тесты (`@ParameterizedTest`, `@TestFactory`). Jupiter делает тесты декларативными и выразительными, приближая их к DSL.
`JUnit Vintage` — это адаптер. Он позволяет запускать старые тесты, написанные на JUnit 3 и 4, внутри новой платформы. Благодаря Vintage проекты могут мигрировать постепенно, без полного переписывания.

Синтаксис стал выразительным. Теперь тесты можно строить как декларации поведения, использовать параметры, вводить структуры.

```kotlin
@ParameterizedTest
@ValueSource(strings = ["admin", "user", "guest"])
fun `roles should not be empty`(role: String) {
    val system = RoleService()
    val permissions = system.getPermissions(role)
    assertTrue(permissions.isNotEmpty())
}
```

JUnit 5 перестал быть "юнит"-фреймворком в узком смысле. Он стал каркасом для любых тестов: юнитов, интеграций, property-based подхода, контрактных проверок. Всё, что можно выразить в виде исполняемого DSL с проверками — теперь помещается внутрь.

JUnit не только принял декларативность, но и сам стал частью архитектурного мышления. И теперь, говоря `@Test`, мы запускаем не просто метод — мы инициируем часть тестового пайплайна, где поведение фиксируется как артефакт.

---

Вот переписанный и углублённый блок без «AI-запаха» — техничный, без философии, в инженерном стиле:

---

### Почему `@Test` — это не просто аннотация

Когда JUnit видит `@Test`, он не просто добавляет метод в список. Он включает его в **модель выполнения**. Это сигнал: «этот метод — самостоятельный тест-кейс», и к нему применяются все фазы жизненного цикла.

#### Что реально происходит

JUnit 5 (через `JUnit Platform`) запускает **discovery-фазу**, где использует reflection, чтобы найти классы и методы, аннотированные `@Test`. Дальше движок строит `TestDescriptor` и планирует его выполнение. Если тест поддерживает другие аннотации (`@BeforeEach`, `@DisplayName` и т.д.), они тоже регистрируются и исполняются в нужные фазы.

Метод с `@Test`:

* должен быть `public`;
* не должен принимать аргументов (если только это не `@ParameterizedTest`);
* должен быть `non-static` (в JUnit 4), `instance`-метод (в JUnit 5);
* не обязан возвращать `void` или `Unit`, но возвращаемое значение игнорируется;
* может выбрасывать исключения.

JUnit 5 использует `org.junit.platform.engine.TestEngine` и `org.junit.jupiter.engine.execution.ExecutableInvoker` — именно тут `@Test` превращается в исполняемый блок, через reflection-инвокацию.

---

### Почему это важно в CI

JUnit-интеграции в IDE, Gradle, Maven, Bazel и CI-системы (например, GitHub Actions) ожидают строго определённую структуру: `@Test`-методы автоматически индексируются, изолируются и репортятся. Без этой аннотации метод — просто функция, недоступная для раннера.

---

### Что делает `@Test` частью контракта

Аннотация фиксирует несколько инженерных соглашений:

* **Изолируемость**: тест должен быть самодостаточным. Его можно запустить отдельно.
* **Предсказуемость**: тест не зависит от глобального состояния, иначе он станет flaky.
* **Детерминизм**: один и тот же вход → один и тот же результат. Без этого невозможна автоматизация.

JUnit создаёт инстанс тестового класса на каждый `@Test`, чтобы избежать shared-state. Это часть контракта.

---

### `@VisibleForTesting`: не тест, но для теста

Аннотация `@VisibleForTesting` — это **информационный маркер**, который говорит: «этот метод или поле доступны шире, чем нужно — только ради тестов». Она не влияет на рантайм и не делает метод тестом. Но:

* подчёркивает, что доступность **искусственно расширена**;
* сигнализирует: в продакшене не использовать.

Используется часто в Kotlin и Java, особенно в Android-проектах, как соглашение на уровне команды.

```kotlin
@VisibleForTesting
internal fun recalculateChecksum() {
    // метод открыт не для продакшена, а чтобы тест мог вызвать напрямую
}
```

---


### Почему JUnit 5 — это уже не просто про юниты

JUnit 5 дал не только удобство, но и **философскую переориентацию**:

* Тест — это DSL.
* Контекст можно выстраивать через `@BeforeEach`, `@Nested`, `@TestInstance`.
* Тесты стали **композиционными**: можно собирать reusable DSL-тесты.
* Появились `TestFactory`, `DynamicTest`, `TestReporter`.

JUnit теперь — это платформа **автоматизированной верификации поведения**. Неважно, unit ты проверяешь или взаимодействие нескольких микросервисов. JUnit — это способ **отформализовать ожидание** и положиться на tooling.

---

## 7. Kotlin Test: Строгая минималистика

* Kotlin Test - не "Kotlin обёртка над JUnit", а другая философия.
* Kotlin First: лямбды, DSL-подход, выразительность.
* Пример теста без boilerplate.
* Почему многие так и не поняли силу `kotest`, `kotlin.test`, `assertSoftly` и т.д.

---

## 8. Заключение: Тест как управляемая иллюзия реальности

* Тест - это симуляция, которой мы *хотим верить*.
* Но именно потому, что это иллюзия, она должна быть контролируемой.
* И чем честнее тест, тем проще продакшен.

---
