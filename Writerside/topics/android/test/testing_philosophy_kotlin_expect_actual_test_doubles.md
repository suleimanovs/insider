---
title: "Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles"
excerpt: "Глубокое погружение в философский фундамент тестирования на Kotlin: что означают expect/actual, в чём разница между Unit и JUnit
тестами, а также концептуальные роли mocks, stubs, fakes и spies. Понимание тестов как контролируемых симуляций реальности."
publishDate: 2025-08-01
readingTime: 20
locked: true
series: "Android под капотом: Тестирование без иллюзий"
part: 1
category: "Android"
---

## 1. Введение: Почему тесты - это не проверка, а модель

Эта статья открывает серию «Android под капотом: Тестирование без иллюзий». Семь частей - семь углублений, от фундамента до системной
архитектуры, от синтаксиса до этики. Перед вами первая: философская база. Она нужна, чтобы все остальные статьи не висели в воздухе.

Если вы давно тестируете - это напоминание о том, *зачем* вы это делаете. Если вы только начинаете - это фундамент, без которого всё
остальное превращается в механическое повторение шаблонов по tutorial-ам и "Best Practice".

Тесты часто представляют как механизм проверки: мол, есть код, и нужно проверить, правильно ли он работает. Но программное обеспечение - не
прибор. У нас нет датчиков, которыми можно измерить корректность. У нас есть только модели поведения. И тесты - это не проверка, а
реализация этих моделей в виде исполняемого кода.

Когда мы пишем тест, мы создаём вторую вселенную, то есть виртуального пользователя. Она похожа на настоящую, но лучше контролируема.
В ней время стоит на месте, зависимости делают только то, что мы им разрешаем, а сама система ведёт себя предсказуемо.
Это не копия продакшена - это его реконструкция. Более того:это реконструкция, основанная не на фактах, а на **намерениях**.
Мы тестируем не то, как система работает - а то, как мы *хотим*, чтобы она работала.

Вот почему тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется - тест падает, частая практика не так ли?).
Не потому, что код стал хуже. А потому, что зеркало, в которое мы смотрели, больше не совпадает с формой оригинала.

Тест - это артефакт доверия. Он фиксирует границы допустимого, которые мы согласились считать истиной.
Каждый`assertEquals(expected, actual)` - это не факт, это акт утверждения. Он говорит: *мы согласны, что если `actual == expected`,
то всё хорошо*. Это соглашение. Это договор.

Kotlin хорошо подходит для тестирования, потому что даёт те же инструменты, что и для основного кода: лямбды, DSL, расширения, корутины,
строгую типизацию. Тесты на Kotlin не ощущаются как отдельный язык - они пишутся теми же средствами, в той же парадигме. Нет ощущения
«тест - это вторая лига». Благодаря компактному синтаксису, читаемости и отсутствию лишнего шаблонного кода, тест выглядит как часть
архитектуры, а не как надстройка над ней.

Во всей серии примеры будут на Kotlin - не потому что «так модно», а потому что это стандарт Android-разработки и полноценный язык для
продакшена, независимо от платформы. Kotlin уже используется в Spring, Ktor, Compose, KMP - и везде он одинаково хорош для тестов.

---

## 2. Базис: Лексикон тестирования

Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Без него любые рассуждения - словно попытка
строить архитектуру без понятий "стена", "связь" и "опора". Ниже - не полный глоссарий, а именно тот минимум, на который будет опираться вся
серия.

#### Assertion

Assertion - это программное утверждение, выражающее ожидание. Если оно не выполняется - тест считается неуспешным. В большинстве фреймворков
assertion реализован как функция, выбрасывающая исключение при расхождении:

```kotlin
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
```

Важно понимать: assertion не описывает поведение - он фиксирует его. Это финальная точка сценария, где тест явно заявляет: *вот то, что я
считаю допустимым*. Всё остальное - лишь подготовка к этому моменту.

#### Test Case

Test Case - это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и
проверка результата (assert). В Kotlin это обычно функция с аннотацией `@Test`.

```kotlin
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login("admin", "wrong")
    assertFalse(result.success)
}
```

Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения - он быстро теряет свою надёжность.

#### Test Suite

Test Suite - это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно
это класс, файл или структура DSL. Назначение suite-а - собрать родственные кейсы и запускать их совместно, например, при CI-сборке или
нагрузочном прогоне.

Хорошо организованный suite - это не просто папка с тестами. Это карта покрытия. Он показывает, где есть тесты, а где - только надежда на
интуицию разработчиков.

#### Test Runner

Test Runner - это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение,
репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через
Gradle (или build system IDE), где runner интегрирован в пайплайн.

Хороший runner не замечается. Плохой - ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.

Отлично, тогда адаптирую секцию так, чтобы:

* **не было кода**;
* всё оставалось **понятным с первого прочтения**;
* объяснение шло не как справка, а как спокойное инженерное разъяснение.

Вот итоговая версия секции **Test Double** - без кода, но с ясными и точными определениями:

---

#### Test Double

Test Double - это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не
отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.

Существует несколько типов Test Double-ов - и каждый из них решает свою задачу.

**Stub** используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем.
Его задача - быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.

**Mock** применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с
какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.

**Fake** - это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В
отличие от stub-ов и mock-ов, фейк умеет «жить» - накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.

**Spy** похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда
вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.

Test Double - это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения.
И если код не поддаётся тестированию с такими объектами - проблема обычно не в тестах, а в архитектуре.

#### Unit vs Integration

Unit-тест - это тест, который полностью контролирует окружение. Все внешние зависимости заменяются на подставные объекты (Test Doubles),
состояние стабильно, внешних эффектов нет. Такой тест проверяет поведение конкретной единицы кода: функции, метода, класса - в изоляции.

Integration-тест допускает реальные зависимости: базу данных, файловую систему, сеть. Его цель - проверить, как компоненты взаимодействуют
друг с другом в условиях, приближенных к боевым.

Разделение между ними не бинарное. Это шкала. Есть тесты, которые используют, например, настоящий генератор UUID или текущее время -
формально это уже не "чистый" Unit. Но такие компромиссы допустимы, если они осознаны. Главное - понимать, что вы контролируете, а что -
нет.

Критерий здесь не в размере функции или скорости выполнения, а в уровне изоляции. Чем больше вы контролируете, тем ближе тест к Unit. Чем
больше полагаетесь на реальные зависимости - тем ближе он к Integration. Это не про формат, это про доверие.

#### Тест как артефакт

Тест - это не костыль и не подстраховка. Это полноценный исполняемый артефакт, живущий в том же репозитории, что и основной код. Он проходит
через компиляцию, участвует в CI/CD пайплайне, ломается при неудачном рефакторинге и требует сопровождения. Если продакшен-код описывает
*как* работает система, то тест - *что считается допустимым* в её поведении.

Хороший тест не объясняет. Он формализует. И в этом его ценность: он позволяет автоматизировать договор между человеком и системой.

## 3. Концепция: Что вообще мы тестируем?

Если упростить до предела, то тест — это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно.
Он подтверждает, что **в заданных условиях** она ведёт себя **определённым образом**.

Мы не тестируем "истину". Мы тестируем поведение в симулированной среде.

---

### Симуляция, а не доказательство

Распространённая ошибка — считать, что наличие тестов означает корректность системы. Это не так. Тест — это не формальное доказательство, а
ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.

Если поведение системы изменилось, но тесты всё ещё проходят — это не значит, что поведение правильное. Это значит, что тест об этом не
знает.

Например: раньше isPremiumUser возвращал true, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь true
возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними — и продолжают проходить. Только теперь они
подтверждают совсем не то, что раньше. Просто не знают, что смысл true изменился.

Тест проверяет не всю систему, а **конкретный срез**: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось
«допустимым». Если позже меняется бизнес-логика, интерфейс или требования — тест становится устаревшим. Это не баг, это свойство теста как
инструмента.

---

### Контролируемое окружение

Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время,
потоки, гонки, кеши. Тест же создаёт **контролируемое окружение**, где всё поведение заранее известно и управляется вручную: от стабов и
фейков до фиктивного времени и UUID.

Разница принципиальна. В production ошибки могут быть случайными. В тестах они — либо детерминированы, либо не обнаруживаются вовсе. Поэтому
тест никогда не может гарантировать "всё работает". Он может только сказать: *в этих условиях — да*.

---

### Уровень доверия

Каждый тест даёт разработчику уровень уверенности. Вопрос в том, **какой именно**. Быстрый unit-тест, в котором всё замокано, даёт
мгновенную обратную связь — но только по локальной логике. Интеграционный тест покрывает больше связей — но требует инфраструктуры, занимает
больше времени, и сложнее в сопровождении.

Каждый тип теста — это компромисс между:

* **Скоростью** (написания, запуска, отладки);
* **Надёжностью** (насколько он чувствителен к реальным изменениям);
* **Уровнем абстракции**, на котором он работает.

Вот почему "100% покрытие" — не цель, а цифра. Она ничего не говорит о качестве тестов, если не уточнено, что именно покрыто, как, и на
каком уровне.

---

### Что мы *действительно* тестируем

На практике — мы тестируем:

* что функция X вызывает компонент Y с параметром Z;
* что при вводе A формируется ответ B;
* что в случае ошибки происходит fallback;
* что состояние сохраняется при выполнении сценария;

И всё это — **в искусственно созданном контексте**, который мы руками собрали вокруг кода. Чем ближе этот контекст к реальному — тем
полезнее тест. Чем больше он фиктивен — тем быстрее, но тем более локально надёжен.

Тест — это способ сделать поведение системы **предсказуемым** в зоне, где хаос не нужен. Всё остальное — следствие.
---

## 4. Expect / Actual: Слова, которые всё говорят

* Истоки пары `expected`/`actual` - не из Kotlin, а из философии логических моделей.
* Почему `assertEquals(expected, actual)` - это не операция сравнения, а утверждение.
* Вставка-факт: `expect`/`actual` - ключевые слова в Kotlin Native, но не об этом речь.
* Почему `actual` почти всегда первичен в поведении, а `expected` - вторичен в логике.

---

## 5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies

* **Stub**: немой дублёр - выдает значения, не запоминает вызовы.
* **Mock**: подслушивающий агент - всё фиксирует, всё валидирует.
* **Fake**: рабочая подделка - может быть полноценной реализацией.
* **Spy**: двойной агент - работает как оригинал, но с багом памяти (пишет все вызовы).
* Почему выбор Double-а - это философское решение: ты моделируешь поведение или структуру?

---

## 6. Unit vs JUnit: Что действительно стоит за словами

* История JUnit: от процедурных корней JUnit 3 до лямбда-функций JUnit 5.
* Почему `@Test` - это не просто аннотация, а контракт.
* Примеры кода: как менялись тесты от `extends TestCase` до `@ParameterizedTest`.
* Почему JUnit 5 - это уже не просто про юниты, а про платформу тестирования.

---

## 7. Kotlin Test: Строгая минималистика

* Kotlin Test - не "Kotlin обёртка над JUnit", а другая философия.
* Kotlin First: лямбды, DSL-подход, выразительность.
* Пример теста без boilerplate.
* Почему многие так и не поняли силу `kotest`, `kotlin.test`, `assertSoftly` и т.д.

---

## 8. Заключение: Тест как управляемая иллюзия реальности

* Тест - это симуляция, которой мы *хотим верить*.
* Но именно потому, что это иллюзия, она должна быть контролируемой.
* И чем честнее тест, тем проще продакшен.

---

## ➕ Далее

Если устраивает структура, я напишу статью целиком - в твоём стиле, без markdown-воды, строго и по делу.

Подтверди или предложи правки - и я начну писать текст.
