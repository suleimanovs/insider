---
title: "Философия тестирования в Kotlin: Expect/Actual, Unit-тесты и природа Test Doubles"
excerpt: "Глубокое погружение в философский фундамент тестирования на Kotlin: что означают expect/actual, в чём разница между Unit и JUnit
тестами, а также концептуальные роли mocks, stubs, fakes и spies. Понимание тестов как контролируемых симуляций реальности."
publishDate: 2025-08-01
readingTime: 20
locked: true
series: "Android под капотом: Тестирование без иллюзий"
part: 1
category: "Android"
---

## 1. Введение: Почему тесты - это не проверка, а модель

Эта статья открывает серию «Android под капотом: Тестирование без иллюзий». Семь частей - семь углублений, от фундамента до системной
архитектуры, от синтаксиса до этики. Перед вами первая: философская база. Она нужна, чтобы все остальные статьи не висели в воздухе.

Если вы давно тестируете - это напоминание о том, *зачем* вы это делаете. Если вы только начинаете - это фундамент, без которого всё
остальное превращается в механическое повторение шаблонов по tutorial-ам и "Best Practice".

Тесты часто представляют как механизм проверки: мол, есть код, и нужно проверить, правильно ли он работает. Но программное обеспечение - не
прибор. У нас нет датчиков, которыми можно измерить корректность. У нас есть только модели поведения. И тесты - это не проверка, а
реализация этих моделей в виде исполняемого кода.

Когда мы пишем тест, мы создаём вторую вселенную, то есть виртуального пользователя. Она похожа на настоящую, но лучше контролируема.
В ней время стоит на месте, зависимости делают только то, что мы им разрешаем, а сама система ведёт себя предсказуемо.
Это не копия продакшена - это его реконструкция. Более того:это реконструкция, основанная не на фактах, а на **намерениях**.
Мы тестируем не то, как система работает - а то, как мы *хотим*, чтобы она работала.

Вот почему тесты редко умирают от багов. Они умирают от изменения ожиданий. Контракт меняется - тест падает, частая практика не так ли?).
Не потому, что код стал хуже. А потому, что зеркало, в которое мы смотрели, больше не совпадает с формой оригинала.

Тест - это артефакт доверия. Он фиксирует границы допустимого, которые мы согласились считать истиной.
Каждый`assertEquals(expected, actual)` - это не факт, это акт утверждения. Он говорит: *мы согласны, что если `actual == expected`,
то всё хорошо*. Это соглашение. Это договор.

Kotlin хорошо подходит для тестирования, потому что даёт те же инструменты, что и для основного кода: лямбды, DSL, расширения, корутины,
строгую типизацию. Тесты на Kotlin не ощущаются как отдельный язык - они пишутся теми же средствами, в той же парадигме. Нет ощущения
«тест - это вторая лига». Благодаря компактному синтаксису, читаемости и отсутствию лишнего шаблонного кода, тест выглядит как часть
архитектуры, а не как надстройка над ней.

Во всей серии примеры будут на Kotlin - не потому что «так модно», а потому что это стандарт Android-разработки и полноценный язык для
продакшена, независимо от платформы. Kotlin уже используется в Spring, Ktor, Compose, KMP - и везде он одинаково хорош для тестов.

---

## 2. Базис: Лексикон тестирования

Прежде чем углубляться в механику и архитектуру тестов, нужно зафиксировать базовый словарь. Без него любые рассуждения - словно попытка
строить архитектуру без понятий "стена", "связь" и "опора". Ниже - не полный глоссарий, а именно тот минимум, на который будет опираться вся
серия.

#### Assertion

Assertion - это программное утверждение, выражающее ожидание. Если оно не выполняется - тест считается неуспешным. В большинстве фреймворков
assertion реализован как функция, выбрасывающая исключение при расхождении:

```kotlin
assertEquals(expected, actual)
assertTrue(user.isLoggedIn)
```

Важно понимать: assertion не описывает поведение - он фиксирует его. Это финальная точка сценария, где тест явно заявляет: *вот то, что я
считаю допустимым*. Всё остальное - лишь подготовка к этому моменту.

#### Test Case

Test Case - это единичный сценарий тестирования. Он состоит из трёх фаз: подготовка контекста (arrange), выполнение действия (act) и
проверка результата (assert). В Kotlin это обычно функция с аннотацией `@Test`.

```kotlin
@Test
fun loginFailsWithInvalidPassword() {
    val auth = AuthService(FakeUserRepo())
    val result = auth.login("admin", "wrong")
    assertFalse(result.success)
}
```

Test Case должен быть изолированным и воспроизводимым. Если тест зависит от состояния внешнего окружения - он быстро теряет свою надёжность.

#### Test Suite

Test Suite - это логическая группа тестов, объединённых по какому-либо признаку: модуль, слой архитектуры, бизнес-функциональность. Обычно
это класс, файл или структура DSL. Назначение suite-а - собрать родственные кейсы и запускать их совместно, например, при CI-сборке или
нагрузочном прогоне.

Хорошо организованный suite - это не просто папка с тестами. Это карта покрытия. Он показывает, где есть тесты, а где - только надежда на
интуицию разработчиков.

#### Test Runner

Test Runner - это механизм, отвечающий за обнаружение и исполнение тестов. Он обеспечивает инфраструктурный цикл: инициализация, выполнение,
репортинг. В JUnit 5 runner разделён на модули: Platform, Jupiter и Vintage. Kotlin-тесты в JVM-проектах чаще всего запускаются через
Gradle (или build system IDE), где runner интегрирован в пайплайн.

Хороший runner не замечается. Плохой - ломает вам отладку, кеширует устаревшие состояния или игнорирует падения.

---

#### Test Double

Test Double - это подставной объект, который заменяет настоящую зависимость в тесте. Это нужно для того, чтобы не вызывать реальную базу, не
отправлять настоящие письма и не ждать сетевых ответов. С такими объектами тест становится изолированным и управляемым.

Существует несколько типов Test Double-ов - и каждый из них решает свою задачу.

**Stub** используется, когда важно просто вернуть фиксированный ответ. Он не запоминает, что у него спрашивали, и не интересуется, зачем.
Его задача - быть стабильным фоном. Например, когда нужно всегда возвращать текущую дату или результат запроса.

**Mock** применяется, когда важно не только то, что вернулось, но и то, как с этим объектом взаимодействовали. Сколько раз вызвали метод, с
какими параметрами, в каком порядке. Mock нужен там, где поведение зависит от побочных эффектов: уведомлений, логов, внешних вызовов.

**Fake** - это рабочая, но упрощённая версия настоящей реализации. Например, фейковая база, которая хранит данные в памяти, а не на диске. В
отличие от stub-ов и mock-ов, фейк умеет «жить» - накапливать состояние, вести себя как настоящая система, но без всей тяжеловесности.

**Spy** похож на mock, но вместо имитации он действительно выполняет действия, как настоящий объект. При этом он фиксирует, что и когда
вызывалось. Spy нужен, когда поведение важно сохранить, но и проверить взаимодействие тоже необходимо.

Test Double - это техника, которая позволяет тестировать сложные системы по частям, без запуска всего окружения.
И если код не поддаётся тестированию с такими объектами - проблема обычно не в тестах, а в архитектуре.

#### Unit vs Integration

Unit-тест - это тест, который полностью контролирует окружение. Все внешние зависимости заменяются на подставные объекты (Test Doubles),
состояние стабильно, внешних эффектов нет. Такой тест проверяет поведение конкретной единицы кода: функции, метода, класса - в изоляции.

Integration-тест допускает реальные зависимости: базу данных, файловую систему, сеть. Его цель - проверить, как компоненты взаимодействуют
друг с другом в условиях, приближенных к боевым.

Разделение между ними не бинарное. Это шкала. Есть тесты, которые используют, например, настоящий генератор UUID или текущее время -
формально это уже не "чистый" Unit. Но такие компромиссы допустимы, если они осознаны. Главное - понимать, что вы контролируете, а что -
нет.

Критерий здесь не в размере функции или скорости выполнения, а в уровне изоляции. Чем больше вы контролируете, тем ближе тест к Unit. Чем
больше полагаетесь на реальные зависимости - тем ближе он к Integration. Это не про формат, это про доверие.

#### Тест как артефакт

Тест - это не костыль и не подстраховка. Это полноценный исполняемый артефакт, живущий в том же репозитории, что и основной код. Он проходит
через компиляцию, участвует в CI/CD пайплайне, ломается при неудачном рефакторинге и требует сопровождения. Если продакшен-код описывает
*как* работает система, то тест - *что считается допустимым* в её поведении.

Хороший тест не объясняет. Он формализует. И в этом его ценность: он позволяет автоматизировать договор между человеком и системой.

## 3. Концепция: Что вообще мы тестируем?

Если упростить до предела, то тест - это запуск части системы в контролируемом контексте. Он не доказывает, что система работает правильно.
Он подтверждает, что **в заданных условиях** она ведёт себя **определённым образом**.

Мы не тестируем "истину". Мы тестируем поведение в симулированной среде.

---

### Симуляция, а не доказательство

Распространённая ошибка - считать, что наличие тестов означает корректность системы. Это не так. Тест - это не формальное доказательство, а
ограниченная модель. Он покрывает конкретный сценарий, с заданными входами и ожидаемыми выходами.

Если поведение системы изменилось, но тесты всё ещё проходят - это не значит, что поведение правильное. Это значит, что тест об этом не
знает.

Например: раньше `isPremiumUser` возвращал `true`, если у пользователя была активная подписка. Потом добавили гратис-период, и теперь `true`
возвращается и в первые 7 дней бесплатно. Логика поменялась, но тесты остались прежними - и продолжают проходить. Только теперь они
подтверждают совсем не то, что раньше. Просто не знают, что смысл `true` изменился.

Тест проверяет не всю систему, а **конкретный срез**: функцию, модуль, цепочку вызовов. Он фиксирует то, что в момент написания считалось
«допустимым». Если позже меняется бизнес-логика, интерфейс или требования - тест становится устаревшим. Это не баг, это свойство теста как
инструмента.

---

### Контролируемое окружение

Настоящая система работает в условиях, которые невозможно воспроизвести на 100%: флуктуации сетевых задержек, состояние внешних API, время,
потоки, гонки, кеши. Тест же создаёт **контролируемое окружение**, где всё поведение заранее известно и управляется вручную: от стабов и
фейков до фиктивного времени и UUID.

Разница принципиальна. В production ошибки могут быть случайными. В тестах они - либо детерминированы, либо не обнаруживаются вовсе. Поэтому
тест никогда не может гарантировать "всё работает". Он может только сказать: *в этих условиях - да*.

---

### Уровень доверия

Каждый тест даёт разработчику определённый уровень уверенности. Но важно понимать, откуда именно эта уверенность берётся. Unit-тесты дают
быструю обратную связь: запускаются мгновенно, падения легко локализуются, работают стабильно. Но они покрывают только локальную логику -
изолированную от остальной системы. Их надёжность держится на том, что окружение подменено, а поведение - строго контролируется.

Интеграционные тесты покрывают больше связей. Они проверяют, как компоненты работают вместе: контроллер, сервис, база, кэш, очередь. Они
ближе к реальности, но требуют больше инфраструктуры, сложнее в запуске, и их падения труднее отлаживать. Тем не менее, именно они ловят те
ошибки, которые unit-прогон никогда не заметит.

Это всегда компромисс. Между скоростью и полнотой. Между удобством и точностью. Между временем отклика и глубиной сигнала. И пока эти
компромиссы не осознаны - ни одно число покрытия не имеет смысла. «100% покрытие» может означать как надёжную защиту, так и пустой ритуал -
всё зависит от того, *что именно* вы покрыли, и *зачем*.

---

### Что мы действительно тестируем

На практике, когда мы пишем тест, мы не «проверяем весь модуль» - мы проверяем конкретное поведение в конкретной ситуации. Например: что при
определённых входных данных метод вызывает другой компонент с нужным параметром. Или что система возвращает ожидаемый результат. Или что в
случае ошибки происходит fallback, а не крэш. Или что состояние сохраняется при переходе экрана.

Это не «абсолютная проверка системы». Это фрагмент поведения, проверенный в специально собранном окружении - со стабами, фейками и полной
симуляцией контекста. Мы руками собираем эту модель и утверждаем: *вот в таких условиях система должна вести себя так-то*.

Чем ближе этот контекст к продакшену - тем ценнее тест. Чем дальше - тем он быстрее, дешевле и проще, но локальнее по смыслу. И в этом нет
ничего плохого. Главное - понимать, что именно мы тестируем, и почему.

Тест - это не способ доказать, что всё работает. Это способ убедиться, что **в заданных условиях** ничего не сломано.
И если условия выбраны правильно - этого уже достаточно, чтобы тест выполнял свою работу честно.

## 4. Expect / Actual: Слова, которые всё говорят

Почти в каждом тесте есть одна и та же сцена: мы сравниваем то, что получилось, с тем, что мы ожидали. Чаще всего - через
`assertEquals(expected, actual)`, `assertTrue(condition)`, `assertFailsWith<SomeException>()` или их аналоги. И вроде бы всё очевидно:
проверяем, что результат совпадает с ожиданием. Но даже в этих простых вызовах есть неочевидный момент.

---

### Не просто сравнение, а утверждение

Когда мы вызываем `assertEquals(expected, actual)`, мы не просто сверяем два значения. Мы делаем утверждение. Мы говорим: *если actual не
совпадает с expected - значит, нарушен контракт*. Это не операция сравнения, это **тест на согласие с нашей моделью**.

Важно понимать: `assert*` - это не отладка. Не исследование. Это декларация. Тест либо пройден, либо нет. Нет «почти», нет «предупреждения».
И если условие не выполняется - не система сломалась, а **наши ожидания не совпали с реальностью**.

---

### Expected/Actual - порядок, который важен

Почти все assert-функции следуют одному и тому же порядку: сначала `expected`, потом `actual`. И это не случайность. Это отражение позиции:
«мы считаем, что вот это - правильно, а теперь проверим, совпадает ли с тем, что вышло». В этом смысле `actual` - первичен. Он результат.
Он - реальность. А `expected` - это наша гипотеза.

Если местами их перепутать, тест всё равно будет работать. Но смысл высказывания становится неявным. Падает читаемость. И, главное, исчезает
ощущение, **что именно** пошло не так: то ли мы ошиблись в модели, то ли код нарушил контракт.

---

### assertTrue / assertFalse - примитив, но с той же логикой

Функции `assertTrue` и `assertFalse` не используют expected/actual явно, но логика та же: вы передаёте условие, которое считаете *
*допустимым**. Если оно ложно - тест не пройден. Значит, что-то пошло не так в коде, в контракте или в наших представлениях о корректности.

По сути, каждая `assert*` - это бинарный фильтр: либо да, либо нет. Это инструмент для фиксации допусков, а не для поиска ошибок. И чем
яснее мы это осознаём - тем точнее пишем тесты.

---

### Ключевые слова Kotlin Native? Не об этом речь

Да, в Kotlin Native действительно есть ключевые слова `expect` и `actual`. Они используются в механизме мультиплатформенности: `expect`
задаёт интерфейс, `actual` - реализацию для конкретной платформы. Это может сбить с толку - особенно начинающих. Но в контексте тестирования
мы говорим совсем о другом. Здесь `expected` и `actual` - это **соглашение на уровне мышления**, а не синтаксиса. Это структура суждения: "я
ожидаю X, и вижу Y - совпали ли они?"

Если воспринимать тест как акт сверки - `expected` и `actual` не более чем параметры. Но если понимать, что тест - это **артефакт соглашения
**, то `expected` - это наш манифест. А `actual` - это отражение реальности. И когда они не совпадают, вопрос не в ошибке, а в расхождении
между тем, что система делает, и тем, что мы от неё хотели.

Писать тест - значит формализовать ожидания. А `assertEquals(expected, actual)` - это не просто вызов функции. Это фраза. Она что-то
утверждает. И если её читать именно как утверждение - структура начинает играть значение.

## 5. Природа Test Doubles: Mocks, Stubs, Fakes, Spies

Когда мы говорим о Test Double, мы имеем в виду объекты, которые заменяют настоящие зависимости в тесте. Они позволяют запускать код в
изоляции, без доступа к базе, сети, времени или другим внешним эффектам. Это делает тесты контролируемыми. Но важно понимать, что Double —
это не просто «заглушка». Это модель. И выбор модели влияет на то, *что именно* мы тестируем.

Есть четыре основных типа Test Double, и у каждого — своя цель.

**Stub** — самый простой тестовый двойник. Он всегда возвращает заранее заданные значения и никак не реагирует на входные данные. Stub не
проверяет, что ему передали, не логирует вызовы и не участвует в бизнес-логике — он просто стабилизирует поведение зависимости.
Используется, когда зависимость нужна «для галочки»: достаточно вернуть нужное значение, чтобы тест мог продолжиться. Stub — это фон, а не
часть сцены. Например, в тесте сервиса пользователей можно создать заглушку репозитория, которая всегда возвращает одного и того же
пользователя, игнорируя запрошенный ID:

```kotlin
interface UserRepository {
    fun findById(id: String): User
}

class UserRepositoryStub : UserRepository {
    override fun findById(id: String): User {
        // Всегда возвращаем одного и того же пользователя, независимо от id
        return User(id = "stub-id", name = "John Doe")
    }
}

// Использование в тесте
val stubRepo = UserRepositoryStub()
val service = UserService(stubRepo)
val user = service.getUser("123")
check(user.name == "John Doe")
```

**Mock** — объект, который фиксирует, как с ним взаимодействовали. Он запоминает, какие методы вызвали, с какими параметрами и сколько раз.
Задача mock-объекта — не возвращать данные, а подтвердить, что код выполнил определённые действия. Mock используют там, где важно проверить,
*как* происходило взаимодействие: был ли вызван логгер, ушло ли письмо, вызвался ли callback. Это объект-наблюдатель, с помощью которого
тест проверяет поведение. Например, можно создать фальшивый логгер, который будет сохранять записанные сообщения вместо реального вывода, а
затем убедиться в тесте, что нужный метод вызывался с ожидаемыми параметрами:

```kotlin
interface Logger {
    fun log(message: String)
}

class LoggerMock : Logger {
    val receivedMessages = mutableListOf<String>()

    override fun log(message: String) {
        receivedMessages.add(message)
    }
}

// Использование
val logger = LoggerMock()
val service = UserService(logger = logger)
service.createUser("Alice")
check(logger.receivedMessages.size == 1)
check(logger.receivedMessages.first() == "User created")
```

**Fake** — рабочая подделка. Это не имитация отдельных вызовов, а полноценная, но упрощённая реализация зависимости. Например, in-memory
база данных или фейковый API, который хранит данные в памяти. Fake не просто «притворяется» — он действительно ведёт себя как настоящая
система, только без использования реальных ресурсов. Его используют, когда нужна реальная логика взаимодействия, но не нужна тяжелая
инфраструктура. Например, вместо обращения к настоящей базе данных можно использовать фейковый репозиторий, который хранит пользователей в
памяти:

```kotlin
interface UserRepository {
    fun save(user: User)
    fun findById(id: String): User?
}

class FakeUserRepository : UserRepository {
    private val users = mutableMapOf<String, User>()

    override fun save(user: User) {
        users[user.id] = user
    }

    override fun findById(id: String): User? {
        return users[id]
    }
}

// Использование
val repo = FakeUserRepository()
repo.save(User("1", "Alice"))
val result = repo.findById("1")
check(result?.name == "Alice")

```

**Spy** — «двойной агент». Он оборачивает реальный объект, но отслеживает, что с ним происходило. Spy не подменяет поведение (как mock) и не
заменяет всю реализацию (как fake). Вместо этого он делегирует вызовы настоящему объекту и параллельно фиксирует обращения (например,
считает вызовы или сохраняет параметры). Это компромисс между прозрачным поведением и возможностью анализировать взаимодействие. Например,
можно обернуть реальный (или фейковый) репозиторий в класс-Spy, который будет делегировать вызовы базовому объекту и считать, сколько раз
вызывался метод поиска пользователя:

```kotlin
class UserRepositorySpy(private val realRepo: UserRepository) : UserRepository {
    var findByIdCallCount = 0

    override fun save(user: User) {
        realRepo.save(user)
    }

    override fun findById(id: String): User? {
        findByIdCallCount++
        return realRepo.findById(id)
    }
}

// Использование
val realRepo = FakeUserRepository()
realRepo.save(User("1", "Bob"))
val spy = UserRepositorySpy(realRepo)
val user = spy.findById("1")
check(user?.name == "Bob")
check(spy.findByIdCallCount == 1)
```

---

Иногда выбор типа Double кажется техническим: что проще заиспользовать, что быстрее написать. Но на самом деле он отражает **подход к
архитектуре**. Если мы используем stub — мы говорим: эта зависимость не важна. Если fake — мы признаём, что логика важна, но
инфраструктура — нет. Если mock — мы хотим проконтролировать, как именно система взаимодействует. Spy — мы хотим знать детали, но не мешать
процессу.

Это выбор: **моделировать поведение или структуру**. Проверять результат или отслеживать путь. Упростить окружение или сохранить его
поведение. И когда Double выбран неправильно — тест может быть зелёным, но бессмысленным.

Поэтому вопрос не в том, *какой* Double использовать, а в том, *что именно мы хотим зафиксировать в этом тесте*.

---

## 6. Unit vs JUnit: Что действительно стоит за словами

* История JUnit: от процедурных корней JUnit 3 до лямбда-функций JUnit 5.
* Почему `@Test` - это не просто аннотация, а контракт.
* Примеры кода: как менялись тесты от `extends TestCase` до `@ParameterizedTest`.
* Почему JUnit 5 - это уже не просто про юниты, а про платформу тестирования.

---

## 7. Kotlin Test: Строгая минималистика

* Kotlin Test - не "Kotlin обёртка над JUnit", а другая философия.
* Kotlin First: лямбды, DSL-подход, выразительность.
* Пример теста без boilerplate.
* Почему многие так и не поняли силу `kotest`, `kotlin.test`, `assertSoftly` и т.д.

---

## 8. Заключение: Тест как управляемая иллюзия реальности

* Тест - это симуляция, которой мы *хотим верить*.
* Но именно потому, что это иллюзия, она должна быть контролируемой.
* И чем честнее тест, тем проще продакшен.

---

## ➕ Далее

Если устраивает структура, я напишу статью целиком - в твоём стиле, без markdown-воды, строго и по делу.

Подтверди или предложи правки - и я начну писать текст.
