<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-content-max-width="1600" data-resizable-sidebar="true" data-sidebar-width="240"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-03-02T02:46:13.909541"><title>ViewModel Under The Hood: View Model Store | Insider</title><script type="application/json" id="virtual-toc-data">[{"id":"-uo7fu8_3","level":0,"title":"Введение","anchor":"#-uo7fu8_3"},{"id":"viewmodel","level":0,"title":"Объявление ViewModel","anchor":"#viewmodel"},{"id":"viewmodelstore-owner","level":0,"title":"Углубляемся в ViewModelStore / Owner","anchor":"#viewmodelstore-owner"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://i.postimg.cc/JnRdxBdC/output-onlinepngtools.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="ViewModel Under The Hood: View Model Store | Insider"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Insider Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/view-model-under-the-hood.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="ViewModel Under The Hood: View Model Store | Insider"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/view-model-under-the-hood.html#webpage",
    "url": "writerside-documentation//1.0/view-model-under-the-hood.html",
    "name": "ViewModel Under The Hood: View Model Store | Insider",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Insider Help"
}</script><!-- End Schema.org --></head><body data-id="view-model-under-the-hood" data-main-title="ViewModel Under The Hood: View Model Store" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Android"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Insider 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="view-model-under-the-hood" id="view-model-under-the-hood.md">ViewModel Under The Hood: View Model Store</h1><section class="chapter"><h2 id="-uo7fu8_3" data-toc="-uo7fu8_3">Введение</h2><p id="-uo7fu8_6">В статье не рассматривается работа с ViewModel, предполагается, что эта тема уже знакома. Основное внимание уделяется тому, как ViewModel переживает изменение конфигурации. Но для начала &mdash; небольшое введение в ViewModel.</p><p id="-uo7fu8_7"><span class="control" id="-uo7fu8_12">ViewModel</span> - компонент архитектурного паттерна MVVM, который был предоставлен Google как примитив позволяющий пережить изменение конфигураций. Изменение конфигураций в свою очередь - это состояние, заставляющая activity/fragment пересоздаваться, это именно то состояние которое может пережить ViewModel. Популярные конфигурации которые приводят к пересозданию Activity:</p><ol class="list _decimal" id="-uo7fu8_8" type="1"><li class="list__item" id="-uo7fu8_13"><p>Изменение ориентаций экрана(screenOrientation): portrait/landscape</p></li><li class="list__item" id="-uo7fu8_14"><p>Изменение направления экрана(layoutDirection): rtl/ltr</p></li><li class="list__item" id="-uo7fu8_15"><p>Изменение языка приложения(locale)</p></li><li class="list__item" id="-uo7fu8_16"><p>Изменение размера шрифтов/соотношение экрана</p></li></ol><p id="-uo7fu8_9">Есть конечно способ сообщать системе о том что пересоздавать Activity при изменении конфигураций не нужно. Флаг android:configChanges используется в AndroidManifest.xml в теге activity, чтобы указать, какие изменения конфигурации система не должна пересоздавать Activity, а передавать управление в Activity.onConfigurationChanged().</p><div class="code-block" data-lang="markup">

&lt;activity
        android:name=&quot;MainActivity&quot;
        android:configChanges=&quot;touchscreen|keyboard|keyboardHidden|navigation|screenLayout|mcc|mnc|locale|fontScale|uiMode|screenSize|smallestScreenSize|density|orientation&quot;
/&gt;
</div><p id="-uo7fu8_11">Но речь сейчас так же не об этом, так как наша цель рассмотреть каким чудом ViewModel может пережить изменение всех конфигурационных состояний выше.</p></section><section class="chapter"><h2 id="viewmodel" data-toc="viewmodel">Объявление ViewModel</h2><div class="micro-format" data-content="{&quot;microFormat&quot;:[&quot;\u003cp id\u003d\&quot;-uo7fu8_36\&quot;\u003eВ статье рассматривается \u003cb id\u003d\&quot;-uo7fu8_38\&quot;\u003eviewmodel:2.8.0+\u003c/b\u003e. Если ваша версия отличается, не переживайте.\u003c/p\u003e&quot;,&quot;\u003cp id\u003d\&quot;-uo7fu8_37\&quot;\u003eС добавлением KMP изменилась внутренняя структура, но логика осталась прежней.\u003c/p\u003e&quot;]}"></div><p id="-uo7fu8_17">C появлением Kotlin делегатов мы сильно обленились и теперь обь являем ViewModel вот таким образом с использованием kotlin delegates:</p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {

    private val viewModel by viewModel&lt;MyViewModel&gt;()
}

</div><p id="-uo7fu8_19">Без делегатов создание объекта ViewModel используя явно ViewModelProvider:</p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {

    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // В старых версиях ViewModelProvider был частью lifecycle-viewmodel
        viewModel = ViewModelProvider(this).get(MyViewModel::class.java)

        // После адаптации ViewModel под KMP и переноса ViewModelProvider в lifecycle-viewmodel-android 
        // можно и рекомендуется через фабричный метод create:
        viewModel = ViewModelProvider.create(owner = this).get(MyViewModel::class.java)

        // Альтернативный способ создания ViewModel (эквивалентен предыдущему)
        viewModel = ViewModelProvider.create(store = this.viewModelStore).get(MyViewModel::class.java)
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="-uo7fu8_21"><p id="-uo7fu8_27"><span class="control" id="-uo7fu8_30">Jetpack ViewModel</span> теперь поддерживает <span class="control" id="-uo7fu8_31">Kotlin Multiplatform (KMP)</span>, что позволяет использовать его не только на Android, но и на iOS, Desktop и Web. Это стало возможным благодаря разделению на два модуля:</p><p id="-uo7fu8_28"><span class="control" id="-uo7fu8_32">lifecycle-viewmodel(expected):</span> KMP-модуль без привязки к Android. <span class="control" id="-uo7fu8_33">lifecycle-viewmodel-android(actual):</span> модуль для работы с ViewModelStoreOwner и ViewModelProvider на Android.</p><p id="-uo7fu8_29">Начиная с версии <span class="control" id="-uo7fu8_34">2.8.0-alpha03</span>, артефакты <span class="control" id="-uo7fu8_35">lifecycle-</span>* теперь официально поддерживают Kotlin Multiplatform! Это означает, что классы, такие как ViewModel, ViewModelStore, ViewModelStoreOwner и ViewModelProvider, теперь можно использовать в общем коде.</p></aside><aside class="prompt" data-type="tip" data-title="" id="-uo7fu8_22"><p>Далее в статье мы рассмотрим именно версию viewmodel:2.8.0+, если в версий на которой вы находитесь сейчас немного отличаются исходники, то не переживайте, c добавлением поддержки kmp немного поменяли внутренюю структуру , но реализация и внутренняя логика такая же что и до поддержки kmp</p></aside><p id="-uo7fu8_24">Как мы видим выше, мы в ручную не создаем объект ViewModel, а только передаем тип его класса в ViewModelProvider, и его созданием лично занимается сам ViewModelProvider. Обратите внимание, что мы так же передаем в метод <code class="code" id="-uo7fu8_39">ViewModelProvider.create</code> поле <code class="code" id="-uo7fu8_40">owner = this</code>, если провалиться в исходники метода create, то можно заметить что требуется тип owner : ViewModelStoreOwner:</p><div class="code-block" data-lang="kotlin">
public actual companion object {

    @JvmStatic
    @Suppress(&quot;MissingJvmstatic&quot;)
    public actual fun create(
        owner: ViewModelStoreOwner, // &lt;- нас интересует этот тип
        factory: Factory,
        extras: CreationExtras,
    ): ViewModelProvider = ViewModelProvider(owner.viewModelStore, factory, extras)
}
</div><aside class="prompt" data-type="tip" data-title="" id="-uo7fu8_26"><p>Если интересно, почему метод `create()` можно вызывать без передачи значений для параметров `factory` и `extras` (хоть они и обязательны): </p><div class="code-block" data-lang="kotlin">
ViewModelProvider.create(owner = this)
</div><p id="-uo7fu8_42">Это связано с тем, что код использует KMP (Kotlin Multiplatform). В expect-объявлении для create() уже заданы значения по умолчанию для factory и extras, поэтому передавать их явно необязательно.</p><p id="-uo7fu8_43">Подробнее можно посмотреть в исходниках: <a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt" id="-uo7fu8_44" data-external="true" rel="noopener noreferrer">ViewModelProvider.kt</a></p></aside></section><section class="chapter"><h2 id="viewmodelstore-owner" data-toc="viewmodelstore-owner">Углубляемся в ViewModelStore / Owner</h2><p id="-uo7fu8_45">Получается что при вызове метода ViewModelProvider.create() для параметра owner мы передаем this(само активити), и как можно догадаться это означает что активити наследуется от этого типа ViewModelStoreOwner, давайте глянем исходники этого <a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelStoreOwner.kt" id="-uo7fu8_60" data-external="true" rel="noopener noreferrer">ViewModelStoreOwner</a>:</p><div class="code-block" data-lang="kotlin">
public interface [[[ViewModelStoreOwner |https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt]]] {

    /**
     * The owned [ViewModelStore]
     */
    public val viewModelStore: ViewModelStore
}
</div><p id="-uo7fu8_47">ViewModelStoreOwner - интерфейс у которого есть одно поле, который является ViewModelStore(хранителем view models), от ViewModelStoreOwner наследуются такие компоненты как: <span class="control" id="-uo7fu8_61">ComponentActivity</span>, <span class="control" id="-uo7fu8_62">Fragment</span>, <span class="control" id="-uo7fu8_63">NavBackStackEntry</span></p><p id="-uo7fu8_48">ViewModelStoreOwner(в лице ComponentActivity/Fragment) - занимается двумя обьязанностями:</p><ol class="list _decimal" id="-uo7fu8_49" type="1"><li class="list__item" id="-uo7fu8_64"><p>Хранение ViewModelStore во время изменения конфигураций</p></li><li class="list__item" id="-uo7fu8_65"><p>Очистка ViewModelStore когда умирает, в состояний Lifecycle.onDestroy()</p></li></ol><p id="-uo7fu8_50">Дальше нас уже интересует сам ViewModelStore. ViewModelStore - это класс который внутри себя делегирует работу HashMap:</p><div class="code-block" data-lang="kotlin">
private val map = mutableMapOf&lt;String, ViewModel&gt;()
</div><p id="-uo7fu8_52">Соответсвенно ViewModelStore так же делегирует методы put, get, key, clear внутреннему HashMap-у, но особого внимания стоит метод clear:</p><div class="code-block" data-lang="kotlin">
public open class ViewModelStore {

    private val map = mutableMapOf&lt;String, ViewModel&gt;()

    // other methods...
    
    /**
     * Clears internal storage and notifies `ViewModel`s that they are no longer used.
     */
    public fun clear() {
        for (vm in map.values) {
            vm.clear()
        }
        map.clear()
    }
}
</div><p id="-uo7fu8_54">Давайте поймем что здесь происходит, когда наш ViewModelStoreOwner(в лице ComponentActivity/Fragment) умирает окончательно(смерть не связанная с пересозданием из-за изменений конфигураций), в этот момент ViewModelStoreOwner вызывает метод clear() у ViewModelStore В этот момент в методе clear() цикл через for пробегается по всем значениям(view models) которые лежат внутри внутренного HashMap, и вызывает у каждой viewmodel internal метод clear() который в свою очередь будет вызывать метод onCleared у нашей viewmodel, onCleared тот самый метод который мы можем переопределять у ViewModel который вызывается только в момент когда наша viewmodel умирает(так как наш актвити/фрагмент умирают окончательно),</p><div class="code-block" data-lang="kotlin">
public actual abstract class ViewModel {

    // other methods....

    protected actual open fun onCleared() {} // &lt;- метода onCleared которую можно переопределять

    @MainThread
    internal actual fun clear() {
        impl?.clear()
        onCleared() // &lt;- вызов метода onCleared которую можно переопределять
    }
}
</div><p id="-uo7fu8_56">А соответственно сам метод viewModelStore.clear() вызывает ViewModelStoreOwner(в лице ComponentActivity/Fragment), давайте в качестве одного из ViewModelStoreOwner выберем ComponentActivity что бы понять как работает очистка. Вот фрагмент кода из ComponentActivity, который прослушивает его уничтожение и вызывает ViewModelStore.clear()::</p><div class="code-block" data-lang="kotlin">
getLifecycle().addObserver(new LifecycleEventObserver() {
    @Override
    public void onStateChanged(@NonNull LifecycleOwner source,
            @NonNull Lifecycle.Event event) { 
        if (event == Lifecycle.Event.ON_DESTROY) { // &lt;- состояние ON_DESTROY является триггером
            // Clear out the available context
            mContextAwareHelper.clearAvailableContext();
            // And clear the ViewModelStore
            if (!isChangingConfigurations()) {  // &lt;- проверка на то можно ли очищать ViewModelStore
                getViewModelStore().clear(); // &lt;- очистка ViewModelStore
            }
            mReportFullyDrawnExecutor.activityDestroyed();
        }
    }
}
</div><p id="-uo7fu8_58">Мы видим что есть проверка для состояния ON_DESTROY которая проверяет, причиной уничтожения не является изменение конфигураций, и в таком случае и очищается ViewModelStore и удаляются все view model-ки</p><p id="-uo7fu8_59">Если стало запутаннее, то вызов следующее ComponentActivity.onDestroy() -&gt; getViewModelStore().clear() -&gt; MyViewModel.onCleared()</p></section><div class="last-modified">Last modified: 01 марта 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="patterns-principle.html" class="navigation-links__next">Topic title</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.10.0-b575/app.js"></script></body></html>