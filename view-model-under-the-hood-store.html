<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-link-color="#57B747" data-content-max-width="1600" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-30T23:19:07.027175"><title>ViewModel под капотом: как она выживает при пересоздании Activity | suleimanov</title><script type="application/json" id="virtual-toc-data">[{"id":"wrb7ek_3","level":0,"title":"Введение","anchor":"#wrb7ek_3"},{"id":"viewmodel","level":0,"title":"Объявление ViewModel","anchor":"#viewmodel"},{"id":"viewmodelstoreowner","level":0,"title":"ViewModelStoreOwner ?","anchor":"#viewmodelstoreowner"},{"id":"321","level":0,"title":"Где ViewModelStore сохраняется?","anchor":"#321"},{"id":"wrb7ek_7","level":0,"title":"Итоги","anchor":"#wrb7ek_7"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/style.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://iili.io/3eop8YX.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="ViewModel под капотом: как она выживает при пересоздании Activity | suleimanov"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="suleimanov Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/view-model-under-the-hood-store.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="ViewModel под капотом: как она выживает при пересоздании Activity | suleimanov"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/view-model-under-the-hood-store.html#webpage",
    "url": "writerside-documentation//1.0/view-model-under-the-hood-store.html",
    "name": "ViewModel под капотом: как она выживает при пересоздании Activity | suleimanov",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "suleimanov Help"
}</script><!-- End Schema.org --></head><body data-id="view-model-under-the-hood-store" data-main-title="ViewModel под капотом: как она выживает при пересоздании Activity" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Android///ViewModel"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>suleimanov 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="view-model-under-the-hood-store" id="view-model-under-the-hood-store.md">ViewModel под капотом: как она выживает при пересоздании Activity</h1><section class="chapter"><h2 id="wrb7ek_3" data-toc="wrb7ek_3">Введение</h2><p id="wrb7ek_8">В статье не рассматривается работа с ViewModel, предполагается, что эта тема уже знакома. Основное внимание уделяется тому, как ViewModel переживает изменение конфигурации. Но для начала &mdash; небольшое введение в ViewModel.</p><p id="wrb7ek_9"><span class="control" id="wrb7ek_14">ViewModel</span> - компонент архитектурного паттерна MVVM, который был предоставлен Google как примитив позволяющий пережить изменение конфигураций. Изменение конфигураций в свою очередь - это состояние, заставляющая activity/fragment пересоздаваться, это именно то состояние которое может пережить ViewModel. Популярные конфигурации которые приводят к пересозданию Activity:</p><ol class="list _decimal" id="wrb7ek_10" type="1"><li class="list__item" id="wrb7ek_15"><p id="wrb7ek_19">Изменение ориентаций экрана(screenOrientation): portrait/landscape</p></li><li class="list__item" id="wrb7ek_16"><p id="wrb7ek_20">Изменение направления экрана(layoutDirection): rtl/ltr</p></li><li class="list__item" id="wrb7ek_17"><p id="wrb7ek_21">Изменение языка приложения(locale)</p></li><li class="list__item" id="wrb7ek_18"><p id="wrb7ek_22">Изменение размера шрифтов/соотношение экрана</p></li></ol><p id="wrb7ek_11">Есть конечно способ сообщать системе о том что пересоздавать Activity при изменении конфигураций не нужно. Флаг <code class="code" id="wrb7ek_23">android:configChanges</code> используется в <code class="code" id="wrb7ek_24">AndroidManifest.xml</code> в теге <code class="code" id="wrb7ek_25">&lt;activity/&gt;</code>, чтобы указать, какие изменения конфигурации система не должна пересоздавать Activity, а передавать управление методу <code class="code" id="wrb7ek_26">Activity.onConfigurationChanged()</code>.</p><div class="code-block" data-lang="markup">

&lt;activity
        android:name=&quot;MainActivity&quot;
        android:configChanges=&quot;layoutDirection|touchscreen|density|orientation|keyboard|locale|keyboardHidden|navigation|screenLayout|mcc|mnc|fontScale|uiMode|screenSize|smallestScreenSize&quot;
/&gt;
</div><p id="wrb7ek_13">Однако сейчас речь не об этом. Наша цель &mdash; разобраться, каким образом <code class="code" id="wrb7ek_27">ViewModel</code> умудряется переживать все изменения конфигурации и сохранять своё состояние.</p></section><section class="chapter"><h2 id="viewmodel" data-toc="viewmodel">Объявление ViewModel</h2><p id="wrb7ek_28">С появлением делегатов в Kotlin разработчики получили возможность значительно упростить создание и использование компонентов. Теперь объявление <code class="code" id="wrb7ek_35">ViewModel</code> с использованием делегатов выглядит следующим образом:</p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {

    private val viewModel by viewModel&lt;MyViewModel&gt;()
}
</div><p id="wrb7ek_30">Без делегатов создание объекта ViewModel, используя явный вызов ViewModelProvider выглядит следующий образом:</p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {

    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // В старых версиях ViewModelProvider был частью lifecycle-viewmodel
        viewModel = ViewModelProvider(this).get(MyViewModel::class.java)

        // После адаптации ViewModel под KMP и переноса ViewModelProvider в lifecycle-viewmodel-android 
        // можно и рекомендуется через перегруженный фабричный метод create:
        viewModel = ViewModelProvider.create(owner = this).get(MyViewModel::class)

        // Альтернативный способ создания ViewModel (эквивалентен предыдущему)
        viewModel = ViewModelProvider.create(store = this.viewModelStore).get(MyViewModel::class)
    }
}
</div><p id="wrb7ek_32">Метод <code class="code" id="wrb7ek_36">ViewModelProvider.create</code> имеет параметры со значениями по умолчанию, поэтому на уровне байткода компилятор создаст несколько перегруженных версий метода (overloads). Это позволяет вызывать его с разным количеством аргументов: только с <code class="code" id="wrb7ek_37">store</code>, с <code class="code" id="wrb7ek_38">store</code> и <code class="code" id="wrb7ek_39">factory</code>, либо со всеми параметрами, включая <code class="code" id="wrb7ek_40">extras</code>.</p><aside class="prompt" data-type="note" data-title="" id="wrb7ek_33"><p id="wrb7ek_41"><span class="control" id="wrb7ek_44">Jetpack ViewModel</span> теперь поддерживает <span class="control" id="wrb7ek_45">Kotlin Multiplatform (KMP)</span>, что позволяет использовать его не только на Android, но и на iOS, Desktop и Web. Это стало возможным благодаря разделению на два модуля:</p><p id="wrb7ek_42"><span class="control" id="wrb7ek_46">lifecycle-viewmodel(expected):</span> KMP-модуль без привязки к Android. <span class="control" id="wrb7ek_47">lifecycle-viewmodel-android(actual):</span> модуль для работы с ViewModelStoreOwner и ViewModelProvider на Android.</p><p id="wrb7ek_43">Начиная с версии <span class="control" id="wrb7ek_48">2.8.0-alpha03</span>, артефакты <span class="control" id="wrb7ek_49">lifecycle-</span>* теперь официально поддерживают Kotlin Multiplatform! Это означает, что классы, такие как ViewModel, ViewModelStore, ViewModelStoreOwner и ViewModelProvider, теперь можно использовать в общем коде.</p></aside><aside class="prompt" data-type="tip" data-title="" id="wrb7ek_34"><p>Далее в статье мы рассмотрим именно версию viewmodel:2.8.0+, если в версий на которой вы находитесь сейчас немного отличаются исходники, то не переживайте, c добавлением поддержки kmp немного поменяли внутренюю структуру , но реализация и внутренняя логика такая же что и до поддержки kmp</p></aside></section><section class="chapter"><h2 id="viewmodelstoreowner" data-toc="viewmodelstoreowner">ViewModelStoreOwner ?</h2><p id="wrb7ek_50">Как мы видим выше, мы вручную не создаём объект ViewModel, а только передаём тип его класса в ViewModelProvider, который самостоятельно занимается созданием экземпляра.</p><p id="wrb7ek_51">Обратите внимание, что мы также передаём в метод <code class="code" id="wrb7ek_56">ViewModelProvider.create</code> параметр <code class="code" id="wrb7ek_57">owner = this</code>. Если заглянуть в исходники метода <span class="control" id="wrb7ek_58">create</span>, можно заметить, что требуется тип owner: ViewModelStoreOwner:</p><div class="code-block" data-lang="kotlin">
public actual companion object {

    @JvmStatic
    @Suppress(&quot;MissingJvmstatic&quot;)
    public actual fun create(
        owner: ViewModelStoreOwner, // &lt;- нас интересует этот тип
        factory: Factory,
        extras: CreationExtras,
    ): ViewModelProvider = ViewModelProvider(owner.viewModelStore, factory, extras)
}
</div><aside class="prompt" data-type="tip" data-title="" id="wrb7ek_53"><p>Если интересно, почему метод `create()` можно вызывать без передачи значений для параметров `factory` и `extras` (хоть они и обязательны): </p><div class="code-block" data-lang="kotlin">
ViewModelProvider.create(owner = this)
</div><p id="wrb7ek_60">Это связано с тем, что код использует KMP (Kotlin Multiplatform). В expect-объявлении для create() уже заданы значения по умолчанию для factory и extras, поэтому передавать их явно необязательно.</p><div class="code-block" data-lang="kotlin">
public expect class ViewModelProvider {
    ....
    public companion object {
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider

    }
    ....
}
</div><p id="wrb7ek_62">Подробнее можно посмотреть в исходниках: <a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt" id="wrb7ek_63" data-external="true" rel="noopener noreferrer" target="_blank">ViewModelProvider.kt</a></p></aside><section class="chapter"><h3 id="viewmodelstore-owner" data-toc="viewmodelstore-owner">Углубляемся в ViewModelStore / Owner</h3><p id="wrb7ek_64">Получается что при вызове метода <code class="code" id="wrb7ek_70">ViewModelProvider.create()</code> для параметра <code class="code" id="wrb7ek_71">owner</code> мы передаем <code class="code" id="wrb7ek_72">this</code> (само активити), и как можно догадаться, это означает, что activity реализует(наследуется) от интерфейса <code class="code" id="wrb7ek_73">ViewModelStoreOwner</code>. Давайте взглянем на исходники этого интерфейса: <a href="https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelStoreOwner.kt" id="wrb7ek_74" data-external="true" rel="noopener noreferrer" target="_blank">ViewModelStoreOwner</a>:</p><div class="code-block" data-lang="kotlin">
public interface [[[ViewModelStoreOwner |https://github.com/androidx/androidx/blob/androidx-main/lifecycle/lifecycle-viewmodel/src/commonMain/kotlin/androidx/lifecycle/ViewModelProvider.kt]]] {

/**
 * The owned [ViewModelStore]
 */
public val viewModelStore: ViewModelStore
}
</div><p id="wrb7ek_66"><code class="code" id="wrb7ek_75">ViewModelStoreOwner</code> &mdash; это интерфейс с единственным полем, которое представляет собой <code class="code" id="wrb7ek_76">ViewModelStore</code> (хранитель view models). От <code class="code" id="wrb7ek_77">ViewModelStoreOwner</code> наследуются такие компоненты как: <span class="control" id="wrb7ek_78">ComponentActivity</span>, <span class="control" id="wrb7ek_79">Fragment</span>, * <span class="emphasis" id="wrb7ek_80">NavBackStackEntry</span>*.</p><p id="wrb7ek_67">Официальная документация гласит:</p><aside class="prompt" data-type="tip" data-title="" id="wrb7ek_68"><p id="wrb7ek_81">A scope that owns ViewModelStore. A responsibility of an implementation of this interface is to retain owned ViewModelStore during the configuration changes and call ViewModelStore. clear, when this scope is going to be destroyed.</p></aside></section><section class="chapter"><h3 id="123" data-toc="123">Обязанности ViewModelStoreOwner:</h3><ol class="list _decimal" id="wrb7ek_82" type="1"><li class="list__item" id="wrb7ek_118"><p id="wrb7ek_120"><span class="control" id="wrb7ek_121">Хранение ViewModelStore во время изменения конфигураций.</span></p></li><li class="list__item" id="wrb7ek_119"><p id="wrb7ek_122"><span class="control" id="wrb7ek_123">Очистка ViewModelStore при уничтожении ComponentActivity/Fragment</span> &mdash; в состоянии <code class="code" id="wrb7ek_124">onDestroy()</code>. Удаляются все ViewModel-и которые ViewModelStore хранить в себе.</p></li></ol><p id="wrb7ek_83">Мы определили, что ViewModelStoreOwner &mdash; это всего лишь интерфейс, не содержащий собственной логики. Его реализуют такие компоненты, как:</p><ul class="list _bullet" id="wrb7ek_84"><li class="list__item" id="wrb7ek_125"><p id="wrb7ek_128"><span class="control" id="wrb7ek_129"><code class="code" id="wrb7ek_131">ComponentActivity</code></span> (<span class="emphasis" id="wrb7ek_130">и его наследники: <code class="code" id="wrb7ek_132">FragmentActivity, AppCompatActivity</code></span>)</p></li><li class="list__item" id="wrb7ek_126"><p id="wrb7ek_133"><span class="control" id="wrb7ek_134"><code class="code" id="wrb7ek_136">Fragment</code></span> (<span class="emphasis" id="wrb7ek_135">и его производные: <code class="code" id="wrb7ek_137">DialogFragment</code>, <code class="code" id="wrb7ek_138">BottomSheetDialogFragment</code>, <code class="code" id="wrb7ek_139">AppCompatDialogFragment</code></span>).</p></li><li class="list__item" id="wrb7ek_127"><p id="wrb7ek_140"><span class="control" id="wrb7ek_141"><code class="code" id="wrb7ek_142">NavBackStackEntry</code></span> - Класс из библиотеки Jetpack Navigation (он же androidx navigation)</p></li></ul><p id="wrb7ek_86">Далее нас уже интересует сам ViewModelStore:</p><p id="wrb7ek_87">ViewModelStore &mdash; это класс, который внутри себя делегирует управление коллекцией Map (LinkedHashMap) для хранения ViewModel по ключу:</p><div class="code-block" data-lang="kotlin">
private val map = mutableMapOf&lt;String, ViewModel&gt;()
</div><p id="wrb7ek_89">По умолчанию в качестве ключа используется полное имя класса (включая его пакет). Этот ключ генерируется следующим образом в исходниках утилитного класса ViewModelProviders (не путать с ViewModelProvider):</p><div class="code-block" data-lang="kotlin">
private const val VIEW_MODEL_PROVIDER_DEFAULT_KEY: String = &quot;androidx.lifecycle.ViewModelProvider.DefaultKey&quot;

internal fun &lt;T : ViewModel&gt; getDefaultKey(modelClass: KClass&lt;T&gt;): String {
    return &quot;$VIEW_MODEL_PROVIDER_DEFAULT_KEY:$modelClass.canonicalName&quot;
}
</div><p id="wrb7ek_91">Таким образом, для MyViewModel ключ будет выглядеть так: <span class="emphasis" id="wrb7ek_143"><code class="code" id="wrb7ek_144">androidx.lifecycle.ViewModelProvider.DefaultKey:com.example.MyViewModel</code></span>.</p><p id="wrb7ek_92">Поскольку ViewModelStore основан на <code class="code" id="wrb7ek_145">Map</code>, он делегирует все основные операции, такие как <code class="code" id="wrb7ek_146">put, get, keys и clear</code>, внутреннему Map (<span class="emphasis" id="wrb7ek_147">LinkedHashMap</span>).</p><p id="wrb7ek_93">Соответственно, так как внутренняя реализация <code class="code" id="wrb7ek_148">ViewModelStore</code> полагается на Map, он также делегирует свои методы <code class="code" id="wrb7ek_149">put</code>, <code class="code" id="wrb7ek_150">get</code>, <code class="code" id="wrb7ek_151">key</code>, <code class="code" id="wrb7ek_152">clear</code> внутреннему <code class="code" id="wrb7ek_153">Map</code> (<span class="emphasis" id="wrb7ek_154">LinkedHashMap</span>). Особого внимания заслуживает метод <code class="code" id="wrb7ek_155">clear()</code>:</p><div class="code-block" data-lang="kotlin">
public open class ViewModelStore {

    private val map = mutableMapOf&lt;String, ViewModel&gt;()
    ...
    /**
     * Clears internal storage and notifies `ViewModel`s that they are no longer used.
     */
    public fun clear() {
        for (vm in map.values) {
            vm.clear()
        }
        map.clear()
    }
}
</div><p id="wrb7ek_95">Давайте разберёмся, что здесь происходит. Когда наш <code class="code" id="wrb7ek_156">ViewModelStoreOwner</code> (в лице <code class="code" id="wrb7ek_157">ComponentActivity</code> или <code class="code" id="wrb7ek_158">Fragment</code>) окончательно умирает (смерть не связана с пересозданием из-за изменения конфигураций), он вызывает метод <code class="code" id="wrb7ek_159">clear()</code> у <code class="code" id="wrb7ek_160">ViewModelStore</code>.</p><p id="wrb7ek_96">В методе <code class="code" id="wrb7ek_161">clear()</code> цикл <code class="code" id="wrb7ek_162">for</code> проходит по всем значениям (<code class="code" id="wrb7ek_163">view models</code>), которые хранятся внутри внутреннего <code class="code" id="wrb7ek_164">HashMap</code>, и вызывает у каждой <code class="code" id="wrb7ek_165">ViewModel</code> внутренний метод <code class="code" id="wrb7ek_166">clear()</code>. Этот метод, в свою очередь, инициирует вызов метода <code class="code" id="wrb7ek_167">onCleared()</code> у нашей <code class="code" id="wrb7ek_168">ViewModel</code>.</p><p id="wrb7ek_97"><code class="code" id="wrb7ek_169">onCleared()</code> &mdash; это метод, который мы можем переопределить в своей <code class="code" id="wrb7ek_170">ViewModel</code>, и он вызывается только в момент окончательного уничтожения <code class="code" id="wrb7ek_171">ViewModel</code>, когда активити или фрагмент также окончательно завершают свою работу.</p><div class="code-block" data-lang="kotlin">
public actual abstract class ViewModel {
    ...
    protected actual open fun onCleared() {} // &lt;- метод onCleared, который можно переопределить

    @MainThread
    internal actual fun clear() {
        impl?.clear()
        onCleared() // &lt;- вызов метода onCleared
    }
}
</div><p id="wrb7ek_99">Таким образом, метод <code class="code" id="wrb7ek_172">clear()</code> гарантирует, что все ресурсы и фоновые задачи, связанные с <code class="code" id="wrb7ek_173">ViewModel</code>, будут корректно освобождены перед уничтожением. Соответственно, сам метод <code class="code" id="wrb7ek_174">viewModelStore.clear()</code> вызывается <code class="code" id="wrb7ek_175">ViewModelStoreOwner</code> (в лице <code class="code" id="wrb7ek_176">ComponentActivity</code> или <code class="code" id="wrb7ek_177">Fragment</code>). <br> Давайте в качестве примера выберем <code class="code" id="wrb7ek_179">ComponentActivity</code>, чтобы понять, как работает очистка.</p><p id="wrb7ek_100">Ниже приведён фрагмент кода из <code class="code" id="wrb7ek_180">ComponentActivity</code>, который отслеживает её уничтожение и вызывает <code class="code" id="wrb7ek_181">viewModelStore.clear()</code>:</p><div class="code-block" data-lang="kotlin">
@Suppress(&quot;LeakingThis&quot;)
lifecycle.addObserver(
    LifecycleEventObserver { _, event -&gt;
        if (event == Lifecycle.Event.ON_DESTROY) { // &lt;- состояние ON_DESTROY является триггером
            // Clear out the available context
            contextAwareHelper.clearAvailableContext()
            // And clear the ViewModelStore 
            if (!isChangingConfigurations) { // &lt;- проверка на то можно ли очищать ViewModelStore
                viewModelStore.clear()      // &lt;- очистка ViewModelStore
            }
            reportFullyDrawnExecutor.activityDestroyed()
        }
    }
)
</div><p id="wrb7ek_102">В данном коде происходит добавление наблюдателя на жизненный цикл активности с использованием <code class="code" id="wrb7ek_182">LifecycleEventObserver</code>. Когда активность достигает состояния <code class="code" id="wrb7ek_183">ON_DESTROY</code>, запускается проверка, не происходит ли изменение конфигурации (<code class="code" id="wrb7ek_184">isChangingConfigurations</code>). Если активность действительно умирает окончательно (и не пересоздаётся), вызывается метод <code class="code" id="wrb7ek_185">viewModelStore.clear()</code>, который очищает все связанные с активностью <code class="code" id="wrb7ek_186">ViewModel</code>.</p><p id="wrb7ek_103">Мы видим, что проверка состояния <code class="code" id="wrb7ek_187">ON_DESTROY</code> в сочетании с условием if (!isChangingConfigurations) позволяет убедиться в том, что причиной уничтожения не является изменение конфигурации. Только в этом случае очищается ViewModelStore и удаляются все экземпляры ViewModel, связанные с данной активностью.</p><aside class="prompt" data-type="tip" data-title="" id="wrb7ek_104"><p id="wrb7ek_188">В этой статье мы подробно разбираем внутренние методы класса <code class="code" id="wrb7ek_190">ComponentActivity</code>, начиная с версии <a href="https://developer.android.com/jetpack/androidx/releases/activity#1.9.0-alpha01" id="wrb7ek_191" data-external="true" rel="noopener noreferrer" target="_blank">**androidx.activity:activity:1.9.0-alpha01 **</a>, когда он был переписан на Kotlin.</p><p id="wrb7ek_189">Если у вас установлена более старая версия библиотеки, и вы видите реализацию на Java &mdash; не переживайте. Логика и основные методы остались прежними, поэтому все представленные концепции и объяснения будут актуальны.</p></aside><section class="procedure-steps"><h3 id="example-procedure" data-toc="example-procedure">Процесс очистки ViewModel при уничтожении активности:</h3><ul class="list _bullet"><li class="list__item" id="wrb7ek_193"><p>Уничтожение Activity (не связано с изменением конфигураций) <code class="code" id="wrb7ek_194">ComponentActivity.onDestroy()</code> <span class="control" id="wrb7ek_195">-&gt;</span> Очистка ViewModelStore <code class="code" id="wrb7ek_196">getViewModelStore().clear()</code> <span class="control" id="wrb7ek_197">-&gt;</span> Оповещение ViewModel <code class="code" id="wrb7ek_198">MyViewModel.onCleared()</code></p></li></ul></section><p id="wrb7ek_106">Теперь мы разобрались с процессом очистки и уничтожения <code class="code" id="wrb7ek_199">ViewModel</code>. <br> Перейдём к следующему этапу &mdash; рассмотрим подробнее, как происходит создание объекта <code class="code" id="wrb7ek_201">ViewModel</code>, когда мы передаём её в <code class="code" id="wrb7ek_202">ViewModelProvider</code>:</p><div class="code-block" data-lang="kotlin">
ViewModelProvider.create(owner = this).get(MyViewModel::class)
</div><p id="wrb7ek_108">Да, можно уточнить, что <code class="code" id="wrb7ek_203">ViewModelProvider.create</code> &mdash; это функция с значениями по умолчанию. Например:</p><div class="code-block" data-lang="kotlin">
ViewModelProvider.create(owner = this).get(MyViewModel::class)
</div><p id="wrb7ek_110">Ранее мы разобрали один из перегруженных методов <code class="code" id="wrb7ek_204">ViewModelProvider.create</code> (функция с аргументами по умолчанию). Это фабричный метод, который принимает минимум <code class="code" id="wrb7ek_205">ViewModelStore</code> или <code class="code" id="wrb7ek_206">ViewModelStoreOwner</code>, создаёт объект<code class="code" id="wrb7ek_207">ViewModelProvider</code> и на этом завершает свою работу.</p><p id="wrb7ek_111">Теперь нас интересует следующий ключевой метод &mdash; <code class="code" id="wrb7ek_208">get</code>, который принимает класс <code class="code" id="wrb7ek_209">ViewModel</code> в качестве параметра. <code class="code" id="wrb7ek_210">ViewModelProvider</code> делегирует свою работу классу <code class="code" id="wrb7ek_211">ViewModelProviderImpl</code>:</p><div class="code-block" data-lang="kotlin">
public actual open class ViewModelProvider private constructor(
    private val impl: ViewModelProviderImpl,
) {
    ...
    @MainThread
    public actual operator fun &lt;T : ViewModel&gt; get(modelClass: KClass&lt;T&gt;): T =
        impl.getViewModel(modelClass) // &lt;- вызов метода getViewModel, принадлежащий ViewModelProviderImpl
}
</div><aside class="prompt" data-type="tip" data-title="" id="wrb7ek_113"><p>Разработчики Google вынесли общую логику создания ViewModel в отдельный объект ViewModelProviderImpl. Это позволило избежать дублирования кода на разных платформах в KMP. Причина в том, что expect-классы в Kotlin Multiplatform не могут содержать реализации методов по умолчанию. Если бы они могли, реализация находилась бы прямо внутри expect-версии ViewModelProvider, без необходимости выносить её в отдельный объект. Однако, из-за этого ограничения, была создана ViewModelProviderImpl, которая содержит общую логику создания ViewModel для всех платформ. </p><p id="wrb7ek_212"><span class="control" id="wrb7ek_214">Оригинальный комментарий:</span></p><p id="wrb7ek_213"><span class="emphasis" id="wrb7ek_215">Kotlin Multiplatform does not support expect class with default implementation yet, so we extracted the common logic used by all platforms to this internal class.</span></p></aside><p id="wrb7ek_114">Исходники метода <code class="code" id="wrb7ek_216">getViewModel()</code> в <code class="code" id="wrb7ek_217">ViewModelProviderImpl.kt</code>:</p><div class="code-block" data-lang="kotlin">
internal fun &lt;T : ViewModel&gt; getViewModel(
    modelClass: KClass&lt;T&gt;,
    key: String = ViewModelProviders.getDefaultKey(modelClass),
): T {
    val viewModel = store[key] // 1. Достается viewmodel из ViewModelStore, если он существует
    if (modelClass.isInstance(viewModel)) {
        if (factory is ViewModelProvider.OnRequeryFactory) {
            factory.onRequery(viewModel!!)
        }
        return viewModel as T
    }

    val extras = MutableCreationExtras(extras)
    extras[ViewModelProviders.ViewModelKey] = key
    // 2. Создается viewmodel и кладется в ViewModelStore
    return createViewModel(factory, modelClass, extras).also { vm -&gt; store.put(key, vm) }
}
</div><p id="wrb7ek_116">При вызове <code class="code" id="wrb7ek_218">ViewModelProvider.create()</code> под капотом вызывается метод <code class="code" id="wrb7ek_219">getViewModel()</code>, который выполняет следующие шаги:</p><ol class="list _decimal" id="wrb7ek_117" type="1"><li class="list__item" id="wrb7ek_220"><p id="wrb7ek_222">Проверяет наличие объекта <code class="code" id="wrb7ek_223">ViewModel</code> в <code class="code" id="wrb7ek_224">ViewModelStore</code> по заданному ключу. Если объект уже существует, он возвращается.</p></li><li class="list__item" id="wrb7ek_221"><p id="wrb7ek_225">Если объект не найден, создаётся новый экземпляр <code class="code" id="wrb7ek_226">ViewModel</code>, который затем кладётся в <code class="code" id="wrb7ek_227">ViewModelStore</code> для последующего использования.</p></li></ol></section></section><section class="chapter"><h2 id="321" data-toc="321">Где ViewModelStore сохраняется?</h2><p id="wrb7ek_228">Теперь, когда мы знаем полный процесс создания <code class="code" id="wrb7ek_271">ViewModel</code> и её размещения в <code class="code" id="wrb7ek_272">ViewModelStore</code>, возникает логичный вопрос: если все <code class="code" id="wrb7ek_273">ViewModel</code>-и хранятся внутри <code class="code" id="wrb7ek_274">ViewModelStore</code>, а сам <code class="code" id="wrb7ek_275">ViewModelStore</code> находится в <code class="code" id="wrb7ek_276">ComponentActivity</code> или <code class="code" id="wrb7ek_277">Fragment</code>, которые реализуют интерфейс <code class="code" id="wrb7ek_278">ViewModelStoreOwner</code>, то где и как хранится сам объект <code class="code" id="wrb7ek_279">ViewModelStore</code>?</p><p id="wrb7ek_229">Для того чтобы найти ответ на вопрос о хранении <code class="code" id="wrb7ek_280">ViewModelStore</code>, давайте посмотрим, как <code class="code" id="wrb7ek_281">ComponentActivity</code> реализует интерфейс <code class="code" id="wrb7ek_282">ViewModelStoreOwner</code>:</p><div class="code-block" data-lang="kotlin">
override val viewModelStore: ViewModelStore
get() {
    checkNotNull(application) {
        (&quot;Your activity is not yet attached to the &quot; +
                &quot;Application instance. You can't request ViewModel before onCreate call.&quot;)
    }
    ensureViewModelStore()
    return _viewModelStore!!
}
</div><p id="wrb7ek_231">Мы видим, что вызывается метод <code class="code" id="wrb7ek_283">ensureViewModelStore</code>, а затем возвращается поле <code class="code" id="wrb7ek_284">_viewModelStore</code>.</p><div class="code-block" data-lang="kotlin">
// Lazily recreated from NonConfigurationInstances by val viewModelStore
private var _viewModelStore: ViewModelStore? = null
</div><p id="wrb7ek_233">Поле <code class="code" id="wrb7ek_285">_viewModelStore</code> не имеет значения по умолчанию, поэтому перед возвратом оно инициализируется внутри метода <code class="code" id="wrb7ek_286">ensureViewModelStore</code>:</p><div class="code-block" data-lang="kotlin">
private fun ensureViewModelStore() {
    if (_viewModelStore == null) {
        // Извлекается ComponentActivity#NonConfigurationInstances из метода Activity#getLastNonConfigurationInstance()
        val nc = lastNonConfigurationInstance as NonConfigurationInstances?
        if (nc != null) {
            // Восстанавливается ViewModelStore из NonConfigurationInstances
            _viewModelStore = nc.viewModelStore
        }
        if (_viewModelStore == null) {
            // Создается ViewModelStore если нет сохраненного внутри объекта NonConfigurationInstances
            _viewModelStore = ViewModelStore()
        }
    }
}
</div><p id="wrb7ek_235">Тут-то и начинается самое интересное. Если поле <code class="code" id="wrb7ek_287">_viewModelStore</code> равно <code class="code" id="wrb7ek_288">null</code>, сначала выполняется попытка получить его из метода <code class="code" id="wrb7ek_289">getLastNonConfigurationInstance()</code>, который возвращает объект класса <code class="code" id="wrb7ek_290">NonConfigurationInstances</code>.</p><p id="wrb7ek_236">Если <code class="code" id="wrb7ek_291">ViewModelStore</code> отсутствует и там, это может означать одно из двух:</p><ol class="list _decimal" id="wrb7ek_237" type="1"><li class="list__item" id="wrb7ek_292"><p id="wrb7ek_294">Активность создаётся впервые и у неё ещё нет сохранённого <code class="code" id="wrb7ek_295">ViewModelStore</code>.</p></li><li class="list__item" id="wrb7ek_293"><p id="wrb7ek_296">Система уничтожила процесс приложения (например, из-за нехватки памяти), а затем пользователь снова запустил приложение, из-за чего <code class="code" id="wrb7ek_297">ViewModelStore</code> не сохранился.</p></li></ol><p id="wrb7ek_238">В любом из этих случаев создаётся новый экземпляр <code class="code" id="wrb7ek_298">ViewModelStore</code>.</p><p id="wrb7ek_239">Самая неочевидная часть &mdash; это вызов метода <code class="code" id="wrb7ek_299">getLastNonConfigurationInstance()</code>. Этот метод принадлежит классу<code class="code" id="wrb7ek_300">Activity</code>, а класс <code class="code" id="wrb7ek_301">NonConfigurationInstances</code>, у которого даже само название выглядит интригующе, объявлен в<code class="code" id="wrb7ek_302">ComponentActivity</code>:</p><div class="code-block" data-lang="kotlin">
internal class NonConfigurationInstances {
    var custom: Any? = null
    var viewModelStore: ViewModelStore? = null
}
</div><p id="wrb7ek_241">Таким образом, объект <code class="code" id="wrb7ek_303">NonConfigurationInstances</code> используется для хранения <code class="code" id="wrb7ek_304">ViewModelStore</code> при изменении конфигурации активности. Это позволяет сохранить состояние <code class="code" id="wrb7ek_305">ViewModel</code> и восстановить его после пересоздания активности.</p><p id="wrb7ek_242">Переменная <code class="code" id="wrb7ek_306">custom</code> по умолчанию имеет значение <code class="code" id="wrb7ek_307">null</code> и фактически не используется, поскольку <code class="code" id="wrb7ek_308">ViewModelStore</code> более гибко выполняет всю работу по сохранению состояний для переживания изменений конфигураций. Тем не менее, переменную <code class="code" id="wrb7ek_309">custom</code> можно задействовать, переопределив такие функции, как <code class="code" id="wrb7ek_310">onRetainCustomNonConfigurationInstance</code> и <code class="code" id="wrb7ek_311">getLastCustomNonConfigurationInstance</code>. До появления <code class="code" id="wrb7ek_312">ViewModel</code> многие разработчики активно использовали(в 2012) именно её для сохранения данных при пересоздании активности когда менялась конфигурация.</p><p id="wrb7ek_243">Переменная <code class="code" id="wrb7ek_313">viewModelStore</code> имеет тип <code class="code" id="wrb7ek_314">ViewModelStore</code> и хранит ссылку на наш объект <code class="code" id="wrb7ek_315">ViewModelStore</code>. Значение в эту переменную <code class="code" id="wrb7ek_316">NonConfigurationInstances#viewModelStore</code> присваивается при вызове метода<code class="code" id="wrb7ek_317">onRetainNonConfigurationInstance</code>, а извлекается при вызове <code class="code" id="wrb7ek_318">getLastNonConfigurationInstance</code> (с этим методом мы уже столкнулись выше в методе <code class="code" id="wrb7ek_319">ensureViewModelStore</code>).</p><p id="wrb7ek_245">Разобравшись с классом <code class="code" id="wrb7ek_320">NonConfigurationInstances</code>, давайте выясним, где создаётся объект этого класса и каким образом в поле <code class="code" id="wrb7ek_321">viewModelStore</code> присваивается значение. <br> Для этого обратимся к методам <code class="code" id="wrb7ek_323">onRetainNonConfigurationInstance</code> и <code class="code" id="wrb7ek_324">getLastNonConfigurationInstance</code>, которые присутствуют в <code class="code" id="wrb7ek_325">Activity</code> и <code class="code" id="wrb7ek_326">ComponentActivity</code>. <br> Исходники метода в <code class="code" id="wrb7ek_328">ComponentActivity</code> выглядят следующим образом:</p><div class="code-block" data-lang="kotlin">
@Suppress(&quot;deprecation&quot;)
final override fun onRetainNonConfigurationInstance(): Any? {
    // Maintain backward compatibility.
    val custom = onRetainCustomNonConfigurationInstance()
    var viewModelStore = _viewModelStore
    if (viewModelStore == null) {
        // No one called getViewModelStore(), so see if there was an existing
        // ViewModelStore from our last NonConfigurationInstance
        val nc = lastNonConfigurationInstance as NonConfigurationInstances?
        if (nc != null) {
            viewModelStore = nc.viewModelStore
        }
    }
    if (viewModelStore == null &amp;&amp; custom == null) {
        return null
    }
    val nci = NonConfigurationInstances()
    nci.custom = custom
    nci.viewModelStore = viewModelStore
    return nci
}
</div><p id="wrb7ek_247">Метод <code class="code" id="wrb7ek_329">onRetainNonConfigurationInstance()</code> возвращает объект <code class="code" id="wrb7ek_330">NonConfigurationInstances</code>, содержащий ссылку на ранее созданный <code class="code" id="wrb7ek_331">ViewModelStore</code>.</p><p id="wrb7ek_248">Таким образом, при уничтожении активности (например, при повороте экрана) вызывается этот метод, и <code class="code" id="wrb7ek_332">ViewModelStore</code> сохраняется в экземпляре <code class="code" id="wrb7ek_333">NonConfigurationInstances</code>. <br> Когда активность пересоздаётся, объект <code class="code" id="wrb7ek_335">NonConfigurationInstances</code> восстанавливается через вызов метода <code class="code" id="wrb7ek_336">getLastNonConfigurationInstance()</code>, и из него извлекается сохранённый <code class="code" id="wrb7ek_337">ViewModelStore</code>.</p><p id="wrb7ek_249">В методе <code class="code" id="wrb7ek_338">onRetainNonConfigurationInstance</code> реализована логика получения уже существующего <code class="code" id="wrb7ek_339">ViewModelStore</code> и объекта <code class="code" id="wrb7ek_340">Custom</code> (если он есть). После получения этих объектов они кладутся в экземпляр класса <code class="code" id="wrb7ek_341">NonConfigurationInstances</code>, который затем возвращается из метода.</p><p id="wrb7ek_250">Метод <code class="code" id="wrb7ek_342">onRetainNonConfigurationInstance</code> создаёт объект класса <code class="code" id="wrb7ek_343">NonConfigurationInstances</code>, помещает внутрь <code class="code" id="wrb7ek_344">viewModelStore</code> и кастомный объект, а затем возвращает его. Возникает вопрос: кто именно вызывает этот метод?</p><p id="wrb7ek_252">Вызывающий метод внутри самого класса Activity(самый базовый Activity от которого наследуются все остальные):</p><div class="code-block" data-lang="java">
NonConfigurationInstances retainNonConfigurationInstances() {
    Object activity = onRetainNonConfigurationInstance(); // &lt;- вызов onRetainNonConfigurationInstance()

    //...code

    NonConfigurationInstances nci = new NonConfigurationInstances();
    nci.activity = activity; // &lt;- присвоение извлеченного объекта из onRetainNonConfigurationInstance()
    nci.children = children;
    nci.fragments = fragments;
    nci.loaders = loaders;
    if (mVoiceInteractor != null) {
        mVoiceInteractor.retainInstance();
        nci.voiceInteractor = mVoiceInteractor;
    }
    return nci;
}
</div><p id="wrb7ek_254">Как видно, сам класс <code class="code" id="wrb7ek_345">Activity</code> вызывает метод <code class="code" id="wrb7ek_346">onRetainNonConfigurationInstance</code> с которым мы ранее познакомились и сохраняет результат в поле<code class="code" id="wrb7ek_347">activity</code> класса <code class="code" id="wrb7ek_348">NonConfigurationInstances</code>. При этом мы снова сталкиваемся с классом <code class="code" id="wrb7ek_349">NonConfigurationInstances</code>, но на этот раз он объявлен в самой <code class="code" id="wrb7ek_350">Activity</code> и имеет дополнительные поля:</p><div class="code-block" data-lang="java">
static final class NonConfigurationInstances {
    Object activity; // &lt;- Здесь и будет храниться ComponentActivity.NonConfigurationInstances
    HashMap&lt;String, Object&gt; children;
    FragmentManagerNonConfig fragments;
    ArrayMap&lt;String, LoaderManager&gt; loaders;
    VoiceInteractor voiceInteractor;
}
</div><p id="wrb7ek_257">Чтобы устранить путаницу:</p><ul class="list _bullet" id="wrb7ek_258"><li class="list__item" id="wrb7ek_351"><p id="wrb7ek_354">Объект <code class="code" id="wrb7ek_355">ViewModelStore</code> хранится внутри <code class="code" id="wrb7ek_356">ComponentActivity#NonConfigurationInstances</code>.</p></li><li class="list__item" id="wrb7ek_352"><p id="wrb7ek_357">Сам объект <code class="code" id="wrb7ek_358">ComponentActivity#NonConfigurationInstances</code> хранится в <code class="code" id="wrb7ek_359">Activity#NonConfigurationInstance</code>.</p></li><li class="list__item" id="wrb7ek_353"><p id="wrb7ek_360">Это достигается через метод <code class="code" id="wrb7ek_361">retainNonConfigurationInstances()</code> класса <code class="code" id="wrb7ek_362">Activity</code>.</p></li></ul><p id="wrb7ek_259">Но кто же вызывает метод <code class="code" id="wrb7ek_363">retainNonConfigurationInstances</code> () и где хранится конечный объект <code class="code" id="wrb7ek_364">Activity#NonConfigurationInstance</code>, который содержит <code class="code" id="wrb7ek_365">ViewModelStore</code>?</p><p id="wrb7ek_260">Ответ на этот вопрос кроется в классе <code class="code" id="wrb7ek_366">ActivityThread</code>, который отвечает за управление жизненным циклом активностей и их взаимодействие с системой. Именно этот класс обрабатывает создание, уничтожение и повторное создание активности, а также отвечает за сохранение и восстановление данных при изменениях конфигурации.</p><p id="wrb7ek_261">Метод из <code class="code" id="wrb7ek_367">ActivityThread</code>, который непосредственно вызывает <code class="code" id="wrb7ek_368">Activity.retainNonConfigurationInstances()</code>, называется <code class="code" id="wrb7ek_369">ActivityThread.performDestroyActivity()</code>.</p><p id="wrb7ek_262">Рассмотрим его исходники в классе <code class="code" id="wrb7ek_370">ActivityThread</code>, далее исходники:</p><div class="code-block" data-lang="java">
void performDestroyActivity(ActivityClientRecord r, boolean finishing,
                            boolean getNonConfigInstance, String reason) {
    //...
    if (getNonConfigInstance) {
        try {
            // Вызов Activity.retainNonConfigurationInstances() 
            // и сохранение в r.lastNonConfigurationInstances
            r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();
        } catch (Exception e) {
            if (!mInstrumentation.onException(r.activity, e)) {
                throw new RuntimeException(&quot;Unable to retain activity &quot;
                        + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e);
            }
        }
    }
    //...
}
</div><aside class="prompt" data-type="note" data-title="" id="wrb7ek_264"><p>Чтобы найти исходники `ActivityThread`, достаточно в Android Studio воспользоваться поиском по имени класса: `ActivityThread`. Или зайти в исходники Android по одной из ссылок: </p><ul class="list _bullet" id="wrb7ek_371"><li class="list__item" id="wrb7ek_372"><p id="wrb7ek_374"><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/app/ActivityThread.java" id="wrb7ek_375" data-external="true" rel="noopener noreferrer" target="_blank">Android Source (cs.android.com)</a></p></li><li class="list__item" id="wrb7ek_373"><p id="wrb7ek_376"><a href="https://android.googlesource.com/platform/frameworks/base/+/0e40462e11d27eb859b829b112cecb8c6f0d7afb/core/java/android/app/ActivityThread.java" id="wrb7ek_377" data-external="true" rel="noopener noreferrer" target="_blank">Android Google Source (googlesource.com)</a></p></li></ul></aside><p id="wrb7ek_265">После вызова метода <code class="code" id="wrb7ek_378">retainNonConfigurationInstances()</code> результат сохраняется в поле <code class="code" id="wrb7ek_379">lastNonConfigurationInstances</code> объекта <code class="code" id="wrb7ek_380">ActivityClientRecord</code>:</p><div class="code-block" data-lang="kotlin">
r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();
</div><p id="wrb7ek_267">Класс <code class="code" id="wrb7ek_381">ActivityClientRecord</code> представляет собой запись активности и используется для хранения всей информации, связанной с реальным экземпляром активности. <br> Это своего рода структура данных для ведения учета активности в процессе выполнения приложения.</p><section class="chapter"><h3 id="activityclientrecord" data-toc="activityclientrecord">Основные поля класса <code class="code" id="wrb7ek_403">ActivityClientRecord</code>:</h3><ul class="list _bullet" id="wrb7ek_384"><li class="list__item" id="wrb7ek_404"><p id="wrb7ek_412"><code class="code" id="wrb7ek_413">lastNonConfigurationInstances</code> &mdash; объект <code class="code" id="wrb7ek_414">Activity#NonConfigurationInstance</code>, в котором хранится <code class="code" id="wrb7ek_415">ComponentActivity#NonConfigurationInstances</code> в котором хранится<code class="code" id="wrb7ek_416">ViewModelStore</code>.</p></li><li class="list__item" id="wrb7ek_405"><p id="wrb7ek_417"><code class="code" id="wrb7ek_418">state</code> &mdash; объект <code class="code" id="wrb7ek_419">Bundle</code>, содержащий сохраненное состояние активности. Да, да, это тот самый Bundle который мы получаем в методе <code class="code" id="wrb7ek_420">onCreate</code>, <code class="code" id="wrb7ek_421">onRestoreInstanceState</code> и <code class="code" id="wrb7ek_422">onSaveInstanceState</code></p></li><li class="list__item" id="wrb7ek_406"><p id="wrb7ek_423"><code class="code" id="wrb7ek_424">intent</code> &mdash; объект <code class="code" id="wrb7ek_425">Intent</code>, представляющий намерение запуска активности.</p></li><li class="list__item" id="wrb7ek_407"><p id="wrb7ek_426"><code class="code" id="wrb7ek_427">window</code> &mdash; объект <code class="code" id="wrb7ek_428">Window</code>, связанный с активностью.</p></li><li class="list__item" id="wrb7ek_408"><p id="wrb7ek_429"><code class="code" id="wrb7ek_430">activity</code> &mdash; сам объект <code class="code" id="wrb7ek_431">Activity</code>.</p></li><li class="list__item" id="wrb7ek_409"><p id="wrb7ek_432"><code class="code" id="wrb7ek_433">parent</code> &mdash; родительская активность (если есть).</p></li><li class="list__item" id="wrb7ek_410"><p id="wrb7ek_434"><code class="code" id="wrb7ek_435">createdConfig</code> &mdash; объект <code class="code" id="wrb7ek_436">Configuration</code>, содержащий настройки, примененные при создании активности.</p></li><li class="list__item" id="wrb7ek_411"><p id="wrb7ek_437"><code class="code" id="wrb7ek_438">overrideConfig</code> &mdash; объект <code class="code" id="wrb7ek_439">Configuration</code>, содержащий текущие настройки активности.</p></li></ul><p id="wrb7ek_385">В рамках данной статьи нас интересует только поле <code class="code" id="wrb7ek_440">lastNonConfigurationInstances</code>, так как именно оно связано с хранением и восстановлением <code class="code" id="wrb7ek_441">ViewModelStore</code>.</p><p id="wrb7ek_387">Теперь давайте разберемся, как вызывается метод <code class="code" id="wrb7ek_442">performDestroyActivity()</code> в рамках системного вызова.</p><p id="wrb7ek_388">Последовательность вызовов:</p><ol class="list _decimal" id="wrb7ek_389" type="1"><li class="list__item" id="wrb7ek_443"><p id="wrb7ek_449"><code class="code" id="wrb7ek_450">ActivityTransactionItem.execute()</code></p></li><li class="list__item" id="wrb7ek_444"><p id="wrb7ek_451"><code class="code" id="wrb7ek_452">ActivityRelaunchItem.execute()</code></p></li><li class="list__item" id="wrb7ek_445"><p id="wrb7ek_453"><code class="code" id="wrb7ek_454">ActivityThread.handleRelaunchActivity()</code></p></li><li class="list__item" id="wrb7ek_446"><p id="wrb7ek_455"><code class="code" id="wrb7ek_456">ActivityThread.handleRelaunchActivityInner()</code></p></li><li class="list__item" id="wrb7ek_447"><p id="wrb7ek_457"><code class="code" id="wrb7ek_458">ActivityThread.handleDestroyActivity()</code></p></li><li class="list__item" id="wrb7ek_448"><p id="wrb7ek_459"><code class="code" id="wrb7ek_460">ActivityThread.performDestroyActivity()</code></p></li></ol><aside class="prompt" data-type="note" data-title="" id="wrb7ek_390"><p>Важно понимать, что на более высоком уровне в этой цепочке стоят такие классы, как ClientTransactionItem, ClientTransaction и ClientLifecycleManager, а еще выше &mdash; сама система, которая управляет взаимодействием устройства с сенсорами и другими компонентами. Однако, углубляться дальше в эту цепочку мы не будем, так как всего через пару слоев окажемся на уровне межпроцессного взаимодействия (IPC) и работы системы с процессами.</p></aside><p id="wrb7ek_391">На вершине вызовов находится метод <code class="code" id="wrb7ek_461">ActivityTransactionItem.execute()</code>, который запускает цепочку: сначала вызывает <code class="code" id="wrb7ek_462">getActivityClientRecord()</code>, а затем тот вызывает <code class="code" id="wrb7ek_463">ClientTransactionHandler.getActivityClient()</code>.</p><div class="code-block" data-lang="java">
public abstract class ActivityTransactionItem extends ClientTransactionItem {
    @Override
    public final void execute(ClientTransactionHandler client, IBinder token,
                              PendingTransactionActions pendingActions) {
        final ActivityClientRecord r = getActivityClientRecord(client, token); // &lt;- Вызов getActivityClientRecord

        execute(client, r, pendingActions);
    }

    @NonNull
    ActivityClientRecord getActivityClientRecord(
            @NonNull ClientTransactionHandler client, IBinder token) {
        final ActivityClientRecord r = client.getActivityClient(token); // &lt;- получение клиент от ClientTransactionHandler(ActivityThread)
        ...
        return r;
    }
}
</div><p id="wrb7ek_393"><code class="code" id="wrb7ek_464">ClientTransactionHandler</code> &mdash; это абстрактный класс, и одна из его реализаций &mdash; класс <code class="code" id="wrb7ek_465">ActivityThread</code>, с которым мы уже успели познакомиться.</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler
        implements ActivityThreadInternal {
   ...

    @Override
    public ActivityClientRecord getActivityClient(IBinder token) {
        return mActivities.get(token); // &lt;- Возвращает из Map ActivityClientRecord по ключу
    }
   ...
}
</div><p id="wrb7ek_395">От ActivityTransactionItem - наследуется класс ActivityRelaunchItem, который и запускает у ActivityThread метод <code class="code" id="wrb7ek_466">handleRelaunchActivity</code>:</p><div class="code-block" data-lang="java">

public class ActivityRelaunchItem extends ActivityTransactionItem {

    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
        ...
    }
}
</div><p id="wrb7ek_397">Все запущенные активности внутри нашего приложения хранятся в коллекций Map в объекте класса <code class="code" id="wrb7ek_467">ActivityThread</code>:</p><div class="code-block" data-lang="java">
/**
 * Maps from activity token to local record of running activities in this process.
 * ....
 */
@UnsupportedAppUsage
final ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;();
</div><p id="wrb7ek_399">Таким образом, мы наконец выяснили, что наша <code class="code" id="wrb7ek_468">ViewModel</code> фактически хранится в объекте <code class="code" id="wrb7ek_469">ActivityThread</code>, который является синглтоном. Благодаря этому <code class="code" id="wrb7ek_470">ViewModel</code> не уничтожается при изменении конфигурации.</p><p id="wrb7ek_401"><span class="control" id="wrb7ek_471">Важно:</span> Экземпляр <code class="code" id="wrb7ek_472">ActivityThread</code> является синглтоном и существует на протяжении всего жизненного цикла процесса приложения. В методе <code class="code" id="wrb7ek_473">handleBindApplication()</code> внутри <code class="code" id="wrb7ek_474">ActivityThread</code> создается объект <code class="code" id="wrb7ek_475">Application</code>, который также живет до завершения процесса. Это означает, что <code class="code" id="wrb7ek_476">ActivityThread</code> и <code class="code" id="wrb7ek_477">Application</code> связаны общим жизненным циклом, за исключением того, что <code class="code" id="wrb7ek_478">ActivityThread</code> появляется раньше &mdash; еще до создания <code class="code" id="wrb7ek_479">Application</code> &mdash; и управляет его инициализацией.</p></section><section class="chapter"><h3 id="viewmodelstore" data-toc="viewmodelstore">Восстановление <code class="code" id="wrb7ek_487">ViewModelStore</code></h3><p id="wrb7ek_481">Исходя из того, что мы обнаружили ранее, цепочка хранения <code class="code" id="wrb7ek_488">ViewModel</code> выглядит следующим образом:</p><ol class="list _decimal" id="wrb7ek_482" type="1"><li class="list__item" id="wrb7ek_489"><p id="wrb7ek_494"><code class="code" id="wrb7ek_495">ViewModel</code> хранится внутри <code class="code" id="wrb7ek_496">ViewModelStore</code>.</p></li><li class="list__item" id="wrb7ek_490"><p id="wrb7ek_497"><code class="code" id="wrb7ek_498">ViewModelStore</code> хранится в <code class="code" id="wrb7ek_499">ComponentActivity#NonConfigurationInstances</code>.</p></li><li class="list__item" id="wrb7ek_491"><p id="wrb7ek_500"><code class="code" id="wrb7ek_501">ComponentActivity#NonConfigurationInstances</code> хранится в <code class="code" id="wrb7ek_502">Activity#NonConfigurationInstance</code>.</p></li><li class="list__item" id="wrb7ek_492"><p id="wrb7ek_503"><code class="code" id="wrb7ek_504">Activity#NonConfigurationInstance</code> хранится в <code class="code" id="wrb7ek_505">ActivityClientRecord</code>.</p></li><li class="list__item" id="wrb7ek_493"><p id="wrb7ek_506"><code class="code" id="wrb7ek_507">ActivityClientRecord</code> хранится в <code class="code" id="wrb7ek_508">ActivityThread</code>.</p></li></ol><p id="wrb7ek_483">При повторном создании <code class="code" id="wrb7ek_509">Activity</code> вызывается его метод <code class="code" id="wrb7ek_510">attach()</code>, одним из параметров которого является <code class="code" id="wrb7ek_511">Activity#NonConfigurationInstances</code>. Этот объект извлекается из связанного с <code class="code" id="wrb7ek_512">Activity</code> объекта <code class="code" id="wrb7ek_513">ActivityClientRecord</code>.</p><p id="wrb7ek_484">Когда у <code class="code" id="wrb7ek_514">Activity</code> меняется конфигурация, система сразу же перезапускает её, чтобы применить новые параметры. В этот момент <code class="code" id="wrb7ek_515">ActivityThread.java</code> мгновенно извлекает <code class="code" id="wrb7ek_516">ViewModelStore</code>, который хранится в <code class="code" id="wrb7ek_517">ComponentActivity#NonConfigurationInstances</code>. Этот объект, в свою очередь, находится внутри <code class="code" id="wrb7ek_518">Activity#NonConfigurationInstances</code>.</p><p id="wrb7ek_485">Далее <code class="code" id="wrb7ek_519">Activity#NonConfigurationInstances</code> сохраняется в <code class="code" id="wrb7ek_520">ActivityClientRecord</code>, связанном с пересоздаваемой <code class="code" id="wrb7ek_521">Activity</code>. Внутри <code class="code" id="wrb7ek_522">ActivityClientRecord</code> есть специальное поле <code class="code" id="wrb7ek_523">lastNonConfigurationInstances</code>, куда и помещается этот объект. Сам <code class="code" id="wrb7ek_524">ActivityClientRecord</code> хранится в Map-коллекции внутри <code class="code" id="wrb7ek_525">ActivityThread.java</code>, который является синглтоном в рамках процесса приложения и способен переживать изменения конфигурации.</p><p id="wrb7ek_486">После этого ActivityThread пересоздаёт Activity, применяя новые параметры конфигурации. При создании он передаёт в неё все сохранённые данные, включая <code class="code" id="wrb7ek_526">NonConfigurationInstances</code>, который, в конечном итоге, содержит <code class="code" id="wrb7ek_527">ViewModelStore</code>. А ViewModelStore, в свою очередь, хранит нашу ViewModel</p></section><section class="chapter"><h3 id="viewmodelstore_1" data-toc="viewmodelstore_1">Диаграмма вызовов при сохранении и восстановлении ViewModelStore</h3><p id="wrb7ek_528">Диаграмма ниже иллюстрирует цепочку вызовов. Ради упрощения некоторые детали опущены, а избыточные абстракции убраны:</p><svg aria-roledescription="flowchart-v2" role="graphics-document document" viewBox="0 0 2329.0234375 2428"  class="flowchart" xmlns="http://www.w3.org/2000/svg" width="2329.0234375" id="mermaid"><g><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointEnd"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 0 L 10 5 L 0 10 z"></path></marker><marker orient="auto" markerHeight="8" markerWidth="8" markerUnits="userSpaceOnUse" refY="5" refX="4.5" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-pointStart"><path style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 0 5 L 10 10 L 10 0 z"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="11" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleEnd"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5" refX="-1" viewBox="0 0 10 10" class="marker flowchart-v2" id="mermaid_flowchart-v2-circleStart"><circle style="stroke-width: 1; stroke-dasharray: 1, 0;" class="arrowMarkerPath" r="5" cy="5" cx="5"></circle></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="12" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossEnd"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><marker orient="auto" markerHeight="11" markerWidth="11" markerUnits="userSpaceOnUse" refY="5.2" refX="-1" viewBox="0 0 11 11" class="marker cross flowchart-v2" id="mermaid_flowchart-v2-crossStart"><path style="stroke-width: 2; stroke-dasharray: 1, 0;" class="arrowMarkerPath" d="M 1,1 l 9,9 M 10,1 l -9,9"></path></marker><g class="root"><g class="clusters"><g data-look="classic" id="ViewModelStore.kt" class="cluster"><rect height="152" width="330" y="2164" x="1234.4609375" style=""></rect><g transform="translate(1332.0234375, 2164)" class="cluster-label"><foreignObject height="24" width="134.875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ViewModelStore.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="Activity.java" class="cluster"><rect height="533" width="1526.609375" y="1249" x="8" style=""></rect><g transform="translate(726.4765625, 1249)" class="cluster-label"><foreignObject height="24" width="89.65625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Activity.java</p></span></div></foreignObject></g></g><g data-look="classic" id="ComponentActivity.kt" class="cluster"><rect height="282" width="1527.9765625" y="1832" x="140.640625" style=""></rect><g transform="translate(827.01953125, 1832)" class="cluster-label"><foreignObject height="24" width="155.21875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ComponentActivity.kt</p></span></div></foreignObject></g></g><g data-look="classic" id="ActivityClientRecord" class="cluster"><rect height="104" width="603.859375" y="1475" x="1717.1640625" style=""></rect><g transform="translate(1945.5546875, 1475)" class="cluster-label"><foreignObject height="24" width="147.078125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityClientRecord</p></span></div></foreignObject></g></g><g data-look="classic" id="s1" class="cluster"><rect height="513" width="628.0625" y="840" x="1554.609375" style=""></rect><g transform="translate(1797.6171875, 840)" class="cluster-label"><foreignObject height="24" width="142.046875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityThread.java</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.java" class="cluster"><rect height="128" width="1347.12890625" y="1629" x="167.48046875" style=""></rect><g transform="translate(727.068359375, 1629)" class="cluster-label"><foreignObject height="24" width="227.953125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.java</p></span></div></foreignObject></g></g><g data-look="classic" id="NonConfigurationInstances.kt" class="cluster"><rect height="128" width="1399.453125" y="1961" x="165.0078125" style=""></rect><g transform="translate(758.828125, 1961)" class="cluster-label"><foreignObject height="24" width="211.8125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>NonConfigurationInstances.kt</p></span></div></foreignObject></g></g></g><g class="edgePaths"><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_scheduleTransactionItemNow_scheduleTransaction_0" d="M2009.094,62L2009.094,66.167C2009.094,70.333,2009.094,78.667,2009.094,84.917C2009.094,91.167,2009.094,95.333,2009.094,98.833C2009.094,102.333,2009.094,105.167,2009.094,106.583L2009.094,108"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_scheduleTransaction_ClientTransaction_1" d="M2009.094,166L2009.094,170.167C2009.094,174.333,2009.094,182.667,2009.094,188.917C2009.094,195.167,2009.094,199.333,2009.094,202.833C2009.094,206.333,2009.094,209.167,2009.094,210.583L2009.094,212"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ClientTransaction_IApplicationThread.scheduleTransaction_2" d="M2009.094,270L2009.094,274.167C2009.094,278.333,2009.094,286.667,2009.094,292.917C2009.094,299.167,2009.094,303.333,2009.094,306.833C2009.094,310.333,2009.094,313.167,2009.094,314.583L2009.094,316"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IApplicationThread.scheduleTransaction_IApplicationThread.scheduleRelaunchActivity_3" d="M2009.094,374L2009.094,378.167C2009.094,382.333,2009.094,390.667,2009.094,396.917C2009.094,403.167,2009.094,407.333,2009.094,410.833C2009.094,414.333,2009.094,417.167,2009.094,418.583L2009.094,420"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_IApplicationThread.scheduleRelaunchActivity_A_4" d="M2009.094,478L2009.094,482.167C2009.094,486.333,2009.094,494.667,2009.094,500.917C2009.094,507.167,2009.094,511.333,2009.094,514.833C2009.094,518.333,2009.094,521.167,2009.094,522.583L2009.094,524"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_A_B_5" d="M2009.094,582L2009.094,586.167C2009.094,590.333,2009.094,598.667,2009.094,604.917C2009.094,611.167,2009.094,615.333,2009.094,618.833C2009.094,622.333,2009.094,625.167,2009.094,626.583L2009.094,628"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_B_ClientTransactionHandler_6" d="M2009.094,686L2009.094,690.167C2009.094,694.333,2009.094,702.667,2009.094,708.917C2009.094,715.167,2009.094,719.333,2009.094,722.833C2009.094,726.333,2009.094,729.167,2009.094,730.583L2009.094,732"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ClientTransactionHandler_C_7" d="M2009.094,790L2009.094,794.167C2009.094,798.333,2009.094,806.667,2009.094,815C2009.094,823.333,2009.094,831.667,2009.094,837.917C2009.094,844.167,2009.094,848.333,2009.094,851.833C2009.094,855.333,2009.094,858.167,2009.094,859.583L2009.094,861"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_X4_8" d="M1901.487,1328L1884.881,1332.167C1868.275,1336.333,1835.063,1344.667,1690.993,1359C1546.922,1373.333,1291.992,1393.667,1164.527,1414C1037.063,1434.333,1037.063,1454.667,1037.063,1466.917C1037.063,1479.167,1037.063,1483.333,1037.063,1486.833C1037.063,1490.333,1037.063,1493.167,1037.063,1494.583L1037.063,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_C_D_9" d="M2009.094,919L2009.094,923.167C2009.094,927.333,2009.094,935.667,2009.094,941.917C2009.094,948.167,2009.094,952.333,2009.094,955.833C2009.094,959.333,2009.094,962.167,2009.094,963.583L2009.094,965"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_D_E_10" d="M2009.094,1023L2009.094,1027.167C2009.094,1031.333,2009.094,1039.667,2009.094,1045.917C2009.094,1052.167,2009.094,1056.333,2009.094,1059.833C2009.094,1063.333,2009.094,1066.167,2009.094,1067.583L2009.094,1069"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_E_F_11" d="M2009.094,1127L2009.094,1137.167C2009.094,1147.333,2009.094,1167.667,2009.094,1188C2009.094,1208.333,2009.094,1228.667,2009.094,1240.917C2009.094,1253.167,2009.094,1257.333,2009.094,1260.833C2009.094,1264.333,2009.094,1267.167,2009.094,1268.583L2009.094,1270"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_PerformLaunch_LAUNCHER_12" d="M1707.469,1023L1707.469,1027.167C1707.469,1031.333,1707.469,1039.667,1707.469,1045.917C1707.469,1052.167,1707.469,1056.333,1707.469,1059.833C1707.469,1063.333,1707.469,1066.167,1707.469,1067.583L1707.469,1069"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_F_H_13" d="M2014.286,1328L2015.087,1332.167C2015.889,1336.333,2017.491,1344.667,2018.292,1359C2019.094,1373.333,2019.094,1393.667,2019.094,1414C2019.094,1434.333,2019.094,1454.667,2019.094,1466.917C2019.094,1479.167,2019.094,1483.333,2019.094,1486.833C2019.094,1490.333,2019.094,1493.167,2019.094,1494.583L2019.094,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_LAUNCHER_X3_16" d="M1707.469,1127L1707.469,1137.167C1707.469,1147.333,1707.469,1167.667,1707.469,1188C1707.469,1208.333,1707.469,1228.667,1603.226,1242.654C1498.983,1256.642,1290.497,1264.283,1082.678,1271.9C874.858,1279.518,667.705,1287.11,564.129,1290.907L460.552,1294.703"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X3_X2_17" d="M288.758,1328L288.758,1332.167C288.758,1336.333,288.758,1344.667,288.758,1359C288.758,1373.333,288.758,1393.667,288.758,1414C288.758,1434.333,288.758,1454.667,288.758,1466.917C288.758,1479.167,288.758,1483.333,288.758,1486.833C288.758,1490.333,288.758,1493.167,288.758,1494.583L288.758,1496"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_MAP_MyViewModel_22" d="M1399.461,2291L1399.461,2295.167C1399.461,2299.333,1399.461,2307.667,1399.461,2316C1399.461,2324.333,1399.461,2332.667,1399.461,2338.917C1399.461,2345.167,1399.461,2349.333,1399.461,2352.833C1399.461,2356.333,1399.461,2359.167,1399.461,2360.583L1399.461,2362"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_H_NonConfigurationInstances.java_14" d="M2019.094,1554L2019.094,1558.167C2019.094,1562.333,2019.094,1570.667,1832.025,1579C1644.957,1587.333,1270.82,1595.667,1083.752,1601.917C896.684,1608.167,896.684,1612.333,896.684,1615.833C896.684,1619.333,896.684,1622.167,896.684,1623.583L896.684,1625"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_X2_NonConfigurationInstances.java_15" d="M288.758,1554L288.758,1558.167C288.758,1562.333,288.758,1570.667,288.758,1579C288.758,1587.333,288.758,1595.667,288.758,1601.917C288.758,1608.167,288.758,1612.333,288.758,1615.833C288.758,1619.333,288.758,1622.167,288.758,1623.583L288.758,1625"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_RetainMethod_NonConfigurationInstances.kt_18" d="M680.813,1911L680.813,1915.167C680.813,1919.333,680.813,1927.667,680.813,1933.917C680.813,1940.167,680.813,1944.333,680.813,1947.833C680.813,1951.333,680.813,1954.167,680.813,1955.583L680.813,1957"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_J_NonConfigurationInstances.kt_19" d="M320.643,1720L325.641,1726.167C330.639,1732.333,340.636,1744.667,345.634,1755C350.633,1765.333,350.633,1773.667,350.633,1782C350.633,1790.333,350.633,1798.667,350.633,1807C350.633,1815.333,350.633,1823.667,350.633,1836.5C350.633,1849.333,350.633,1866.667,350.633,1884C350.633,1901.333,350.633,1918.667,350.633,1929.417C350.633,1940.167,350.633,1944.333,350.633,1947.833C350.633,1951.333,350.633,1954.167,350.633,1955.583L350.633,1957"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-normal edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_R_ViewModelStore.kt_20" d="M1399.461,2064L1399.461,2068.167C1399.461,2072.333,1399.461,2080.667,1399.461,2089C1399.461,2097.333,1399.461,2105.667,1399.461,2114C1399.461,2122.333,1399.461,2130.667,1399.461,2136.917C1399.461,2143.167,1399.461,2147.333,1399.461,2150.833C1399.461,2154.333,1399.461,2157.167,1399.461,2158.583L1399.461,2160"></path><path marker-end="url(#mermaid_flowchart-v2-pointEnd)" style="" class="edge-thickness-thick edge-pattern-solid edge-thickness-normal edge-pattern-solid flowchart-link" id="L_ComponentActivity.kt_Activity.java_21" d="M246.883,1832L246.883,1827.833C246.883,1823.667,246.883,1815.333,246.883,1809.083C246.883,1802.833,246.883,1798.667,246.883,1795.167C246.883,1791.667,246.883,1788.833,246.883,1787.417L246.883,1786"></path></g><g class="edgeLabels"><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(1037.0625, 1414)" class="edgeLabel"><g transform="translate(-100, -36)" class="label"><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>До уничтожения получает Activity . NonConfigurationInstances</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(2019.09375, 1414)" class="edgeLabel"><g transform="translate(-78.734375, -12)" class="label"><foreignObject height="24" width="157.46875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Сохраняет состояние</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 1188)" class="edgeLabel"><g transform="translate(-108.7421875, -36)" class="label"><foreignObject height="72" width="217.484375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Передает ActivityClientRecord . lastNonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1414)" class="edgeLabel"><g transform="translate(-47.265625, -12)" class="label"><foreignObject height="24" width="94.53125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Присваивает</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(350.63281, 1835.18606)" class="edgeLabel"><g transform="translate(-36.65625, -12)" class="label"><foreignObject height="24" width="73.3125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Содержит</p></span></div></foreignObject></g></g><g class="edgeLabel"><g transform="translate(0, 0)" class="label"><foreignObject height="0" width="0"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"></span></div></foreignObject></g></g><g transform="translate(246.8828125, 1807)" class="edgeLabel"><g transform="translate(-47.09375, -12)" class="label"><foreignObject height="24" width="94.1875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" class="labelBkg" xmlns="http://www.w3.org/1999/xhtml"><span class="edgeLabel"><p>Наследуется</p></span></div></foreignObject></g></g></g><g class="nodes"><g transform="translate(2009.09375, 996)" id="flowchart-D-0" class="node default"><rect height="54" width="277.15625" y="-27" x="-138.578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-108.578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="217.15625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleRelaunchActivityInner()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 892)" id="flowchart-C-1" class="node default"><rect height="54" width="240.140625" y="-27" x="-120.0703125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-90.0703125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="180.140625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 1100)" id="flowchart-E-2" class="node default"><rect height="54" width="229.515625" y="-27" x="-114.7578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-84.7578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="169.515625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleDestroyActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 1301)" id="flowchart-F-3" class="node default"><rect height="54" width="239.140625" y="-27" x="-119.5703125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-89.5703125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="179.140625"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>performDestroyActivity()</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 1100)" id="flowchart-LAUNCHER-4" class="node default"><rect height="54" width="235.71875" y="-27" x="-117.859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-87.859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="175.71875"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>performLaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(1707.46875, 996)" id="flowchart-PerformLaunch-5" class="node default"><rect height="54" width="226.09375" y="-27" x="-113.046875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-83.046875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="166.09375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>handleLaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2019.09375, 1527)" id="flowchart-H-6" class="node default"><rect height="54" width="533.859375" y="-27" x="-266.9296875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-236.9296875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="473.859375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>lastNonConfigurationInstances:Activity.NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1527)" id="flowchart-X2-7" class="node default"><rect height="54" width="491.515625" y="-27" x="-245.7578125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-215.7578125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="431.515625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>mLastNonConfigurationInstances:NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(288.7578125, 1301)" id="flowchart-X3-9" class="node default"><rect height="54" width="335.59375" y="-27" x="-167.796875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-137.796875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="275.59375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>attach(lastNonConfigurationInstances)</p></span></div></foreignObject></g></g><g transform="translate(1037.0625, 1527)" id="flowchart-X4-10" class="node default"><rect height="54" width="503.71875" y="-27" x="-251.859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-221.859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="443.71875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>retainNonConfigurationInstances():NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(680.8125, 1884)" id="flowchart-RetainMethod-11" class="node default"><rect height="54" width="517.046875" y="-27" x="-258.5234375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-228.5234375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="457.046875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>onRetainNonConfigurationInstance():NonConfigurationInstances</p></span></div></foreignObject></g></g><g transform="translate(350.6328125, 2025)" id="flowchart-Q-13" class="node default"><rect height="54" width="180.78125" y="-27" x="-90.390625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-60.390625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="120.78125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var custom: Any?</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2025)" id="flowchart-R-14" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>var viewModelStore: ViewModelStore?</p></span></div></foreignObject></g></g><g transform="translate(298.7578125, 1693)" id="flowchart-J-15" class="node default"><rect height="54" width="167.609375" y="-27" x="-83.8046875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-53.8046875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="107.609375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>Object activity</p></span></div></foreignObject></g></g><g transform="translate(525.828125, 1693)" id="flowchart-K-16" class="node default"><rect height="54" width="186.53125" y="-27" x="-93.265625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-63.265625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="126.53125"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>HashMap children</p></span></div></foreignObject></g></g><g transform="translate(802.296875, 1693)" id="flowchart-L-17" class="node default"><rect height="78" width="266.40625" y="-39" x="-133.203125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-103.203125, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="206.40625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>FragmentManagerNonConfig fragments</p></span></div></foreignObject></g></g><g transform="translate(1077.5546875, 1693)" id="flowchart-M-18" class="node default"><rect height="54" width="184.109375" y="-27" x="-92.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-62.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="124.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ArrayMap loaders</p></span></div></foreignObject></g></g><g transform="translate(1349.609375, 1693)" id="flowchart-N-19" class="node default"><rect height="78" width="260" y="-39" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -24)" style="" class="label"><rect></rect><foreignObject height="48" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>VoiceInteractor voiceInteractor</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2240)" id="flowchart-MAP-20" class="node default"><rect height="102" width="260" y="-51" x="-130" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-100, -36)" style="" class="label"><rect></rect><foreignObject height="72" width="200"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>private val map = mutableMapOf&lt;String, ViewModel&gt;()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 35)" id="flowchart-scheduleTransactionItemNow-21" class="node default"><rect height="54" width="452.171875" y="-27" x="-226.0859375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-196.0859375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="392.171875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientLifecycleManager.scheduleTransactionItemNow()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 139)" id="flowchart-scheduleTransaction-22" class="node default"><rect height="54" width="388.5" y="-27" x="-194.25" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-164.25, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="328.5"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientLifecycleManager.scheduleTransaction()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 243)" id="flowchart-ClientTransaction-24" class="node default"><rect height="54" width="265.875" y="-27" x="-132.9375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-102.9375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="205.875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientTransaction.schedule()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 347)" id="flowchart-IApplicationThread.scheduleTransaction-26" class="node default"><rect height="54" width="359.359375" y="-27" x="-179.6796875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-149.6796875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="299.359375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>IApplicationThread.scheduleTransaction()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 451)" id="flowchart-IApplicationThread.scheduleRelaunchActivity-28" class="node default"><rect height="54" width="397.109375" y="-27" x="-198.5546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-168.5546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="337.109375"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>IApplicationThread.scheduleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 555)" id="flowchart-A-30" class="node default"><rect height="54" width="305.265625" y="-27" x="-152.6328125" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-122.6328125, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="245.265625"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityTransactionItem.execute()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 763)" id="flowchart-ClientTransactionHandler-31" class="node default"><rect height="54" width="425.28125" y="-27" x="-212.640625" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-182.640625, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="365.28125"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ClientTransactionHandler.handleRelaunchActivity()</p></span></div></foreignObject></g></g><g transform="translate(2009.09375, 659)" id="flowchart-B-33" class="node default"><rect height="54" width="287.921875" y="-27" x="-143.9609375" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-113.9609375, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="227.921875"><div style="display: table; white-space: break-spaces; line-height: 1.5; max-width: 200px; text-align: center; width: 200px;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>ActivityRelaunchItem.execute()</p></span></div></foreignObject></g></g><g transform="translate(1399.4609375, 2393)" id="flowchart-MyViewModel-67" class="node default"><rect height="54" width="156.109375" y="-27" x="-78.0546875" data-et="node" data-id="abc" style="" class="basic label-container"></rect><g transform="translate(-48.0546875, -12)" style="" class="label"><rect></rect><foreignObject height="24" width="96.109375"><div style="display: table-cell; white-space: nowrap; line-height: 1.5; max-width: 200px; text-align: center;" xmlns="http://www.w3.org/1999/xhtml"><span class="nodeLabel"><p>MyViewModel</p></span></div></foreignObject></g></g></g></g></g></svg></section></section><section class="chapter"><h2 id="wrb7ek_7" data-toc="wrb7ek_7">Итоги</h2><p id="wrb7ek_530">В этой статье мы не касались работы ViewModel как таковой &mdash; фокус был исключительно на том, <span class="control" id="wrb7ek_536">почему она не умирает при пересоздании Activity</span>, и за счёт чего это вообще возможно.</p><p id="wrb7ek_531">Мы проследили всю цепочку: <code class="code" id="wrb7ek_537">ViewModel</code> &rarr; <code class="code" id="wrb7ek_538">ViewModelStore</code> &rarr; <code class="code" id="wrb7ek_539">ComponentActivity#NonConfigurationInstances</code> &rarr; <code class="code" id="wrb7ek_540">Activity#NonConfigurationInstances</code> &rarr; <code class="code" id="wrb7ek_541">ActivityClientRecord</code> &rarr; <code class="code" id="wrb7ek_542">ActivityThread</code>. Именно в этой глубокой вложенности и заключается ответ: <span class="control" id="wrb7ek_543">ViewModel выживает, потому что сохраняется не в Activity напрямую, а в объекте, который система сама передаёт новой Activity при конфигурационных изменениях.</span></p><p id="wrb7ek_532">Сам <code class="code" id="wrb7ek_544">ViewModelStore</code> создаётся либо с нуля, либо восстанавливается через <code class="code" id="wrb7ek_545">getLastNonConfigurationInstance()</code>. Он очищается только в <code class="code" id="wrb7ek_546">onDestroy()</code>, если <code class="code" id="wrb7ek_547">isChangingConfigurations == false</code>, &mdash; то есть если Activity действительно умирает, а не пересоздаётся.</p><p id="wrb7ek_533">Под капотом всё это обеспечивается <code class="code" id="wrb7ek_548">ActivityThread</code>, который сохраняет <code class="code" id="wrb7ek_549">NonConfigurationInstances</code> в <code class="code" id="wrb7ek_550">ActivityClientRecord</code>, а потом передаёт в метод <code class="code" id="wrb7ek_551">attach()</code> при создании новой Activity. <code class="code" id="wrb7ek_552">ActivityThread</code> &mdash; синглтон, живущий столько же, сколько и процесс, и именно он является опорной точкой, через которую проходит вся цепочка восстановления.</p><p id="wrb7ek_534"><span class="control" id="wrb7ek_553">ViewModel выживает не потому, что её кто-то &ldquo;сохраняет&rdquo; &mdash; а потому, что никто её не убивает.</span> Пока жив <code class="code" id="wrb7ek_554">ActivityThread</code>, жив и <code class="code" id="wrb7ek_555">ViewModelStore</code>.</p><p id="wrb7ek_535">Позже мы снова вернемся к <code class="code" id="wrb7ek_556">ActivityThread</code> и <code class="code" id="wrb7ek_557">ActivityClientRecord</code>, это будет в рамках следующих статьей.</p></section><div class="last-modified">08 июля 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="start-page.html" class="navigation-links__prev">suleimanovs.github.io</a><a href="fragment-viewmodelstore-and-retain-fragment.html" class="navigation-links__next">ViewModel в Fragment под капотом: от ViewModelStore до Retain-фрагментов</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>