<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#1B9F8E" data-link-color="#57B747" data-content-max-width="1600" data-resizable-sidebar="true"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="built-on" content="2025-07-06T18:25:40.293471"><title>SavedStateHandle и Bundle под капотом: как Android сохраняет состояние | suleimanov</title><script type="application/json" id="virtual-toc-data">[{"id":"qin34a_6","level":0,"title":"Базис","anchor":"#qin34a_6"},{"id":"onsaveinstancestate-onrestoreinstancestate","level":0,"title":"onSaveInstanceState / onRestoreInstanceState","anchor":"#onsaveinstancestate-onrestoreinstancestate"},{"id":"saved-state-api","level":0,"title":"Saved State Api","anchor":"#saved-state-api"},{"id":"oncreate","level":0,"title":"Цепочка вызова onCreate","anchor":"#oncreate"},{"id":"bundle","level":0,"title":"Пересоздание процесса с сохранением Bundle","anchor":"#bundle"},{"id":"activityrecord","level":0,"title":"Где и когда создается ActivityRecord в первые","anchor":"#activityrecord"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><link href="static/style.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://iili.io/3eop8YX.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="SavedStateHandle и Bundle под капотом: как Android сохраняет состояние | suleimanov"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="suleimanov Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation//1.0/saved-state-handle-under-the-hood.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="SavedStateHandle и Bundle под капотом: как Android сохраняет состояние | suleimanov"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation//1.0/saved-state-handle-under-the-hood.html#webpage",
    "url": "writerside-documentation//1.0/saved-state-handle-under-the-hood.html",
    "name": "SavedStateHandle и Bundle под капотом: как Android сохраняет состояние | suleimanov",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "suleimanov Help"
}</script><!-- End Schema.org --></head><body data-id="saved-state-handle-under-the-hood" data-main-title="SavedStateHandle и Bundle под капотом: как Android сохраняет состояние" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="Android"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>suleimanov 1.0 Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="saved-state-handle-under-the-hood" id="saved-state-handle-under-the-hood.md">SavedStateHandle и Bundle под капотом: как Android сохраняет состояние</h1><p id="qin34a_3">Это продолжение трех предыдущих статей.</p><ol class="list _decimal" id="qin34a_4" type="1"><li class="list__item" id="qin34a_12"><p id="qin34a_15">В первой мы разобрали, где в конечном итоге хранится <code class="code" id="qin34a_16">ViewModelStore</code> в случае с <code class="code" id="qin34a_17">Activity</code>,</p></li><li class="list__item" id="qin34a_13"><p id="qin34a_18">Во второй &mdash; как это устроено во <code class="code" id="qin34a_19">Fragment</code>,</p></li><li class="list__item" id="qin34a_14"><p id="qin34a_20">В третьей где хранятся <code class="code" id="qin34a_21">ViewModel</code>-и, когда мы используем <span class="control" id="qin34a_22">Compose</span> (или даже просто <code class="code" id="qin34a_23">View</code>).</p></li></ol><p id="qin34a_5">В этой статье рассмотрим Где хранится SavedStateHandle, проверим SavedStateHandle vs onSaveInstanceState vs ViewModel(ViewModelStore) Поймем связку SavedStateHandle с ViewModel. И узнаем ответ на главный вопрос, где храниться Bundle. Но, как всегда, начнём с базиса.</p><section class="chapter"><h2 id="qin34a_6" data-toc="qin34a_6">Базис</h2><p id="qin34a_24">В статье не будет описания того, как работать с этими API, а будет рассказано о том, как они устроены изнутри, поэтому я буду исходить из того, что вы уже работали с ними. Как всегда, начнём с базиса &mdash; дадим определения для SavedStateHandle, onSaveInstanceState и ViewModel:</p><p id="qin34a_25"><span class="control" id="qin34a_31">ViewModel</span> &mdash; компонент архитектурного паттерна MVVM, предоставленный Google как примитив, позволяющий пережить изменение конфигурации. Изменение конфигурации &mdash; это состояние, из-за которого Activity/Fragment пересоздаётся; именно это состояние может пережить ViewModel. Увы, на этом обязанности ViewModel по хранению данных в контексте Android заканчиваются.</p><p id="qin34a_26">Если же процесс приложения умирает или прерывается, ViewModel не справится; тогда на сцену выходят старые добрые методы onSaveInstanceState/onRestoreInstanceState.</p><p id="qin34a_27"><span class="control" id="qin34a_32">onSaveInstanceState/onRestoreInstanceState</span> &mdash; методы жизненного цикла Activity, Fragment и даже View (да, View тоже может сохранять состояние), которые позволяют сохранять и восстанавливать временное состояние пользовательского интерфейса при изменении конфигурации ( например, при повороте экрана) или при полном уничтожении активности из-за нехватки ресурсов. В onSaveInstanceState данные сохраняются в Bundle, который автоматически передаётся в onRestoreInstanceState при восстановлении активности.</p><p id="qin34a_28">Это базовый механизм для хранения примитивных типов (и их массивов), Parcelable/Serializable и ещё пары нативных Android-типов. Эти методы требуют явного указания того, что именно нужно сохранить, а логика прописывается внутри Activity и Fragment. Большинство архитектурных паттернов (MVI, MVVM) гласят, что View (Fragment/Activity/Compose) должны быть максимально простыми и не содержать никакой логики, кроме отображения данных, поэтому прямое использование этих методов сейчас уступает место Saved State API, которое хорошо интегрируется с ViewModel, наделяя её не только возможностью &laquo;спасать&raquo; данные от изменений конфигурации, но и сохранять сериализуемые данные при уничтожении или остановке процесса по инициативе системы.</p><p id="qin34a_29"><span class="control" id="qin34a_33">Saved State API</span> &mdash; современная альтернатива onSaveInstanceState/onRestoreInstanceState, более гибко управляющая состоянием, особенно в связке с ViewModel. <span class="control" id="qin34a_34">SavedStateHandle</span> &mdash; объект, передаваемый в конструктор ViewModel, который позволяет безопасно сохранять и восстанавливать данные даже после уничтожения процесса. В отличие от статичного onSaveInstanceState, SavedStateHandle также позволяет подписываться на Flow и LiveData тех данных, которые он хранит и восстанавливает. Он автоматически интегрирован с ViewModel и поддерживает сохранение состояния при изменениях конфигурации, а также при полном уничтожении процесса приложения. Дополнительное преимущество &mdash; возможность подписываться на изменения значений в SavedStateHandle и получать реактивное поведение прямо в ViewModel.</p><aside class="prompt" data-type="tip" data-title="" id="qin34a_30"><p>Под &laquo;уничтожением или прерыванием процесса&raquo;, о котором идёт речь в статье, подразумевается ситуация, когда приложение находится в фоне и сохраняется в стеке задач. Обычно это происходит, когда пользователь сворачивает приложение, не закрывая его. Через некоторое время бездействия система может остановить процесс. Не стоит путать это с кейсом, когда пользователь сам вручную закрывает приложение &mdash; это другой сценарий.</p></aside></section><section class="chapter"><h2 id="onsaveinstancestate-onrestoreinstancestate" data-toc="onsaveinstancestate-onrestoreinstancestate">onSaveInstanceState / onRestoreInstanceState</h2><p id="qin34a_35">Давайте также освежим память о методах onSaveInstanceState и onRestoreInstanceState:</p><div class="code-block" data-lang="kotlin">
class RestoreActivity : AppCompatActivity() {

    private var counter = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Восстановление значения при пересоздании
        counter = savedInstanceState?.getInt(&quot;counter_key&quot;) ?: 0
    }

    override fun onRestoreInstanceState(savedInstanceState: Bundle) {
        super.onRestoreInstanceState(savedInstanceState)
        // Восстановление значения при пересоздании
        counter = savedInstanceState.getInt(&quot;counter_key&quot;)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // Сохраняем значение
        outState.putInt(&quot;counter_key&quot;, counter)
        Log.d(&quot;RestoreActivity&quot;, &quot;onSaveInstanceState: Counter saved = $counter&quot;)
    }
}
</div><p id="qin34a_37"><span class="control" id="qin34a_47">onSaveInstanceState</span> &mdash; вызывается для получения состояния Activity перед её уничтожением, чтобы оно могло быть восстановлено в методах <code class="code" id="qin34a_48">onCreate</code> или <code class="code" id="qin34a_49">onRestoreInstanceState</code>. <code class="code" id="qin34a_50">Bundle</code>, заполненный в этом методе, будет передан в оба метода.</p><p id="qin34a_38">Этот метод вызывается до того, как Activity может быть уничтожена, чтобы при повторном создании она могла восстановить своё состояние. Не следует путать его с методами жизненного цикла, такими как <code class="code" id="qin34a_51">onPause</code> (вызывается всегда, вызывается при частичной потере фокуса Activity) или <code class="code" id="qin34a_52">onStop</code> (когда Activity становится невидимой).</p><ul class="list _bullet" id="qin34a_39"><li class="list__item" id="qin34a_53"><p id="qin34a_55"><span class="control" id="qin34a_56">Пример</span>, когда <code class="code" id="qin34a_57">onPause</code> и <code class="code" id="qin34a_58">onStop</code> вызываются, но <code class="code" id="qin34a_59">onSaveInstanceState</code> &mdash; нет: при возвращении из Activity B в Activity A. В этом случае состояние B не требуется восстанавливать, поэтому <code class="code" id="qin34a_60">onSaveInstanceState</code> для B не вызывается.</p></li><li class="list__item" id="qin34a_54"><p id="qin34a_61"><span class="control" id="qin34a_62">Другой пример</span>: если Activity B запускается поверх Activity A, но A остаётся в памяти, то <code class="code" id="qin34a_63">onSaveInstanceState</code> для A также не вызывается, так как Activity остаётся в памяти и не требуется сохранять её состояние.</p></li></ul><p id="qin34a_40">Реализация по умолчанию этого метода автоматически сохраняет большую часть состояния пользовательского интерфейса, <span class="control" id="qin34a_64">вызывая <code class="code" id="qin34a_66">onSaveInstanceState()</code> у каждого <code class="code" id="qin34a_67">View</code> в иерархии, у которого есть ID</span>, а также сохраняет ID элемента, находившегося в фокусе. Восстановление этих данных происходит в стандартной реализации <code class="code" id="qin34a_65">onRestoreInstanceState()</code>. Если вы переопределяете метод для сохранения дополнительной информации, рекомендуется вызвать реализацию по умолчанию через</p><div class="code-block" data-lang="kotlin">
super.onSaveInstanceState(outState)
</div><p id="qin34a_42">&mdash; иначе придётся вручную сохранять состояние всех <code class="code" id="qin34a_68">View</code>.</p><p id="qin34a_43">Если метод вызывается, то это произойдёт <span class="control" id="qin34a_69">после <code class="code" id="qin34a_72">onStop</code></span> для приложений, нацеленных на платформы, начиная с Android P. Для более ранних версий Android этот метод будет вызван <span class="control" id="qin34a_70">до <code class="code" id="qin34a_73">onStop</code></span>, и нет никаких гарантий, будет ли он вызван до или после <code class="code" id="qin34a_71">onPause</code>.</p><aside class="prompt" data-type="tip" data-title="Документация гласит:" id="qin34a_44"><p>If called, this method will occur after onStop for applications targeting platforms starting with android.os.Build.VERSION_CODES.P. For applications targeting earlier platform versions this method will occur before onStop and there are no guarantees about whether it will occur before or after onPause.</p></aside><p id="qin34a_45"><span class="control" id="qin34a_74">onRestoreInstanceState</span> &mdash; этот метод вызывается <span class="control" id="qin34a_75">после</span> <code class="code" id="qin34a_76">onStart</code>, когда активность повторно инициализируется из ранее сохранённого состояния, переданного в <code class="code" id="qin34a_77">savedInstanceState</code>. Большинство реализаций используют для восстановления состояния метод <code class="code" id="qin34a_78">onCreate</code>, но иногда бывает удобнее делать это здесь, после того как завершена вся инициализация, или чтобы подклассы могли решить, использовать ли вашу реализацию по умолчанию. Стандартная реализация этого метода восстанавливает состояние представлений (View), которое было ранее заморожено методом <code class="code" id="qin34a_79">onSaveInstanceState</code>. Этот метод вызывается <span class="control" id="qin34a_80">между <code class="code" id="qin34a_84">onStart</code> и <code class="code" id="qin34a_85">onPostCreate</code></span>. Он срабатывает <span class="control" id="qin34a_81">только при повторном создании активности</span>; метод <span class="control" id="qin34a_82">не вызывается</span>, если <code class="code" id="qin34a_83">onStart</code> был вызван по любой другой причине (например, при переходе из фона на передний план).</p><p id="qin34a_46">На этом примере временно забываем о них, чуть позже мы их снова встретим в более низкоуровневых цепочках вызовов.</p></section><section class="chapter"><h2 id="saved-state-api" data-toc="saved-state-api">Saved State Api</h2><aside class="prompt" data-type="note" data-title="" id="qin34a_86"><p>С версии 1.3.0-alpha02 androidx.savedstate:savedstate стала поддерживать Kotlin Multiplatform. Теперь SavedState работает не только на Android (Bundle), но и на iOS, JVM, Linux и macOS Map&lt;String, Any&gt;, сохраняя совместимость.</p></aside><p id="qin34a_87">Что бы понять работу <span class="control" id="qin34a_237">Saved State Api</span> перепишем пример выше с <code class="code" id="qin34a_238">onSaveInstanceState</code> и <code class="code" id="qin34a_239">onRestoreInstanceState</code> используя Saved State Api, делает ровно тоже самое:</p><div class="code-block" data-lang="kotlin">
class RestoreActivity : AppCompatActivity() {

    private var counter = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Восстановление значения при пересоздании
        counter = savedStateRegistry.consumeRestoredStateForKey(&quot;counter_key&quot;)?.getInt(&quot;counter&quot;, 0) ?: 0

        savedStateRegistry.registerSavedStateProvider(
            key = &quot;counter_key&quot;,
            provider = object : SavedStateRegistry.SavedStateProvider {
                override fun saveState(): SavedState {
                    return SavedState(bundleOf(&quot;counter&quot; to counter))
                }
            }
        )
    }
}
</div><p id="qin34a_89">Мы вызываем у объекта <code class="code" id="qin34a_240">savedStateRegistry</code> метод <code class="code" id="qin34a_241">registerSavedStateProvider</code> куда передаем <code class="code" id="qin34a_242">key</code> и анонимный объект <code class="code" id="qin34a_243">SavedStateRegistry.SavedStateProvider</code> который возвращает <code class="code" id="qin34a_244">Bundle</code> обернутый в объект <code class="code" id="qin34a_245">SavedState</code>, давайте сейчас же определим что из себя представляет этот тип <code class="code" id="qin34a_246">SavedState</code>, если зайти в исходники, а именно в <code class="code" id="qin34a_247">expect</code> логику, то тип описан следующим образом: <span class="control" id="qin34a_248">androidx.savedstate.SavedState.kt</span>:</p><div class="code-block" data-lang="kotlin">
/**
 * An opaque (empty) common type that holds saveable values to be saved and restored by native
 * platforms that have a concept of System-initiated Process Death.
 *
 * That means, the OS will give the chance for the process to keep the state of the application
 * (normally using a serialization mechanism), and allow the app to restore its state later. That is
 * commonly referred to as &quot;state restoration&quot;.
 * ...
 */
public expect class SavedState
</div><p id="qin34a_91">В контексте <code class="code" id="qin34a_249">android</code> нас интересует именно <code class="code" id="qin34a_250">actual</code> реализация, по этому далее специфичная для android <code class="code" id="qin34a_251">actual</code></p><p id="qin34a_92"><span class="control" id="qin34a_252">androidx.savedstate.SavedState.android.kt</span>:</p><div class="code-block" data-lang="kotlin">
public actual typealias SavedState = android.os.Bundle
</div><p id="qin34a_94">Как видим в <code class="code" id="qin34a_253">Android</code> нет на самом деле какого-то типа как <code class="code" id="qin34a_254">SavedState</code>, в <code class="code" id="qin34a_255">actual</code> реализаций это просто <code class="code" id="qin34a_256">typealias</code> который ссылается на тот же старый добрый родной класс <code class="code" id="qin34a_257">Bundle</code>, по этому всегда представляйте что там где используется <code class="code" id="qin34a_258">SavedState</code> - на самом деле используется класс <code class="code" id="qin34a_259">Bundle</code>, поэтому ничто не мешает нам отказаться от лишней обёртки и вернуть <code class="code" id="qin34a_260">Bundle</code> напрямую:</p><div class="code-block" data-lang="kotlin">
savedStateRegistry.registerSavedStateProvider(
    key = &quot;counter_key&quot;,
    provider = object : SavedStateRegistry.SavedStateProvider {
        override fun saveState(): Bundle {
            return bundleOf(&quot;counter&quot; to counter)
        }
    }
)
</div><p id="qin34a_96">Раз с этим разобрались, дальше давайте зайдем в исходники метода <code class="code" id="qin34a_261">registerSavedStateProvider</code> и <code class="code" id="qin34a_262">consumeRestoredStateForKey</code>, эти методы вызывается у переменной <code class="code" id="qin34a_263">savedStateRegistry</code> которая имеет тип <code class="code" id="qin34a_264">SavedStateRegistry</code>, давайте быстро узнаем определение этого класса:</p><p id="qin34a_97"><span class="control" id="qin34a_265"><code class="code" id="qin34a_271">SavedStateRegistry</code></span> - управляет сохранением и восстановлением сохранённого состояния, чтобы данные не терялись при пересоздании компонентов. Реализация привязана к <code class="code" id="qin34a_266">SavedStateRegistryImpl</code>, которая отвечает за фактическое хранение и восстановление данных. Интерфейс для подключения компонентов, которые потребляют и вносят данные в сохранённое состояние. Объект имеет такой же жизненный цикл, как и его владелец (<code class="code" id="qin34a_267">Activity</code> или <code class="code" id="qin34a_268">Fragment</code>): когда <code class="code" id="qin34a_269">Activity</code> или <code class="code" id="qin34a_270">Fragment</code> пересоздаются (например, после уничтожения процесса или изменении конфигурации), создаётся новый экземпляр этого объекта.</p><p id="qin34a_98">Но откуда берется <code class="code" id="qin34a_272">savedStateRegistry</code> переменная внутри <code class="code" id="qin34a_273">Activity</code> мы рассмотрим позже, пока достаточно знать что он есть у <code class="code" id="qin34a_274">Activity</code>, далее исходники метода <code class="code" id="qin34a_275">registerSavedStateProvider</code> и <code class="code" id="qin34a_276">consumeRestoredStateForKey</code> принадлежащий классу <code class="code" id="qin34a_277">SavedStateRegistry</code> (expect): <span class="control" id="qin34a_278">androidx.savedstate.SavedStateRegistry.kt</span></p><div class="code-block" data-lang="kotlin">
public expect class SavedStateRegistry internal constructor(
    impl: SavedStateRegistryImpl,
) {

    /** This interface marks a component that contributes to saved state. */
    public fun interface SavedStateProvider {

        public fun saveState(): SavedState
    }

    ...
    public val isRestored: Boolean
    ...
    @MainThread
    public fun consumeRestoredStateForKey(key: String): SavedState?
    ...
    @MainThread
    public fun registerSavedStateProvider(key: String, provider: SavedStateProvider)
    ...
    public fun getSavedStateProvider(key: String): SavedStateProvider?
    ...
    @MainThread
    public fun unregisterSavedStateProvider(key: String)
}
</div><p id="qin34a_100">Как мы видим на самом деле тут много методов у <code class="code" id="qin34a_279">SavedStateRegistry</code>, для нашей статьи достаточно понимать работу методов <code class="code" id="qin34a_280">registerSavedStateProvider</code> и <code class="code" id="qin34a_281">consumeRestoredStateForKey</code>, но что бы хоть какое-то понимание было, давайте быстро пройдемся по каждому:</p><ol class="list _decimal" id="qin34a_101" type="1"><li class="list__item" id="qin34a_282"><p id="qin34a_288"><span class="control" id="qin34a_289">consumeRestoredStateForKey</span> &mdash; извлекает и удаляет из памяти <code class="code" id="qin34a_290">SavedState</code> (Bundle), который был зарегистрирован с помощью <code class="code" id="qin34a_291">registerSavedStateProvider</code>. При повторном вызове возвращает <code class="code" id="qin34a_292">null</code>.</p></li><li class="list__item" id="qin34a_283"><p id="qin34a_293"><span class="control" id="qin34a_294">registerSavedStateProvider</span> &mdash; регистрирует <code class="code" id="qin34a_295">SavedStateProvider</code> с указанным ключом. Этот провайдер будет использоваться для сохранения состояния при вызове <code class="code" id="qin34a_296">onSaveInstanceState</code>.</p></li><li class="list__item" id="qin34a_284"><p id="qin34a_297"><span class="control" id="qin34a_298">getSavedStateProvider</span> &mdash; возвращает зарегистрированный <code class="code" id="qin34a_299">SavedStateProvider</code> по ключу или <code class="code" id="qin34a_300">null</code>, если он не найден.</p></li><li class="list__item" id="qin34a_285"><p id="qin34a_301"><span class="control" id="qin34a_302">unregisterSavedStateProvider</span> &mdash; удаляет из реестра ранее зарегистрированный <code class="code" id="qin34a_303">SavedStateProvider</code> по переданному ключу.</p></li><li class="list__item" id="qin34a_286"><p id="qin34a_304"><span class="control" id="qin34a_305">SavedStateProvider</span> &mdash; интерфейс, предоставляющий объект <code class="code" id="qin34a_306">SavedState</code> (Bundle) при сохранении состояния.</p></li><li class="list__item" id="qin34a_287"><p id="qin34a_307"><span class="control" id="qin34a_308">isRestored</span> &mdash; возвращает <code class="code" id="qin34a_309">true</code>, если состояние было восстановлено после создания компонента.</p></li></ol><p id="qin34a_102">В <code class="code" id="qin34a_310">expect</code>-версиях отсутствуют реализации &mdash; там только сигнатуры методов. Также мы рассмотрели исходники интерфейса <code class="code" id="qin34a_311">SavedStateProvider</code>, который представляет собой callback для получения <code class="code" id="qin34a_312">Bundle</code>, подлежащего сохранению. Чтобы увидеть реализацию метода <code class="code" id="qin34a_313">registerSavedStateProvider</code>, необходимо найти <span class="control" id="qin34a_314"><code class="code" id="qin34a_317">actual</code>-реализацию</span>, а затем перейти к <code class="code" id="qin34a_315">actual</code>-реализации <code class="code" id="qin34a_316">SavedStateRegistry</code>.</p><p id="qin34a_103"><span class="control" id="qin34a_318">androidx.savedstate.SavedStateRegistry.android.kt</span>:</p><div class="code-block" data-lang="kotlin">
public actual class SavedStateRegistry internal actual constructor(
    private val impl: SavedStateRegistryImpl,
) {

    @get:MainThread
    public actual val isRestored: Boolean
        get() = impl.isRestored

    @MainThread
    public actual fun consumeRestoredStateForKey(key: String): SavedState? =
        impl.consumeRestoredStateForKey(key)

    @MainThread
    public actual fun registerSavedStateProvider(key: String, provider: SavedStateProvider) {
        impl.registerSavedStateProvider(key, provider)
    }

    public actual fun getSavedStateProvider(key: String): SavedStateProvider? =
        impl.getSavedStateProvider(key)

    @MainThread
    public actual fun unregisterSavedStateProvider(key: String) {
        impl.unregisterSavedStateProvider(key)
    }

    public actual fun interface SavedStateProvider {
        public actual fun saveState(): SavedState
    }
    ...
}
</div><p id="qin34a_105"><code class="code" id="qin34a_319">actual</code> реализация <code class="code" id="qin34a_320">SavedStateRegistry</code> делегирует все вызовы своих методов готовой имплементацией <code class="code" id="qin34a_321">SavedStateRegistryImpl</code>, по этому далее рассмотрим именно <code class="code" id="qin34a_322">SavedStateRegistryImpl</code>:</p><div class="code-block" data-lang="kotlin">
internal class SavedStateRegistryImpl(
    private val owner: SavedStateRegistryOwner,
    internal val onAttach: () -&gt; Unit = {},
) {

    private val keyToProviders = mutableMapOf&lt;String, SavedStateProvider&gt;()
    private var restoredState: SavedState? = null

    @MainThread
    fun consumeRestoredStateForKey(key: String): SavedState? {
        ...
        val state = restoredState ?: return null

        val consumed = state.read { if (contains(key)) getSavedState(key) else null }
        state.write { remove(key) }
        if (state.read { isEmpty() }) {
            restoredState = null
        }

        return consumed
    }

    @MainThread
    fun registerSavedStateProvider(key: String, provider: SavedStateProvider) {
        ..
        keyToProviders[key] = provider
        ...
    }
    ...
}
</div><p id="qin34a_107">Основные методы для сохранения, давайте просто поймем что здесь происходит:</p><ol class="list _decimal" id="qin34a_108" type="1"><li class="list__item" id="qin34a_323"><p id="qin34a_325"><code class="code" id="qin34a_326">consumeRestoredStateForKey</code> - достает значение из <code class="code" id="qin34a_327">restoredState</code> (Bundle) по ключу, после того как достает значение, удаляет из <code class="code" id="qin34a_328">restoredState</code> (Bundle) значение и ключ, <code class="code" id="qin34a_329">restoredState</code> является самым коренным <code class="code" id="qin34a_330">Bundle</code> который внутри себя хранит все другие bundle</p></li><li class="list__item" id="qin34a_324"><p id="qin34a_331"><code class="code" id="qin34a_332">registerSavedStateProvider</code> - просто добавляет объект <code class="code" id="qin34a_333">SavedStateProvider</code> внутрь карты <code class="code" id="qin34a_334">keyToProviders</code></p></li></ol><p id="qin34a_109">Эти методы &mdash; очень верхне уровневые и не раскрывают, как именно в итоге сохраняются данные, поэтому нужно копнуть глубже &mdash; внутри этого же класса <code class="code" id="qin34a_335">SavedStateRegistryImpl</code>:</p><div class="code-block" data-lang="kotlin">
internal class SavedStateRegistryImpl(
    private val owner: SavedStateRegistryOwner,
    internal val onAttach: () -&gt; Unit = {},
) {
    private val keyToProviders = mutableMapOf&lt;String, SavedStateProvider&gt;()
    private var restoredState: SavedState? = null

    @MainThread
    internal fun performRestore(savedState: SavedState?) {
        ...
        restoredState =
            savedState?.read {
                if (contains(SAVED_COMPONENTS_KEY)) getSavedState(SAVED_COMPONENTS_KEY) else null
            }
        isRestored = true
    }

    @MainThread
    internal fun performSave(outBundle: SavedState) {
        val inState = savedState {
            restoredState?.let { putAll(it) }
            synchronized(lock) {
                for ((key, provider) in keyToProviders) {
                    putSavedState(key, provider.saveState())
                }
            }
        }

        if (inState.read { !isEmpty() }) {
            outBundle.write { putSavedState(SAVED_COMPONENTS_KEY, inState) }
        }
    }

    private companion object {
        private const val SAVED_COMPONENTS_KEY =
            &quot;androidx.lifecycle.BundlableSavedStateRegistry.key&quot;
    }
}
</div><ol class="list _decimal" id="qin34a_111" type="1"><li class="list__item" id="qin34a_336"><p id="qin34a_338"><code class="code" id="qin34a_339">performSave</code> &mdash; вызывается, когда <code class="code" id="qin34a_340">Activity</code> или <code class="code" id="qin34a_341">Fragment</code> переходит в состояние <code class="code" id="qin34a_342">pause</code>-&gt; <code class="code" id="qin34a_343">stop</code>, то есть в момент вызова <code class="code" id="qin34a_344">onSaveInstanceState</code>. Этот метод отвечает за сохранение состояния всех <code class="code" id="qin34a_345">SavedStateProvider</code>, зарегистрированных через <code class="code" id="qin34a_346">registerSavedStateProvider</code>. Внутри метода создается объект <code class="code" id="qin34a_347">inState</code> типа SavedState (по сути, это сам <code class="code" id="qin34a_348">Bundle</code>). Если в restoredState уже есть данные, они добавляются в <code class="code" id="qin34a_349">inState</code>. Затем, в синхронизированном блоке, происходит обход всех зарегистрированных <code class="code" id="qin34a_350">SavedStateProvider</code>, вызывается метод <code class="code" id="qin34a_351">saveState</code> (), и результаты сохраняются в <code class="code" id="qin34a_352">inState</code>. В конце, если <code class="code" id="qin34a_353">inState</code> не пустой, его содержимое записывается в параметр <code class="code" id="qin34a_354">outBundle</code> под ключом <code class="code" id="qin34a_355">SAVED_COMPONENTS_KEY</code>.</p></li><li class="list__item" id="qin34a_337"><p id="qin34a_356"><code class="code" id="qin34a_357">performRestore</code> &mdash; вызывается при создании или восстановлении <code class="code" id="qin34a_358">Activity</code> или <code class="code" id="qin34a_359">Fragment</code>. Этот метод просто читает из <code class="code" id="qin34a_360">savedState</code>значение по ключу <code class="code" id="qin34a_361">SAVED_COMPONENTS_KEY</code>, если оно существует. Найденное значение (вложенный <code class="code" id="qin34a_362">SavedState</code>) сохраняется в переменную <code class="code" id="qin34a_363">restoredState</code>, чтобы потом можно было передать его в соответствующие компоненты.</p></li></ol><p id="qin34a_112">На данный момент мы увидели как работает логика сохранения и регистраций, теперь осталось понять кто же вызывает методы <code class="code" id="qin34a_364">performSave</code> и <code class="code" id="qin34a_365">performRestore</code> и в какой момент.</p><p id="qin34a_113">Этой логикой управляет <code class="code" id="qin34a_366">SavedStateRegistryController</code>, в связи с тем что Saved State Api тоже на <code class="code" id="qin34a_367">KMP</code>, по этому лучше сразу посмотрим actual версию:</p><div class="code-block" data-lang="kotlin">
public actual class SavedStateRegistryController private actual constructor(
    private val impl: SavedStateRegistryImpl,
) {

    public actual val savedStateRegistry: SavedStateRegistry = SavedStateRegistry(impl)

    @MainThread
    public actual fun performAttach() {
        impl.performAttach()
    }

    @MainThread
    public actual fun performRestore(savedState: SavedState?) {
        impl.performRestore(savedState)
    }

    @MainThread
    public actual fun performSave(outBundle: SavedState) {
        impl.performSave(outBundle)
    }

    public actual companion object {

        @JvmStatic
        public actual fun create(owner: SavedStateRegistryOwner): SavedStateRegistryController {
            val impl =
                SavedStateRegistryImpl(
                    owner = owner,
                    onAttach = { owner.lifecycle.addObserver(Recreator(owner)) },
                )
            return SavedStateRegistryController(impl)
        }
    }
}
</div><p id="qin34a_115">И видим, что вызовами методов <code class="code" id="qin34a_368">SavedStateRegistryImpl.performSave</code> и <code class="code" id="qin34a_369">SavedStateRegistryImpl.performRestore</code> управляют одноимённые методы из <code class="code" id="qin34a_370">SavedStateRegistryController</code>.</p><p id="qin34a_116">Также видим метод <code class="code" id="qin34a_371">create</code>, который создаёт <code class="code" id="qin34a_372">SavedStateRegistryImpl</code>, передаёт его в конструктор <code class="code" id="qin34a_373">SavedStateRegistryController</code> и возвращает сам <code class="code" id="qin34a_374">SavedStateRegistryController</code>.</p><p id="qin34a_117">Далее остаётся только понять, откуда вызываются сами методы <code class="code" id="qin34a_375">SavedStateRegistryController</code>. В начале статьи мы отложили разбор источника поля <code class="code" id="qin34a_376">savedStateRegistry</code> в <code class="code" id="qin34a_377">Activity</code>. Сейчас самое время разобраться.</p><p id="qin34a_118">Внутри <code class="code" id="qin34a_378">Activity</code> нам доступно поле <code class="code" id="qin34a_379">savedStateRegistry</code>. Это возможно потому, что <code class="code" id="qin34a_380">Activity</code> реализует интерфейс <code class="code" id="qin34a_381">SavedStateRegistryOwner</code>. Если посмотреть исходники, то можно увидеть, что <code class="code" id="qin34a_382">ComponentActivity</code> реализует <code class="code" id="qin34a_383">SavedStateRegistryOwner</code>. На самом деле <code class="code" id="qin34a_384">ComponentActivity</code> реализует множество интерфейсов, но ниже приведён фрагмент с опущенными остальными родителями:</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    private val savedStateRegistryController: SavedStateRegistryController =
        SavedStateRegistryController.create(this)

    final override val savedStateRegistry: SavedStateRegistry
        get() = savedStateRegistryController.savedStateRegistry
}
</div><p id="qin34a_120"><code class="code" id="qin34a_385">SavedStateRegistryOwner</code> - это просто interface который хранит в себе <code class="code" id="qin34a_386">SavedStateRegistry</code>, его реализует <code class="code" id="qin34a_387">Activity</code>, <code class="code" id="qin34a_388">Fragment</code> и <code class="code" id="qin34a_389">NavBackStackEntry</code>, выглядит он следующим образом:</p><div class="code-block" data-lang="kotlin">
public interface SavedStateRegistryOwner : androidx.lifecycle.LifecycleOwner {
    /** The [SavedStateRegistry] owned by this SavedStateRegistryOwner */
    public val savedStateRegistry: SavedStateRegistry
}
</div><p id="qin34a_122"><code class="code" id="qin34a_390">SavedStateRegistry</code> доступен в любом компоненте, реализующем интерфейс <code class="code" id="qin34a_391">SavedStateRegistryOwner</code>. Этим интерфейсом обладают:</p><ul class="list _bullet" id="qin34a_123"><li class="list__item" id="qin34a_392"><p id="qin34a_395"><code class="code" id="qin34a_397">ComponentActivity</code> &mdash; это базовый класс для всех современных <code class="code" id="qin34a_398">Activity</code>.</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    private val savedStateRegistryController: SavedStateRegistryController =
        SavedStateRegistryController.create(this)

    final override val savedStateRegistry: SavedStateRegistry
        get() = savedStateRegistryController.savedStateRegistry
}
</div></li><li class="list__item" id="qin34a_393"><p id="qin34a_399"><code class="code" id="qin34a_401">Fragment</code> &mdash; любой <code class="code" id="qin34a_402">Fragment</code> также реализует этот интерфейс.</p><div class="code-block" data-lang="java">
public class Fragment implements ...SavedStateRegistryOwner,...{

    SavedStateRegistryController mSavedStateRegistryController;

    @NonNull
    @Override
    public final SavedStateRegistry getSavedStateRegistry() {
        return mSavedStateRegistryController.getSavedStateRegistry();
    }
}
</div></li><li class="list__item" id="qin34a_394"><p id="qin34a_403"><code class="code" id="qin34a_405">NavBackStackEntry</code> - компонент навигаций из Jetpack Navigation</p><div class="code-block" data-lang="kotlin">
public expect class NavBackStackEntry : ..., SavedStateRegistryOwner {

    override val savedStateRegistry: SavedStateRegistry

}
</div></li></ul><p id="qin34a_124">Мы выяснили большую цепочку вызовов, давайте визуально посмотрим:</p><div class="code-block" data-lang="nginx">
expect -&gt; SavedStateRegistryController.performSave 
  -&gt; actual SavedStateRegistryController.performSave 
  -&gt; expect SavedStateRegistry 
  -&gt; actual SavedStateRegistry 
  -&gt; SavedStateRegistryImpl.performSave 
  -&gt; SavedStateProvider.saveState() 
  -&gt; // Bundle
</div><p id="qin34a_126">Углубляться в работу <code class="code" id="qin34a_406">Fragment</code> и <code class="code" id="qin34a_407">NavBackStackEntry</code> не будем &mdash; разберёмся только с <code class="code" id="qin34a_408">Activity</code>. На данный момент мы понимаем, что в конечном итоге все вызовы идут в <code class="code" id="qin34a_409">SavedStateRegistryController</code>. Давай посмотрим, как <code class="code" id="qin34a_410">Activity</code> с ним взаимодействует:</p><p id="qin34a_127">Метод <code class="code" id="qin34a_411">performRestore</code> у <code class="code" id="qin34a_412">SavedStateRegistryController</code>, отвечающий за восстановление данных из <code class="code" id="qin34a_413">Bundle</code>, вызывается внутри <code class="code" id="qin34a_414">ComponentActivity.onCreate</code>, а метод <code class="code" id="qin34a_415">performSave</code>, сохраняющий данные в <code class="code" id="qin34a_416">Bundle</code>, &mdash; внутри <code class="code" id="qin34a_417">ComponentActivity.onSaveInstanceState</code>.</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    override fun onCreate(savedInstanceState: Bundle?) {
        savedStateRegistryController.performRestore(savedInstanceState)
        super.onCreate(savedInstanceState)
        ...
    }

    @CallSuper
    override fun onSaveInstanceState(outState: Bundle) {
        ...
        super.onSaveInstanceState(outState)
        savedStateRegistryController.performSave(outState)
    }
}
</div><p id="qin34a_129">Здесь та самая точка, где <code class="code" id="qin34a_418">onSaveInstanceState</code>/<code class="code" id="qin34a_419">onRestoreInstanceState</code> объединяются с <code class="code" id="qin34a_420">SavedStateRegistryController</code>/<code class="code" id="qin34a_421">SavedStateRegistry</code>.</p><p id="qin34a_130">Теперь переключимся на <code class="code" id="qin34a_422">ViewModel</code> и его <code class="code" id="qin34a_423">SavedStateHandle</code>, чтобы понять, как он вписывается во всю эту логику. Для начала объявим обычную <code class="code" id="qin34a_424">ViewModel</code>, но в конструкторе передадим <code class="code" id="qin34a_425">SavedStateHandle</code>:</p><div class="code-block" data-lang="kotlin">
class MyViewModel(val savedStateHandle: SavedStateHandle) : ViewModel()
</div><aside class="prompt" data-type="note" data-title="" id="qin34a_132"><p>Как и говорилось в начале статьи, это не гайд по тому как пользоваться Saved State Api, тут больше ответ на вопрос как это работает под капотом</p></aside><p id="qin34a_133">Далее пробуем инициализировать нашу ViewModel в Activity:</p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {

    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        viewModel = ViewModelProvider.create(this).get(MyViewModel::class)
    }

}
</div><p id="qin34a_135">Тут на первый взгляд можно ожидать, что будет краш при запуске приложения, так как если <code class="code" id="qin34a_426">ViewModel</code> на вход принимает какой-либо параметр, то нужна фабрика <code class="code" id="qin34a_427">ViewModel</code>, он же <code class="code" id="qin34a_428">ViewModelProvider.Factory</code>, где мы вручную должны каким-то образом положить требуемый параметр в конструктор. И в нашем примере конструктор не пустой, но если мы запустим этот код, то никакого краша и ошибки не будет, всё запустится и инициализируется должным образом. Почему так?</p><p id="qin34a_136">Разработчики из google знали что часто понадобиться передавать <code class="code" id="qin34a_429">SavedStateHandle</code> в <code class="code" id="qin34a_430">ViewModel</code>, и что бы разработчикам не приходилось каждый раз создавать фабрику для передачи - имеется готовая фабрика которая работает под капотом, так же имеются готовые классы вроде</p><p id="qin34a_137"><code class="code" id="qin34a_431">AbstractSavedStateViewModelFactory</code> - начиная с lifecycle-viewmodel-savedstate-android-<span class="control" id="qin34a_432">2.9.0</span> - обьявлен устаревшим <code class="code" id="qin34a_433">SavedStateViewModelFactory</code> - актуален на данный момент для создания ViewModel с SavedStateHandle</p><p id="qin34a_138">Давайте теперь посмотрим как это работает на уровне <code class="code" id="qin34a_434">Activity</code>, логику <code class="code" id="qin34a_435">ViewModelProvider/ViewModel</code> мы уже рассматривали в прошлых статьях, сейчас просто пройдемся по интересующей нас теме, когда мы обращаемся к <code class="code" id="qin34a_436">ViewModelProvider.create</code>:</p><div class="code-block" data-lang="kotlin">
public expect class ViewModelProvider {
    public companion object {
        ...
        public fun create(
            owner: ViewModelStoreOwner,
            factory: Factory = ViewModelProviders.getDefaultFactory(owner),
            extras: CreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
        ): ViewModelProvider

    }
}
</div><p id="qin34a_140">То видим что в качестве factory идет обращение к методу <code class="code" id="qin34a_437">ViewModelProviders.getDefaultFactory(owner)</code>, посмотрим его исходники тоже:</p><div class="code-block" data-lang="kotlin">
internal object ViewModelProviders {
    internal fun getDefaultFactory(owner: ViewModelStoreOwner): ViewModelProvider.Factory =
        if (owner is HasDefaultViewModelProviderFactory) {
            owner.defaultViewModelProviderFactory
        } else {
            DefaultViewModelProviderFactory
        }
}
</div><aside class="prompt" data-type="note" data-title="" id="qin34a_142"><p id="qin34a_438">ViewModelProvider<span class="control" id="qin34a_439">s</span> &mdash; это утилитный класс, не стоит путать его с <code class="code" id="qin34a_440">ViewModelProvider</code>.</p></aside><p id="qin34a_143">В этом методе нас интересует проверка на <code class="code" id="qin34a_441">is HasDefaultViewModelProviderFactory</code>:</p><div class="code-block" data-lang="kotlin">
if (owner is HasDefaultViewModelProviderFactory) {
    owner.defaultViewModelProviderFactory
}
</div><p id="qin34a_145">Если <code class="code" id="qin34a_442">owner</code> (<code class="code" id="qin34a_443">ViewModelStoreOwner</code>, например <code class="code" id="qin34a_444">Activity</code> или <code class="code" id="qin34a_445">Fragment</code>) реализует интерфейс <code class="code" id="qin34a_446">HasDefaultViewModelProviderFactory</code>, то у него берётся поле <code class="code" id="qin34a_447">defaultViewModelProviderFactory</code>. Интерфейс <code class="code" id="qin34a_448">HasDefaultViewModelProviderFactory</code> выглядит следующим образом: <span class="control" id="qin34a_449">androidx.lifecycle.HasDefaultViewModelProviderFactory.android.kt</span></p><div class="code-block" data-lang="kotlin">
public interface HasDefaultViewModelProviderFactory {

    public val defaultViewModelProviderFactory: ViewModelProvider.Factory

    public val defaultViewModelCreationExtras: CreationExtras
        get() = CreationExtras.Empty
}
</div><p id="qin34a_147">Реализация интерфейса <code class="code" id="qin34a_450">HasDefaultViewModelProviderFactory</code> в <code class="code" id="qin34a_451">Activity</code>:</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, HasDefaultViewModelProviderFactory, ... {
    ...
    override val defaultViewModelProviderFactory: ViewModelProvider.Factory by lazy {
        SavedStateViewModelFactory(application, this, if (intent != null) intent.extras else null)
    }

    @get:CallSuper
    override val defaultViewModelCreationExtras: CreationExtras
        /**
         * {@inheritDoc}
         *
         * The extras of [getIntent] when this is first called will be used as the defaults to any
         * [androidx.lifecycle.SavedStateHandle] passed to a view model created using this extra.
         */
        get() {
            val extras = MutableCreationExtras()
            if (application != null) {
                extras[APPLICATION_KEY] = application
            }
            extras[SAVED_STATE_REGISTRY_OWNER_KEY] = this
            extras[VIEW_MODEL_STORE_OWNER_KEY] = this
            val intentExtras = intent?.extras
            if (intentExtras != null) {
                extras[DEFAULT_ARGS_KEY] = intentExtras
            }
            return extras
        }
    ...
}
</div><p id="qin34a_149">Тут происходят два очень важных момента:</p><ol class="list _decimal" id="qin34a_150" type="1"><li class="list__item" id="qin34a_452"><p id="qin34a_454"><code class="code" id="qin34a_455">defaultViewModelProviderFactory</code> &mdash; в качестве фабрики по умолчанию используется <code class="code" id="qin34a_456">SavedStateViewModelFactory</code>.</p></li><li class="list__item" id="qin34a_453"><p id="qin34a_457"><code class="code" id="qin34a_458">defaultViewModelCreationExtras</code> &mdash; в <code class="code" id="qin34a_459">CreationExtras</code> кладётся <code class="code" id="qin34a_460">SavedStateRegistryOwner</code> под ключом <code class="code" id="qin34a_461">SAVED_STATE_REGISTRY_OWNER_KEY</code> и <code class="code" id="qin34a_462">ViewModelStoreOwner</code> под ключом <code class="code" id="qin34a_463">VIEW_MODEL_STORE_OWNER_KEY</code>.</p></li></ol><p id="qin34a_151">Это ключевая часть того как в итоге <code class="code" id="qin34a_464">SavedStateHandle</code> подключается к <code class="code" id="qin34a_465">ViewModel</code> и к <code class="code" id="qin34a_466">SavedStateRegistryOwner</code></p><p id="qin34a_152">Чтобы понять, как <code class="code" id="qin34a_467">SavedStateHandle</code> создаётся и восстанавливается для <code class="code" id="qin34a_468">ViewModel</code>, давайте разберёмся, что происходит в <code class="code" id="qin34a_469">SavedStateViewModelFactory</code></p><p id="qin34a_153"><span class="control" id="qin34a_470">androidx.lifecycle.SavedStateViewModelFactory.android.kt:</span></p><div class="code-block" data-lang="kotlin">
public actual class SavedStateViewModelFactory :
    ViewModelProvider.OnRequeryFactory, ViewModelProvider.Factory {

    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T {
        ...
        return if (
            extras[SAVED_STATE_REGISTRY_OWNER_KEY] != null &amp;&amp;
            extras[VIEW_MODEL_STORE_OWNER_KEY] != null
        ) {
            ...
            newInstance(modelClass, constructor, extras.createSavedStateHandle())
            ...
        }
        ...
    }
}

internal fun &lt;T : ViewModel?&gt; newInstance(
    modelClass: Class&lt;T&gt;,
    constructor: Constructor&lt;T&gt;,
    vararg params: Any
): T {
    return try {
        constructor.newInstance(*params)
    }
    ...
}
</div><p id="qin34a_155">Тут сокращена логика из исходников, чтобы сосредоточиться на главном. Внутри метода <code class="code" id="qin34a_471">create</code> у фабрики проверяется, содержат ли <code class="code" id="qin34a_472">extras</code>поля с ключами <code class="code" id="qin34a_473">SAVED_STATE_REGISTRY_OWNER_KEY</code> и <code class="code" id="qin34a_474">VIEW_MODEL_STORE_OWNER_KEY</code>. Если содержат &mdash; вызывается метод <code class="code" id="qin34a_475">newInstance</code>, который через рефлексию вызывает конструктор и передаёт параметры, одним из которых является <code class="code" id="qin34a_476">SavedStateHandle</code>.</p><p id="qin34a_156">Но нас интересует другой момент. Обратим внимание на вызов <code class="code" id="qin34a_477">createSavedStateHandle()</code>:</p><div class="code-block" data-lang="kotlin">
newInstance(modelClass, constructor, extras.createSavedStateHandle())
</div><p id="qin34a_158">Что происходит внутри <code class="code" id="qin34a_478">createSavedStateHandle()</code>? Чтобы понять, как создаётся <code class="code" id="qin34a_479">SavedStateHandle</code>, нужно заглянуть в исходный код этого метода:</p><p id="qin34a_159"><span class="control" id="qin34a_480">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="code-block" data-lang="kotlin">
@MainThread
public fun CreationExtras.createSavedStateHandle(): SavedStateHandle {
    val savedStateRegistryOwner =
        this[SAVED_STATE_REGISTRY_OWNER_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `SAVED_STATE_REGISTRY_OWNER_KEY`&quot;
            )
    val viewModelStateRegistryOwner =
        this[VIEW_MODEL_STORE_OWNER_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `VIEW_MODEL_STORE_OWNER_KEY`&quot;
            )

    val defaultArgs = this[DEFAULT_ARGS_KEY]
    val key =
        this[VIEW_MODEL_KEY]
            ?: throw IllegalArgumentException(
                &quot;CreationExtras must have a value by `VIEW_MODEL_KEY`&quot;
            )
    return createSavedStateHandle(
        savedStateRegistryOwner,
        viewModelStateRegistryOwner,
        key,
        defaultArgs
    )
}
</div><p id="qin34a_161">Здесь из CreationExtras извлекаются три ключевых объекта:</p><ol class="list _decimal" id="qin34a_162" type="1"><li class="list__item" id="qin34a_481"><p id="qin34a_484">savedStateRegistryOwner &mdash; ссылка на SavedStateRegistry для управления состоянием.</p></li><li class="list__item" id="qin34a_482"><p id="qin34a_485">viewModelStateRegistryOwner &mdash; ссылка на ViewModelStore для привязки к жизненному циклу.</p></li><li class="list__item" id="qin34a_483"><p id="qin34a_486">defaultArgs &mdash; начальные параметры, если они были переданы.</p></li></ol><p id="qin34a_163">Все эти зависимости передаются в другой метод <code class="code" id="qin34a_487">createSavedStateHandle</code>, который как раз и занимается созданием или восстановлением SavedStateHandle для данной ViewModel.</p><p id="qin34a_164"><span class="control" id="qin34a_488">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="code-block" data-lang="kotlin">
private fun createSavedStateHandle(
    savedStateRegistryOwner: SavedStateRegistryOwner,
    viewModelStoreOwner: ViewModelStoreOwner,
    key: String,
    defaultArgs: SavedState?
): SavedStateHandle {
    val provider = savedStateRegistryOwner.savedStateHandlesProvider
    val viewModel = viewModelStoreOwner.savedStateHandlesVM
    return viewModel.handles[key]
        ?: SavedStateHandle.createHandle(provider.consumeRestoredStateForKey(key), defaultArgs)
            .also { viewModel.handles[key] = it }
}
</div><p id="qin34a_166">Тут сначала ищется нужный <code class="code" id="qin34a_489">SavedStateHandle</code> внутри <code class="code" id="qin34a_490">SavedStateHandlesVM</code>. Если он не найден &mdash; создаётся новый, сохраняется в <code class="code" id="qin34a_491">SavedStateHandlesVM</code>, а функция <code class="code" id="qin34a_492">createSavedStateHandle</code> возвращает управление обратно в <code class="code" id="qin34a_493">CreationExtras.createSavedStateHandle()</code>, которую мы уже видели. В конечном итоге управление возвращается в фабрику, таким образом создаётся <code class="code" id="qin34a_494">SavedStateHandle</code> для конкретной <code class="code" id="qin34a_495">ViewModel</code>.</p><p id="qin34a_167">Также в этом методе видим вызовы вроде <code class="code" id="qin34a_496">savedStateRegistryOwner.savedStateHandlesProvider</code> и <code class="code" id="qin34a_497">viewModelStoreOwner.savedStateHandlesVM</code>.</p><p id="qin34a_168">Теперь посмотрим, как это связано с провайдером. В коде вызывается <code class="code" id="qin34a_498">savedStateRegistryOwner.savedStateHandlesProvider</code>. На самом деле это просто extension свойство, которая вытаскивает объект (<code class="code" id="qin34a_499">SavedStateProvider</code>) из <code class="code" id="qin34a_500">SavedStateRegistry</code>.</p><p id="qin34a_169">Этот провайдер отвечает за доступ ко всем сохранённым состояниям (<code class="code" id="qin34a_501">SavedStateHandle</code>), привязанным к разным <code class="code" id="qin34a_502">ViewModel</code>. Перейдем к провайдеру: <code class="code" id="qin34a_503">savedStateHandlesProvider</code></p><p id="qin34a_170"><span class="control" id="qin34a_504">androidx.lifecycle.SavedStateHandleSupport.kt:</span></p><div class="code-block" data-lang="kotlin">
internal val SavedStateRegistryOwner.savedStateHandlesProvider: SavedStateHandlesProvider
get() =
    savedStateRegistry.getSavedStateProvider(SAVED_STATE_KEY) as? SavedStateHandlesProvider
        ?: throw IllegalStateException(
            &quot;enableSavedStateHandles() wasn't called &quot; +
                    &quot;prior to createSavedStateHandle() call&quot;
        )

internal class SavedStateHandlesProvider(
    private val savedStateRegistry: SavedStateRegistry,
    viewModelStoreOwner: ViewModelStoreOwner
) : SavedStateRegistry.SavedStateProvider {
    private var restored = false
    private var restoredState: SavedState? = null

    private val viewModel by lazy { viewModelStoreOwner.savedStateHandlesVM }

    override fun saveState(): SavedState {
        return savedState {
            restoredState?.let { putAll(it) }
            viewModel.handles.forEach { (key, handle) -&gt;
                val savedState = handle.savedStateProvider().saveState()
                if (savedState.read { !isEmpty() }) {
                    putSavedState(key, savedState)
                }
            }
            restored = false
        }
    }

    fun performRestore() {
        ...
    }

    fun consumeRestoredStateForKey(key: String): SavedState? {
        ...
    }
}
</div><p id="qin34a_172"><code class="code" id="qin34a_505">SavedStateHandlesProvider</code> &mdash; это прослойка между <code class="code" id="qin34a_506">SavedStateRegistry</code> и <code class="code" id="qin34a_507">SavedStateHandle</code>, обеспечивающая централизованное сохранение и восстановление состояний <code class="code" id="qin34a_508">ViewModel</code>. В методе <code class="code" id="qin34a_509">saveState()</code> собираются все актуальные состояния из <code class="code" id="qin34a_510">viewModel.handles</code>, добавляется возможное ранее восстановленное состояние, и итог сохраняется в <code class="code" id="qin34a_511">SavedStateRegistry</code>.</p><p id="qin34a_173">Для выборочного восстановления используется метод <code class="code" id="qin34a_512">consumeRestoredStateForKey()</code>, позволяющий получить состояние по ключу без необходимости загружать всё сразу. Восстановление и подготовка состояний происходят в <code class="code" id="qin34a_513">performRestore()</code>.</p><p id="qin34a_174">По сути, <code class="code" id="qin34a_514">SavedStateHandlesProvider</code> управляет жизненным циклом всех <code class="code" id="qin34a_515">SavedStateHandle</code> в рамках владельца состояния, поддерживая логику ленивого восстановления и гарантируя корректное сохранение после процесса или конфигурационных изменений.</p><p id="qin34a_175"><span class="control" id="qin34a_516">Взаимодействие с <code class="code" id="qin34a_517">SavedStateHandlesVM</code>:</span></p><p id="qin34a_176">Теперь перейдём к тому, как данные хранятся внутри <code class="code" id="qin34a_518">ViewModel</code>. <code class="code" id="qin34a_519">savedStateHandlesVM</code> &mdash; это расширение, которое создаёт или восстанавливает объект <code class="code" id="qin34a_520">SavedStateHandlesVM</code>, хранящий в себе Map из ключей на <code class="code" id="qin34a_521">SavedStateHandle</code>:</p><div class="code-block" data-lang="kotlin">
internal val ViewModelStoreOwner.savedStateHandlesVM: SavedStateHandlesVM
get() =
    ViewModelProvider.create(
        owner = this,
        factory =
            object : ViewModelProvider.Factory {
                override fun &lt;T : ViewModel&gt; create(
                    modelClass: KClass&lt;T&gt;,
                    extras: CreationExtras
                ): T {
                    @Suppress(&quot;UNCHECKED_CAST&quot;) return SavedStateHandlesVM() as T
                }
            }
    )[VIEWMODEL_KEY, SavedStateHandlesVM::class]

internal class SavedStateHandlesVM : ViewModel() {
    val handles = mutableMapOf&lt;String, SavedStateHandle&gt;()
}
</div><p id="qin34a_178">Здесь создаётся объект <code class="code" id="qin34a_522">SavedStateHandlesVM</code>, внутри которого поддерживается <code class="code" id="qin34a_523">Map</code>, связывающая ключи с объектами <code class="code" id="qin34a_524">SavedStateHandle</code>. <code class="code" id="qin34a_525">SavedStateHandlesVM</code> нужен для того, чтобы хранить и управлять всеми <code class="code" id="qin34a_526">SavedStateHandle</code> всех <code class="code" id="qin34a_527">ViewModel</code> в рамках одного <code class="code" id="qin34a_528">ViewModelStoreOwner</code> и <code class="code" id="qin34a_529">SavedStateRegistryOwner</code>.</p><p id="qin34a_179"><code class="code" id="qin34a_530">SavedStateHandlesProvider</code> &mdash; класс, реализующий интерфейс <code class="code" id="qin34a_531">SavedStateProvider</code>. Когда <code class="code" id="qin34a_532">SavedStateController</code> вызывает <code class="code" id="qin34a_533">performSave</code>, он также обращается к <code class="code" id="qin34a_534">SavedStateHandlesProvider</code> и вызывает его метод <code class="code" id="qin34a_535">saveState</code>. Далее он кладёт все существующие <code class="code" id="qin34a_536">SavedStateHandle</code> в объект <code class="code" id="qin34a_537">SavedState</code> (<code class="code" id="qin34a_538">Bundle</code>) и возвращает его.</p><p id="qin34a_180">Но чтобы весь этот процесс работал, необходимо зарегистрировать <code class="code" id="qin34a_539">SavedStateHandlesProvider</code> в <code class="code" id="qin34a_540">SavedStateRegistry</code>, однако пока что в коде мы не встретили блок, отвечающий за регистрацию провайдера, то есть вызов метода: <code class="code" id="qin34a_541">savedStateRegistry.registerSavedStateProvider(...)</code></p><p id="qin34a_181">На самом деле такая логика есть, и она триггерится внутри <code class="code" id="qin34a_542">ComponentActivity</code>, <code class="code" id="qin34a_543">Fragment</code> и <code class="code" id="qin34a_544">NavBackStackEntry</code>, то есть во всех <code class="code" id="qin34a_545">SavedStateRegistryOwner</code>. Давайте просто глянем, как это вызывается в <code class="code" id="qin34a_546">ComponentActivity</code>:</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    init {
        ...
        enableSavedStateHandles()
        ...
    }
}
</div><p id="qin34a_183">Видим вызов некого метода <code class="code" id="qin34a_547">enableSavedStateHandles</code> &mdash; само название звучит заманчиво. Далее &mdash; исходники метода <code class="code" id="qin34a_548">enableSavedStateHandles</code>:</p><div class="code-block" data-lang="kotlin">
@MainThread
public fun &lt;T&gt; T.enableSavedStateHandles() where T : SavedStateRegistryOwner, T : ViewModelStoreOwner {
    ...
    if (savedStateRegistry.getSavedStateProvider(SAVED_STATE_KEY) == null) {
        val provider = SavedStateHandlesProvider(savedStateRegistry, this)
        savedStateRegistry.registerSavedStateProvider(SAVED_STATE_KEY, provider)
        lifecycle.addObserver(SavedStateHandleAttacher(provider))
    }
}
</div><p id="qin34a_185"><code class="code" id="qin34a_549">enableSavedStateHandles</code> &mdash; это типизированный метод, который требует, чтобы вызывающая область одновременно являлась и <code class="code" id="qin34a_550">SavedStateRegistryOwner</code>, и <code class="code" id="qin34a_551">ViewModelStoreOwner</code>. <code class="code" id="qin34a_552">ComponentActivity</code>/<code class="code" id="qin34a_553">Fragment</code>/<code class="code" id="qin34a_554">NavBackStackEntry</code> идеально подходят под это &mdash; все трое реализуют оба интерфейса.</p><p id="qin34a_186">Давайте вкратце поймём, что происходит в этом методе. Для начала у <code class="code" id="qin34a_555">SavedStateRegistry</code> запрашивается сохранённый <code class="code" id="qin34a_556">provider</code> (<code class="code" id="qin34a_557">SavedStateProvider</code>) по ключу <code class="code" id="qin34a_558">SAVED_STATE_KEY</code>. Это ключ для хранения <code class="code" id="qin34a_559">SavedStateHandlesProvider</code> (он же <code class="code" id="qin34a_560">SavedStateProvider</code>).</p><p id="qin34a_187">Если по ключу ничего не найдено, то есть <code class="code" id="qin34a_561">null</code>, это означает, что <code class="code" id="qin34a_562">provider</code> ещё не был зарегистрирован. Тогда создаётся объект <code class="code" id="qin34a_563">SavedStateHandlesProvider</code> (он же <code class="code" id="qin34a_564">SavedStateProvider</code>) и регистрируется в <code class="code" id="qin34a_565">savedStateRegistry</code>.</p><p id="qin34a_188">Мы подробно разобрали, как механизм <code class="code" id="qin34a_566">SavedStateHandle</code> автоматически создаётся и подключается к <code class="code" id="qin34a_567">ViewModel</code>. Это достигается за счёт встроенного механизма фабрики <code class="code" id="qin34a_568">SavedStateViewModelFactory</code>, которая при создании ViewModel извлекает необходимые зависимости из объекта <code class="code" id="qin34a_569">CreationExtras</code>. Эти зависимости включают в себя:</p><ol class="list _decimal" id="qin34a_189" type="1"><li class="list__item" id="qin34a_570"><p id="qin34a_573"><span class="control" id="qin34a_574">SavedStateRegistryOwner</span> &mdash; для управления сохранением и восстановлением состояния.</p></li><li class="list__item" id="qin34a_571"><p id="qin34a_575"><span class="control" id="qin34a_576">ViewModelStoreOwner</span> &mdash; для привязки жизненного цикла ViewModel.</p></li><li class="list__item" id="qin34a_572"><p id="qin34a_577"><span class="control" id="qin34a_578">DefaultArgs</span> &mdash; начальные параметры, если они были переданы.</p></li></ol><p id="qin34a_190">В момент инициализации ViewModel, фабрика <code class="code" id="qin34a_579">SavedStateViewModelFactory</code> через метод <code class="code" id="qin34a_580">createSavedStateHandle</code> формирует объект <code class="code" id="qin34a_581">SavedStateHandle</code>. Этот объект связывается с <code class="code" id="qin34a_582">SavedStateRegistry</code> и регистрируется в нём посредством специального провайдера &mdash; <code class="code" id="qin34a_583">SavedStateHandlesProvider</code> (SavedStateProvider).</p><p id="qin34a_191">Механизм регистрации провайдера запускается автоматически при создании <code class="code" id="qin34a_584">ComponentActivity</code>, <code class="code" id="qin34a_585">Fragment</code> или <code class="code" id="qin34a_586">NavBackStackEntry</code>. Это обеспечивается вызовом метода <code class="code" id="qin34a_587">enableSavedStateHandles</code>, который регистрирует провайдер в <code class="code" id="qin34a_588">SavedStateRegistry</code> под ключом <code class="code" id="qin34a_589">SAVED_STATE_KEY</code>. В дальнейшем, при вызове <code class="code" id="qin34a_590">onSaveInstanceState</code>, этот провайдер сохраняет все текущие состояния из SavedStateHandle, привязанные к ключам <code class="code" id="qin34a_591">ViewModel</code>.</p><p id="qin34a_192">Таким образом, когда компонент пересоздаётся (например, при смене ориентации экрана или в случае уничтожения и восстановления Activity), механизм восстановления срабатывает автоматически. <code class="code" id="qin34a_592">SavedStateRegistry</code> восстанавливает состояние из провайдера, а <code class="code" id="qin34a_593">SavedStateHandle</code> вновь связывается с ViewModel, обеспечивая прозрачную работу с сохранёнными данными.</p><p id="qin34a_193">Это позволяет нам не заботиться о ручной передаче сохранённого состояния при каждом пересоздании ViewModel. Android-фреймворк делает это за нас, используя мощный механизм фабрик и хранилищ состояний, что делает <code class="code" id="qin34a_594">SavedStateHandle</code> удобным и надежным инструментом для управления состоянием внутри ViewModel.</p><p id="qin34a_194">На текущий момент мы понимаем, как <code class="code" id="qin34a_595">SavedStateHandle</code> работает в связке с <code class="code" id="qin34a_596">ViewModel</code> и как он в итоге соединяется с <code class="code" id="qin34a_597">SavedStateRegistry</code>. Также до этого мы узнали, как работают сам <code class="code" id="qin34a_598">SavedStateRegistry</code> и <code class="code" id="qin34a_599">SavedStateRegistryController</code>, и увидели их связь с методами <code class="code" id="qin34a_600">onSaveInstanceState</code> и <code class="code" id="qin34a_601">onRestoreInstanceState</code>.</p><p id="qin34a_195">Оказалось, что и <code class="code" id="qin34a_602">Saved State API</code>, и древние методы <code class="code" id="qin34a_603">onSaveInstanceState</code>/<code class="code" id="qin34a_604">onRestoreInstanceState</code> в конечном итоге работают по одному и тому же пути. Давайте вернёмся к точке, где они встречаются. Далее &mdash; код, который мы уже видели:</p><div class="code-block" data-lang="kotlin">
open class ComponentActivity() : ..., SavedStateRegistryOwner, ... {

    override fun onCreate(savedInstanceState: Bundle?) {
        savedStateRegistryController.performRestore(savedInstanceState)
        super.onCreate(savedInstanceState)
        ...
    }

    @CallSuper
    override fun onSaveInstanceState(outState: Bundle) {
        ...
        super.onSaveInstanceState(outState)
        savedStateRegistryController.performSave(outState)
    }
}
</div><p id="qin34a_197">То есть в стандартной практике при использовании механизма сохранения состояния применяются два метода:</p><ul class="list _bullet" id="qin34a_198"><li class="list__item" id="qin34a_605"><p id="qin34a_607"><code class="code" id="qin34a_608">onCreate</code> &mdash; получает на вход параметр <code class="code" id="qin34a_609">savedInstanceState</code> типа <code class="code" id="qin34a_610">Bundle</code>. Именно в этом методе читаются сохранённые значения.</p></li><li class="list__item" id="qin34a_606"><p id="qin34a_611"><code class="code" id="qin34a_612">onSaveInstanceState</code> &mdash; получает на вход параметр <code class="code" id="qin34a_613">outState</code> типа <code class="code" id="qin34a_614">Bundle</code>. В этот параметр записываются значения, которые должны быть сохранены.</p></li></ul><p id="qin34a_199">Давайте разберёмся, каким образом вся эта конструкция работает: как значения, сохранённые в <code class="code" id="qin34a_615">outState</code> метода <code class="code" id="qin34a_616">onSaveInstanceState</code>, переживают изменение конфигурации и даже смерть процесса, и как эти сохранённые данные возвращаются обратно в <code class="code" id="qin34a_617">onCreate</code>.</p><p id="qin34a_200">Посмотрим на реализацию метода <code class="code" id="qin34a_618">onSaveInstanceState</code> в <code class="code" id="qin34a_619">super</code>, то есть в самом классе <code class="code" id="qin34a_620">Activity</code>:</p><div class="code-block" data-lang="java">
public class Activity extends ContextThemeWrapper ...{

final void performSaveInstanceState(@NonNull Bundle outState) {
       ...
    onSaveInstanceState(outState);
       ...
}

protected void onSaveInstanceState(@NonNull Bundle outState) {
       ...
}
}
</div><p id="qin34a_202">Всё, что происходит внутри этого метода, нас сейчас не волнует. Главное, что <code class="code" id="qin34a_621">onSaveInstanceState</code> вызывает другой финальный метод &mdash; <code class="code" id="qin34a_622">performSaveInstanceState</code>.</p><p id="qin34a_203">Теперь давайте поймём, кто вызывает <code class="code" id="qin34a_623">performSaveInstanceState</code>. Этот вызов инициируется классом <code class="code" id="qin34a_624">Instrumentation</code>:</p><p id="qin34a_204"><span class="control" id="qin34a_625">android.app.Instrumentation.java:</span></p><div class="code-block" data-lang="java">

@android.ravenwood.annotation.RavenwoodKeepPartialClass
public class Instrumentation {
   ...

    public void callActivityOnSaveInstanceState(@NonNull Activity activity,
                                                @NonNull Bundle outState) {
        activity.performSaveInstanceState(outState);
    }
   ...
}
</div><aside class="prompt" data-type="note" data-title="Официальная документация гласит следующее об этом классе:" id="qin34a_206"><p>Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xml's </p><p> tag.</p></aside><p id="qin34a_207">Теперь нужно понять, кто же вызывает <code class="code" id="qin34a_627">Instrumentation.callActivityOnSaveInstanceState</code>? И тут мы встречаем <code class="code" id="qin34a_628">ActivityThread</code>:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {
    ...

    private void callActivityOnSaveInstanceState(ActivityClientRecord r) {
        r.state = new Bundle();
        r.state.setAllowFds(false);
        if (r.isPersistable()) {
            r.persistentState = new PersistableBundle();
            mInstrumentation.callActivityOnSaveInstanceState(
                    r.activity, r.state,
                    r.persistentState
            );
        } else {
            mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state);
        }
    }
   ...
}
</div><p id="qin34a_209">Что здесь происходит? <code class="code" id="qin34a_629">callActivityOnSaveInstanceState</code> на вход принимает параметр <code class="code" id="qin34a_630">r</code> типа <code class="code" id="qin34a_631">ActivityClientRecord</code>. У этого класса есть поле <code class="code" id="qin34a_632">state</code>, которое является <code class="code" id="qin34a_633">Bundle</code>. Ему присваивается новый объект <code class="code" id="qin34a_634">Bundle</code>.</p><p id="qin34a_210">Класс <code class="code" id="qin34a_635">ActivityClientRecord</code> мы уже встречали, когда рассматривали <code class="code" id="qin34a_636">ViewModelStore</code>. <code class="code" id="qin34a_637">ActivityClientRecord</code> представляет собой запись активности и используется для хранения всей информации, связанной с реальным экземпляром активности. Это своего рода структура данных для учёта активности в процессе выполнения приложения.</p><p id="qin34a_211">Основные поля класса <code class="code" id="qin34a_638">ActivityClientRecord</code>:</p><ul class="list _bullet" id="qin34a_212"><li class="list__item" id="qin34a_639"><p id="qin34a_647"><code class="code" id="qin34a_648">state</code> &mdash; объект <code class="code" id="qin34a_649">Bundle</code>, содержащий сохраненное состояние активности. Да, да, это тот самый Bundle который мы получаем в методе <code class="code" id="qin34a_650">onCreate</code>, <code class="code" id="qin34a_651">onRestoreInstanceState</code> и <code class="code" id="qin34a_652">onSaveInstanceState</code></p></li><li class="list__item" id="qin34a_640"><p id="qin34a_653"><code class="code" id="qin34a_654">lastNonConfigurationInstances</code> &mdash; объект <code class="code" id="qin34a_655">Activity#NonConfigurationInstance</code>, в котором хранится <code class="code" id="qin34a_656">ComponentActivity#NonConfigurationInstances</code> в котором хранится<code class="code" id="qin34a_657">ViewModelStore</code>.</p></li><li class="list__item" id="qin34a_641"><p id="qin34a_658"><code class="code" id="qin34a_659">intent</code> &mdash; объект <code class="code" id="qin34a_660">Intent</code>, представляющий намерение запуска активности.</p></li><li class="list__item" id="qin34a_642"><p id="qin34a_661"><code class="code" id="qin34a_662">window</code> &mdash; объект <code class="code" id="qin34a_663">Window</code>, связанный с активностью.</p></li><li class="list__item" id="qin34a_643"><p id="qin34a_664"><code class="code" id="qin34a_665">activity</code> &mdash; сам объект <code class="code" id="qin34a_666">Activity</code>.</p></li><li class="list__item" id="qin34a_644"><p id="qin34a_667"><code class="code" id="qin34a_668">parent</code> &mdash; родительская активность (если есть).</p></li><li class="list__item" id="qin34a_645"><p id="qin34a_669"><code class="code" id="qin34a_670">createdConfig</code> &mdash; объект <code class="code" id="qin34a_671">Configuration</code>, содержащий настройки, примененные при создании активности.</p></li><li class="list__item" id="qin34a_646"><p id="qin34a_672"><code class="code" id="qin34a_673">overrideConfig</code> &mdash; объект <code class="code" id="qin34a_674">Configuration</code>, содержащий текущие настройки активности.</p></li></ul><p id="qin34a_213">Пока что не будем отвлекаться, и узнаем кто же вызывает <code class="code" id="qin34a_675">callActivityOnSaveInstanceState</code>:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private void callActivityOnStop(ActivityClientRecord r, boolean saveState, String reason) {
        final boolean shouldSaveState = saveState &amp;&amp; !r.activity.mFinished &amp;&amp; r.state == null
                &amp;&amp; !r.isPreHoneycomb();
        final boolean isPreP = r.isPreP();
        if (shouldSaveState &amp;&amp; isPreP) {
            callActivityOnSaveInstanceState(r);
        }
        ...
    }

    private Bundle performPauseActivity(ActivityClientRecord r, boolean finished, String reason,
                                        PendingTransactionActions pendingActions) {
       ...
        final boolean shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();
        if (shouldSaveState) {
            callActivityOnSaveInstanceState(r);
        }
       ...
    }
}
</div><p id="qin34a_215">Метод callActivityOnStop определяет, нужно ли сохранять состояние активности перед остановкой. Проверяется флаг saveState, активность не должна быть завершена (!mFinished), состояние (r.state) должно быть ещё не сохранено, и версия должна быть до Honeycomb (!isPreHoneycomb()). Если все условия выполняются и версия до Android P (isPreP()), вызывается callActivityOnSaveInstanceState, чтобы создать и заполнить Bundle</p><p id="qin34a_216">Метод performPauseActivity проверяет, нужно ли сохранить состояние перед паузой. Здесь условия упрощены: активность не должна быть завершена, версия &mdash; до Honeycomb. Если да, то снова вызывается callActivityOnSaveInstanceState для формирования Bundle.</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private void performStopActivityInner(ActivityClientRecord r, StopInfo info,
                                          boolean saveState, boolean finalStateRequest, String reason) {
      ...
        callActivityOnStop(r, saveState, reason);
    }

    private void handleRelaunchActivityInner(@NonNull ActivityClientRecord r,...) {
       ...
        if (!r.stopped) {
            callActivityOnStop(r, true /* saveState */, reason);
        }
       ...
    }
}
</div><p id="qin34a_218">performStopActivityInner используется при полной остановке активности. Внутри сразу вызывается callActivityOnStop, который проверяет и, если нужно, инициирует сохранение состояния. Это гарантирует, что состояние активности попадёт в Bundle до того, как активность будет остановлена и уничтожена.</p><p id="qin34a_219">В handleRelaunchActivityInner вызывается callActivityOnStop, если активность ещё не остановлена (!r.stopped). Это важно при пересоздании активности (например, при изменении конфигурации), чтобы сохранить состояние до пересоздания.</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {
    @Override
    public void handleRelaunchActivity(@NonNull ActivityClientRecord tmp,
                                       @NonNull PendingTransactionActions pendingActions) {
      ...
        handleRelaunchActivityInner(r, tmp.pendingResults, tmp.pendingIntents,
                pendingActions, tmp.startsNotResumed, tmp.overrideConfig, tmp.mActivityWindowInfo,
                &quot;handleRelaunchActivity&quot;);
    }


    @Override
    public void handleStopActivity(ActivityClientRecord r,
                                   PendingTransactionActions pendingActions, boolean finalStateRequest, String reason) {
      ...
        performStopActivityInner(r, stopInfo, true /* saveState */, finalStateRequest,
                reason);
      ...
    }
}
</div><p id="qin34a_221">handleRelaunchActivity &mdash; внешний метод, который вызывает handleRelaunchActivityInner. Используется для обработки полного пересоздания активности. Все проверки и логика сохранения состояния уже находятся внутри handleRelaunchActivityInner.</p><p id="qin34a_222">handleStopActivity вызывает performStopActivityInner, передавая туда флаг saveState = true, чтобы принудительно сохранить состояние перед окончательной остановкой. Это используется, например, при закрытии приложения или выгрузке активности системой.</p><p id="qin34a_223">Последующие вызовы методов <code class="code" id="qin34a_676">performStopActivity</code> и <code class="code" id="qin34a_677">handleRelaunchActivity</code> упираются в классы <code class="code" id="qin34a_678">ActivityRelaunchItem.execute()</code> и <code class="code" id="qin34a_679">StopActivityItem.execute()</code>. Метод <code class="code" id="qin34a_680">performStopActivity</code> вызывается из <code class="code" id="qin34a_681">StopActivityItem.execute()</code>, а <code class="code" id="qin34a_682">handleRelaunchActivity</code> &mdash; из <code class="code" id="qin34a_683">ActivityRelaunchItem.execute()</code>.</p><div class="code-block" data-lang="java">
public class StopActivityItem extends ActivityLifecycleItem {
    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        client.handleStopActivity(r, pendingActions,
                true /* finalStateRequest */, &quot;STOP_ACTIVITY_ITEM&quot;);
        Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);
    }
}
</div><p id="qin34a_225">В методе <code class="code" id="qin34a_684">StopActivityItem.execute</code> видим вызов <code class="code" id="qin34a_685">client.handleStopActivity</code>. Так как <code class="code" id="qin34a_686">client</code> &mdash; это <code class="code" id="qin34a_687">ClientTransactionHandler</code>, а <code class="code" id="qin34a_688">ActivityThread</code> наследуется от него, фактически здесь вызывается <code class="code" id="qin34a_689">ActivityThread.handleStopActivity</code>.</p><div class="code-block" data-lang="java">
public class ActivityRelaunchItem extends ActivityTransactionItem {
    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
    }
}
</div><p id="qin34a_227">В методе <code class="code" id="qin34a_690">ActivityRelaunchItem.execute</code> видим вызов <code class="code" id="qin34a_691">client.handleRelaunchActivity</code>. По той же логике, фактически вызывается <code class="code" id="qin34a_692">ActivityThread.handleRelaunchActivity</code>.</p><p id="qin34a_228">На данный момент мы выследили следующую цепочку вызовов:</p><p id="qin34a_229"><code class="code" id="qin34a_693">StopActivityItem.execute</code> &rarr; <code class="code" id="qin34a_694">ActivityThread.handleStopActivity</code> &rarr; <code class="code" id="qin34a_695">ActivityThread.performStopActivityInner</code> &rarr; <code class="code" id="qin34a_696">ActivityThread.callActivityOnStop</code> &rarr; <code class="code" id="qin34a_697">ActivityThread.callActivityOnSaveInstanceState</code> &rarr; <code class="code" id="qin34a_698">Instrumentation.callActivityOnSaveInstanceState</code> &rarr; <code class="code" id="qin34a_699">Activity.performSaveInstanceState</code> &rarr; <code class="code" id="qin34a_700">Activity.onSaveInstanceState</code>.</p><p id="qin34a_230">Это ключевая цепочка, которая обеспечивает сохранение состояния <code class="code" id="qin34a_701">Activity</code> при изменениях конфигурации или её завершении. Обратим внимание, что вызов <code class="code" id="qin34a_702">callActivityOnSaveInstanceState</code> из <code class="code" id="qin34a_703">Instrumentation</code> &mdash; это как раз та точка, где система передаёт управление обратно в <code class="code" id="qin34a_704">Activity</code>, вызывая метод <code class="code" id="qin34a_705">performSaveInstanceState</code>, который инициирует сохранение всех данных в объект <code class="code" id="qin34a_706">Bundle</code>.</p><p id="qin34a_231">Параллельно, в случае изменения конфигурации или пересоздания активности, запускается другая цепочка:</p><p id="qin34a_232"><code class="code" id="qin34a_707">ActivityRelaunchItem.execute</code> &rarr; <code class="code" id="qin34a_708">ActivityThread.handleRelaunchActivity</code> &rarr; <code class="code" id="qin34a_709">ActivityThread.handleRelaunchActivityInner</code> &rarr; <code class="code" id="qin34a_710">ActivityThread.callActivityOnStop</code> &rarr; <code class="code" id="qin34a_711">ActivityThread.callActivityOnSaveInstanceState</code> &rarr; <code class="code" id="qin34a_712">Instrumentation.callActivityOnSaveInstanceState</code> &rarr; <code class="code" id="qin34a_713">Activity.performSaveInstanceState</code> &rarr; <code class="code" id="qin34a_714">Activity.onSaveInstanceState</code>.</p><p id="qin34a_233">Эти две цепочки работают независимо, но сходятся в методе <code class="code" id="qin34a_715">callActivityOnStop</code>, который гарантирует сохранение данных в <code class="code" id="qin34a_716">Bundle</code> перед тем, как <code class="code" id="qin34a_717">Activity</code> будет остановлена или пересоздана.</p><p id="qin34a_234">Далее, сформированный объект <code class="code" id="qin34a_718">Bundle</code>, содержащий состояние <code class="code" id="qin34a_719">Activity</code>, сохраняется в объекте <code class="code" id="qin34a_720">ActivityClientRecord</code>. Этот объект представляет собой структуру данных, хранящую всю необходимую информацию о <code class="code" id="qin34a_721">Activity</code> во время её жизненного цикла. Именно в поле <code class="code" id="qin34a_722">state</code> этого класса система сохраняет переданный <code class="code" id="qin34a_723">Bundle</code>, чтобы при пересоздании активности восстановить её состояние. <code class="code" id="qin34a_724">ActivityClientRecord</code> существует в процессе всех вызовов цепочки, перед тем как <code class="code" id="qin34a_725">Activity</code> перейдёт в состояние STOP. Внутри метода <code class="code" id="qin34a_726">ActivityThread.callActivityOnSaveInstanceState</code> полю <code class="code" id="qin34a_727">ActivityClientRecord.state</code> присваивается новый <code class="code" id="qin34a_728">Bundle</code>, в который активити и фрагменты кладут всё нужное &mdash; от состояния иерархий <code class="code" id="qin34a_729">View</code> до любых данных, которые разработчик решил сохранить.</p><p id="qin34a_235">Таким образом, мы видим, что эта цепочка запускается не из самой <code class="code" id="qin34a_730">Activity</code>, а из внутренней логики Android через <code class="code" id="qin34a_731">ActivityThread</code>. Это ещё раз подтверждает, что все жизненные циклы управляются системой через единый механизм клиент-серверных транзакций, а <code class="code" id="qin34a_732">ActivityThread</code> выполняет роль посредника, координирующего вызовы между <code class="code" id="qin34a_733">Activity</code> и системой.</p><p id="qin34a_236">Важный момент здесь &mdash; откуда берётся <code class="code" id="qin34a_734">ActivityClientRecord</code> и как его внутренний <code class="code" id="qin34a_735">Bundle</code> переживает смерть процесса. В случае сохранения между PAUSE/STOP мы увидели, где создаётся чистый <code class="code" id="qin34a_736">Bundle</code>, в который можно сохранять данные. Здесь особых секретов нет. Но то, как этот сохранённый <code class="code" id="qin34a_737">Bundle</code> внутри <code class="code" id="qin34a_738">ActivityClientRecord</code> переживает смерть системы и затем возвращается в <code class="code" id="qin34a_739">Activity.onCreate</code>, мы ещё не знаем. Следующая глава раскроет этот момент.</p></section><section class="chapter"><h2 id="oncreate" data-toc="oncreate">Цепочка вызова onCreate</h2><p id="qin34a_740">Начнем наше движение с самого низа &mdash; с метода <code class="code" id="qin34a_751">onCreate</code>. Как видно из кода, его вызов происходит внутри метода <code class="code" id="qin34a_752">performCreate</code>, который, в свою очередь, вызывается из метода <code class="code" id="qin34a_753">callActivityOnCreate</code> класса <code class="code" id="qin34a_754">Instrumentation</code>.</p><div class="code-block" data-lang="java">
public class Activity extends ContextThemeWrapper ...{

public void onCreate(@Nullable Bundle savedInstanceState, @Nullable PersistableBundle persistentState) {
    onCreate(savedInstanceState);
}

@MainThread
@CallSuper
protected void onCreate(@Nullable Bundle savedInstanceState) {
            ...
}

final void performCreate(Bundle icicle) {
    performCreate(icicle, null);
}

@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
final void performCreate(Bundle icicle, PersistableBundle persistentState) {
            ...
    if (persistentState != null) {
        onCreate(icicle, persistentState);
    } else {
        onCreate(icicle);
    }
            ...
}
}
</div><p id="qin34a_742">Метод <code class="code" id="qin34a_755">performCreate</code> является связующим звеном между логикой вызова <code class="code" id="qin34a_756">onCreate</code> и более низкоуровневыми компонентами системы. Сам же вызов <code class="code" id="qin34a_757">performCreate</code> осуществляется в классе <code class="code" id="qin34a_758">Instrumentation</code>:</p><div class="code-block" data-lang="java">
public class Instrumentation {
    ...

    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        ...
        activity.performCreate(icicle);
        ...
    }
}
</div><p id="qin34a_744">Класс <code class="code" id="qin34a_759">Instrumentation</code> управляет жизненным циклом <code class="code" id="qin34a_760">Activity</code> и вызывает <code class="code" id="qin34a_761">performCreate</code>, передавая ему объект <code class="code" id="qin34a_762">Bundle</code> для восстановления состояния. Теперь поднимемся выше. Кто же вызывает <code class="code" id="qin34a_763">callActivityOnCreate</code>? За это отвечает метод <code class="code" id="qin34a_764">performLaunchActivity</code> в классе <code class="code" id="qin34a_765">ActivityThread</code>:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ...
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
        } else {
            mInstrumentation.callActivityOnCreate(activity, r.state);
        }
        ...
    }
}
</div><p id="qin34a_746">Здесь мы видим, что в зависимости от состояния активности (сохранено ли оно в <code class="code" id="qin34a_766">PersistentState</code>), <code class="code" id="qin34a_767">callActivityOnCreate</code> вызывается с разным количеством параметров, но всегда через <code class="code" id="qin34a_768">Instrumentation</code>.</p><p id="qin34a_747">Далее, этот метод <code class="code" id="qin34a_769">performLaunchActivity</code> вызывается из метода <code class="code" id="qin34a_770">handleLaunchActivity</code> того же класса:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    @Override
    public Activity handleLaunchActivity(ActivityClientRecord r, ...) {
    ...
        final Activity a = performLaunchActivity(r, customIntent);
    ...
    }
}
</div><section class="chapter"><h3 id="activity_1" data-toc="activity_1">Перезапуск Activity при релаунче (например, при повороте экрана)</h3><p id="qin34a_771">При пересоздании Activity, например, при повороте экрана, срабатывает метод <code class="code" id="qin34a_777">handleRelaunchActivity</code>:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    @Override
    public void handleRelaunchActivity(@NonNull ActivityClientRecord tmp,
                                       @NonNull PendingTransactionActions pendingActions) {
        ...
        handleRelaunchActivityInner(r, tmp.pendingResults, tmp.pendingIntents,
                pendingActions, tmp.startsNotResumed, tmp.overrideConfig, tmp.mActivityWindowInfo,
                &quot;handleRelaunchActivity&quot;);
    }

    private void handleRelaunchActivityInner(@NonNull ActivityClientRecord r,...) {
    ....
        handleLaunchActivity(r, pendingActions, mLastReportedDeviceId, customIntent);
    }
}
</div><p id="qin34a_773">Вызов метода handleRelaunchActivity иницирует класс команда/транзакция <code class="code" id="qin34a_778">ActivityRelaunchItem</code>, которая действует как маркер для того, чтобы выполнить перезапуск с сохранением состояния:</p><div class="code-block" data-lang="java">
public class ActivityRelaunchItem extends ActivityTransactionItem {

    @Override
    public void execute(@NonNull ClientTransactionHandler client, @NonNull ActivityClientRecord r,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        client.handleRelaunchActivity(mActivityClientRecord, pendingActions);
        ...
    }
}

</div><p id="qin34a_775">Эта команда инициирует следующую цепочку вызовов:</p><p id="qin34a_776"><code class="code" id="qin34a_779">ActivityRelaunchItem.execute</code> &rarr; <code class="code" id="qin34a_780">handleRelaunchActivity</code> &rarr; <code class="code" id="qin34a_781">handleRelaunchActivityInner</code> &rarr; <code class="code" id="qin34a_782">handleLaunchActivity</code> &rarr; <code class="code" id="qin34a_783">performLaunchActivity</code> &rarr; <code class="code" id="qin34a_784">callActivityOnCreate</code> &rarr; <code class="code" id="qin34a_785">performCreate</code> &rarr; <code class="code" id="qin34a_786">onCreate</code>.</p></section><section class="chapter"><h3 id="activity" data-toc="activity">Создание Activity после уничтожения процесса или при первом запуске</h3><p id="qin34a_787">В случае, если процесс был уничтожен или это первый запуск <code class="code" id="qin34a_852">Activity</code>, используется другая команда &mdash; <code class="code" id="qin34a_853">LaunchActivityItem</code>. Она запускает аналогичную, но отдельную цепочку вызовов:</p><div class="code-block" data-lang="java">
public class LaunchActivityItem extends ClientTransactionItem {

    @Nullable
    private final Bundle mState;

    @Nullable
    private final PersistableBundle mPersistentState;

    public LaunchActivityItem(
            // остальные параметры
            @Nullable Bundle state,
            @Nullable PersistableBundle persistentState,
            // остальные параметры
    ) {
        this(
                // передаваемые аргументы до
                state != null ? new Bundle(state) : null,
                persistentState != null ? new PersistableBundle(persistentState) : null,
                // оставшиеся аргументы
        );
    ...
    }


    @Override
    public void execute(@NonNull ClientTransactionHandler client,
                        @NonNull PendingTransactionActions pendingActions) {
        ...
        ActivityClientRecord r = new ActivityClientRecord(...,mState, mPersistentState, ...);
        client.handleLaunchActivity(r, pendingActions, mDeviceId, null /* customIntent */);
        ...
    }
}

</div><p id="qin34a_789">Цепочка выглядит так: <code class="code" id="qin34a_854">LaunchActivityItem.execute</code> &rarr; <code class="code" id="qin34a_855">ActivityThread.handleLaunchActivity</code> &rarr; <code class="code" id="qin34a_856">ActivityThread.performLaunchActivity</code> &rarr; <code class="code" id="qin34a_857">ActivityThread.callActivityOnCreate</code> &rarr; <code class="code" id="qin34a_858">ActivityperformCreate</code> &rarr; <code class="code" id="qin34a_859">ActivityonCreate</code>.</p><p id="qin34a_790">Следует запомнить важную вещь, прежде чем подниматься выше, нужно понимать что <code class="code" id="qin34a_860">LaunchActivityItem</code> &mdash; это транзакция, которая в своём конструкторе принимает<code class="code" id="qin34a_861">Bundle</code> и <code class="code" id="qin34a_862">PersistableBundle</code> (последний мы рассматривать не будем). Класс <code class="code" id="qin34a_863">LaunchActivityItem</code> наследуется от <code class="code" id="qin34a_864">ClientTransactionItem</code>.</p><p id="qin34a_791"><code class="code" id="qin34a_865">ClientTransactionItem</code> &mdash; это абстрактный базовый класс, от которого наследуются все транзакции, связанные с жизненным циклом <code class="code" id="qin34a_866">Activity</code>. В него входят <code class="code" id="qin34a_867">LaunchActivityItem</code>, <code class="code" id="qin34a_868">ActivityRelaunchItem</code>, <code class="code" id="qin34a_869">ResumeActivityItem</code> (последние &mdash; <span class="control" id="qin34a_870">не прямые</span>, а транзитивные наследники) и другие элементы, участвующие в управлении состоянием <code class="code" id="qin34a_871">Activity</code>.</p><p id="qin34a_792">Мы увидели что создание ActivityClientRecord происходит в <code class="code" id="qin34a_872">LaunchActivityItem.execute</code>, но она использует готовые данные которые бьли переданы ей в конструктор при созданий.</p><p id="qin34a_793">Наша цель дальше &mdash; выяснить два момента:</p><ol class="list _decimal" id="qin34a_794" type="1"><li class="list__item" id="qin34a_873"><p id="qin34a_875"><span class="control" id="qin34a_876">Кто создаёт <code class="code" id="qin34a_877">LaunchActivityItem</code> и передаёт в него <code class="code" id="qin34a_878">Bundle</code></span>, который как раз и переживает смерть или остановку процесса.</p></li><li class="list__item" id="qin34a_874"><p id="qin34a_879"><span class="control" id="qin34a_880">Кто вызывает метод <code class="code" id="qin34a_887">execute</code> у <code class="code" id="qin34a_888">LaunchActivityItem</code></span> и запускает описанную выше цепочку вызовов : <code class="code" id="qin34a_881">LaunchActivityItem.execute</code> &rarr; <code class="code" id="qin34a_882">handleLaunchActivity</code> &rarr; <code class="code" id="qin34a_883">performLaunchActivity</code> &rarr; <code class="code" id="qin34a_884">callActivityOnCreate</code> &rarr; <code class="code" id="qin34a_885">performCreate</code> &rarr; <code class="code" id="qin34a_886">onCreate</code>.</p></li></ol><p id="qin34a_795">И так идем дальше, выше вызова <code class="code" id="qin34a_889">LaunchActivityItem.execute</code>, стоит класс <code class="code" id="qin34a_890">TransactionExecutor</code></p><div class="code-block" data-lang="java">
public class TransactionExecutor {

    private final ClientTransactionHandler mTransactionHandler;

    public TransactionExecutor(@NonNull ClientTransactionHandler clientTransactionHandler) {
        mTransactionHandler = clientTransactionHandler;
    }

    public void execute(@NonNull ClientTransaction transaction) {
        ...
        executeTransactionItems(transaction);
        ...
    }

    public void executeTransactionItems(@NonNull ClientTransaction transaction) {
        final List&lt;ClientTransactionItem&gt; items = transaction.getTransactionItems();
        final int size = items.size();
        for (int i = 0; i &lt; size; i++) {
            final ClientTransactionItem item = items.get(i);
            if (item.isActivityLifecycleItem()) {
                executeLifecycleItem(transaction, (ActivityLifecycleItem) item);
            } else {
                executeNonLifecycleItem(transaction, item,
                        shouldExcludeLastLifecycleState(items, i));
            }
        }
    }

    private void executeLifecycleItem(@NonNull ClientTransaction transaction,
                                      @NonNull ActivityLifecycleItem lifecycleItem) {
        ...
        lifecycleItem.execute(mTransactionHandler, mPendingActions);
                ...
    }

    private void executeNonLifecycleItem(@NonNull ClientTransaction transaction,
                                         @NonNull ClientTransactionItem item, boolean shouldExcludeLastLifecycleState) {
        ...
        item.execute(mTransactionHandler, mPendingActions);
        ...
    }
}
</div><p id="qin34a_797"><code class="code" id="qin34a_891">TransactionExecutor</code> - это как раз класс который работает со всеми транзакциями, то есть с ClientTransactionItem, и ClientTransaction - который является массивом или очередью которая хранит ClientTransactionItem-ы,</p><p id="qin34a_798">Конструктор <code class="code" id="qin34a_892">TransactionExecutor</code> принимает на вход <code class="code" id="qin34a_893">ClientTransactionHandler</code>, если вы не забыли, то ActivityThread реализует абстрактный класс <code class="code" id="qin34a_894">ClientTransactionHandler</code>, по этому фактический в конструктор <code class="code" id="qin34a_895">TransactionExecutor</code> прилетает ActivityThread.</p><p id="qin34a_799">У <code class="code" id="qin34a_896">TransactionExecutor</code> есть метод <code class="code" id="qin34a_897">execute</code> который вызывает другой метод <code class="code" id="qin34a_898">executeTransactionItems</code>, <code class="code" id="qin34a_899">executeTransactionItems</code> - в свою очередь пробегается по всем элемента внутри очереди транзакций, то есть в <code class="code" id="qin34a_900">ClientTransaction</code>, и в итоге определяет какой метод вызывать, <code class="code" id="qin34a_901">executeNonLifecycleItem</code> или <code class="code" id="qin34a_902">executeLifecycleItem</code>.</p><p id="qin34a_800">Различие этих методов в том, что <code class="code" id="qin34a_903">executeLifecycleItem</code> вызывается для транзакций, представляющих этапы жизненного цикла активности &mdash; такие как <code class="code" id="qin34a_904">ResumeActivityItem</code>, <code class="code" id="qin34a_905">PauseActivityItem</code>, <code class="code" id="qin34a_906">StopActivityItem</code>, <code class="code" id="qin34a_907">DestroyActivityItem</code>. Эти элементы отвечают за переходы между состояниями уже существующей <code class="code" id="qin34a_908">Activity</code>. Их назначение &mdash; вызвать соответствующие колбэки (<code class="code" id="qin34a_909">onPause</code>, <code class="code" id="qin34a_910">onStop</code>, и так далее) на объекте активности, который уже был создан и существует в памяти.</p><p id="qin34a_801">С другой стороны, <code class="code" id="qin34a_911">executeNonLifecycleItem</code> используется для выполнения транзакций, которые <span class="control" id="qin34a_912">не</span> относятся к жизненному циклу. Главный представитель &mdash; <code class="code" id="qin34a_913">LaunchActivityItem</code>, который отвечает за создание <code class="code" id="qin34a_914">Activity</code> с нуля. Это может происходить либо при первом запуске <code class="code" id="qin34a_915">Activity</code>, либо после того, как система уничтожила процесс, и теперь восстанавливает его. Внутри <code class="code" id="qin34a_916">executeNonLifecycleItem</code> вызывается <code class="code" id="qin34a_917">item.execute(...)</code>, который, в случае <code class="code" id="qin34a_918">LaunchActivityItem</code>, инициирует полную цепочку создания: от <code class="code" id="qin34a_919">ActivityClientRecord</code> до вызова <code class="code" id="qin34a_920">onCreate</code>.</p><p id="qin34a_802">Внутри <code class="code" id="qin34a_921">LaunchActivityItem</code>, в методе <code class="code" id="qin34a_922">executeNonLifecycleItem</code>, мы видим, что у <code class="code" id="qin34a_923">item</code> (экземпляр <code class="code" id="qin34a_924">ClientTransactionItem</code>) вызывается метод <code class="code" id="qin34a_925">execute</code>, которому передаются <code class="code" id="qin34a_926">ClientTransactionHandler</code> и <code class="code" id="qin34a_927">PendingTransactionActions</code>. Фактически в этот момент вызывается метод <code class="code" id="qin34a_928">execute</code> у <code class="code" id="qin34a_929">LaunchActivityItem</code>. Не забываем, что <code class="code" id="qin34a_930">LaunchActivityItem</code> наследуется от <code class="code" id="qin34a_931">ClientTransactionItem</code>.</p><p id="qin34a_803">Теперь разберёмся, кто вызывает метод <code class="code" id="qin34a_932">execute</code> у <code class="code" id="qin34a_933">TransactionExecutor</code>. Это делает внутренний класс <code class="code" id="qin34a_934">H</code>, являющийся <code class="code" id="qin34a_935">Handler</code>-ом:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    final H mH = new H();
    private final TransactionExecutor mTransactionExecutor = new TransactionExecutor(this);

    class H extends Handler {

        public void handleMessage(Message msg) {
            switch (msg.what) {
                ...
                case EXECUTE_TRANSACTION:
                    final ClientTransaction transaction = (ClientTransaction) msg.obj;
                    final ClientTransactionListenerController controller = ClientTransactionListenerController.getInstance();
                    controller.onClientTransactionStarted();
                    try {
                        mTransactionExecutor.execute(transaction);
                    } finally {
                        controller.onClientTransactionFinished();
                    }
                    ...
                ...
            }
        }
    }
}
</div><p id="qin34a_805">Напомним, что <code class="code" id="qin34a_936">ClientTransactionHandler</code> &mdash; это абстрактный класс, от которого наследуется <code class="code" id="qin34a_937">ActivityThread</code>. Далее мы видим, что создаётся объект <code class="code" id="qin34a_938">H</code>, а также <code class="code" id="qin34a_939">TransactionExecutor</code>, которому в качестве аргумента передаётся <code class="code" id="qin34a_940">this</code>, то есть <code class="code" id="qin34a_941">ActivityThread</code>, реализующий <code class="code" id="qin34a_942">ClientTransactionHandler</code>.</p><p id="qin34a_806">Теперь обратим внимание на реализацию <code class="code" id="qin34a_943">handleMessage</code> внутри класса <code class="code" id="qin34a_944">H</code>: когда приходит сообщение с типом <code class="code" id="qin34a_945">EXECUTE_TRANSACTION</code>, из объекта <code class="code" id="qin34a_946">Message</code> извлекается <code class="code" id="qin34a_947">ClientTransaction</code>, содержащий в себе список (<code class="code" id="qin34a_948">List</code>) транзакций. Затем вызывается метод <code class="code" id="qin34a_949">execute</code> у <code class="code" id="qin34a_950">TransactionExecutor</code>, что и запускает выполнение транзакции.</p><p id="qin34a_807">Сам метод handleMessage у класса H вызывает методы из самого класса ActivityThread:</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    final H mH = new H();

    void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1) {
        sendMessage(what, obj, arg1, 0, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2) {
        sendMessage(what, obj, arg1, arg2, false);
    }

    private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {
        ...
        mH.sendMessage(msg);
    }
}
</div><p id="qin34a_809">Видим что последний метод sendMessage и вызывает у класса H метод sendMessage, так как класс H наследуетсч от класса Handler, то у него есть метод sendMessage и вызывает метод handleMessage, надо понять кто вызывает sendMessage у ActivityThread,</p><div class="code-block" data-lang="java">
public final class ActivityThread extends ClientTransactionHandler implements ActivityThreadInternal {

    void sendMessage(int what, Object obj) {
        sendMessage(what, obj, 0, 0, false);
    }

    private class ApplicationThread extends IApplicationThread.Stub {

        @Override
        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException {
            ActivityThread.this.scheduleTransaction(transaction);
        }
    }
}
</div><p id="qin34a_811">Этим занимается ApplicationThread, каким образом вызов метода ActivityThread.scheduleTransaction вызывает ActivityThread.sendMessage?</p><p id="qin34a_812">Дело в том что ActivityThread наследуется от ClientTransactionHandler, а ClientTransactionHandler выглядит следующим образом:</p><div class="code-block" data-lang="java">
public abstract class ClientTransactionHandler {

    void scheduleTransaction(ClientTransaction transaction) {
        transaction.preExecute(this);
        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);
    }

    abstract void sendMessage(int what, Object obj);

}
</div><p id="qin34a_814">Получается у ApplicationThread вызывается метод scheduleTransaction, он вызывает у ActivityThread метод scheduleTransaction который он унаследовал от ClientTransactionHandler, внутри метода scheduleTransaction у ClientTransactionHandler мы видим что он вызывает метод sendMessage с двумя параметрами, ActivityThread как раз переопредляет этот метод, и далее вызов идет в H.sendMessage.</p><p id="qin34a_815">ApplicationThread - это Proxy который реализует AIDL интерфейс, этот класс отвечает за многие планирования, например сервисы, receiver или binding Application. Так же заметьте что он реализует IApplicationThread.Stub, то есть фактический сам AIDL интерфейс IApplicationThread</p><p id="qin34a_816">Дальше поймем откуда происходит вызов метода ApplicationThread.scheduleTransaction, и вуаля, этим занимается класс:</p><div class="code-block" data-lang="java">
public class ClientTransaction implements Parcelable, ObjectPoolItem {

    private IApplicationThread mClient;

    public void schedule() throws RemoteException {
        mClient.scheduleTransaction(this);
    }
}
</div><p id="qin34a_818">Он вызывает у ApplicationThread.scheduleTransaction передавая себя, тем самым запланируя себя и свои внутренние транзакций на выполнение, IApplicationThread это и есть класс ActivityThread.ApplicationThread, далее отследим вызов метода ClientTransaction.schedule(), встречайте еще один класс,</p><div class="code-block" data-lang="java">
class ClientLifecycleManager {

    void scheduleTransactionItems(@NonNull IApplicationThread client,
                                  boolean shouldDispatchImmediately,
                                  @NonNull ClientTransactionItem... items) throws RemoteException {
        ...
        final ClientTransaction clientTransaction = getOrCreatePendingTransaction(client);

        final int size = items.length;
        for (int i = 0; i &lt; size; i++) {
            clientTransaction.addTransactionItem(items[i]);
        }

        onClientTransactionItemScheduled(clientTransaction, shouldDispatchImmediately);
    }

    private void onClientTransactionItemScheduled(
            @NonNull ClientTransaction clientTransaction,
            boolean shouldDispatchImmediately) throws RemoteException {
        ...
        scheduleTransaction(clientTransaction);
    }


    void scheduleTransaction(@NonNull ClientTransaction transaction) throws RemoteException {
        ...
        transaction.schedule();
        ...
    }
}
</div><p id="qin34a_820">Внутри него определён метод <code class="code" id="qin34a_951">scheduleTransactionItems</code>, который принимает <code class="code" id="qin34a_952">IApplicationThread</code> и массив <code class="code" id="qin34a_953">ClientTransactionItem</code>. Этот метод создаёт или достаёт транзакцию через <code class="code" id="qin34a_954">getOrCreatePendingTransaction</code>, добавляет в неё все <code class="code" id="qin34a_955">ClientTransactionItem</code> (например, <code class="code" id="qin34a_956">LaunchActivityItem</code>, <code class="code" id="qin34a_957">ResumeActivityItem</code>, <code class="code" id="qin34a_958">PauseActivityItem</code> и т.д.), после чего передаёт её в метод <code class="code" id="qin34a_959">onClientTransactionItemScheduled</code>, где вызывается<code class="code" id="qin34a_960">scheduleTransaction</code>.</p><p id="qin34a_821">После чего управление переходит в метод <code class="code" id="qin34a_961">scheduleTransaction</code>, внутри которого вызывается <code class="code" id="qin34a_962">transaction.schedule()</code>. А как мы уже знаем, метод <code class="code" id="qin34a_963">schedule</code> вызывает <code class="code" id="qin34a_964">ApplicationThread.scheduleTransaction</code>, то есть фактически мы возвращаемся обратно к AIDL-вызову, из которого всё и начинается.</p><p id="qin34a_822">Таким образом, <code class="code" id="qin34a_965">ClientLifecycleManager</code> собирает транзакцию, наполняет её нужными <code class="code" id="qin34a_966">ClientTransactionItem</code>, и отправляет её в исполнение. Это класс, который формирует цепочку действий, и делегирует выполнение низкоуровневому слою через AIDL.</p><p id="qin34a_823"><code class="code" id="qin34a_967">ClientLifecycleManager.scheduleTransactionItems</code> - вызовом метода занимается очень важный класс <code class="code" id="qin34a_968">ActivityTaskSupervisor</code></p><div class="code-block" data-lang="java">
public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;
    ...

    boolean realStartActivityLocked(ActivityRecord r, WindowProcessController proc,
                                    boolean andResume, boolean checkConfig) throws RemoteException {


        // Create activity launch transaction.
        final LaunchActivityItem launchActivityItem = new LaunchActivityItem(r.token,
                ...,r.getSavedState(), r.getPersistentSavedState(), ...,
       );
        ...
        mService.getLifecycleManager().scheduleTransactionItems(
                proc.getThread(),
                // Immediately dispatch the transaction, so that if it fails, the server can
                // restart the process and retry now.
                true /* shouldDispatchImmediately */,
                launchActivityItem, lifecycleItem);
        ...
        return true;
    }
    ...
}
</div><p id="qin34a_825">Видим очень ключевые моменты:</p><ol class="list _decimal" id="qin34a_826" type="1"><li class="list__item" id="qin34a_969"><p id="qin34a_972">В методе realStartActivityLocked на вход передается объект класса ActivityRecord, который в себе хранит значения - r.getSavedState()(Bundle) и r.getPersistentSavedState(PersistentBundle) и прочие важные значения и информацию об активити</p></li><li class="list__item" id="qin34a_970"><p id="qin34a_973">Наконецто видим создание транзакций <code class="code" id="qin34a_974">LaunchActivityItem</code> c передачей всех нужных аргументов, в числе и Bundle</p></li><li class="list__item" id="qin34a_971"><p id="qin34a_975">Видим что у класса ActivityTaskManagerService вызывается метод <code class="code" id="qin34a_976">getLifecycleManager()</code> который возвращает объект класса <code class="code" id="qin34a_977">ClientLifecycleManager</code> и вызывает у него метод scheduleTransactionItems который мы уже видели, с передачей <code class="code" id="qin34a_978">LaunchActivityItem</code></p></li></ol><p id="qin34a_827">Давай убедимся что метод getLifecycleManager у ActivityTaskManagerService действительно вовзращает ClientLifecycleManager:</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    ClientLifecycleManager getLifecycleManager() {
        return mLifecycleManager;
    }
}
</div><p id="qin34a_829">Убедились, прекрасно, идем дальше, отследим вызов метода <code class="code" id="qin34a_979">realStartActivityLocked</code> класса <code class="code" id="qin34a_980">ActivityTaskSupervisor</code></p><div class="code-block" data-lang="java">
class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt; implements DisplayManager.DisplayListener {

    ActivityTaskSupervisor mTaskSupervisor;
    ActivityTaskManagerService mService;

    boolean attachApplication(WindowProcessController app) throws RemoteException {
        final ArrayList&lt;ActivityRecord&gt; activities = mService.mStartingProcessActivities;
        for (int i = activities.size() - 1; i &gt;= 0; i--) {
            final ActivityRecord r = activities.get(i);
            ...
            if (mTaskSupervisor.realStartActivityLocked(r, app, canResume,
                    true /* checkConfig */)) {
                hasActivityStarted = true;
            }
            ...
            return hasActivityStarted;
        }
    }
}
</div><aside class="prompt" data-type="tip" data-title="RootWindowContainer..." id="qin34a_831"><p id="qin34a_981"><code class="code" id="qin34a_984">RootWindowContainer</code> &mdash; это центральный компонент в системе управления окнами Android, который содержит в себе всю иерархию окон на всех дисплеях. Он управляет экземплярами <code class="code" id="qin34a_985">DisplayContent</code>, координирует layout, input, фокус, анимации, транзишены, split-screen, <code class="code" id="qin34a_986">picture-in-picture</code> и любые изменения, связанные с конфигурацией экрана. Всё, что должно появиться, исчезнуть, пересчитаться или анимироваться &mdash; сначала проходит через него. Это точка входа для всех транзакций окон, включая запуск и завершение активностей.</p><p id="qin34a_982">Он настолько крут, что может остановить перезапуск activity, если чувствует, что layout всё ещё &quot;в пути&quot;. Ему не нужно подтверждение от <code class="code" id="qin34a_987">WindowManagerService</code> для показа Window и работы с контентом.</p><p id="qin34a_983"><code class="code" id="qin34a_988">RootWindowContainer</code> раньше назывался <code class="code" id="qin34a_989">RootActivityContainer</code></p></aside><p id="qin34a_832">Видим вызов метода <code class="code" id="qin34a_990">ActivityTaskSupervisor.realStartActivityLocked</code> происходит в классе RootWindowContainer, который в методе <code class="code" id="qin34a_991">attachApplication</code>, получает список ActivityRecord у ActivityTaskManagerService, и в цикле для всех вызывает метод <code class="code" id="qin34a_992">ActivityTaskSupervisor.realStartActivityLocked</code>.</p><p id="qin34a_833">Далее мы снова возвращаемся к <code class="code" id="qin34a_993">ActivityTaskManagerService</code>, потому что именно он вызывает метод attachApplication у RootWindowContainer и передает ему</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
   ...

    /** The starting activities which are waiting for their processes to attach. */
    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    @HotPath(caller = HotPath.PROCESS_CHANGE)
    @Override
    public boolean attachApplication(WindowProcessController wpc) throws RemoteException {
        ...
        return mRootWindowContainer.attachApplication(wpc);
    }

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
         ...
        mStartingProcessActivities.add(activity);
         ...
    }


    ClientLifecycleManager getLifecycleManager() {
        return mLifecycleManager;
    }
   ...
}
</div><p id="qin34a_835">Видим, что он хранит в себе список <code class="code" id="qin34a_994">ActivityRecord</code> в поле <code class="code" id="qin34a_995">mStartingProcessActivities</code> &mdash; вызов которого мы уже видели в <code class="code" id="qin34a_996">RootWindowContainer.attachApplication</code>.</p><p id="qin34a_836">Далее видим, что у него также есть ссылка на <code class="code" id="qin34a_997">RootWindowContainer</code>, и в методе <code class="code" id="qin34a_998">ActivityTaskManagerService.attachApplication</code> происходит вызов метода <code class="code" id="qin34a_999">RootWindowContainer.attachApplication</code>. <code class="code" id="qin34a_1000">startProcessAsync</code> &mdash; также очень важный метод, который добавляет новые <code class="code" id="qin34a_1001">ActivityRecord</code> в список <code class="code" id="qin34a_1002">mStartingProcessActivities</code>, внутри которых хранится <code class="code" id="qin34a_1003">Bundle</code> (его мы разберём позже).</p><p id="qin34a_837">Выше <code class="code" id="qin34a_1004">ActivityTaskManagerService</code> находится класс <code class="code" id="qin34a_1005">ActivityManagerService</code>, он и вызывает <code class="code" id="qin34a_1006">attachApplication</code> у <code class="code" id="qin34a_1007">ActivityTaskManagerService</code>:</p><div class="code-block" data-lang="java">
public class ActivityManagerService extends IActivityManager.Stub {

    public ActivityTaskManagerInternal mAtmInternal;
    final PidMap mPidsSelfLocked = new PidMap();

    @GuardedBy(&quot;this&quot;)
    private void attachApplicationLocked(@NonNull IApplicationThread thread,
                                         int pid, int callingUid, long startSeq) {
        ...
        finishAttachApplicationInner(startSeq, callingUid, pid);
        ...
    }

    private void finishAttachApplicationInner(long startSeq, int uid, int pid) {
        ...
        final ProcessRecord app;
        app = mPidsSelfLocked.get(pid);
        ...

        didSomething = mAtmInternal.attachApplication(app.getWindowProcessController());
        ...
    }
}
</div><p id="qin34a_839">Видим в методе <code class="code" id="qin34a_1008">finishAttachApplicationInner</code> вызов метода <code class="code" id="qin34a_1009">attachApplication</code> у <code class="code" id="qin34a_1010">mAtmInternal</code>, <code class="code" id="qin34a_1011">ActivityTaskManagerInternal</code>, который является абстрактным AIDL-интерфейсом для <code class="code" id="qin34a_1012">ActivityTaskManagerService</code>, поэтому фактически здесь вызывается <code class="code" id="qin34a_1013">ActivityTaskManagerService.attachApplication()</code>.</p><p id="qin34a_840">Сам метод <code class="code" id="qin34a_1014">finishAttachApplicationInner</code> вызывается из <code class="code" id="qin34a_1015">attachApplicationLocked</code>, где процесс извлекается из <code class="code" id="qin34a_1016">mPidsSelfLocked</code> по ключу <code class="code" id="qin34a_1017">pid</code> (то есть process id).</p><p id="qin34a_841">Сам <code class="code" id="qin34a_1018">ActivityManagerService</code> является синглтоном в рамках всей системы Android, у него внутри есть структура <code class="code" id="qin34a_1019">PidMap</code>, которая хранит объекты <code class="code" id="qin34a_1020">ProcessRecord</code> по ключу <code class="code" id="qin34a_1021">pid</code>. То есть вызов <code class="code" id="qin34a_1022">mPidsSelfLocked.get(pid)</code> обращается к <code class="code" id="qin34a_1023">PidMap</code>:</p><div class="code-block" data-lang="java">
public class ActivityManagerService extends IActivityManager.Stub {

    final PidMap mPidsSelfLocked = new PidMap();

    ...

    static final class PidMap {
        private final SparseArray&lt;ProcessRecord&gt; mPidMap = new SparseArray&lt;&gt;();

        ProcessRecord get(int pid) {
            return mPidMap.get(pid);
        }
        ...

        void doAddInternal(int pid, ProcessRecord app) {
            mPidMap.put(pid, app);
        }
       ...
    }

    public void setSystemProcess() {
      ...
        ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName,
                false,
                0,
                false,
                0,
                null,
                new HostingRecord(HostingRecord.HOSTING_TYPE_SYSTEM));
            ...
        addPidLocked(app);
            ...
    }

    void addPidLocked(ProcessRecord app) {
        final int pid = app.getPid();
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.doAddInternal(pid, app);
        }
      ...
    }
}
</div><p id="qin34a_843">Видим структуру <code class="code" id="qin34a_1024">PidMap</code>, которая внутри себя хранит список записей процессов приложения.</p><p id="qin34a_844">Также видим методы <code class="code" id="qin34a_1025">setSystemProcess</code> и <code class="code" id="qin34a_1026">addPidLocked</code>. В <code class="code" id="qin34a_1027">setSystemProcess</code> создаётся новый <code class="code" id="qin34a_1028">ProcessRecord</code> и вызывается метод <code class="code" id="qin34a_1029">addPidLocked</code>, который кладёт его в <code class="code" id="qin34a_1030">mPidsSelfLocked</code>. Метод <code class="code" id="qin34a_1031">setSystemProcess</code> вызывается из <code class="code" id="qin34a_1032">SystemServer</code> (он же system_service). Ниже краткий стек вызовов:</p><div class="code-block" data-lang="none">
1. Загрузчик (Bootloader) → Ядро (Linux Kernel)  
2. Процесс init (первый userspace-процесс)  
   ├─ Запуск zygote (через app_process)  
   │   ├─ ZygoteInit (singleton, подготавливает среду для Java-процессов)  
   │   │   ├─ fork() → создаёт SystemServer  
   │   │   └─ fork() → создаёт приложения  
   └─ SystemServer (singleton, запускает все системные сервисы)  
       ├─ RuntimeInit (инициализирует среду для SystemServer)  
       └─ ActivityManagerService (singleton, включая `setSystemProcess()`)
</div><p id="qin34a_846">Выше <code class="code" id="qin34a_1033">ActivityManagerService</code> подниматься нет смысла, так как там <code class="code" id="qin34a_1034">Bundle</code> не хранится, большинство этих компонентов &mdash; это синглтоны всей системы и не имеют прямого отношения к конкретному приложению.</p><p id="qin34a_847">На этом моменте уже многое стало ясно: мы рассмотрели очень длинный flow вызовов. Момент, который мы немного пропустили, &mdash; где именно создаются <code class="code" id="qin34a_1035">ActivityRecord</code>. Ранее мы уже видели список <code class="code" id="qin34a_1036">ActivityRecord</code>, получаемый из поля <code class="code" id="qin34a_1037">mStartingProcessActivities</code> у <code class="code" id="qin34a_1038">ActivityTaskManagerService</code>:</p><div class="code-block" data-lang="java">
class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt; implements DisplayManager.DisplayListener {

    ActivityTaskSupervisor mTaskSupervisor;
    ActivityTaskManagerService mService;

    boolean attachApplication(WindowProcessController app) throws RemoteException {
        final ArrayList&lt;ActivityRecord&gt; activities = mService.mStartingProcessActivities;
        for (int i = activities.size() - 1; i &gt;= 0; i--) {
            final ActivityRecord r = activities.get(i);
            ...
            if (mTaskSupervisor.realStartActivityLocked(r, app, canResume,
                    true /* checkConfig */)) {
                hasActivityStarted = true;
            }
            ...
        }
    }
}
</div><p id="qin34a_849">В <code class="code" id="qin34a_1039">ActivityTaskManagerService</code> это выглядит следующим образом. Как мы уже видели, поле <code class="code" id="qin34a_1040">mStartingProcessActivities</code> является коллекцией, которая хранит объекты <code class="code" id="qin34a_1041">ActivityRecord</code>. Есть один метод, который добавляет <code class="code" id="qin34a_1042">ActivityRecord</code> в эту коллекцию &mdash; это метод <code class="code" id="qin34a_1043">startProcessAsync</code>:</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    /** The starting activities which are waiting for their processes to attach. */
    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}
</div><p id="qin34a_851">Следующая глава статьи будет раскрывать этот момент, где создается ActivityRecord и кто его кладет в ActivityTaskManagerService в поле mStartingProcessActivities</p></section></section><section class="chapter"><h2 id="bundle" data-toc="bundle">Пересоздание процесса с сохранением Bundle</h2><div class="code-block" data-lang="none">
ActivityManagerService.startActivity()
  → ActivityTaskManagerService.startActivityAsUser()
    → ActivityStartController.obtainStarter()
      → ActivityStarter.execute()
        → executeRequest():
          1. Создание ActivityRecord (новый объект)
          2. startActivityUnchecked()
             → startActivityInner()
               → setInitialState(r) // сохраняем ActivityRecord в mStartActivity
               → RootWindowContainer.resumeFocusedTasksTopActivities(mStartActivity)
                 → Task.resumeTopActivityUncheckedLocked()
                   → ActivityTaskSupervisor.startSpecificActivity(r)
                     → (если процесс не запущен)
                        → ActivityTaskManagerService.startProcessAsync(r)
                          → mStartingProcessActivities.add(r) // финальная точка
</div><p id="qin34a_1045"><code class="code" id="qin34a_1088">ActivityRecord</code> (с <code class="code" id="qin34a_1089">Bundle</code>) умеет переживать смерть процесса или его прерывание. Подразумевается ситуация, когда приложение уходит в фон и сохраняется в стеке задач (Recents), система через какое-то время убивает процесс. Когда пользователь возвращается, система вызывает метод <code class="code" id="qin34a_1090">startActivityFromRecents</code>, чтобы восстановить задачу (Task) и поднять процесс. Каждая задача, как правило, соответствует одной корневой Activity, но внутри может хранить дочерние Activity, которые тоже связаны с компонентами.</p><div class="code-block" data-lang="java">
public class ActivityManagerService extends IActivityManager.Stub {

    @Override
    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        return mActivityTaskManager.startActivityFromRecents(taskId, bOptions);
    }

}
</div><p id="qin34a_1047">Метод <code class="code" id="qin34a_1091">startActivityFromRecents</code> внутри <code class="code" id="qin34a_1092">ActivityManagerService</code> напрямую делегирует вызов в <code class="code" id="qin34a_1093">ActivityTaskManagerService</code>. Сам по себе он ничего не делает, просто перекидывает управление дальше.</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    ActivityTaskSupervisor mTaskSupervisor;

    @Override
    public final int startActivityFromRecents(int taskId, Bundle bOptions) {
        ...
        return mTaskSupervisor.startActivityFromRecents(callingPid, callingUid, taskId, safeOptions);
    }
}
</div><p id="qin34a_1049">В <code class="code" id="qin34a_1094">ActivityTaskManagerService.startActivityFromRecents</code> происходит подготовка: извлекаются PID, UID, формируются безопасные опции запуска ( SafeActivityOptions). Далее метод сразу передаёт выполнение в <code class="code" id="qin34a_1095">ActivityTaskSupervisor</code>, где происходит основная логика обработки задачи.</p><div class="code-block" data-lang="java">
public class ActivityTaskSupervisor implements RecentTasks.Callbacks {

    final ActivityTaskManagerService mService;
    RootWindowContainer mRootWindowContainer;

    int startActivityFromRecents(int callingPid, int callingUid, int taskId,
                                 SafeActivityOptions options) {
        final Task task;

        task = mRootWindowContainer.anyTaskForId(taskId, MATCH_ATTACHED_TASK_OR_RECENT_TASKS_AND_RESTORE, activityOptions, ON_TOP);

        if (!mService.mAmInternal.shouldConfirmCredentials(task.mUserId) &amp;&amp; task.getRootActivity() != null) {
            final ActivityRecord targetActivity = task.getTopNonFinishingActivity();
         ...
            mService.moveTaskToFrontLocked(...);
         ...
            return ActivityManager.START_TASK_TO_FRONT;
        }
    }

}

</div><p id="qin34a_1051">Внутри <code class="code" id="qin34a_1096">startActivityFromRecents</code> у <code class="code" id="qin34a_1097">ActivityTaskSupervisor</code> происходит уже настоящий разбор: сначала ищется нужная задача через <code class="code" id="qin34a_1098">mRootWindowContainer.anyTaskForId(...)</code>, где передаются различные флаги (например, <code class="code" id="qin34a_1099">MATCH_ATTACHED_TASK_OR_RECENT_TASKS_AND_RESTORE</code>), чтобы восстановить задачу из списка недавних. Затем проверяется, нужно ли подтверждать учётные данные пользователя (например, если включён режим защиты профиля). После этого смотрится, есть ли у задачи root Activity (<code class="code" id="qin34a_1100">getRootActivity()</code>), и извлекается верхняя невыполненная Activity через <code class="code" id="qin34a_1101">getTopNonFinishingActivity()</code>.</p><p id="qin34a_1052">Если все условия подходят, вызывается <code class="code" id="qin34a_1102">moveTaskToFrontLocked(...)</code> у <code class="code" id="qin34a_1103">ActivityTaskManagerService</code>, который отвечает за перенос задачи в передний план и дальнейший запуск. Всё это нужно для того, чтобы корректно восстановить состояние приложения из стека задач без необходимости полного пересоздания Activity с нуля.</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    void moveTaskToFrontLocked(@Nullable IApplicationThread appThread,
                               @Nullable String callingPackage, int taskId, ...) {

        final Task task = mRootWindowContainer.anyTaskForId(taskId);
        ...
        mTaskSupervisor.findTaskToMoveToFront(task, flags, ...);
    }

}
</div><p id="qin34a_1054">Метод <code class="code" id="qin34a_1104">moveTaskToFrontLocked</code> после проверки передаёт управление в <code class="code" id="qin34a_1105">findTaskToMoveToFront</code>. Здесь задача не просто находится, а действительно перемещается на передний план. В начале вытаскивается корневой контейнер задачи через <code class="code" id="qin34a_1106">getRootTask()</code>. Если задача ещё не была &laquo;переподвешена&raquo; (reparented), вызывается <code class="code" id="qin34a_1107">moveHomeRootTaskToFrontIfNeeded</code>, чтобы при необходимости поднять домашнюю задачу (например, если приложение долго не запускалось).</p><p id="qin34a_1055">Далее через <code class="code" id="qin34a_1108">getTopNonFinishingActivity()</code> достаётся верхняя невыполненная ActivityRecord(Activity) в задаче. Затем вызывается <code class="code" id="qin34a_1109">currentRootTask.moveTaskToFront</code>, куда передаётся сама задача, опции анимации и другие параметры</p><div class="code-block" data-lang="java">
public class ActivityTaskSupervisor implements RecentTasks.Callbacks {

    void findTaskToMoveToFront(Task task, int flags, ActivityOptions options, String reason,
                               boolean forceNonResizeable) {
        Task currentRootTask = task.getRootTask();

        if (!reparented) {
            moveHomeRootTaskToFrontIfNeeded(flags, currentRootTask.getDisplayArea(), reason);
        }

        final ActivityRecord r = task.getTopNonFinishingActivity();
        currentRootTask.moveTaskToFront(task, false /* noAnimation */, options,
                r == null ? null : r.appTimeTracker, reason);
        ...
    }

}
</div><p id="qin34a_1057">В методе <code class="code" id="qin34a_1110">moveTaskToFront</code> внутри класса <code class="code" id="qin34a_1111">Task</code> мы видим финальный шаг &mdash; вызов <code class="code" id="qin34a_1112">mRootWindowContainer.resumeFocusedTasksTopActivities()</code>. Этот вызов отвечает за то, чтобы на уровне контейнера окон (WindowContainer) запустить или возобновить верхнюю активность, сделать её активной и отрисовать.</p><div class="code-block" data-lang="java">
class Task extends TaskFragment {

    final void moveTaskToFront(Task tr, boolean noAnimation, ActivityOptions options,
                               AppTimeTracker timeTracker, boolean deferResume, String reason) {
        ...
        mRootWindowContainer.resumeFocusedTasksTopActivities();
    }

}
</div><p id="qin34a_1059">Метод <code class="code" id="qin34a_1113">resumeFocusedTasksTopActivities</code> у <code class="code" id="qin34a_1114">RootWindowContainer</code> проходит по всем дисплеям, чтобы определить, какая задача должна быть запущена или возобновлена. Для каждого дисплея вызывается <code class="code" id="qin34a_1115">forAllRootTasks</code>, внутри которого берётся верхняя активность (<code class="code" id="qin34a_1116">topRunningActivity</code>). Если она уже в состоянии <code class="code" id="qin34a_1117">RESUMED</code>, то просто выполняется переход приложения (executeAppTransition). В противном случае активность активируется через <code class="code" id="qin34a_1118">makeActiveIfNeeded</code>.</p><p id="qin34a_1060">Если на дисплее не оказалось ни одной подходящей активности, вызывается <code class="code" id="qin34a_1119">resumeTopActivityUncheckedLocked</code> у фокусной задачи. А если вообще нет фокусных задач, система запускает домашнюю Activity через <code class="code" id="qin34a_1120">resumeHomeActivity</code>.</p><div class="code-block" data-lang="java">
class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;
        implements DisplayManager.DisplayListener {

    boolean resumeFocusedTasksTopActivities(
            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,
            boolean deferPause) {

        for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) {
            final DisplayContent display = getChildAt(displayNdx);
            final boolean curResult = result;
            boolean[] resumedOnDisplay = new boolean[1];
            final ActivityRecord topOfDisplay = display.topRunningActivity();
            display.forAllRootTasks(rootTask -&gt; {
                final ActivityRecord topRunningActivity = rootTask.topRunningActivity();
                if (!rootTask.isFocusableAndVisible() || topRunningActivity == null) {
                    return;
                }
                if (rootTask == targetRootTask) {
                    resumedOnDisplay[0] |= curResult;
                    return;
                }
                if (topRunningActivity.isState(RESUMED) &amp;&amp; topRunningActivity == topOfDisplay) {
                    rootTask.executeAppTransition(targetOptions);
                } else {
                    resumedOnDisplay[0] |= topRunningActivity.makeActiveIfNeeded(target);
                }
            });
            result |= resumedOnDisplay[0];
            if (!resumedOnDisplay[0]) {

                final Task focusedRoot = display.getFocusedRootTask();
                if (focusedRoot != null) {
                    result |= focusedRoot.resumeTopActivityUncheckedLocked(
                            target, targetOptions, false /* skipPause */);
                } else if (targetRootTask == null) {
                    result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;,
                            display.getDefaultTaskDisplayArea());
                }
            }
        }

        return result;
    }

}
</div><p id="qin34a_1062">Таким образом, когда пользователь возвращается к приложению из Recents, система шаг за шагом поднимает задачу из стека, подготавливает корневую Activity и доводит её до состояния RESUMED. Всё это происходит последовательно: от поиска задачи в стеке &mdash; до финального вызова <code class="code" id="qin34a_1121">makeActiveIfNeeded</code>, который, по сути, завершает процесс восстановления.</p><p id="qin34a_1063">После того как контейнер окон выбрал задачу для возобновления, управление переходит в метод <code class="code" id="qin34a_1122">resumeTopActivityUncheckedLocked</code> внутри класса <code class="code" id="qin34a_1123">Task</code>. Здесь вызывается внутренний метод <code class="code" id="qin34a_1124">resumeTopActivityInnerLocked</code>, который уже окончательно определяет, какую Activity нужно запустить.</p><div class="code-block" data-lang="java">
class Task extends TaskFragment {

    @GuardedBy(&quot;mService&quot;)
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options,
                                             boolean deferPause) {
        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);
    }

    @GuardedBy(&quot;mService&quot;)
    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options,
                                                 boolean deferPause) {
        final TaskFragment topFragment = topActivity.getTaskFragment();
        resumed[0] = topFragment.resumeTopActivity(prev, options, deferPause);
    }

}
</div><p id="qin34a_1065">В методе <code class="code" id="qin34a_1125">resumeTopActivityInnerLocked</code> вытаскивается фрагмент задачи (<code class="code" id="qin34a_1126">TaskFragment</code>), к которому привязана верхняя Activity. Именно тут начинается конкретная подготовка к запуску компонента приложения.</p><p id="qin34a_1066">Дальше вызывается <code class="code" id="qin34a_1127">resumeTopActivity</code> у <code class="code" id="qin34a_1128">TaskFragment</code>. Здесь происходит поиск верхней активности (<code class="code" id="qin34a_1129">topRunningActivity</code>) и запуск метода <code class="code" id="qin34a_1130">startSpecificActivity</code>. По сути, <code class="code" id="qin34a_1131">startSpecificActivity</code> &mdash; это последняя точка внутри ядра системы, где принимается решение: запустить новый процесс для активности или использовать уже существующий.</p><div class="code-block" data-lang="java">
class TaskFragment extends WindowContainer&lt;WindowContainer&gt; {

    final boolean resumeTopActivity(ActivityRecord prev, ActivityOptions options,
                                    boolean skipPause) {
        ActivityRecord next = topRunningActivity(true /* focusableOnly */);
        mTaskSupervisor.startSpecificActivity(next, true, false);
        ...
        return true;
        ...
    }

}
</div><p id="qin34a_1068">Далее метод <code class="code" id="qin34a_1132">startSpecificActivity</code> внутри <code class="code" id="qin34a_1133">ActivityTaskSupervisor</code>. Здесь анализируется состояние процесса: если процесс уже существует и привязан, то активити будет сразу запущена. Если же процесс отсутствует или был завершён системой, тогда вызывается <code class="code" id="qin34a_1134">startProcessAsync</code>, чтобы создать новый процесс для этой активности.</p><div class="code-block" data-lang="java">
public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;

    void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
        ...
        mService.startProcessAsync(r, knownToBeDead, isTop,
                isTop ? HostingRecord.HOSTING_TYPE_TOP_ACTIVITY
                        : HostingRecord.HOSTING_TYPE_ACTIVITY);
    }
}
</div><p id="qin34a_1070">В методе <code class="code" id="qin34a_1135">startProcessAsync</code> активити добавляется в список <code class="code" id="qin34a_1136">mStartingProcessActivities</code>. Это своего рода &laquo;очередь на запуск&raquo;, куда система кладёт активности, пока ожидает, что процесс для них будет создан и привязан.</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}
</div><p id="qin34a_1072">Таким образом, когда мы доходим до финальной стадии, встает важный вопрос: <span class="control" id="qin34a_1137">где в конечном итоге хранится <code class="code" id="qin34a_1138">ActivityRecord</code> и как устроены связи между ключевыми сущностями &mdash; <code class="code" id="qin34a_1139">DisplayContent</code>, <code class="code" id="qin34a_1140">WindowContainer</code>, <code class="code" id="qin34a_1141">Task</code> (и <code class="code" id="qin34a_1142">TaskFragment</code>)?</span> Это поможет окончательно понять, как именно система управляет состоянием и &laquo;жизнью&raquo; Activity на стороне System Server.</p><p id="qin34a_1073"><span class="control" id="qin34a_1143">Общая структура иерархии</span> Android управляет активностями и окнами в виде <span class="control" id="qin34a_1144">иерархического дерева контейнеров</span>, где каждый контейнер реализован через базовый класс <code class="code" id="qin34a_1145">WindowContainer</code>. Вся структура начинается с корневого контейнера <code class="code" id="qin34a_1146">RootWindowContainer</code>, внутри которого для каждого физического или виртуального дисплея создается <code class="code" id="qin34a_1147">DisplayContent</code>.</p><p id="qin34a_1074"><span class="control" id="qin34a_1148">DisplayContent</span> <code class="code" id="qin34a_1149">DisplayContent</code> представляет отдельный физический или виртуальный дисплей. Он является прямым потомком <code class="code" id="qin34a_1150">RootWindowContainer</code> и внутри себя хранит так называемые <span class="control" id="qin34a_1151">DisplayAreas</span>, в которых сегментируются разные типы окон (например, область приложений, область системных оверлеев и т.д.). Внутри DisplayContent находится <span class="control" id="qin34a_1152">TaskDisplayArea</span>, которая отвечает за размещение пользовательских задач (Tasks).</p><p id="qin34a_1075"><span class="control" id="qin34a_1153">TaskDisplayArea</span> <code class="code" id="qin34a_1154">TaskDisplayArea</code> &mdash; это область дисплея, куда добавляются задачи (<code class="code" id="qin34a_1155">Task</code>). В большинстве случаев, если нет multi-window или особых режимов, используется один <span class="control" id="qin34a_1156">DefaultTaskDisplayArea</span>, где и размещаются все задачи приложения. В иерархии путь выглядит так: <span class="control" id="qin34a_1157">DisplayContent &rarr; TaskDisplayArea &rarr; Task</span>.</p><p id="qin34a_1076"><span class="control" id="qin34a_1158">Task</span> <code class="code" id="qin34a_1159">Task</code> (по сути, &laquo;стек задач&raquo;) группирует одну или несколько активити, которые пользователь воспринимает как одно приложение в списке Recents. В Android <code class="code" id="qin34a_1160">Task</code> наследуется от <code class="code" id="qin34a_1161">TaskFragment</code>, что делает его контейнером, способным содержать дочерние <code class="code" id="qin34a_1162">WindowContainer</code>. Обычно внутри задачи размещаются именно <code class="code" id="qin34a_1163">ActivityRecord</code>, каждая из которых представляет конкретную активити. В более сложных случаях, например при split-screen, <code class="code" id="qin34a_1164">Task</code> может содержать и другие задачи или TaskFragments. Однако в стандартном сценарии (одиночный экран без split) задача содержит список ActivityRecords напрямую.</p><p id="qin34a_1077"><span class="emphasis" id="qin34a_1165">Здесь ключевой момент</span>: <span class="control" id="qin34a_1166"><code class="code" id="qin34a_1168">Task</code> является прямым родителем для <code class="code" id="qin34a_1169">ActivityRecord</code></span>. Это значит, что все состояния и контекст конкретной Activity хранятся внутри её <code class="code" id="qin34a_1167">ActivityRecord</code>, который в свою очередь всегда находится внутри задачи. Таким образом, при возврате пользователя к приложению через Recents, система восстанавливает задачу, а вместе с ней и все вложенные ActivityRecords.</p><p id="qin34a_1078"><span class="control" id="qin34a_1170">TaskFragment</span> <code class="code" id="qin34a_1171">TaskFragment</code> &mdash; это базовый класс, который используется для создания под-контейнеров внутри задачи. В обычных сценариях мы его напрямую не видим, потому что работаем с <code class="code" id="qin34a_1172">Task</code>, который уже является расширением <code class="code" id="qin34a_1173">TaskFragment</code>. В некоторых режимах (например, Activity Embedding) могут создаваться отдельные TaskFragments, чтобы разделить экран между несколькими активити. Но если таких сценариев нет, <code class="code" id="qin34a_1174">Task</code> сам по себе содержит ActivityRecords, и дополнительных TaskFragments не используется.</p><p id="qin34a_1079"><span class="control" id="qin34a_1175">ActivityRecord</span> <code class="code" id="qin34a_1176">ActivityRecord</code> представляет конкретный экземпляр Activity в системе. Он наследуется от <code class="code" id="qin34a_1177">WindowToken</code>, который в свою очередь является дочерним классом <code class="code" id="qin34a_1178">WindowContainer</code>. Таким образом, <code class="code" id="qin34a_1179">ActivityRecord</code> &mdash; это одновременно и контейнер для окон активити, и токен, который WindowManager использует для управления окнами. Обычно внутри <code class="code" id="qin34a_1180">ActivityRecord</code> размещается один основной <code class="code" id="qin34a_1181">WindowState</code> (окно приложения), а также любые дочерние окна (например, диалоги).</p><p id="qin34a_1080"><span class="control" id="qin34a_1182">Путь в иерархии выглядит так</span>: <code class="code" id="qin34a_1183">RootWindowContainer &rarr; DisplayContent &rarr; TaskDisplayArea &rarr; Task &rarr; ActivityRecord &rarr; WindowState</code>.</p><p id="qin34a_1081">Это означает, что <code class="code" id="qin34a_1184">ActivityRecord</code> <span class="control" id="qin34a_1185">всегда живёт внутри задачи</span> и никогда не существует сам по себе или в глобальном списке. Именно поэтому при возврате из Recents задача сначала поднимается целиком (<code class="code" id="qin34a_1186">Task</code>), а затем уже внутри неё активируются нужные активности (<code class="code" id="qin34a_1187">ActivityRecord</code>).</p><p id="qin34a_1082">Такое дерево контейнеров позволяет системе Android централизованно управлять всей иерархией окон и задач. Например, при изменении конфигурации или выгрузке процесса, состояние активности остаётся &laquo;привязанным&raquo; к её <code class="code" id="qin34a_1188">ActivityRecord</code>, который живёт внутри <code class="code" id="qin34a_1189">Task</code>. Когда задача возвращается на экран, все объекты дерева последовательно восстанавливаются, и Activity получает свои данные обратно через <code class="code" id="qin34a_1190">Bundle</code>, связанный с её <code class="code" id="qin34a_1191">ActivityRecord</code>.</p><p id="qin34a_1083">Сделаем краткий итог</p><ul class="list _bullet" id="qin34a_1084"><li class="list__item" id="qin34a_1192"><p id="qin34a_1198"><span class="control" id="qin34a_1199">DisplayContent</span> &mdash; верхний контейнер для дисплея, включает TaskDisplayArea.</p></li><li class="list__item" id="qin34a_1193"><p id="qin34a_1200"><span class="control" id="qin34a_1201">TaskDisplayArea</span> &mdash; область дисплея для задач.</p></li><li class="list__item" id="qin34a_1194"><p id="qin34a_1202"><span class="control" id="qin34a_1203">Task</span> &mdash; контейнер, группирующий одну или несколько ActivityRecords.</p></li><li class="list__item" id="qin34a_1195"><p id="qin34a_1204"><span class="control" id="qin34a_1205">TaskFragment</span> &mdash; промежуточный контейнер, используется при embedding или split, обычно не нужен в базовом сценарии.</p></li><li class="list__item" id="qin34a_1196"><p id="qin34a_1206"><span class="control" id="qin34a_1207">ActivityRecord</span> &mdash; контейнер и токен конкретной Activity, всегда находится внутри Task.</p></li><li class="list__item" id="qin34a_1197"><p id="qin34a_1208"><span class="control" id="qin34a_1209">WindowState</span> &mdash; дочерние окна Activity, живут внутри ActivityRecord.</p></li></ul><p id="qin34a_1085">Таким образом, вопрос <span class="emphasis" id="qin34a_1210">&laquo;где хранится ActivityRecord&raquo;</span> можно чётко ответить: <span class="control" id="qin34a_1211">внутри Task</span>, как дочерний элемент в дереве контейнеров.</p><p id="qin34a_1086">Эта архитектура делает поведение задач предсказуемым и позволяет системе сохранять, приостанавливать и восстанавливать активности, не нарушая общую структуру приложения в памяти. Именно поэтому пользователь всегда видит &laquo;цельную&raquo; задачу в Recents, а не отдельные активности.</p><aside class="prompt" data-type="tip" data-title="" id="qin34a_1087"><p id="qin34a_1212">Для более наглядного понимания иерархии можно посмотреть диаграмму ниже, которая отлично иллюстрирует дерево контейнеров в Android WindowManager (начиная с Android 12).</p><figure id="qin34a_1213"><img alt="Android WindowManager Hierarchy" src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/02/15/8e302de71ed649b7aab54919ae455e61.png" title="Android WindowManager Hierarchy"></figure><p id="qin34a_1214"><span class="emphasis" id="qin34a_1215">Диаграмма взята с <a href="https://www.sobyte.net/post/2022-02/android-12-wms-hierarchy/#:~:text=%2A%20RootWindowContainer%3A%20The%20top,%E2%80%A6" id="qin34a_1216" data-external="true" rel="noopener noreferrer" target="_blank">sobyte.net &mdash; Android 12 WMS Hierarchy</a> для иллюстрации иерархии WindowManager.</span></p></aside></section><section class="chapter"><h2 id="activityrecord" data-toc="activityrecord">Где и когда создается ActivityRecord в первые</h2><p id="qin34a_1217">После того как мы разобрали, где именно хранится <code class="code" id="qin34a_1248">ActivityRecord</code> в иерархии контейнеров, возникает следующий важный вопрос: <span class="control" id="qin34a_1249">а когда и как этот объект вообще появляется в системе?</span></p><p id="qin34a_1218">Все предыдущие главы показывали нам, как система управляет уже существующими <code class="code" id="qin34a_1250">ActivityRecord</code> &mdash; как они восстанавливаются из стека задач ( Recents), как переходят между состояниями, как сохраняются их состояния. Но откуда берётся первый экземпляр <code class="code" id="qin34a_1251">ActivityRecord</code>, когда Activity запускается впервые, например, при самом первом запуске приложения или при старте новой Activity через интент?</p><p id="qin34a_1219">Именно этот момент &mdash; создание <code class="code" id="qin34a_1252">ActivityRecord</code> &mdash; можно считать точкой входа активности в &laquo;жизнь&raquo; на стороне system server. На этом этапе создаётся основная структура, к которой в дальнейшем будут привязаны всё: и окна (<code class="code" id="qin34a_1253">WindowState</code>), и состояния (<code class="code" id="qin34a_1254">Bundle</code>), и привязки к задаче (<code class="code" id="qin34a_1255">Task</code>).</p><p id="qin34a_1220">Дальше система начинает &laquo;разворачивать&raquo; процесс по цепочке вызовов, начиная с верхнего уровня &mdash; <code class="code" id="qin34a_1256">ActivityManagerService</code>. Когда приложение или другой компонент системы вызывает <code class="code" id="qin34a_1257">startActivity(...)</code>, эта команда сначала попадает в публичный API <code class="code" id="qin34a_1258">ActivityManagerService</code>, а уже оттуда прокладывает путь вниз через слои system server, где и подготавливаются все объекты, необходимые для старта.</p><p id="qin34a_1221">Вот как выглядит эта цепочка вызовов на первых уровнях:</p><div class="code-block" data-lang="java">
public class ActivityManagerService extends IActivityManager.Stub,...{

@Override
public int startActivityWithFeature(IApplicationThread caller, String callingPackage,...) {
    return mActivityTaskManager.startActivity(caller, callingPackage, callingFeatureId, intent,...);
}

}
</div><p id="qin34a_1223">Здесь <code class="code" id="qin34a_1259">ActivityManagerService</code> лишь перенаправляет вызов в <code class="code" id="qin34a_1260">ActivityTaskManagerService</code>, где начинается более детальная работа с профилями пользователей, флагами интентов и прочими проверками.</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {

    @Override
    public final int startActivity(IApplicationThread caller, String callingPackage, ...) {
        return startActivityAsUser(caller, callingPackage, callingFeatureId, intent, ...);
    }

    private int startActivityAsUser(IApplicationThread caller, String callingPackage, ...) {

        return getActivityStartController().obtainStarter(intent, &quot;startActivityAsUser&quot;)
              ...
              .execute();
    }

    ActivityStartController getActivityStartController() {
        return mActivityStartController;
    }

}
</div><p id="qin34a_1225">В методе <code class="code" id="qin34a_1261">startActivityAsUser</code> мы уже видим обращение к <code class="code" id="qin34a_1262">ActivityStartController</code>, который управляет процессом создания и конфигурации старта активности. Метод <code class="code" id="qin34a_1263">obtainStarter</code> возвращает объект <code class="code" id="qin34a_1264">ActivityStarter</code>, который можно назвать настоящим &laquo;дирижёром&raquo; запуска. Он собирает все параметры, проверяет, нужна ли новая задача (<code class="code" id="qin34a_1265">Task</code>) или можно использовать существующую, проверяет конфигурацию и наконец подготавливает <code class="code" id="qin34a_1266">ActivityRecord</code>.</p><div class="code-block" data-lang="java">
public class ActivityStartController {

    ActivityStarter obtainStarter(Intent intent, String reason) {
        return mFactory.obtain().setIntent(intent).setReason(reason);
    }
}
</div><p id="qin34a_1227">После того как мы получаем <code class="code" id="qin34a_1267">ActivityStarter</code> через <code class="code" id="qin34a_1268">obtainStarter</code>, именно здесь происходит создание нового объекта <code class="code" id="qin34a_1269">ActivityRecord</code>. <code class="code" id="qin34a_1270">ActivityStarter</code> формирует все ключевые параметры запуска: интент, флаги, целевой <code class="code" id="qin34a_1271">Task</code>, конфигурацию окна, а также решает, нужно ли создать новую задачу или использовать существующую.</p><p id="qin34a_1228">Созданный <code class="code" id="qin34a_1272">ActivityRecord</code> связывается с задачей, добавляется в иерархию контейнеров и становится частью общей структуры <code class="code" id="qin34a_1273">RootWindowContainer</code>. После создания <code class="code" id="qin34a_1274">ActivityRecord</code> хранится в дереве контейнеров до завершения активности или её удаления системой.</p><div class="code-block" data-lang="java">
class ActivityStarter {

    private final ActivityTaskManagerService mService;
    private final RootWindowContainer mRootWindowContainer;
    ActivityRecord mStartActivity;

    int execute() {
        ...
        res = executeRequest(mRequest);
        ...
    }

    private int executeRequest(Request request) {
        final ActivityRecord r = new ActivityRecord.Builder(mService)
                 ... // параметры через билдер
                .build();

        mLastStartActivityResult = startActivityUnchecked(r, ...);
        ...
    }

    private int startActivityUnchecked(final ActivityRecord r, ...) {
        ...
        result = startActivityInner(r, ...);
        ...
    }

    int startActivityInner(final ActivityRecord r, ...) {
        setInitialState(r, ...);

        mRootWindowContainer.resumeFocusedTasksTopActivities(
                mTargetRootTask, mStartActivity, mOptions, mTransientLaunch);
    }

    private void setInitialState(ActivityRecord r, ...) {
        ...
        mStartActivity = r;
        ...
    }
}
</div><p id="qin34a_1231">В методе <code class="code" id="qin34a_1275">executeRequest</code> через билдер создаётся объект <code class="code" id="qin34a_1276">ActivityRecord</code>. После инициализации передаётся в <code class="code" id="qin34a_1277">startActivityUnchecked</code>, а затем в <code class="code" id="qin34a_1278">startActivityInner</code>, где вызывается метод <code class="code" id="qin34a_1279">setInitialState</code>. Здесь объект сохраняется в <code class="code" id="qin34a_1280">mStartActivity</code> &mdash; это ссылка на текущую активность, которая будет запущена.</p><p id="qin34a_1232">Далее активити подготавливается к запуску через вызов <code class="code" id="qin34a_1281">resumeFocusedTasksTopActivities</code> у <code class="code" id="qin34a_1282">RootWindowContainer</code>.</p><div class="code-block" data-lang="java">
class RootWindowContainer extends WindowContainer&lt;DisplayContent&gt;
        implements DisplayManager.DisplayListener {

    boolean resumeFocusedTasksTopActivities(
            Task targetRootTask, ActivityRecord target, ActivityOptions targetOptions,
            boolean deferPause) {

        for (int displayNdx = getChildCount() - 1; displayNdx &gt;= 0; --displayNdx) {
            final DisplayContent display = getChildAt(displayNdx);
            final boolean curResult = result;
            boolean[] resumedOnDisplay = new boolean[1];
            final ActivityRecord topOfDisplay = display.topRunningActivity();
            display.forAllRootTasks(rootTask -&gt; {
                final ActivityRecord topRunningActivity = rootTask.topRunningActivity();
                if (!rootTask.isFocusableAndVisible() || topRunningActivity == null) {
                    return;
                }
                if (rootTask == targetRootTask) {
                    resumedOnDisplay[0] |= curResult;
                    return;
                }
                if (topRunningActivity.isState(RESUMED) &amp;&amp; topRunningActivity == topOfDisplay) {
                    rootTask.executeAppTransition(targetOptions);
                } else {
                    resumedOnDisplay[0] |= topRunningActivity.makeActiveIfNeeded(target);
                }
            });
            result |= resumedOnDisplay[0];
            if (!resumedOnDisplay[0]) {
                final Task focusedRoot = display.getFocusedRootTask();
                if (focusedRoot != null) {
                    result |= focusedRoot.resumeTopActivityUncheckedLocked(
                            target, targetOptions, false /* skipPause */);
                } else if (targetRootTask == null) {
                    result |= resumeHomeActivity(null /* prev */, &quot;no-focusable-task&quot;,
                            display.getDefaultTaskDisplayArea());
                }
            }
        }

        return result;
    }
}
</div><p id="qin34a_1235">В методе <code class="code" id="qin34a_1283">resumeFocusedTasksTopActivities</code> происходит обход всех дисплеев и корневых задач. Для каждой задачи выбирается верхняя активити, проверяется её состояние и возможность активации. Если задача содержит целевую активити (<code class="code" id="qin34a_1284">target</code>), она активируется вызовом <code class="code" id="qin34a_1285">resumeTopActivityUncheckedLocked</code>.</p><p id="qin34a_1236">Таким образом, после создания <code class="code" id="qin34a_1286">ActivityRecord</code>, система полностью подготавливает задачу и активирует верхнюю активити, переводя её в состояние RESUMED. Отлично, продолжим ровно в том же техническом, &laquo;ровном&raquo; стиле, учитывая, что эти методы мы действительно уже подробно разбирали ранее.</p><p id="qin34a_1237">После того как контейнер окон выбрал задачу для возобновления, управление переходит в метод <code class="code" id="qin34a_1287">resumeTopActivityUncheckedLocked</code> внутри класса <code class="code" id="qin34a_1288">Task</code>. Мы уже встречали этот метод раньше &mdash; он отвечает за выбор и финальную подготовку верхней активити внутри задачи перед запуском. Внутри него вызывается <code class="code" id="qin34a_1289">resumeTopActivityInnerLocked</code>, который в свою очередь извлекает нужный <code class="code" id="qin34a_1290">TaskFragment</code>.</p><div class="code-block" data-lang="java">
class Task extends TaskFragment {

    @GuardedBy(&quot;mService&quot;)
    boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options,
                                             boolean deferPause) {
        someActivityResumed = resumeTopActivityInnerLocked(prev, options, deferPause);
    }

    @GuardedBy(&quot;mService&quot;)
    private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options,
                                                 boolean deferPause) {
        final TaskFragment topFragment = topActivity.getTaskFragment();
        resumed[0] = topFragment.resumeTopActivity(prev, options, deferPause);
    }

}
</div><p id="qin34a_1239">Как мы помним, в методе <code class="code" id="qin34a_1291">resumeTopActivityInnerLocked</code> вытаскивается верхний фрагмент задачи (объект <code class="code" id="qin34a_1292">TaskFragment</code>), который содержит активити, готовую к запуску.</p><p id="qin34a_1240">Далее вызывается <code class="code" id="qin34a_1293">resumeTopActivity</code> у <code class="code" id="qin34a_1294">TaskFragment</code>. Этот метод ищет верхнюю активити в контейнере (<code class="code" id="qin34a_1295">topRunningActivity</code>) и инициирует вызов <code class="code" id="qin34a_1296">startSpecificActivity</code>. Здесь принимается решение, нужно ли запускать новый процесс или использовать уже существующий.</p><div class="code-block" data-lang="java">
class TaskFragment extends WindowContainer&lt;WindowContainer&gt; {

    final boolean resumeTopActivity(ActivityRecord prev, ActivityOptions options,
                                    boolean skipPause) {
        ActivityRecord next = topRunningActivity(true /* focusableOnly */);
        mTaskSupervisor.startSpecificActivity(next, true, false);
        ...
        return true;
        ...
    }

}
</div><p id="qin34a_1242">Мы уже видели метод <code class="code" id="qin34a_1297">startSpecificActivity</code> внутри <code class="code" id="qin34a_1298">ActivityTaskSupervisor</code> в предыдущих главах. Он проверяет, существует ли уже процесс для текущей активности. Если процесс жив и активити привязана, то система продолжает её запуск напрямую. Если процесс отсутствует или был выгружен системой, вызывается метод <code class="code" id="qin34a_1299">startProcessAsync</code>, который отвечает за асинхронный старт нового процесса.</p><div class="code-block" data-lang="java">
public class ActivityTaskSupervisor implements RecentTasks.Callbacks {
    ...
    final ActivityTaskManagerService mService;

    void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) {
        ...
        mService.startProcessAsync(r, knownToBeDead, isTop,
                isTop ? HostingRecord.HOSTING_TYPE_TOP_ACTIVITY
                        : HostingRecord.HOSTING_TYPE_ACTIVITY);
    }
}
</div><p id="qin34a_1244">Внутри <code class="code" id="qin34a_1300">startProcessAsync</code>, как мы уже подробно разбирали, активити добавляется в список <code class="code" id="qin34a_1301">mStartingProcessActivities</code>. Это очередь для тех активити, которые ждут, пока процесс будет создан и привязан системой. Такая очередь позволяет системе контролировать порядок запуска и управлять ресурсами без потерь состояний.</p><div class="code-block" data-lang="java">
public class ActivityTaskManagerService extends IActivityTaskManager.Stub {
    ...

    final ArrayList&lt;ActivityRecord&gt; mStartingProcessActivities = new ArrayList&lt;&gt;();
    RootWindowContainer mRootWindowContainer;

    void startProcessAsync(ActivityRecord activity, boolean knownToBeDead, boolean isTop,
                           String hostingType) {
        ...
        mStartingProcessActivities.add(activity);
        ...
    }
    ...
}
</div><p id="qin34a_1246">Таким образом, вся эта цепочка методов, которые мы уже встречали ранее, замыкается именно здесь: от вызова из контейнеров окон до финального решения о создании нового процесса или продолжении в текущем. В результате создаётся, сохраняется и активируется <code class="code" id="qin34a_1302">ActivityRecord</code>, и именно он становится ключевым звеном между системой и пользовательским интерфейсом. Что происходит после вызова этого метода и последующую логику обработки мы уже подробно разбирали в предыдущих главах.</p><p id="qin34a_1247">На этом, пожалуй, всё &mdash; это конец статьи.</p></section><div class="last-modified">06 июля 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="view-model-under-the-hood-сompose.html" class="navigation-links__prev">ViewModel под капотом: как работает в Compose и View</a><a href="decompose-save-state-internal.html" class="navigation-links__next">Decompose и Essenty: под капотом сохранения состояния без ViewModel</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>